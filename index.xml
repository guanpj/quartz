<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AboutTheGardens on</title><link>https://www.guanpj.top/</link><description>Recent content in AboutTheGardens on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.guanpj.top/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://www.guanpj.top/2023-03-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-15/</guid><description>弄完了同步，牛逼</description></item><item><title/><link>https://www.guanpj.top/2023-03-16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-16/</guid><description/></item><item><title/><link>https://www.guanpj.top/2023-03-18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-18/</guid><description>2023-03-18 今日开发工作 今日感想</description></item><item><title/><link>https://www.guanpj.top/2023-03-19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-19/</guid><description>今日开发工作 今日感想</description></item><item><title/><link>https://www.guanpj.top/2023-03-20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-20/</guid><description>今日开发工作 今日感想 sadlfjsal
from windows
之类主页是[[AboutTheGarden]]</description></item><item><title/><link>https://www.guanpj.top/2023-03-24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-24/</guid><description>今日开发工作 今日感想</description></item><item><title/><link>https://www.guanpj.top/ADB-%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/ADB-%E5%91%BD%E4%BB%A4/</guid><description>ADB 命令 shell adb shell 常用的命令有 ：
am（activity manager） 可执行 启动 activity，service，broadcast，杀死进程等操作。
pm（package manager） 可以执行 安装/卸载 应用，输出 apk 路径等操作。</description></item><item><title/><link>https://www.guanpj.top/Android-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96-/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Android-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96-/</guid><description>Android 对容器类的优化 在之前 HashMap 的源码解析的文章中可知，HashMap 的一级存储结构是一个初始容量为 16 的数组， 所以当我们创建出一个 HashMap 对象时，即使里面没有任何元素，也要分别一块内存空间给它。而且，在不断的向 HashMap 里 put 数据的过程中，当数据量达到阈值（容量*加载因子，加载因子默认为 0.75）时，将会触发 HashMap 扩容流程，扩大后新的容量一定是原来的 2 倍。</description></item><item><title/><link>https://www.guanpj.top/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>使用 首先引入依赖 1 2 3 4 5 6 7 8 9 10 11 12 apply plugin: &amp;#39;kotlin-kapt&amp;#39; dependencies { implementation &amp;#39;org.</description></item><item><title/><link>https://www.guanpj.top/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>Glide 加载流程和缓存原理分析 加载流程 Glide 最普通的用法如下：
Glide.with(this).load(url).into(textView);
以首次加载 url 指向的资源到 textView 对象为例，由于代码实在太过冗长，下面用流程图的方式表示各个环节的执行顺序。
with with 流程的主要职责：
创建 RequestManager 对象 初始化各式各样的配置信息（缓存、请求线程池、图片大小和格式等等）以及 Glide 单例对象。 将 Glide 请求和 application/Activity/SupportFragment/Fragment 的生命周期绑定在一起，从而实现自动执行请求，暂停操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Glide implements ComponentCallbacks2 { .</description></item><item><title/><link>https://www.guanpj.top/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>Glide 基本使用 准备 添加依赖 1 2 implementation &amp;#39;com.github.bumptech.glide:glide:4.12.0&amp;#39; annotationProcessor &amp;#39;com.github.bumptech.glide:compiler:4.12.0&amp;#39; 添加网路权限 1 &amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34; /&amp;gt; 定义控件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &amp;lt;androidx.</description></item><item><title/><link>https://www.guanpj.top/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</guid><description>Glide 高级用法 回调与监听 Target 我们都知道，使用 Glide 在界面上加载并展示一张图片只需要一行代码：
1 Glide.with(this).load(url).into(imageView); 将 ImageView 的实例传入到 into() 方法当中，Glide 将图片加载完成之后，图片就能显示到 ImageView 上了。这是怎么实现的呢？来看一下 into() 方法的源码：</description></item><item><title/><link>https://www.guanpj.top/Java-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Java-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid><description>Java 静态代理 &amp;amp; 动态代理 代理模式是软件开发中常见的设计模式，它的目的是让调用者不用持有具体操作者的引用，而是通过代理者去对具体操作者执行具体的操作。本文通过使用静态代理和动态代理分别实现代理模式，来对比和分析两者的实现原理。
静态代理的实现 代理接口：
public interface Person {
1 String doSomething(int i); }
目标对象：</description></item><item><title/><link>https://www.guanpj.top/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>LeakCanary 使用及源码分析 Refercence 及 ReferenceQueue Reference 介绍 Reference 即是我们平时所说的“引用”，与之对应的是一个泛型抽象类。四种引用类型：SoftReference(软引用)、WeakReference(弱引用)、PhantomReference（虚引用）都继承自 Reference。它的声明如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 public abstract class Reference&amp;lt;T&amp;gt; { //引用对象 volatile T referent; //保存即将被回收的Reference对象 final ReferenceQueue&amp;lt;?</description></item><item><title/><link>https://www.guanpj.top/Linter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Linter/</guid><description>注意点: 要使用 vercel 或 github pages 或 cloudflare pages，不能用 netlify，因为 netlify 会自动将 url 小写，带来 bug。
核心 2 个点，命令参考 dg3 仓库的 deploy.</description></item><item><title/><link>https://www.guanpj.top/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>OkHttp 使用及源码分析 https://juejin.cn/post/6881436122950402056
请求流程 同步请求 MainActivity.kt
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 val user = &amp;#34;guanpj&amp;#34; val client = OkHttpClient.</description></item><item><title/><link>https://www.guanpj.top/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>Retrofit 使用及源码分析 使用 导入依赖。 1 2 3 4 5 6 7 8 9 implementation &amp;#34;com.squareup.okhttp3:okhttp:4.9.0&amp;#34; implementation &amp;#34;com.squareup.okhttp3:logging-interceptor:4.9.0&amp;#34; implementation &amp;#34;com.</description></item><item><title/><link>https://www.guanpj.top/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>RxJava 使用及源码分析 https://juejin.cn/post/6881436122950402056
介绍 Rx 是 ReactiveX 的简写，后者是 Reactive Extensions 的缩写，Rx 是一种编程模型，用于方便处理异步数据流。
RxJava 是响应式编程（Reactive Extensions）在 Java VM 上的实现，是一个在 Java VM 上使用可观察序列来组成异步的、基于事件的程序库。</description></item><item><title/><link>https://www.guanpj.top/TP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/TP/</guid><description>Date now: &amp;lt;% tp.config %&amp;gt; Date now with format: &amp;lt;% tp.date.now(&amp;ldquo;Do MMMM YYYY&amp;rdquo;) %&amp;gt;
Last week: &amp;lt;% tp.date.now(&amp;ldquo;dddd Do MMMM YYYY&amp;rdquo;, -7) %&amp;gt; Today: &amp;lt;% tp.</description></item><item><title/><link>https://www.guanpj.top/%E4%B8%80Binder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E4%B8%80Binder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E7%AF%87/</guid><description>上次没砍我的,这次我又来了。看完这篇还不明白 Binder 你砍我(一) - 掘金
不懂砍我之看完这篇还不明白 Binder 你砍我(二) - 掘金
不懂砍我之看完这篇还不明白 Binder 你砍我(三) - 掘金
不懂砍我之看完这篇还不明白 Binder 你砍我(四)完结篇 - 掘金</description></item><item><title/><link>https://www.guanpj.top/%E4%B8%83View-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E4%B8%83View-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</guid><description>不知不觉，系列文章已经更新到第四篇了，从手机电源被按下到 App 被点击再到 UI 呈现在屏幕上，从系统内核到 framework 层再到应用层，期间发生了无数次交互，最终才使得我们五彩斑斓的 View 得于被渲染并出现在我们的眼前。可是，有了这些还不够，用户也是需要跟 App 进行交互的，其中最重要也是最直接的交互方式便是触摸手机屏幕了！
而我们的手指的触摸事件是怎样被一屏幕上的 View 感知的呢？本文将继续基于 Android Nougat 的源码来讲解这个过程。
触摸事件的产生 ab cd 有硬件基础的同学应该都知道，计算机（当然包括手机）输入输出设备是通过触发硬件中断来</description></item><item><title/><link>https://www.guanpj.top/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>看完这篇还不明白 Handler 你砍我 - 掘金
Android 应用层通常使用 Handler 实现线程之间的消息通讯，Handler 是 Android 消息机制中非常重要的一员。以下分析通过剖析 Handler 的工作原理来深入了解 Android 应用开发过程中最常见也是最实用的消息收发机制。
在分析之前，先回顾一下 Handler 的使用方式：首先，最常用的是子线程往主线程发送消息：</description></item><item><title/><link>https://www.guanpj.top/%E4%BA%8CBinder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E7%AF%87/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E4%BA%8CBinder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E7%AF%87/</guid><description>AIDL 是 Android Interface Definition Language（Android 接口定义语言）的缩写，它是 Android 进程间通信的接口语言。由于 Android 系统的 Linux 内核采用了进程隔离机制，使得不同的应用程序运行在不同的进程当中，有时候两个应用之间需要传递或者共享某些数据，就需要进行进程间的通信讯。
在上一篇文章——[[一、Binder 机制分析——概念篇]]中我们已经分析了使用 Binder 机制的原因以及分析了 Binder 机制，而 AIDL 也正是运用了 Binder 机制来实现进程间的通讯，本章我们将继续从 AIDL 的使用过程体验 Binder 在应用层的使用和原理。</description></item><item><title/><link>https://www.guanpj.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 import sys import io import json from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.</description></item><item><title/><link>https://www.guanpj.top/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>在我的上一篇文章 Android 系统启动流程分析中，我们分析了系统在开机以后的一系列行为，其中最后一阶段 AMS(ActivityManagerService) 会启动 Launcher 来展示我们手机中所有已安装的应用图标，点击图标后相应的应用程序将会被系统启动运行并展示在我们面前，那么，点击了图标之后系统道理做了哪些工作呢？应用进程是怎么被启动的呢？Activity 的生命周期是什么时候被谁调用的呢？本文将继续基于 Android Nougat 的 frameworks 层源码的解答这些问题。
阅读建议：
如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。
1. Launcher —— AMS 1.1 调用过程分析 1.</description></item><item><title/><link>https://www.guanpj.top/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>在我的系列文章上一篇： App 竟然是这样跑起来的 —— Android App/Activity 启动流程分析中已经分析了一个 App 从点击它的图标到 Activity 的 onCreate()、onStart() 和 onResume() 等生命周期被调用的整个流程。我们都知道，普通 App 屏幕上显示的内容都是由一个个自己设计的界面被系统加载而来的，而这些界面中的元素又是怎么被渲染出来的呢？本文将继续基于 Android Nougat 从源码的角度来进一步分析整个过程。</description></item><item><title/><link>https://www.guanpj.top/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88/</guid><description>Date now: &amp;lt;% tp.config %&amp;gt;### 史蒂夫
line1: &amp;lt;% tp.file.cursor(1) %&amp;gt; line2: &amp;lt;% tp.file.cursor(2) %&amp;gt;</description></item><item><title/><link>https://www.guanpj.top/%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description/></item><item><title/><link>https://www.guanpj.top/%E5%95%8A%E5%95%8A%E5%95%8A/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%95%8A%E5%95%8A%E5%95%8A/</guid><description>Date now: &amp;lt;% tp.config %&amp;gt; Date now with format: &amp;lt;% tp.date.now(&amp;ldquo;Do MMMM YYYY&amp;rdquo;) %&amp;gt;
Last week: &amp;lt;% tp.date.now(&amp;ldquo;dddd Do MMMM YYYY&amp;rdquo;, -7) %&amp;gt; Today: &amp;lt;% tp.</description></item><item><title/><link>https://www.guanpj.top/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</guid><description>作为一名 Android 程序员，你有没有想过：那么复杂的 Android 系统，它是怎样运行起来的，我们的 App 又是怎样被 Android 系统加载后呈现在屏幕上的呢？Android 系统的启动是一个比较复杂的过程，涉及到了一些我们没有接触过的知识，本文将基于 Android Nougat 最新的代码上讲述 Android 系统的启动流程。
Bootloader —— 第一个程序 当按下电源键（加电）或者系统重启（复位）的时候，引导芯片会从 ROM（这里一般指 Flash ROM，即闪存）中预定义的位置将 Bootloader 载入到 RAM 中，接着，Bootloader 将会把 Linux 内核载入到 RAM 中并启动。</description></item><item><title/><link>https://www.guanpj.top/%E5%A7%94%E6%89%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%A7%94%E6%89%98/</guid><description>https://juejin.cn/post/7043843490366619685</description></item><item><title/><link>https://www.guanpj.top/%E5%BC%95%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%BC%95%E7%94%A8/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include &amp;lt;iostream&amp;gt;using namespace std; // 函数声明 void swap(int&amp;amp; x, int&amp;amp; y); void swap1(int* x, int* y); void swap2(int x, int y); void swap3(int* x, int* y); int main () { // 局部变量声明 int a = 100; int b = 200; cout &amp;lt;&amp;lt; &amp;#34;交换前，&amp;amp;a 的值：&amp;#34; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换前，&amp;amp;b 的值：&amp;#34; &amp;lt;&amp;lt; &amp;amp;b &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换前，a 的值：&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换前，b 的值：&amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; /* 调用函数来交换值 */ //swap(a, b); //swap1(&amp;amp;a, &amp;amp;b); //swap2(a, b); swap3(&amp;amp;a, &amp;amp;b); cout &amp;lt;&amp;lt; &amp;#34;交换后，a 的值：&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换后，b 的值：&amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换后，&amp;amp;a 的值：&amp;#34; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;交换后，&amp;amp;b 的值：&amp;#34; &amp;lt;&amp;lt; &amp;amp;b &amp;lt;&amp;lt; endl; return 0; } // 函数定义 void swap(int&amp;amp; x, int&amp;amp; y) { cout &amp;lt;&amp;lt; &amp;#34;swap&amp;#34; &amp;lt;&amp;lt; endl; int temp; temp = x; x = y; y = temp; } void swap1(int* x, int* y) { cout &amp;lt;&amp;lt; &amp;#34;swap1&amp;#34; &amp;lt;&amp;lt; endl; int* temp; temp = x; x = y; y = temp; } void swap2(int x, int y) { cout &amp;lt;&amp;lt; &amp;#34;swap2&amp;#34; &amp;lt;&amp;lt; endl; int temp; temp = x; x = y; y = temp; } void swap3(int* x, int* y) { cout &amp;lt;&amp;lt; &amp;#34;swap3&amp;#34; &amp;lt;&amp;lt; endl; int temp; temp = *x; *x = *y; *y = temp; }</description></item><item><title/><link>https://www.guanpj.top/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/</guid><description>今日开发工作 今日感想</description></item><item><title/><link>https://www.guanpj.top/%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 fun main() { &amp;#34;a&amp;#34;.</description></item><item><title/><link>https://www.guanpj.top/%E6%8C%87%E9%92%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%8C%87%E9%92%88/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include &amp;lt;iostream&amp;gt; using namespace std; int main () { int var; int *ptr; int **pptr; int ***ppptr; var = 3000; // 获取 var 的地址 ptr = &amp;amp;var; // 使用运算符 &amp;amp; 获取 ptr 的地址 pptr = &amp;amp;ptr; ppptr = &amp;amp;pptr; cout &amp;lt;&amp;lt; &amp;#34;var 值为 :&amp;#34; &amp;lt;&amp;lt; var &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;ptr 值为:&amp;#34; &amp;lt;&amp;lt; ptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;pptr 值为:&amp;#34; &amp;lt;&amp;lt; pptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;ppptr 值为:&amp;#34; &amp;lt;&amp;lt; ppptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-------------------&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;*&amp;amp;var 值为:&amp;#34; &amp;lt;&amp;lt; *&amp;amp;*&amp;amp;var &amp;lt;&amp;lt; endl; //cout &amp;lt;&amp;lt; &amp;#34;pptr 值为:&amp;#34; &amp;lt;&amp;lt; pptr &amp;lt;&amp;lt; endl; //cout &amp;lt;&amp;lt; &amp;#34;ppptr 值为:&amp;#34; &amp;lt;&amp;lt; ppptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;-------------------&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;var 值为 :&amp;#34; &amp;lt;&amp;lt; var &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;*ptr 值为:&amp;#34; &amp;lt;&amp;lt; *ptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;**pptr 值为:&amp;#34; &amp;lt;&amp;lt; **pptr &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;***ppptr 值为:&amp;#34; &amp;lt;&amp;lt; ***ppptr &amp;lt;&amp;lt; endl; return 0; }</description></item><item><title/><link>https://www.guanpj.top/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 filename = &amp;#39;user.txt&amp;#39; with open(filename) as f: lines = f.</description></item><item><title/><link>https://www.guanpj.top/%E6%9C%AA%E5%91%BD%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%9C%AA%E5%91%BD%E5%90%8D/</guid><description/></item><item><title/><link>https://www.guanpj.top/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BD%BF%E7%94%A8/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #类定义 class people: #定义基本属性 name = &amp;#39;&amp;#39; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.</description></item><item><title/><link>https://www.guanpj.top/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import os,re def traversal_files1(path): for root, dirs, files in os.</description></item><item><title>About Atlas</title><link>https://www.guanpj.top/About-Atlas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/About-Atlas/</guid><description>Atlas意思是地图集。
单个案例或项目的MOC，考虑直接放在对应文件夹里面，相当于起到一个个文件夹的readme和导览的作用。这里专门放这些MOC的MOC。
围绕本库和obsidian的使用教程、方法和细节，也放到这里，就像是地图的指南针。</description></item><item><title>About Extras</title><link>https://www.guanpj.top/About-Extras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/About-Extras/</guid><description/></item><item><title>CAS 和 AQS 原理</title><link>https://www.guanpj.top/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/</guid><description>CAS 介绍 CAS 英文全称是 Compare-And-Swap，中文叫做“比较并交换”，它是一种思想、一种算法。
在大多数处理器的指令中，都会实现 CAS 相关的指令，这一条指令就可以完成“比较并交换”的操作，也正是由于这是一条（而不是多条）CPU 指令，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以无需我们程序员来操心。
CAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。CAS 最核心的思路就是，仅当预期值 A 和当前的内存值 V 相同时，才将内存值修改为 B。</description></item><item><title>HashMap 源码解析</title><link>https://www.guanpj.top/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>前言 HashMap 是 Java 中最常用 K-V 容器，使用哈希值来确定元素存储的位置，HashMap 对 Entry 进行了扩展（Node），使其形成以链表或者树的形式存储在 HashMap 的容器里。
在 Java 8 之前和之后，HashMap 的实现有较大的不同，因此对于 put 流程、扩容机制等主要过程分析将会采用两个版本进行对比。
成员变量 HashMap 成员变量和构造方法声明如下（Java 7 和 8 大致相同，以下为 Java 8 版本）：</description></item><item><title>HTTP 基础PS</title><link>https://www.guanpj.top/HTTP-%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/HTTP-%E5%9F%BA%E7%A1%80/</guid><description>什么是 HTTP ？ Hypertext Transfer Protocol，超文本传输协议，和 HTML (Hypertext Markup Language 超文本标记语言) 一起诞生，用于在网络上请求和传输 HTML 内容。
超文本，即「扩展型文本」，指的是 HTML 中可以有链向别的文本的链接 (hyperlink)。
HTTP 报文格式 请求报文格式：</description></item><item><title>Index for Atlases</title><link>https://www.guanpj.top/Index-for-Atlases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Index-for-Atlases/</guid><description>up:: [[ACCESS 笔记组织法]]
1 2 3 4 5 6 7 8 9 10 11 // 获取当前文件所在的文件夹 const currentFolder = dv.</description></item><item><title>Index for Extras</title><link>https://www.guanpj.top/Index-for-Extras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Index-for-Extras/</guid><description>1 2 3 4 5 6 7 8 9 10 11 // 获取当前文件所在的文件夹 const currentFolder = dv.current().file.folder // 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息 const groups = dv.</description></item><item><title>IO</title><link>https://www.guanpj.top/IO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/IO/</guid><description/></item><item><title>Java 内存模型</title><link>https://www.guanpj.top/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid><description>JMM 是什么？ JMM 是和多线程相关的一组规范，它 定义了 JVM 在计算机内存中的工作方式，需要各个 JVM 的实现来遵守 JMM 规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。这样，即便同一个程序在不同的虚拟机上运行，得到的程序结果也是一致的，从而保证了“一次编译，处处运行”。
因此，JMM 与处理器、缓存、并发、编译器有关。它解决了 CPU 多级缓存、处理器优化、指令重排等导致的结果不可预期的问题。
比如关键字 synchronized，JVM 就会在 JMM 的规则下，“翻译”出合适的指令，包括限制指令之间的顺序，以便在即使发生了重排序的情况下，也能保证必要的“可见性”。这样一来，不同的 JVM 对于相同的代码的执行结果就变得可预期了，Java 程序员就只需要用同步工具和关键字就可以开发出正确的并发程序了。</description></item><item><title>JVM 中的对象和垃圾回收</title><link>https://www.guanpj.top/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>虚拟机中的对象 了解了 JVM 运行时数据区域之后，大致明白了 JVM 内存模型的概况，对内存中的存放内容也有了初步了解。更进一步地，如果要了解内存中的数据的创建过程、在内存中如何布局、以及访问方式等，就必须要把范围限定到具体的虚拟机类型和集中在某一个内存区域上才有意义。下面以最常用的 HotSpot 虚拟机和最常用的内存区域 Java 堆为例，深入探索对象分配、布局和访问过程。
对象的创建 虚拟机遇到一条 new 指令时，首先检查是否被类加载器加载，如果没有，则必须先执行相应的类加载过程。类加载就是把 class 加载到 JVM 的运行时数据区的过程。
1、检查加载 首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用（以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。</description></item><item><title>JVM 内存区域</title><link>https://www.guanpj.top/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid><description>简介 什么是 JVM？ Java 虚拟机（Java Virtual Machine，简称 JVM），它能识别 .class 后缀的字节码文件（Java bytecode），并且能够解析它的指令，最终调用操作系统上的函数以完成指定操作。
为什么需要 JVM？ Java 程序使用 javac 编译成 .class 文件之后，还需要使用 Java 命令去主动执行它，操作系统并不认识这些 .</description></item><item><title>JVM 字节码指令简介</title><link>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</guid><description>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需的参数（操作数）构成。
在 Java 虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。比如， iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在 Class 文件中它们必须拥有各自独立的操作码。
编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的对 int 类型作为运算类型来进行的。</description></item><item><title>JVM 字节码结构分析</title><link>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</guid><description>概述 提到字节码，首先想到的就是 Java，Java 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。
​其实不止是 Java，其他很多编程语言如 Scala、Kotlin 和 Groovy 等都是运行在 JVM 的语言，因此它们对应的编译器也能够生成 .class 字节码。
源代码中的各种变量，关键字和运算符号的语义最终都会编译成多条字节码命令。而字节码命令所能提供的语义描述能力是要明显强于 Java 本身的，所以有其他一些同样基于 JVM 的语言能提供许多 Java 所不支持的语言特性。</description></item><item><title>JVM 类加载机制</title><link>https://www.guanpj.top/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid><description>概述 JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 Java 类型，这个过程被称作 JVM 的类加载机制。
与那些在编译时需要进行连接的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。
类加载的时机 一个类型从被加载到虚拟机内存中开始到卸载位置，整个生命周期会经历如下七个阶段，其中验证、准备、解析三个部分统称为连接。 上图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段后再开始，这是为了支持 Java 语言的运行时半丁特性（也被称为动态绑定或者晚期绑定）。</description></item><item><title>Troubleshooting and FAQ</title><link>https://www.guanpj.top/2023-03-22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-22/</guid><description>Still having trouble? Here are a list of common questions and problems people encounter when installing Quartz.
While you&amp;rsquo;re here, join our Discord :)</description></item><item><title>容器类</title><link>https://www.guanpj.top/%E5%AE%B9%E5%99%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%AE%B9%E5%99%A8%E7%B1%BB/</guid><description>全家福： Iterable 接口 可迭代的意思，实现此接口允许对象成为“for-each”循环语句的目标，提供 iterator 方法用于遍历元素。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface Iterable&amp;lt;T&amp;gt; { Iterator&amp;lt;T&amp;gt; iterator(); default void forEach(Consumer&amp;lt;?</description></item><item><title>并发容器</title><link>https://www.guanpj.top/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</guid><description>ConcurentHashMap Java 7 实现 Java 7 版本的 ConcurrentHashMap 数据结构示意图：
ConcurrentHashMap 内部进行了 Segment 分段，Segment 继承了 ReentrantLock，可以理解为一把锁，各个 Segment 之间都是相互独立上锁的，互不影响。相比于之前的 Hashtable 每次操作都需要把整个对象锁住而言，大大提高了并发效率。因为它的锁与锁之间是独立的，而不是整个对象只有一把锁。</description></item><item><title>泛型</title><link>https://www.guanpj.top/%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%B3%9B%E5%9E%8B/</guid><description>什么是泛型？ 声明中具有一个或者多个类型参数(type parameter)的类或者接口，就是泛型类或者接口。泛型类和接口统称为泛型(generic type)。
每种泛型定义一组类型形参(formal type parameters)，这些类型形参有时也被简称为类型参数(type parameter)，例如对于 List&amp;lt;E&amp;gt; 而言，List&amp;lt;String&amp;gt; 就是一个参数化的类型(parameterized type)，String 就是对应于类型形参(formal type parameters)的类型实参(actual type parameter)。
而如果 List&amp;lt;E&amp;gt; 不使用泛型参数，List 则为原生类型(raw type)。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。</description></item><item><title>注解和反射</title><link>https://www.guanpj.top/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</guid><description>注解是什么？有何作用？ Java 注解（Annotation）又称 Java 标注，是 JDK1.5 引入的一种注释机制。是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。
注解本身没有任何意义，单独的注解就是一种注释，他需要结合其他如反射、插桩等技术才有意义。
元注解 在 JDK 中提供了 4 个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：
@Target Target 注解的作用是：描述注解的使用范围(即被修饰的注解可以用在什么地方).
Target 注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数），在定义注解类时使用了 @Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在 ElementType 枚举中.</description></item><item><title>等待-通知机制</title><link>https://www.guanpj.top/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</guid><description>wait/notify 模式 public class MyBlockingQueueForWaitNotify {
 private int maxSize = 16;
 private LinkedList storage;
  public MyBlockingQueueForWaitNotify (int size) {</description></item><item><title>线程协作</title><link>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/</guid><description>Thread.join() 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class UseJoin { public static void main(String[] args) { final Thread thread1 = new Thread(() -&amp;gt; { try { Thread.</description></item><item><title>线程基础</title><link>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid><description>CPU 核心数和线程数的关系 增加 CPU 核心数目就是为了增加线程数，因为操作系统是通过线程来执行任务的，一般情况下它们是 1:1 对应关系，也就是说四核 CPU 一般拥有四个线程。但 Intel 引入超线程技术后，使核心数与线程数形成 1:2 的关系。
进程和线程 进程是程序运行资源分配的最小单位 进程是操作系统进行资源分配的最小单位，其中资源包括：CPU、内存空间、磁盘等，同一进程中的多条线程共享该进程中的全部系统资源，而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的、静态的，进程是活的、动态的。
进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身，用户进程就是所有由你启动的进程。
线程是 CPU 调度的最小单位，必须依赖于进程而存在 线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的、能独立运行的基本单位。</description></item><item><title>线程池和 BlockingQueue</title><link>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-BlockingQueue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-BlockingQueue/</guid><description>BlockingQueue 阻塞队列 队列  队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。
在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。
什么是阻塞队列 public interface BlockingQueue&amp;lt;E&amp;gt; extends Queue&amp;lt;E&amp;gt;
支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</description></item><item><title>编码、加密、Hash、序列化和字符集</title><link>https://www.guanpj.top/%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86Hash%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86Hash%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86/</guid><description>加密 在密码学中，加密是将明文信息改变为难以读取的密文内容，使之不可读的过程。只有拥有解密方法的对象，经由解密过程，才能将密文还原为正常可读的内容。理想情况下，只有经授权的人员能够读取密文所要传达的信息。加密本身并不能防止信息传输被截取，但加密能防止截取者理解其内容。
对称加密 原理 通信双方使用同一个密钥，使用加密算法配合上密钥来加密，解密时使用加密过程
的完全逆过程配合密钥来进行解密。
经典算法 DES(56 位密钥，密钥太短而逐渐被弃用) AES(128 位、192 位、256 位密钥， 现在最流行) 对称加密作用 加密通信，防止信息在不安全网络上被截获后，信息被人读取或篡改。
对称加密(如 AES)的破解 破解思路</description></item><item><title>计算机网络体系结构、TCP&amp;IP 和 HTTPS</title><link>https://www.guanpj.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84TCPIP-%E5%92%8C-HTTPS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84TCPIP-%E5%92%8C-HTTPS/</guid><description>为什么需要计算机网络体系结构？ 计算机网络是个非常复杂的系统。比如，连接在网络上的两台计算机需要进行通信时，由于计算机网络的复杂性和异质性，需要考虑很多复杂的因素，比如：
这两台计算机之间必须有一条传送数据的通路； 告诉网络如何识别接收数据的计算机； 发起通信的计算机必须保证要传送的数据能在这条通路上正确发送和接收； 对出现的各种差错和意外事故，如数据传送错误、网络中某个节点交换机出现故障等问题，应该有可靠完善的措施保证对方计算机最终能正确收到数据。 计算机网络体系结构标准的制定正是为了解决这些问题，要想完成这种网络通信就必须保证相互通信的这两个计算机系统达成高度默契。事实上，在网络通信领域，两台计算机(网络设备)之间的通信并不像人与人之间的交流那样自然天然，这种计算机间高度默契的交流(通信) 背后需要十分复杂、完备的网络体系结构作为支撑。那么，用什么方法才能合理地组织网络的结构，以保证其具有结构清晰、设计与实现简化、便于更新和维护、较强的独立性和适应性，从而使网络设备之间具有这种 “高度默契” 呢？答案是分而治之，更进一步地说就是分层思想。
计算机网络体系结构设计基本思想 分层思想在日常生活中的应用 在快递系统中，用户和用户之间的通信依赖于下层的服务，但是他们并不需要关心快递、运输等细节，也就是说，寄信者只需将写好的信交给快递员而收信者只需从快递员手中查收信件即可。类似地，快递员也只需要从寄信人手中拿到信件并交给分检员或将信件从分检员手中拿走并交给收信人即可，至于分检员为何要把这份信交给他进行投递(事实上，每个快递员会负责某个片区，分检员根据收信人地址将信件分发给不同的快递员)，他不需要关心也没必要关心。显然，在这个快递系统中，各个角色（用户、快递员…）在功能上相互独立却又能协调合作达成一种 “高度默契”，这在很大程度上得益于分层思想的理念和应用。
分层思想的优点 耦合度低(独立性强)。上层只需通过下层为上层提供的接口来使用下层所实现的服务，而不需要关心下层的具体实现。也就是说，下层对上层而言就是具有一定功能的黑箱。 适应性强。只要每层为上层提供的服务和接口不变，每层的实现细节可以任意改变。 易于实现和维护。把复杂的系统分解成若干个涉及范围小且功能简单的子单元，从而使得系统结构清晰，实现、调试和维护都变得简单和容易。也就是说，对于设计/开发人员而言，这种方法使设计/开发人员能够专心设计和开发他们所关心的功能模块；对于调试/维护人员而言，这种方法也方便调试/维护人员去处理他们所负责的功能模块。 计算机网络体系结构的概念与标准 计算机网络体系结构的概念 计算机网络体系结构必须包括三个内容，即分层结构与每层的功能，服务与层间接口和协议。所以，计算机网络体系结构的定义为：在计算机网络中，层、层间接口及协议的集合。</description></item><item><title>锁</title><link>https://www.guanpj.top/%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E9%94%81/</guid><description>锁的分类 偏向锁/轻量级锁/重量级锁 Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级但不能降级。
这些状态被记录在对象头中的 mark word 中。
偏向锁 如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。
轻量级锁 JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。</description></item></channel></rss>