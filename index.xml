<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AboutTheGardens on</title><link>https://www.guanpj.top/</link><description>Recent content in AboutTheGardens on</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://www.guanpj.top/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://www.guanpj.top/2023-03-18/</link><pubDate>Sat, 18 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-18/</guid><description>2023-03-18 今日开发工作 今日感想</description></item><item><title/><link>https://www.guanpj.top/2023-03-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-15/</guid><description>弄完了同步，牛逼</description></item><item><title/><link>https://www.guanpj.top/2023-03-16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-16/</guid><description/></item><item><title/><link>https://www.guanpj.top/2023-03-19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-19/</guid><description>今日开发工作 今日感想</description></item><item><title/><link>https://www.guanpj.top/2023-03-20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-20/</guid><description>今日开发工作 今日感想 sadlfjsal
from windows
之类主页是[[AboutTheGarden]]</description></item><item><title/><link>https://www.guanpj.top/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/</guid><description>CAS 和 AQS 原理 CAS 介绍 CAS 英文全称是 Compare-And-Swap，中文叫做“比较并交换”，它是一种思想、一种算法。
在大多数处理器的指令中，都会实现 CAS 相关的指令，这一条指令就可以完成“比较并交换”的操作，也正是由于这是一条（而不是多条）CPU 指令，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以无需我们程序员来操心。
CAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。CAS 最核心的思路就是，仅当预期值 A 和当前的内存值 V 相同时，才将内存值修改为 B。</description></item><item><title/><link>https://www.guanpj.top/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid><description>Java 内存模型 JMM 是什么？ JMM 是和多线程相关的一组规范，它 定义了 JVM 在计算机内存中的工作方式，需要各个 JVM 的实现来遵守 JMM 规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。这样，即便同一个程序在不同的虚拟机上运行，得到的程序结果也是一致的，从而保证了“一次编译，处处运行”。
因此，JMM 与处理器、缓存、并发、编译器有关。它解决了 CPU 多级缓存、处理器优化、指令重排等导致的结果不可预期的问题。
比如关键字 synchronized，JVM 就会在 JMM 的规则下，“翻译”出合适的指令，包括限制指令之间的顺序，以便在即使发生了重排序的情况下，也能保证必要的“可见性”。这样一来，不同的 JVM 对于相同的代码的执行结果就变得可预期了，Java 程序员就只需要用同步工具和关键字就可以开发出正确的并发程序了。</description></item><item><title/><link>https://www.guanpj.top/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88/</guid><description>史蒂夫 line1: &amp;lt;% tp.file.cursor(1) %&amp;gt; line2: &amp;lt;% tp.file.cursor(2) %&amp;gt;</description></item><item><title/><link>https://www.guanpj.top/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-/</guid><description>并发容器 ConcurentHashMap Java 7 实现 Java 7 版本的 ConcurrentHashMap 数据结构示意图：
ConcurrentHashMap 内部进行了 Segment 分段，Segment 继承了 ReentrantLock，可以理解为一把锁，各个 Segment 之间都是相互独立上锁的，互不影响。相比于之前的 Hashtable 每次操作都需要把整个对象锁住而言，大大提高了并发效率。因为它的锁与锁之间是独立的，而不是整个对象只有一把锁。</description></item><item><title/><link>https://www.guanpj.top/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/</guid><description>今日开发工作 今日感想</description></item><item><title/><link>https://www.guanpj.top/%E6%9C%AA%E5%91%BD%E5%90%8D/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%9C%AA%E5%91%BD%E5%90%8D/</guid><description/></item><item><title/><link>https://www.guanpj.top/%E7%AD%89%E5%BE%85_%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%AD%89%E5%BE%85_%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</guid><description>等待_通知机制 wait/notify 模式 public class MyBlockingQueueForWaitNotify {
 private int maxSize = 16;
 private LinkedList storage;
  public MyBlockingQueueForWaitNotify (int size) {</description></item><item><title/><link>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C-/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C-/</guid><description>线程协作 Thread.join() 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class UseJoin { public static void main(String[] args) { final Thread thread1 = new Thread(() -&amp;gt; { try { Thread.</description></item><item><title/><link>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-/</guid><description>线程基础 CPU 核心数和线程数的关系 增加 CPU 核心数目就是为了增加线程数，因为操作系统是通过线程来执行任务的，一般情况下它们是 1:1 对应关系，也就是说四核 CPU 一般拥有四个线程。但 Intel 引入超线程技术后，使核心数与线程数形成 1:2 的关系。
进程和线程 进程是程序运行资源分配的最小单位 进程是操作系统进行资源分配的最小单位，其中资源包括：CPU、内存空间、磁盘等，同一进程中的多条线程共享该进程中的全部系统资源，而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的、静态的，进程是活的、动态的。
进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身，用户进程就是所有由你启动的进程。
线程是 CPU 调度的最小单位，必须依赖于进程而存在 线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的、能独立运行的基本单位。</description></item><item><title/><link>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-BlockingQueue-/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-BlockingQueue-/</guid><description>线程池和 BlockingQueue BlockingQueue 阻塞队列 队列  队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。
在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。
什么是阻塞队列 public interface BlockingQueue&amp;lt;E&amp;gt; extends Queue&amp;lt;E&amp;gt;
支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</description></item><item><title/><link>https://www.guanpj.top/%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E9%94%81/</guid><description>锁 锁的分类 偏向锁/轻量级锁/重量级锁 Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级但不能降级。
这些状态被记录在对象头中的 mark word 中。
偏向锁 如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。</description></item><item><title>About Atlas</title><link>https://www.guanpj.top/About-Atlas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/About-Atlas/</guid><description>up:: [[ACCESS 笔记组织法]]
Atlas意思是地图集。
单个案例或项目的MOC，考虑直接放在对应文件夹里面，相当于起到一个个文件夹的readme和导览的作用。这里专门放这些MOC的MOC。
围绕本库和obsidian的使用教程、方法和细节，也放到这里，就像是地图的指南针。</description></item><item><title>About Extras</title><link>https://www.guanpj.top/About-Extras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/About-Extras/</guid><description>up:: [[ACCESS 笔记组织法]]
[[图片保存：图床or本地]]</description></item><item><title>HashMap 源码解析</title><link>https://www.guanpj.top/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>前言 HashMap 是 Java 中最常用 K-V 容器，使用哈希值来确定元素存储的位置，HashMap 对 Entry 进行了扩展（Node），使其形成以链表或者树的形式存储在 HashMap 的容器里。
在 Java 8 之前和之后，HashMap 的实现有较大的不同，因此对于 put 流程、扩容机制等主要过程分析将会采用两个版本进行对比。
成员变量 HashMap 成员变量和构造方法声明如下（Java 7 和 8 大致相同，以下为 Java 8 版本）：</description></item><item><title>Index for Atlases</title><link>https://www.guanpj.top/Index-for-Atlases/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Index-for-Atlases/</guid><description>up:: [[ACCESS 笔记组织法]]
1 2 3 4 5 6 7 8 9 10 11 // 获取当前文件所在的文件夹 const currentFolder = dv.</description></item><item><title>Index for Extras</title><link>https://www.guanpj.top/Index-for-Extras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Index-for-Extras/</guid><description>up:: [[ACCESS 笔记组织法]]
1 2 3 4 5 6 7 8 9 10 11 // 获取当前文件所在的文件夹 const currentFolder = dv.</description></item><item><title>IO</title><link>https://www.guanpj.top/IO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/IO/</guid><description/></item><item><title>JVM 中的对象和垃圾回收</title><link>https://www.guanpj.top/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>虚拟机中的对象 了解了 JVM 运行时数据区域之后，大致明白了 JVM 内存模型的概况，对内存中的存放内容也有了初步了解。更进一步地，如果要了解内存中的数据的创建过程、在内存中如何布局、以及访问方式等，就必须要把范围限定到具体的虚拟机类型和集中在某一个内存区域上才有意义。下面以最常用的 HotSpot 虚拟机和最常用的内存区域 Java 堆为例，深入探索对象分配、布局和访问过程。
对象的创建 虚拟机遇到一条 new 指令时，首先检查是否被类加载器加载，如果没有，则必须先执行相应的类加载过程。类加载就是把 class 加载到 JVM 的运行时数据区的过程。
1、检查加载 首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用（以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。</description></item><item><title>JVM 内存区域</title><link>https://www.guanpj.top/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid><description>简介 什么是 JVM？ Java 虚拟机（Java Virtual Machine，简称 JVM），它能识别 .class 后缀的字节码文件（Java bytecode），并且能够解析它的指令，最终调用操作系统上的函数以完成指定操作。
为什么需要 JVM？ Java 程序使用 javac 编译成 .class 文件之后，还需要使用 Java 命令去主动执行它，操作系统并不认识这些 .</description></item><item><title>JVM 字节码指令简介</title><link>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</guid><description>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需的参数（操作数）构成。
在 Java 虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。比如， iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在 Class 文件中它们必须拥有各自独立的操作码。
编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的对 int 类型作为运算类型来进行的。</description></item><item><title>JVM 字节码结构分析</title><link>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</guid><description>概述 提到字节码，首先想到的就是 Java，Java 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。
​其实不止是 Java，其他很多编程语言如 Scala、Kotlin 和 Groovy 等都是运行在 JVM 的语言，因此它们对应的编译器也能够生成 .class 字节码。
源代码中的各种变量，关键字和运算符号的语义最终都会编译成多条字节码命令。而字节码命令所能提供的语义描述能力是要明显强于 Java 本身的，所以有其他一些同样基于 JVM 的语言能提供许多 Java 所不支持的语言特性。</description></item><item><title>JVM 类加载机制</title><link>https://www.guanpj.top/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid><description>概述 JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 Java 类型，这个过程被称作 JVM 的类加载机制。
与那些在编译时需要进行连接的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。
类加载的时机 一个类型从被加载到虚拟机内存中开始到卸载位置，整个生命周期会经历如下七个阶段，其中验证、准备、解析三个部分统称为连接。 上图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段后再开始，这是为了支持 Java 语言的运行时半丁特性（也被称为动态绑定或者晚期绑定）。</description></item><item><title>Troubleshooting and FAQ</title><link>https://www.guanpj.top/2023-03-22/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/2023-03-22/</guid><description>Still having trouble? Here are a list of common questions and problems people encounter when installing Quartz.
While you&amp;rsquo;re here, join our Discord :)</description></item><item><title>容器类</title><link>https://www.guanpj.top/%E5%AE%B9%E5%99%A8%E7%B1%BB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%AE%B9%E5%99%A8%E7%B1%BB/</guid><description>全家福： Iterable 接口 可迭代的意思，实现此接口允许对象成为“for-each”循环语句的目标，提供 iterator 方法用于遍历元素。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface Iterable&amp;lt;T&amp;gt; { Iterator&amp;lt;T&amp;gt; iterator(); default void forEach(Consumer&amp;lt;?</description></item><item><title>泛型</title><link>https://www.guanpj.top/%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%B3%9B%E5%9E%8B/</guid><description>什么是泛型？ 声明中具有一个或者多个类型参数(type parameter)的类或者接口，就是泛型类或者接口。泛型类和接口统称为泛型(generic type)。
每种泛型定义一组类型形参(formal type parameters)，这些类型形参有时也被简称为类型参数(type parameter)，例如对于 List&amp;lt;E&amp;gt; 而言，List&amp;lt;String&amp;gt; 就是一个参数化的类型(parameterized type)，String 就是对应于类型形参(formal type parameters)的类型实参(actual type parameter)。
而如果 List&amp;lt;E&amp;gt; 不使用泛型参数，List 则为原生类型(raw type)。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。</description></item><item><title>注解和反射</title><link>https://www.guanpj.top/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</guid><description>注解是什么？有何作用？ Java 注解（Annotation）又称 Java 标注，是 JDK1.5 引入的一种注释机制。是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。
注解本身没有任何意义，单独的注解就是一种注释，他需要结合其他如反射、插桩等技术才有意义。
元注解 在 JDK 中提供了 4 个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：
@Target Target 注解的作用是：描述注解的使用范围(即被修饰的注解可以用在什么地方).
Target 注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数），在定义注解类时使用了 @Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在 ElementType 枚举中.</description></item></channel></rss>