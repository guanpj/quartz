<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>原子类 on</title><link>https://www.guanpj.top/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/</link><description>Recent content in 原子类 on</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://www.guanpj.top/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/index.xml" rel="self" type="application/rss+xml"/><item><title>CAS 和 AQS 原理</title><link>https://www.guanpj.top/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/</guid><description>CAS 介绍 CAS 英文全称是 Compare-And-Swap，中文叫做“比较并交换”，它是一种思想、一种算法。
在大多数处理器的指令中，都会实现 CAS 相关的指令，这一条指令就可以完成“比较并交换”的操作，也正是由于这是一条（而不是多条）CPU 指令，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以无需我们程序员来操心。
CAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。CAS 最核心的思路就是，仅当预期值 A 和当前的内存值 V 相同时，才将内存值修改为 B。</description></item><item><title>Java 内存模型</title><link>https://www.guanpj.top/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid><description>JMM 是什么？ JMM 是和多线程相关的一组规范，它 定义了 JVM 在计算机内存中的工作方式，需要各个 JVM 的实现来遵守 JMM 规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。这样，即便同一个程序在不同的虚拟机上运行，得到的程序结果也是一致的，从而保证了“一次编译，处处运行”。
因此，JMM 与处理器、缓存、并发、编译器有关。它解决了 CPU 多级缓存、处理器优化、指令重排等导致的结果不可预期的问题。
比如关键字 synchronized，JVM 就会在 JMM 的规则下，“翻译”出合适的指令，包括限制指令之间的顺序，以便在即使发生了重排序的情况下，也能保证必要的“可见性”。这样一来，不同的 JVM 对于相同的代码的执行结果就变得可预期了，Java 程序员就只需要用同步工具和关键字就可以开发出正确的并发程序了。</description></item></channel></rss>