<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码解析 on</title><link>https://www.guanpj.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><description>Recent content in 源码解析 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.guanpj.top/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>EventBus 使用及源码解析</title><link>https://www.guanpj.top/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>使用 首先引入依赖 1 2 3 4 5 6 7 8 9 10 11 12 apply plugin: &amp;#39;kotlin-kapt&amp;#39; dependencies { implementation &amp;#39;org.</description></item><item><title>Glide 加载流程和缓存原理分析</title><link>https://www.guanpj.top/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>加载流程 Glide 最普通的用法如下：
Glide.with(this).load(url).into(textView);
以首次加载 url 指向的资源到 textView 对象为例，由于代码实在太过冗长，下面用流程图的方式表示各个环节的执行顺序。
with with 流程的主要职责：
创建 RequestManager 对象 初始化各式各样的配置信息（缓存、请求线程池、图片大小和格式等等）以及 Glide 单例对象。 将 Glide 请求和 application/Activity/SupportFragment/Fragment 的生命周期绑定在一起，从而实现自动执行请求，暂停操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Glide implements ComponentCallbacks2 { .</description></item><item><title>Glide 基本使用</title><link>https://www.guanpj.top/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>准备 添加依赖 1 2 implementation &amp;#39;com.github.bumptech.glide:glide:4.12.0&amp;#39; annotationProcessor &amp;#39;com.github.bumptech.glide:compiler:4.12.0&amp;#39; 添加网路权限 1 &amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34; /&amp;gt; 定义控件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 &amp;lt;androidx.</description></item><item><title>Glide 高级用法</title><link>https://www.guanpj.top/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</guid><description>回调与监听 Target 我们都知道，使用 Glide 在界面上加载并展示一张图片只需要一行代码：
1 Glide.with(this).load(url).into(imageView); 将 ImageView 的实例传入到 into() 方法当中，Glide 将图片加载完成之后，图片就能显示到 ImageView 上了。这是怎么实现的呢？来看一下 into() 方法的源码：</description></item><item><title>HashMap 源码解析</title><link>https://www.guanpj.top/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>前言 HashMap 是 Java 中最常用 K-V 容器，使用哈希值来确定元素存储的位置，HashMap 对 Entry 进行了扩展（Node），使其形成以链表或者树的形式存储在 HashMap 的容器里。
在 Java 8 之前和之后，HashMap 的实现有较大的不同，因此对于 put 流程、扩容机制等主要过程分析将会采用两个版本进行对比。
成员变量 HashMap 成员变量和构造方法声明如下（Java 7 和 8 大致相同，以下为 Java 8 版本）：</description></item><item><title>LeakCanary 使用及源码解析</title><link>https://www.guanpj.top/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>Reference 介绍 Reference 即是我们平时所说的“引用”，与之对应的是一个泛型抽象类。四种引用类型：SoftReference(软引用)、WeakReference(弱引用)、PhantomReference（虚引用）都继承自 Reference。它的声明如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 public abstract class Reference&amp;lt;T&amp;gt; { //引用对象 volatile T referent; //保存即将被回收的Reference对象 final ReferenceQueue&amp;lt;?</description></item><item><title>OkHttp 使用及源码分析</title><link>https://www.guanpj.top/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>https://juejin.cn/post/6881436122950402056
请求流程 同步请求 MainActivity.kt
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 val user = &amp;#34;guanpj&amp;#34; val client = OkHttpClient.</description></item><item><title>Retrofit 使用及源码分析</title><link>https://www.guanpj.top/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>使用 导入依赖。 1 2 3 4 5 6 7 8 9 implementation &amp;#34;com.squareup.okhttp3:okhttp:4.9.0&amp;#34; implementation &amp;#34;com.squareup.okhttp3:logging-interceptor:4.9.0&amp;#34; implementation &amp;#34;com.squareup.retrofit2:retrofit:2.9.0&amp;#34; implementation &amp;#34;com.</description></item><item><title>RxJava 使用及源码分析</title><link>https://www.guanpj.top/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>https://juejin.cn/post/6881436122950402056
介绍 Rx 是 ReactiveX 的简写，后者是 Reactive Extensions 的缩写，Rx 是一种编程模型，用于方便处理异步数据流。
RxJava 是响应式编程（Reactive Extensions）在 Java VM 上的实现，是一个在 Java VM 上使用可观察序列来组成异步的、基于事件的程序库。</description></item></channel></rss>