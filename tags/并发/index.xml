<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>并发 on</title><link>https://www.guanpj.top/tags/%E5%B9%B6%E5%8F%91/</link><description>Recent content in 并发 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.guanpj.top/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>CAS 和 AQS 原理</title><link>https://www.guanpj.top/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86/</guid><description>CAS 介绍 CAS 英文全称是 Compare-And-Swap，中文叫做“比较并交换”，它是一种思想、一种算法。
在大多数处理器的指令中，都会实现 CAS 相关的指令，这一条指令就可以完成“比较并交换”的操作，也正是由于这是一条（而不是多条）CPU 指令，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以无需我们程序员来操心。
CAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。CAS 最核心的思路就是，仅当预期值 A 和当前的内存值 V 相同时，才将内存值修改为 B。</description></item><item><title>并发容器</title><link>https://www.guanpj.top/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</guid><description>ConcurentHashMap Java 7 实现 Java 7 版本的 ConcurrentHashMap 数据结构示意图：
ConcurrentHashMap 内部进行了 Segment 分段，Segment 继承了 ReentrantLock，可以理解为一把锁，各个 Segment 之间都是相互独立上锁的，互不影响。相比于之前的 Hashtable 每次操作都需要把整个对象锁住而言，大大提高了并发效率。因为它的锁与锁之间是独立的，而不是整个对象只有一把锁。</description></item><item><title>等待-通知机制</title><link>https://www.guanpj.top/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</guid><description>wait/notify 模式 public class MyBlockingQueueForWaitNotify {
 private int maxSize = 16;
 private LinkedList storage;
  public MyBlockingQueueForWaitNotify (int size) {</description></item><item><title>锁</title><link>https://www.guanpj.top/Java-%E4%B8%AD%E7%9A%84%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/Java-%E4%B8%AD%E7%9A%84%E9%94%81/</guid><description>锁的分类 偏向锁/轻量级锁/重量级锁 Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级但不能降级。
这些状态被记录在对象头中的 mark word 中。
偏向锁 如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。
轻量级锁 JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。</description></item></channel></rss>