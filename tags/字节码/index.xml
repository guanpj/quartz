<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>字节码 on</title><link>https://www.guanpj.top/tags/%E5%AD%97%E8%8A%82%E7%A0%81/</link><description>Recent content in 字节码 on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://www.guanpj.top/tags/%E5%AD%97%E8%8A%82%E7%A0%81/index.xml" rel="self" type="application/rss+xml"/><item><title>JVM 字节码指令简介</title><link>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</guid><description>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需的参数（操作数）构成。
在 Java 虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。比如， iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在 Class 文件中它们必须拥有各自独立的操作码。
编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的对 int 类型作为运算类型来进行的。</description></item><item><title>JVM 字节码结构分析</title><link>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.guanpj.top/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</guid><description>概述 提到字节码，首先想到的就是 Java，Java 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。
​其实不止是 Java，其他很多编程语言如 Scala、Kotlin 和 Groovy 等都是运行在 JVM 的语言，因此它们对应的编译器也能够生成 .class 字节码。
源代码中的各种变量，关键字和运算符号的语义最终都会编译成多条字节码命令。而字节码命令所能提供的语义描述能力是要明显强于 Java 本身的，所以有其他一些同样基于 JVM 的语言能提供许多 Java 所不支持的语言特性。</description></item></channel></rss>