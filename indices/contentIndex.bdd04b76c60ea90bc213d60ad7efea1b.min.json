{"/":{"title":"AboutTheGardens","content":"## 111111\n\n### hello everyone!\n\n#### 哈哈哈哈哈\n\nsldfjlsajdfl sldfjlasjdlfjsld\nalsjfsd\nldjfsdf sld\n\n## 了散打减肥了\n\nsldfjlsdfj\nThis is my note:[[2023-03-20]]\n\n### 啊啊啊啊啊\n\n#### 手里的积分啦\n\n了散打发**教练**\n我这里讲了泛型：[[泛型]]\n我这里讲了IO：[[IO]]\n\ntoday's note:[[2023-03-22]]\n\nhashmap:[[HashMap 源码解析]]\n\nmore:[[容器类]]\n\nmore:[[JVM 内存区域]]\n\n\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["本库教程"]},"/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88":{"title":"其他模版","content":"### 史蒂夫\n\nline1: \u003c% tp.file.cursor(1) %\u003e\nline2: \u003c% tp.file.cursor(2) %\u003e","lastmodified":"2023-03-23T02:32:34.054210061Z","tags":[]},"/%E5%AE%B9%E5%99%A8%E7%B1%BB":{"title":"容器类","content":"全家福：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095328.png)\n# Iterable 接口\n\n可迭代的意思，实现此接口允许对象成为“for-each”循环语句的目标，提供 iterator 方法用于遍历元素。\n\n```java\npublic interface Iterable\u003cT\u003e {\n    Iterator\u003cT\u003e iterator();\n\n    default void forEach(Consumer\u003c? super T\u003e action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }\n\n    default Spliterator\u003cT\u003e spliterator() {\n        return Spliterators.spliteratorUnknownSize(iterator(), 0);\n    }\n}\n```\n\nIterator 意思为迭代器，它的定义如下：\n\n```java\npublic interface Iterator\u003cE\u003e {\n    boolean hasNext();\n\n    E next();\n\n    default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n\n    default void forEachRemaining(Consumer\u003c? super E\u003e action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n```\n\n迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的接口。它是一个经典的设计模式——迭代器模式（Iterator）。 迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e当使用 Iterator 对集合元素进行迭代时，Iterator 并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量），所以修改迭代变量的值对集合元素本身没有任何影响。\n\n# Collection 接口\n\nCollection 接口为集合层次的根接口，Collection 框架概览如图：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095429.png)\nCollection 接口中的关键方法定义如下：\n\n```java\npublic interface Collection\u003cE\u003e extends Iterable\u003cE\u003e {\n    // 集合大小\n    int size();\n    // 是否为空\n    boolean isEmpty();\n    // 是否包含此元素 o\n    boolean contains(Object o);\n    // 迭代器\n    Iterator\u003cE\u003e iterator();\n    // 转换成数组\n    Object[] toArray();\n    // 转换成指定类型数组\n    \u003cT\u003e T[] toArray(T[] a);\n    // 添加元素 e\n    boolean add(E e);\n    // 移除元素 o\n    boolean remove(Object o);\n    // 是否包含另一集合 c\n    boolean containsAll(Collection\u003c?\u003e c);\n    // 移除所有集合 c 中的元素\n    boolean removeAll(Collection\u003c?\u003e c);\n    /**\n     * 移除符合条件的元素\n     * @since 1.8\n     */\n    default boolean removeIf(Predicate\u003c? super E\u003e filter) {\n        Objects.requireNonNull(filter);\n        boolean removed = false;\n        final Iterator\u003cE\u003e each = iterator();\n        while (each.hasNext()) {\n            if (filter.test(each.next())) {\n                each.remove();\n                removed = true;\n            }\n        }\n        return removed;\n    }\n    // 判断集合中是否有不存在集合 c 中的元素\n    boolean retainAll(Collection\u003c?\u003e c);\n    // 清空所有元素\n    void clear();\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, 0);\n    }\n    /**\n     * @since 1.8\n     */\n    default Stream\u003cE\u003e stream() {\n        return StreamSupport.stream(spliterator(), false);\n    }\n    /**\n     * @since 1.8\n     */\n    default Stream\u003cE\u003e parallelStream() {\n        return StreamSupport.stream(spliterator(), true);\n    }\n}\n可以看出 Collection 有添加、删除和清除元素等方法。\n```\n\nCollection 接口下属有三个关键子借口，分别为 Set、Queue 和 List。\n\n## Set 接口\n\nSet 集合与 Collection 集合基本相同，没有提供任何额外的方法。实际上 Set 就是 Collection，只是行为略有不同（Set 不允许包含重复元素）。\n\nSet 集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个 Set 集合中，则 add() 方法会返回 false，且新元素不会被加入。\n\n```java\npublic interface Set\u003cE\u003e extends Collection\u003cE\u003e {\n    int size();\n\n    boolean isEmpty();\n\n    boolean contains(Object o);\n\n    Iterator\u003cE\u003e iterator();\n    \n    Object[] toArray();\n\n    \u003cT\u003e T[] toArray(T[] a);\n\n    boolean add(E e);\n\n    boolean remove(Object o);\n\n    boolean containsAll(Collection\u003c?\u003e c);\n\n    boolean addAll(Collection\u003c? extends E\u003e c);\n    \n    boolean removeAll(Collection\u003c?\u003e c);\n\n    void clear();\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT);\n    }\n}\n```\n\n### HashSet 类\n\nHashSet 是 Set 接口的典型实现，实现了 Set 接口中的所有方法，并没有添加额外的方法，大多数时候使用 Set 集合时就是使用这个实现类。使用的底层结构是 HashMap，按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。它的实现如下：\n\n```java\npublic class HashSet\u003cE\u003e extends AbstractSet\u003cE\u003e implements Set\u003cE\u003e {\n    static final long serialVersionUID = -5024744406713321676L;\n\n    private transient HashMap\u003cE,Object\u003e map;\n\n    private static final Object PRESENT = new Object();\n\n    public HashSet() {\n        map = new HashMap\u003c\u003e();\n    }\n\n    public HashSet(Collection\u003c? extends E\u003e c) {\n        map = new HashMap\u003c\u003e(Math.max((int) (c.size()/.75f) + 1, 16));\n        addAll(c);\n    }\n\n    public HashSet(int initialCapacity, float loadFactor) {\n        map = new HashMap\u003c\u003e(initialCapacity, loadFactor);\n    }\n\n    public HashSet(int initialCapacity) {\n        map = new HashMap\u003c\u003e(initialCapacity);\n    }\n\n    // dummy 并没有作用，只是用来区分重载构造方法\n    HashSet(int initialCapacity, float loadFactor, boolean dummy) {\n        map = new LinkedHashMap\u003c\u003e(initialCapacity, loadFactor);\n    }\n\n    public Iterator\u003cE\u003e iterator() {\n        return map.keySet().iterator();\n    }\n\n    public int size() {\n        return map.size();\n    }\n\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    public boolean contains(Object o) {\n        return map.containsKey(o);\n    }\n\n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n\n    public boolean remove(Object o) {\n        return map.remove(o)==PRESENT;\n    }\n\n    public void clear() {\n        map.clear();\n    }\n}\n```\n\n可以看出 HashSet 内部其实是一个 HashMap。它的 add(E e) 方法会调用 HashMap 的 put 方法，插入的值会作为 put 的 key 并且把 PRESENT 作为 put 方法的 value 值进行插入，put 方法新增一个原来不存在的值会返回 null，如果原来存在的话会返回原来存在的值，所以是 HashMap 保证了元素不重复。\n\n#### 特点\n\n- 不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。\n- HashSet 不是线程安全的，如果多个线程同时访问一个 HashSet，则必须通过代码来保证其同步。\n- 集合元素值可以是 null。\n\n#### 添加元素规则\n\n两个对象比较，具体分为如下四个情况：\n\n1. equals() 方法返回 false，hashCode() 方法返回不相等，HashSet 将会把它们存储在不同的位置。\n2. equals() 方法返回 true，hashCode() 方法返回不相等，HashSet 将会把它们存储在不同的位置。\n3. equals() 方法返回 true，hashCode() 方法比较相等，HashSet 将会把它们存储在相同的位置，在这个位置以链表式结构来保存多个对象。这是因为当向 HashSet 集合中存入一个元素时，HashSet 会调用对象的 hashCode() 方法来得到对象的 hashCode 值，然后根据该 hashCode 值来决定该对象存储在 HashSet 中存储位置。\n4. equals() 方法返回 true，hashCode() 方法返回 true，HashSet 将不予添加。\n\n如果 HashSet 中两个以上的元素具有相同的 hashCode 值，将会导致性能下降。所以如果重写类的 equals() 方法和 hashCode() 方法时，应尽量保证两个对象通过 hashCode() 方法返回值相等时，通过 equals() 方法比较返回 true。\n\n### LinkedHashSet 类\n\nLinkedHashSet 是 HashSet 的子类，也是根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素是以插入的顺序来保存的。当遍历 LinkedHashSet 集合里的元素时，LinkedHashSet 将会按元素的添加顺序来访问集合里的元素。但是由于要维护元素的插入顺序，在性能上略低与 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。\n\n它的实现如下：\n\n```java\npublic class LinkedHashSet\u003cE\u003e extends HashSet\u003cE\u003e implements Set\u003cE\u003e {\n\n    private static final long serialVersionUID = -2851667679971038690L;\n\n    public LinkedHashSet(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor, true);\n    }\n\n    public LinkedHashSet(int initialCapacity) {\n        super(initialCapacity, .75f, true);\n    }\n\n    public LinkedHashSet() {\n        super(16, .75f, true);\n    }\n\n    public LinkedHashSet(Collection\u003c? extends E\u003e c) {\n        super(Math.max(2*c.size(), 11), .75f, true);\n        addAll(c);\n    }\n\n    @Override\n    public Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT | \nSpliterator.ORDERED);\n    }\n}\n\n```\n\n可以看到，它的构造方法都是通过调用父类 HashSet 的三个参数的构造方法。\n\nHashSet 的构造分方法如下：\n\n```java\nHashSet(int initialCapacity, float loadFactor, boolean dummy) {\n    map = new LinkedHashMap\u003c\u003e(initialCapacity, loadFactor)\n}\n```\n\nLinkedHashMap 的实现见后文。\n\n### TreeSet 类\n\nTreeSet 是 SortedSet 接口的实现类，正如 SortedSet 名字所暗示的，TreeSet 可以确保集合元素处于排序状态。此外，TreeSet 还提供了几个额外的方法。\n\n#### 主要方法\n\ncomparator()：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。\n\nfirst()：返回此 set 中当前第一个（最低）元素。\n\nlast()：返回此 set 中当前最后一个（最高）元素。\n\nlower(E e)：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。\n\nhigher(E e)：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。\n\nfloor(E e)：返回此 set 中小于等于给定元素的最小值；如果不存在这样的元素，则返回 null。\n\nceiling(E e)：返回此 set 中大于给定元素的最大值；如果不存在这样的元素，则返回 null。\n\nsubSet(E fromElement, E toElement)：返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。\n\nheadSet(E toElement)：返回此 set 的部分视图，其元素小于 toElement。\n\ntailSet(E fromElement)：返回此 set 的部分视图，其元素大于等于 fromElement。\n\n#### 排序方式\n\nTreeSet 中所谓的有序，不同于之前所讲的插入顺序，而是通过集合中元素属性进行排序方式来实现的。TreeSet 支持两种排序方法：自然排序和定制排序。在默认情况下，TreeSet 采用自然排序。\n\n##### \u003cstrong\u003e自然排序\u003c/strong\u003e\n\nTreeSet 会调用集合中元素所属类的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列，即把通过 compareTo(Object obj) 方法比较后比较大的的往后排。这种方式就是自然排序。\n\n除了已经实现 Comparable 接口类（String 和 Integer 等）之外，如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口，否则就会出现异常。\n\n\u003cstrong\u003e注意：\u003c/strong\u003eTreeSet 中只能添加同一种类型的对象，否则无法比较，会出现异常。\n\n当一个对象调用该方法与另一个对象比较时，例如 obj1.compareTo(obj2)，如果该方法返回 0，则表明两个对象相等；如果该方法返回一个正整数，则表明 obj1 大于 obj2；如果该方法返回一个负整数，则表明 obj1 小于 obj2。\n\n##### \u003cstrong\u003e定制排序\u003c/strong\u003e\n\n定制排序是通过 Comparator 接口实现的。该接口包含一个 int compare(T o1,T o2) 方法，该方法用于比较 o1, o2 的大小：如果该方法返回正整数，则表明 o1 大于 o2；如果该方法返回 0，则表明 o1 等于 o2；如果该方法返回负整数，则表明 o1 小于 o2。\n\n如果要实现定制排序，则需要在创建 TreeSet 时，调用一个带参构造器，传入 Comparator 对 象。并有该 Comparator 对象负责集合元素的排序逻辑，此时集合元素可以不必实现 Comparable 接口。\n\n#### 判断元素相等\n\n对于 TreeSet 集合而言，判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较是否返回 0——如果通过 compareTo(Object obj) 方法比较返回 0，TreeSet 则会认为它们相等，不予添加入集合内；否则就认为它们不相等，添加到集合内。\n\n\u003cstrong\u003eTreeSet 是根据红黑树结构找到集合元素的存储位置。\u003c/strong\u003e\n\n注意：\n\n1. 无论使用自然排序还是定制排序，都可以通过自定义比较逻辑实现各种各样的排序方式。\n2. 如果向 TreeSet 中添加了一个可变对象后，并且后面程序修改了该可变对象的实例变量，这将导致它与其他对象的大小顺序发生了改变，但 TreeSet 不会再次调整它们。\n3. TreeSet 也是非线程安全的。\n\n### HashSet 和 TreeSet 对比\n\n\u003cstrong\u003e性能：HashSet \u003e LinkedHashSet \u003eTreeSet\u003c/strong\u003e\n\n- HashSet 以 hash 算法进行位置存储，特别适合用于添加、查询操作。\n- LinkedHashSet 由于要维护链表，性能比 HashSet 差点，但是有了链表，LinkedHashSet 更适合于插入、删除以及遍历操作。\n- TreeSet 需要额外的红黑树算法来维护集合的次序，性能最次。\n\n但是具体使用要考虑具体的使用场景。\n\n当需要一个特定排序的集合时，使用 TreeSet 集合。\n\n当经常使用添加、查询操作时，使用 HashSet。\n\n当经常插入排序或使用删除、插入及遍历操作时，使用 LinkedHashSet。\n\n## Queue 接口\n\nQueue 用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常队列不允许随机访问其中的元素。\n\n```java\npublic interface Queue\u003cE\u003e extends Collection\u003cE\u003e {\n    // 插入元素，容量已满时抛出 IllegalStateException 异常\n    boolean add(E e);\n    // 插入元素，容量已满时返回 false\n    boolean offer(E e);\n    // 移除队列头部元素并返回，当集合为空时抛出异常\n    E remove();\n    // 移除队列头部元素并返回，当集合为空时返回 null\n    E poll();\n    // 获取队列中第一个元素，当集合为空时抛出异常\n    E element();\n    // 获取队列中第一个元素，当集合为空时返回 null\n    E peek();\n}\n```\n\n### Deque 接口\n\nDeque 接口是 Queue 接口的子接口，它代表一个双端队列。\n\n就是说对于这个队列容器，既可以从头部插入也可以从尾部插入，既可以从头部获取，也可以从尾部获取，其机制如下图所示：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095517.png)\nLinkedList 也实现了 Deque 接口，所以也可以被当作双端队列使用。\n\n#### 主要方法\n\nvoid addFirst(E e):将指定元素插入此列表的开头。\n\nvoid addLast(E e): 将指定元素添加到此列表的结尾。\n\nE getFirst(E e): 返回此列表的第一个元素。\n\nE getLast(E e): 返回此列表的最后一个元素。\n\nboolean offerFirst(E e): 在此列表的开头插入指定的元素。\n\nboolean offerLast(E e): 在此列表末尾插入指定的元素。\n\nE peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。\n\nE peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。\n\nE pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。\n\nE pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。\n\nE removeFirst(E e): 移除并返回此列表的第一个元素。\n\nboolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\n\nE removeLast(E e): 移除并返回此列表的最后一个元素。\n\nboolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n\n从上面方法中可以看出，Deque 不仅可以当成双端队列使用，而且可以被当成栈来使用，因为该类里还包含了 pop(出栈)、push(入栈)两个方法。\n\n#### 与 Queue、Stack 的关系\n\n当 Deque 当做 Queue 队列使用时（FIFO），添加元素是添加到队尾，删除时删除的是头部元素。从 Queue 接口继承的方法对应 Deque 的方法如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095628.png)\nDeque 也能当 Stack 栈用（LIFO）。这时入栈、出栈元素都是在双端队列的头部进行。Deque  中和 Stack 对应的方法如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095654.png)\n\u003cstrong\u003e注意：\u003c/strong\u003eStack 过于古老，并且实现地非常不好，因此现在基本已经不用了，可以直接用 Deque 来代替 Stack 进行栈操作。\n\n#### ArrayDeque 类\n\n顾名思义，就是用数组实现的 Deque。既然底层是数组那肯定也可以指定其 capacity，也可以不指定，\u003cstrong\u003e默认长度是 16\u003c/strong\u003e，然后根据添加的元素的个数，动态扩展。ArrayDeque 由于是两端队列，所以其顺序是按照元素插入数组中对应位置产生的（下面会具体说明）。\n\n由于本身数据结构的限制，ArrayDeque 没有像 ArrayList 中的 trimToSize 方法可以为自己瘦身。ArrayDeque 的使用方法就是上面的 Deque 的使用方法，基本没有对 Deque 拓展什么方法。\n\n##### \u003cstrong\u003e实现原理\u003c/strong\u003e\n\nArrayDeque 为了满足可以同时在数组两端插入或删除元素的需求，其内部的动态数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。\n\nArrayDeque 维护了两个变量，表示 ArrayDeque 的头和尾：\n\n```java\n//具体存放元素的数组，数组大小一定是2的幂次方\ntransient Object[] elements; // non-private to \n//队列头索引\ntransient int head;\n//队列尾索引\ntransient int tail;\n//默认的最小初始化容量，即传入的容量小于8容量为8，而默认容量是16\nprivate static final int MIN_INITIAL_CAPACITY = 8;\n```\n\n当向头部插入元素时，head 下标减一然后插入元素。而 tail 表示的索引为当前末尾元素表示的索引值加一。若当向尾部插入元素时，直接向 tail 表示的位置插入，然后 tail 再减一。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095736.png)\n\n最初头部和尾部索引都是 0，addLast 方向往右，addFirst 方向往左，所以数组中间可能是空的，当头指针和尾指针相遇的时候对数组进行扩容，并对元素位置进行调整。\n\n注意：ArrayDeque 不是线程安全的。 当作为栈使用时，性能比 Stack 好；当作为队列使用时，性能比 LinkedList 好。\n\n### PriorityQueue 类\n\nPriorityQueue 是 Java 中唯一一个 Queue 接口的直接实现。PriorityQueue 保存队列元素的顺序不是按加入队列的顺序，而是按特定规则进行排序的。因此当调用 peek() 或 poll() 方法取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列中按规则排序最小的元素。\n\n#### 方法概览\n\nPriorityQueue 实现了 Queue 接口，下面列举出 PriorityQueue 的方法。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095901.png)\n\n#### 排序方式\n\n与 TreeSet 相同，PriorityQueue 中的元素可以默认自然排序（也就是数字默认是小的在队列头，字符串则按字典序排列）或者通过提供的 Comparator（比较器）在队列实例化时指定的排序方式。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e\n\n1. 队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素——选择方法是任意的。\n2. 当 PriorityQueue 中没有指定 Comparator 时，加入 PriorityQueue 的元素必须实现 Comparable 接口（即元素是可比较的），否则会导致 ClassCastException。\n\n#### 实现原理\n\nPriorityQueue 本质也是一个动态数组，在这一方面与 ArrayList 是一致的。它的成员变量和构造方法如下：\n\n```java\npublic class PriorityQueue\u003cE\u003e extends AbstractQueue\u003cE\u003e\n    implements java.io.Serializable {\n    private static final int DEFAULT_INITIAL_CAPACITY = 11;\n\n    transient Object[] queue; // non-private to simplify nested class access\n\n\n    private int size = 0;\n\n    private final Comparator\u003c? super E\u003e comparator;\n\n    transient int modCount = 0; // non-private to simplify nested class access\n\n    public PriorityQueue() {\n      this(DEFAULT_INITIAL_CAPACITY, null);\n    }\n\n    public PriorityQueue(int initialCapacity) {\n      this(initialCapacity, null);\n    }\n\n    public PriorityQueue(int initialCapacity,\n                         Comparator\u003c? super E\u003e comparator) {\n      // Note: This restriction of at least one is not actually \n      needed,but continues for 1.5 compatibility\n      if (initialCapacity \u003c 1)\n        throw new IllegalArgumentException();\n      this.queue = new Object[initialCapacity];\n      this.comparator = comparator;\n    }\n    ...\n}\n```\n\nPriorityQueue 可由以下三种构造方法创建：\n\n- 调用默认的构造方法时，使用默认的初始容量（DEFAULT_INITIAL_CAPACITY=11），并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable）。\n- 使用指定的初始容量，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable）。\n- 使用指定的初始容量，并根据指定的比较器 comparator 来排序其元素。\n\n从第三个构造方法可以看出，内部维护了一个动态数组。当添加元素到集合时，会先检查数组是否还有余量，有余量则把新元素加入集合，没余量则调用  grow() 方法增加容量，然后调用 siftUp 将新加入的元素排序插入对应位置。\n\n```java\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i \u003e= queue.length)\n        grow(i + 1);\n    size = i + 1;\n    if (i == 0)\n        queue[0] = e;\n    else\n        siftUp(i, e);\n    return true;\n}\n```\n\n除此之外，还要注意：\n\n1. PriorityQueue 不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的 PriorityBlockingQueue 类。\n2. 不允许插入 null 元素。\n3. PriorityQueue 实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是 O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是 O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是 O(1)。所以在遍历时，若不需要删除元素，则以 peek 的方式遍历每个元素。\n4. 方法 iterator() 中提供的迭代器并不保证以有序的方式遍历优 PriorityQueue 中的元素。\n\n## List 接口\n\nList 集合代表一个\u003cstrong\u003e元素有序、可重复\u003c/strong\u003e的集合，集合中每个元素都有其对应的顺序索引。List 集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List 集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为 0，第二个添加的元素索引为 1......\n\nList 作为 Collection 接口的子接口，可以使用 Collection 接口里的全部方法。而且由于 List 是有序集合，因此 List 集合里增加了一些根据索引来操作集合元素的方法。\n\n```java\npublic interface List\u003cE\u003e extends Collection\u003cE\u003e {\n    int size();\n\n    boolean isEmpty();\n\n    boolean contains(Object o);\n\n    Iterator\u003cE\u003e iterator();\n\n    Object[] toArray();\n\n    \u003cT\u003e T[] toArray(T[] a);\n\n    boolean add(E e);\n\n    boolean remove(Object o);\n\n    boolean containsAll(Collection\u003c?\u003e c);\n    \n    boolean addAll(Collection\u003c? extends E\u003e c);\n    \n    boolean addAll(int index, Collection\u003c? extends E\u003e c);\n    \n    boolean removeAll(Collection\u003c?\u003e c);\n    \n    boolean retainAll(Collection\u003c?\u003e c);\n    /**\n     * 根据 operator 指定的计算规则重新设置 List 集合的所有元素\n     * @since 1.8\n     */\n    default void replaceAll(UnaryOperator\u003cE\u003e operator) {\n        Objects.requireNonNull(operator);\n        final ListIterator\u003cE\u003e li = this.listIterator();\n        while (li.hasNext()) {\n            li.set(operator.apply(li.next()));\n        }\n    }\n    /**\n     * 根据Comparator参数对List集合的元素排序\n     * @since 1.8\n     */\n    default void sort(Comparator\u003c? super E\u003e c) {\n        Object[] a = this.toArray();\n        Arrays.sort(a, (Comparator) c);\n        ListIterator\u003cE\u003e i = this.listIterator();\n        for (Object e : a) {\n            i.next();\n            i.set((E) e);\n        }\n    }\n\n    void clear();\n    // 根据下标获取元素\n    E get(int index);\n    // 替换指定下标位置的元素\n    E set(int index, E element);\n    // 在指定下标位置插入元素\n    void add(int index, E element);\n    // 根据下标删除元素\n    E remove(int index);\n    // 获取元素下标，不存在则返回 -1\n    int indexOf(Object o);\n    // 获取与元素最后一个下标，，不存在则返回 -1\n    int lastIndexOf(Object o);\n\n    ListIterator\u003cE\u003e listIterator();\n    \n    ListIterator\u003cE\u003e listIterator(int index);\n    \n    List\u003cE\u003e subList(int fromIndex, int toIndex);\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.ORDERED);\n    }\n}\n```\n\n可以看出，经过扩展之后，List 相比于 Collection 多了“顺序”的概念，并且支持根据下表对集合进行操作。\n\nisEmpty()、contains() 等方法重新声明是为了为了方便查看文档。比如在 java doc 文档里，在 List 接口里也能看到 Collecion 声明的相关接口。\n\n此外，Java 8 为 List 接口添加了如下两个默认方法：\n\n- \u003cstrong\u003evoid replaceAll(UnaryOperator operator)：\u003c/strong\u003e根据 operator 指定的计算规则重新设置 List 集合的所有元素。\n- \u003cstrong\u003evoid sort(Comparator c)：\u003c/strong\u003e根据 Comparator 参数对 List 集合的元素排序。\n\nListIterator 接口在 Iterator 接口基础上增加了如下方法：\n\n- \u003cstrong\u003eboolean hasPrevious()：\u003c/strong\u003e 如果以逆向遍历列表。如果迭代器有上一个元素，则返回 true。\n- \u003cstrong\u003eObject previous()：\u003c/strong\u003e返回迭代器的前一个元素。\n- \u003cstrong\u003evoid add(Object o)：\u003c/strong\u003e将指定的元素插入列表（可选操作）。\n\n与 Iterator 相比，ListIterator 增加了前向迭代的功能，还可以通过 add() 方法向 List 集合中添加元素。\n\n### ArrayList 类\n\nArrayList 作为 List 类的典型实现，完全支持之前介绍的 List 接口的全部功能。它的成员变量和构造方法声明如下：\n\n```java\npublic class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e\n        implements List\u003cE\u003e, RandomAccess {\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    transient Object[] elementData;\n    \n    private int size;\n    \n    /**\n     * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity \u003e 0) {//初始容量大于0\n            //创建 initialCapacity 大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            // 创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {// 初始容量小于 0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n   /**\n    * 构造包含指定 collection 元素的列表，这些元素利用该集合的迭代器按顺序返回\n    * 如果指定的集合为 null，throws NullPointerException。\n    */\n     public ArrayList(Collection\u003c? extends E\u003e c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n    ...\n}\n```\n\nArrayList 是基于数组实现的 List 类，所以 ArrayList 类封装了一个动态的、允许再分配的 Object[] 数组。ArrayList 对象使用 initalCapacity 参数来设置该数组的长度，当向 ArrayList 中添加元素超过了该数组的长度时，它们的 initalCapacity 会自动增加。下面我们通过阅读 JDK 8 ArrayList 源码来了解这些内容。\n\n#### 扩容机制\n\n以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 \n\nJDK 7 new 无参构造的 ArrayList 对象时，直接创建了长度是 10 的 Object[] 数组 elementData 。并且 JDK 7 中的 ArrayList 的对象的创建类似于单例的饿汉式，而 JDK 8 中的 ArrayList 的对象的创建类似于单例的懒汉式。\n\n添加元素时，首先调用 add 方法：\n\n```java\n/**\n * 将指定的元素追加到此列表的末尾。\n */\npublic boolean add(E e) {\n    //添加元素之前，先调用ensureCapacityInternal方法\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    //这里看到ArrayList添加元素的实质就相当于为数组赋值\n    elementData[size++] = e;\n    return true;\n}\n```\n\n先调用了一个 ensureCapacityInternal() 方法，该方法用来确保数组中是否还有足够容量。\n\n\u003cstrong\u003e注意 ：JDK 11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法 \u003c/strong\u003e\n\n经过一系列方法，最后有个判断：如果剩余容量足够存放这个数据，则进行下一步，如果不够，则需要执行一个重要的方法：\n\n```java\n/**\n * 要分配的最大数组大小\n */\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n/**\n * ArrayList 扩容的核心方法。\n */\nprivate void grow(int minCapacity) {\n   // oldCapacity 为旧容量，newCapacity 为新容量\n   int oldCapacity = elementData.length;\n   //将 oldCapacity 右移一位，其效果相当于 oldCapacity / 2，\n   int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1);\n   //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n   if (newCapacity - minCapacity \u003c 0)\n      newCapacity = minCapacity;\n   // 如果新容量大于 MAX_ARRAY_SIZE，进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n   //如果 minCapacity大 于最大容量，则新容量则为 Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即 Integer.MAX_VALUE - 8。\n   if (newCapacity - MAX_ARRAY_SIZE \u003e 0)\n      newCapacity = hugeCapacity(minCapacity);\n   // minCapacity is usually close to size, so this is a win:\n   elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n`int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1)`，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）。\n\n由此可见，ArrayList 是一个能够进行动态扩展的数组。\n\n#### System.arraycopy() 和 Arrays.copyOf() 方法\n\nArrays.copyOf() 内部调用了 System.arraycopy() 方法，arraycopy() 方法由 native 层实现：\n\n```java\npublic static int[] copyOf(int[] original, int newLength) {\n   // 申请一个新的数组\n   int[] copy = new int[newLength];\n   // 调用System.arraycopy，将源数组中的数据进行拷贝，并返回新的数组\n   System.arraycopy(original, 0, copy, 0,\n           Math.min(original.length, newLength));\n   return copy;\n}\n\n/**\n * @param src 源数组\n * @param srcPos 源数组中的起始位置\n * @param dest 目标数组\n * @param destPos 目标数组中的起始位置\n * @param length 要复制的数组元素的数量\n */\npublic static native void arraycopy(Object src,  int  srcPos,\n                                    Object dest, int destPos,\n                                    int length);\n```\n\nensureCapacity() 和 trimToSize() 方法\n\n- \u003cstrong\u003evoid ensureCapacity(int minCapacity): \u003c/strong\u003e如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。\u003cstrong\u003e在增加大量数据之前，调用此方法，可以减少扩容次数。\u003c/strong\u003e\n- \u003cstrong\u003evoid trimToSize(): \u003c/strong\u003e将此 ArrayList 实例的容量调整为列表的当前大小。\n\n#### transient 的作用\n\n从构造方法中可以看到，实际存放集合元素的数组声明时时被 transient 所修饰的：\n\n`transient Object[] elementData;`\n\n当一个对象被序行化的时候，transient 修饰的变量的值是不包括在序行化的表示中的。但是 ArrayList 又是可序行化的类，elementData 是 ArrayList 具体存放元素的成员，用 transient 来修饰 elementData，岂不是反序列化后的 ArrayList 丢失了原先的元素？\n\n来看下面两个方法：\n\n```java\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException{\n    // Write out element count, and any hidden stuff\n    int expectedModCount = modCount;\n    s.defaultWriteObject();\n\n    // Write out size as capacity for behavioural compatibility with clone()\n    s.writeInt(size);\n\n    // Write out all elements in the proper order.\n    for (int i=0; i\u003csize; i++) {\n        s.writeObject(elementData[i]);\n    }\n\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n\n/**\n * Reconstitute the \u003ctt\u003eArrayList\u003c/tt\u003e instance from a stream (that is,\n * deserialize it).\n */\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n    elementData = EMPTY_ELEMENTDATA;\n\n    // Read in size, and any hidden stuff\n    s.defaultReadObject();\n\n    // Read in capacity\n    s.readInt(); // ignored\n\n    if (size \u003e 0) {\n        // be like clone(), allocate array based upon size not capacity\n        int capacity = calculateCapacity(elementData, size);\n        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);\n        ensureCapacityInternal(size);\n\n        Object[] a = elementData;\n        // Read in all elements in the proper order.\n        for (int i=0; i\u003csize; i++) {\n            a[i] = s.readObject();\n        }\n    }\n}\n由于 elementData 的扩容机制，数组中可能有空元素。因此，每次序列化的时候调用 writeObject() 方法，进而调用 defaultWriteObject() 方法忽略 elementData 先序列化 ArrayList 中的非 transient 元素，然后再通过遍历 elementData 只序列化那些有的元素。\n```\n\n这样一来，既\u003cstrong\u003e加快了序列化的速度，又减小了序列化之后的文件大小 。\u003c/strong\u003e\n\n反序列化时调用 readObject，从 ObjectInputStream 获取 size 和 element，再恢复到 elementData。\n\n//todo\n\n#### 遍历方式\n\nArrayList 支持 3 种遍历方式\n\n\u003cstrong\u003e第一种，通过迭代器遍历：\u003c/strong\u003e\n\n```java\nInteger value = null;\nIterator iter = list.iterator();\nwhile (iter.hasNext()) {\n    value = ter.next();\n}\n```\n\n\u003cstrong\u003e第二种，随机访问，通过索引值去遍历：\u003c/strong\u003e\n\n由于 ArrayList 实现了 RandomAccess 接口，它支持通过索引值去随机访问元素。\n\n```java\nInteger value = null;\nfor (int i = 0; i \u003c list.size(); i++) {\n    value = list.get(i);        \n}\n```\n\n\u003cstrong\u003e第三种，for 循环遍历：\u003c/strong\u003e\n\n```java\nInteger value = null;\nfor (Integer item : list) {\n    value = item;\n}\n```\n\n\u003cstrong\u003e遍历 ArrayList 时，使用随机访问(通过索引序号访问)效率最高，而使用迭代器的效率最低。\u003c/strong\u003e\n\n\u003cstrong\u003e//todo\u003c/strong\u003e\n\n### Vector 类\n\nVector 和 ArrayList 的实现基本类似，以 remove 方法为例：\n\n```java\npublic synchronized E remove(int index) {\n    modCount++;\n    if (index \u003e= elementCount)\n        throw new ArrayIndexOutOfBoundsException(index);\n    E oldValue = elementData(index);\n\n    int numMoved = elementCount - index - 1;\n    if (numMoved \u003e 0)\n        //复制数组，假设数组移除了中间某元素，后边有效值前移1位\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--elementCount] = null; // Let gc do its work\n\n    return oldValue;\n}\n```\n\n它的关键方法都加上了 synchronized 关键字，所以它是\u003cstrong\u003e线程安全\u003c/strong\u003e的，并且也因此\u003cstrong\u003e降低了性能\u003c/strong\u003e。\n\n除此之外，它的扩容机制也与 ArrayList 有所不同：\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    //扩容大小\n    int newCapacity = oldCapacity + ((capacityIncrement \u003e 0) ?\n                                     capacityIncrement : oldCapacity);\n    if (newCapacity - minCapacity \u003c 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE \u003e 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n当构造没有设置 capacityIncrement 时，一次扩容数组变成原来两倍，否则每次容量增加  capacityIncrement。\n\n#### Stack 类\n\nStack 是 Vector 的子类，用于模拟“栈”这种数据结构，即“后进先出”(LIFO)的容器。它提供了如下方法：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095956.png)\n\n由于继承自 Vector，Stack 自然也继承了 Vecor 线程安全和性能较低的特点。因此 Stack 类基本处于废弃状态，实现栈结构可由 LinkedList 代替。\n\n### LinkedList 类\n\nLinkedList 类是 List 接口的实现类——这意味着它是一个 List 集合，可以根据索引来随机访问集合中的元素。\n\n```java\npublic class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e\n             implements List\u003cE\u003e, Deque\u003cE\u003e {\n    transient int size = 0;\n\n    transient Node\u003cE\u003e first;\n\n    transient Node\u003cE\u003e last;\n\n    public LinkedList() {\n    }\n\n    public LinkedList(Collection\u003c? extends E\u003e c) {\n        this();\n        addAll(c);\n    }\n    ...\n}\n```\n\n可以看出，LinkedList 还实现了 Deque 接口，可以被当作成双端队列来使用，因此既可以被当成\u003cstrong\u003e栈\u003c/strong\u003e来使用，也可以当成\u003cstrong\u003e队列\u003c/strong\u003e来使用。\n\nLinkedList 的实现机制与 ArrayList 完全不同。ArrayList 内部是以数组的形式来保存集合中的元素的，因此随机访问集合元素时有较好的性能；而 L inkedList 内部以链表的形式来保存集合中的元素，因此随机访问集合元素时性能较差，但在插入、删除元素时性能比较出色。\n\n由于 LinkedList 双端队列的特性，所以新增了一些方法。\n\n#### 方法概览\n\n```java\nvoid addFirst(E e):将指定元素插入此列表的开头。\nvoid addLast(E e): 将指定元素添加到此列表的结尾。\nE getFirst(E e): 返回此列表的第一个元素。\nE getLast(E e): 返回此列表的最后一个元素。\nboolean offerFirst(E e): 在此列表的开头插入指定的元素。\nboolean offerLast(E e): 在此列表末尾插入指定的元素。\nE peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。\nE peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。\nE pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。\nE pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。\nE removeFirst(E e): 移除并返回此列表的第一个元素。\nboolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\nE removeLast(E e): 移除并返回此列表的最后一个元素。\nboolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n```\n\n#### 实现原理\n\nLinkedList 调用默认构造函数，创建一个链表。由于维护了一个表头，表尾的 Node 对象的变量。可以进行后续的添加元素到链表中的操作，以及其他删除，插入等操作。也因此实现了双向队列的功能，即可向表头加入元素，也可以向表尾加入元素。\n\nNode 定义如下：\n\n```java\nprivate static class Node\u003cE\u003e {\n    E item;//节点值\n    Node\u003cE\u003e next;//后继节点\n    Node\u003cE\u003e prev;//前驱节点\n    Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n新增操作 add(E e)，默认使用尾插法添加元素：\n\n```java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n\nvoid linkLast(E e) {\n    final Node\u003cE\u003e l = last;\n    final Node\u003cE\u003e newNode = new Node\u003c\u003e(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n```\n\n删除指定元素 remove(Object o): \n\n```java\npublic boolean remove(Object o) {\n    //如果删除对象为null\n    if (o == null) {\n        //从头开始遍历\n        for (Node\u003cE\u003e x = first; x != null; x = x.next) {\n            //找到元素\n            if (x.item == null) {\n                //从链表中移除找到的元素\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        //从头开始遍历\n        for (Node\u003cE\u003e x = first; x != null; x = x.next) {\n            //找到元素\n            if (o.equals(x.item)) {\n                //从链表中移除找到的元素\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nE unlink(Node\u003cE\u003e x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node\u003cE\u003e next = x.next;//得到后继节点\n    final Node\u003cE\u003e prev = x.prev;//得到前驱节点\n    //删除前驱指针\n    if (prev == null) {\n        first = next;// 如果删除的节点是头节点,令头节点指向该节点的后继节点\n    } else {\n        prev.next = next;// 将前驱节点的后继节点指向后继节点\n        x.prev = null;\n    }\n    //删除后继指针\n    if (next == null) {\n        last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n获取制定下表元素 get(int index):\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);//检查索引是否有效\n    return node(index).item;\n}\n\nNode\u003cE\u003e node(int index) {\n    // assert isElementIndex(index);\n    if (index \u003c (size \u003e\u003e 1)) {\n        Node\u003cE\u003e x = first;\n        for (int i = 0; i \u003c index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node\u003cE\u003e x = last;\n        for (int i = size - 1; i \u003e index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\nnode 方法首先会比较“index”和“双向链表长度的 1/2”；若前者小，则从链表头开始往后查找，直到 index 位置；否则，从链表末尾开始先前查找，直到 index 位置。\n\n由此可见，LinkedList 在插入、删除元素时性能比较出色，随机访问集合元素时性能较差。\n\n#### 遍历方式\n\n//todo\n\n# Map 接口\n\nMap 用于保存具有映射关系的数据。它是一种键值对的结构，即 Key-Value 结构，一个 Map 就是很多这样 K-V 键值对组成的，一个 K-V 结构我们将其称作 Entry，Key 和 Value 都可以是任何引用类型的数据。Map 的 Key 不允许重复，即同一个 Map 对象的任何两个 Key 通过 equals 方法比较总是返回 false。\n\nKey 和 Value 之间存在单向一对一关系，即通过指定的 Key，总能找到唯一的、确定的 Value。从 Map 中取出数据时，只要给出指定的 Key，就可以取出对应的 Value。\n\nMap 框架概览：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_100030.png)\n\nMap 接口的定义如下：\n\n```java\npublic interface Map\u003cK,V\u003e {\n    int size();\n\n    boolean isEmpty();\n    \n    boolean containsKey(Object key);\n    \n    boolean containsValue(Object value);\n    \n    V get(Object key);\n    \n    V put(K key, V value);\n    \n    V remove(Object key);\n\n    void putAll(Map\u003c? extends K, ? extends V\u003e m);\n    \n    void clear();\n\n    Set\u003cK\u003e keySet();\n    \n    Collection\u003cV\u003e values();\n    \n    Entry\u003cK, V\u003e\u003e entrySet();\n    \n    interface Entry\u003cK,V\u003e {\n        K getKey();\n\n        V getValue();\n        \n        V setValue(V value);\n        \n        boolean equals(Object o);\n        \n        int hashCode();\n        /**\n         * @since 1.8\n         */\n        public static \u003cK extends Comparable\u003c? super K\u003e, V\u003e Comparator\u003cMap.Entry\u003cK,V\u003e\u003e comparingByKey() {\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e c1.getKey().compareTo(c2.getKey());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V extends Comparable\u003c? super V\u003e\u003e Comparator\u003cMap.Entry\u003cK,V\u003e\u003e comparingByValue() {\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e c1.getValue().compareTo(c2.getValue());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V\u003e Comparator\u003cMap.Entry\u003cK, V\u003e\u003e comparingByKey(Comparator\u003c? super K\u003e cmp) {\n            Objects.requireNonNull(cmp);\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e cmp.compare(c1.getKey(), c2.getKey());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V\u003e Comparator\u003cMap.Entry\u003cK, V\u003e\u003e comparingByValue(Comparator\u003c? super V\u003e cmp) {\n            Objects.requireNonNull(cmp);\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e cmp.compare(c1.getValue(), c2.getValue());\n        }\n    }\n\n    boolean equals(Object o);\n\n    int hashCode();\n    // Defaultable methods\n    /**\n     * @since 1.8\n     */\n    default V getOrDefault(Object key, V defaultValue) {\n        V v;\n        return (((v = get(key)) != null) || containsKey(key))\n            ? v\n            : defaultValue;\n    }\n    /**\n     * @since 1.8\n     */\n    default void forEach(BiConsumer\u003c? super K, ? super V\u003e action) {\n        Objects.requireNonNull(action);\n        for (Map.Entry\u003cK, V\u003e entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n            action.accept(k, v);\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default void replaceAll(BiFunction\u003c? super K, ? super V, ? extends V\u003e function) {\n        Objects.requireNonNull(function);\n        for (Map.Entry\u003cK, V\u003e entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n            // ise thrown from function is not a cme.\n            v = function.apply(k, v);\n            try {\n                entry.setValue(v);\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V putIfAbsent(K key, V value) {\n        V v = get(key);\n        if (v == null) {\n            v = put(key, value);\n        }\n        return v;\n    }\n    /**\n     * @since 1.8\n     */\n    default boolean remove(Object key, Object value) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, value) ||\n            (curValue == null \u0026\u0026 !containsKey(key))) {\n            return false;\n        }\n        remove(key);\n        return true;\n    }\n    /**\n     * @since 1.8\n     */\n    default boolean replace(K key, V oldValue, V newValue) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, oldValue) ||\n            (curValue == null \u0026\u0026 !containsKey(key))) {\n            return false;\n        }\n        put(key, newValue);\n        return true;\n    }\n    /**\n     * @since 1.8\n     */\n    default V replace(K key, V value) {\n        V curValue;\n        if (((curValue = get(key)) != null) || containsKey(key)) {\n            curValue = put(key, value);\n        }\n        return curValue;\n    }\n    /**\n     * @since 1.8\n     */\n    default V computeIfAbsent(K key,\n            Function\u003c? super K, ? extends V\u003e mappingFunction) {\n        Objects.requireNonNull(mappingFunction);\n        V v;\n        if ((v = get(key)) == null) {\n            V newValue;\n            if ((newValue = mappingFunction.apply(key)) != null) {\n                put(key, newValue);\n                return newValue;\n            }\n        }\n        return v;\n    }\n    /**\n     * @since 1.8\n     */\n    default V computeIfPresent(K key,\n            BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue;\n        if ((oldValue = get(key)) != null) {\n            V newValue = remappingFunction.apply(key, oldValue);\n            if (newValue != null) {\n                put(key, newValue);\n                return newValue;\n            } else {\n                remove(key);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V compute(K key,\n            BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue = get(key);\n        V newValue = remappingFunction.apply(key, oldValue);\n        if (newValue == null) {\n            // delete mapping\n            if (oldValue != null || containsKey(key)) {\n                // something to remove\n                remove(key);\n                return null;\n            } else {\n                // nothing to do. Leave things as they were.\n                return null;\n            }\n        } else {\n            // add or replace old mapping\n            put(key, newValue);\n            return newValue;\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V merge(K key, V value,\n            BiFunction\u003c? super V, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        Objects.requireNonNull(value);\n        V oldValue = get(key);\n        V newValue = (oldValue == null) ? value :\n                   remappingFunction.apply(oldValue, value);\n        if(newValue == null) {\n            remove(key);\n        } else {\n            put(key, newValue);\n        }\n        return newValue;\n    }\n}\n```\n\nMap 接口处于整个框架的顶层，由一堆 Map 自身接口方法和一个 Entry 接口组成，Entry 接口定义了主要是关于 Key-Value 自身的一些操作，Map 接口定义的是一些属性和关于属性查找修改的一些接口方法。\n\n## HashMap\n\n见《HashMap 源码解析》\n\n### LinkedHashMap\n\nHashSet 有一个 LinkedHashSet 子类，HashMap 也有一个 LinkedHashMap 子类；LinkedHashMap 使用双向链表来维护 key-value 对的次序。\n\nLinkedHashMap 需要维护元素的插入顺序，因此性能略低于 HashMap 的性能；但是因为它以链表来维护内部顺序，所以在迭代访问 \u003cstrong\u003eMap 里的全部元素时有较好的性能\u003c/strong\u003e。迭代输出 LinkedHashMap 的元素时，将会按照添加 key-value 对的顺序输出。\n\n\u003cstrong\u003e本质上来讲，LinkedHashMap = 散列表 + 双向循环链表\u003c/strong\u003e\n\n#### \u003cstrong\u003e实现原理\u003c/strong\u003e\n\nLinkedHashMap 的主要成员变量和方法实现简化后如下：\n\n```java\npublic class LinkedHashMap\u003cK,V\u003e extends HashMap\u003cK,V\u003e \n          implements Map\u003cK,V\u003e {\n    static class Entry\u003cK,V\u003e extends HashMap.Node\u003cK,V\u003e {\n        Entry\u003cK,V\u003e before, after;\n        Entry(int hash, K key, V value, Node\u003cK,V\u003e next) {\n            super(hash, key, value, next);\n        }\n    } \n    // 双向链表的头节点\n    transient LinkedHashMap.Entry\u003cK,V\u003e head;\n    // 双向链表的尾戒低钠\n    transient LinkedHashMap.Entry\u003cK,V\u003e tail;\n    // 是否按照访问顺序排序\n    final boolean accessOrder;\n    \n    public LinkedHashMap(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor);\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(int initialCapacity) {\n        super(initialCapacity);\n        accessOrder = false;\n    }\n\n    public LinkedHashMap() {\n        super();\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(Map\u003c? extends K, ? extends V\u003e m) {\n        super();\n        accessOrder = false;\n        putMapEntries(m, false);\n    }\n\n    public LinkedHashMap(int initialCapacity,\n               float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n    \n    Node\u003cK,V\u003e newNode(int hash, K key, V value, Node\u003cK,V\u003e e) {\n        LinkedHashMap.Entry\u003cK,V\u003e p =\n            new LinkedHashMap.Entry\u003cK,V\u003e(hash, key, value, e);\n        // 将 Entry 接在双向链表的尾部\n        linkNodeLast(p);\n        return p;\n    }\n \n    @Overrid\n    Node\u003cK,V\u003e replacementNode(Node\u003cK,V\u003e p, Node\u003cK,V\u003e next) {\n        LinkedHashMap.Entry\u003cK,V\u003e q = (LinkedHashMap.Entry\u003cK,V\u003e)p;\n        LinkedHashMap.Entry\u003cK,V\u003e t = new LinkedHashMap.Entry\u003cK,V\u003e\n            (q.hash, q.key, q.value, next);\n        transferLinks(q, t);\n        return t;\n    }\n \n    @Overrid\n    TreeNode\u003cK,V\u003e newTreeNode(int hash, K key, V value, \n            Node\u003cK,V\u003e next) {\n        TreeNode\u003cK,V\u003e p = new TreeNode\u003cK,V\u003e(hash, key, value, next);\n        linkNodeLast(p);\n        return p;\n    }\n    \n    @Override\n    TreeNode\u003cK,V\u003e replacementTreeNode(Node\u003cK,V\u003e p, Node\u003cK,V\u003e next) {\n        LinkedHashMap.Entry\u003cK,V\u003e q = (LinkedHashMap.Entry\u003cK,V\u003e)p;\n        TreeNode\u003cK,V\u003e t = new TreeNode\u003cK,V\u003e(q.hash, q.key, \n            q.value, next);\n        transferLinks(q, t);\n        return t;\n    }\n    \n    // link at the end of list\n    private void linkNodeLast(LinkedHashMap.Entry\u003cK,V\u003e p) {\n        LinkedHashMap.Entry\u003cK,V\u003e last = tail;\n        tail = p;\n        // last 为 null，表明链表还未建立\n        if (last == null)\n            head = p;\n        else {\n            // 将新节点 p 接在链表尾部\n            p.before = last;\n            last.after = p;\n        }\n    }\n    \n    // apply src's links to dst\n    private void transferLinks(LinkedHashMap.Entry\u003cK,V\u003e src,\n                  LinkedHashMap.Entry\u003cK,V\u003e dst) {\n        LinkedHashMap.Entry\u003cK,V\u003e b = dst.before = src.before;\n        LinkedHashMap.Entry\u003cK,V\u003e a = dst.after = src.after;\n        if (b == null)\n            head = dst;\n        else\n            b.after = dst;\n        if (a == null)\n            tail = dst;\n        else\n            a.before = dst;\n    }\n    \n    @Override\n    void afterNodeAccess(Node\u003cK,V\u003e p) { }\n    @Override\n    void afterNodeInsertion(boolean evict) { }\n    @Override\n    void afterNodeRemoval(Node\u003cK,V\u003e e) { }\n}\n```\n\nLinkedHashMap 继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。\n\nMap 类型的集合类是通过 put(K,V) 方法插入键值对，LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。\n\n在 newNode 方法中，LinkedHashMap 创建了 Entry，并通过 linkNodeLast 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立\n\n#### afterNodeAccess()\n\n当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。\n\n```java\nvoid afterNodeAccess(Node\u003cK,V\u003e e) { // move node to last\n    LinkedHashMap.Entry\u003cK,V\u003e last;\n    if (accessOrder \u0026\u0026 (last = tail) != e) {\n        LinkedHashMap.Entry\u003cK,V\u003e p =\n            (LinkedHashMap.Entry\u003cK,V\u003e)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n```\n\n#### afterNodeInsertion()\n\n```java\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n    LinkedHashMap.Entry\u003cK,V\u003e first;\n    if (evict \u0026\u0026 (first = head) != null \u0026\u0026 removeEldestEntry(first)) {\n        K key = first.key;\n        removeNode(hash(key), key, null, false, true);\n    }\n}\n\nprotected boolean removeEldestEntry(Map.Entry\u003cK,V\u003e eldest) {\n    return false;\n}\n```\n\n在元素新增之后，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。\n\nevict 只有在构建 Map 的时候才为 false，在这里为 true。\n\nremoveEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。\n\n#### afterNodeRemoval()\n\n元素被删除后，此方法会被回调，删除双向链表中对应的节点。\n\n```java\nvoid afterNodeRemoval(Node\u003cK,V\u003e e) { // unlink\n    LinkedHashMap.Entry\u003cK,V\u003e p = (LinkedHashMap.Entry\u003cK,V\u003e)e, \n          b = p.before, a = p.after;\n    // 将 p 节点的前驱后后继引用置空\n    p.before = p.after = null;\n    // b 为 null，说明 p 是头节点\n    if (b == null)\n        head = a;\n    else\n        b.after = a;\n    // a 为 null，说明 p 是尾节点\n    if (a == null)\n        tail = b;\n    else\n        a.before = b;\n}\n```\n\n#### LRU 缓存\n\n以下是使用 LinkedHashMap 实现的一个 LRU 缓存：\n\n- 设定最大缓存空间 MAX_ENTRIES 为 3；\n- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；\n- 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。\n\n```java\nclass LRUCache\u003cK, V\u003e extends LinkedHashMap\u003cK, V\u003e {\n    private static final int MAX_ENTRIES = 3;\n\n    protected boolean removeEldestEntry(Map.Entry eldest) {\n        return size() \u003e MAX_ENTRIES;\n    }\n\n    LRUCache() {\n        super(MAX_ENTRIES, 0.75f, true);\n    }\n}\n```\n\n## TreeMap\n\nTreeMap 是 SortedMap 接口的实现类。TreeMap 是一个\u003cstrong\u003e有序的 \u003c/strong\u003ekey-value 集合，它是通过红黑树实现的，每个 key-value 对即作为红黑树的一个节点。\n\n### 排序方式\n\n和 TreeSet 一样，TreeMap 有两种排序方式：\n\n- 自然排序：TreeMap 的所有 key 必须实现 Comparable 接口，而且所有的 key 应该是同一个类的对象，否则会抛出 ClassCastException 异常。\n- 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。\n\n### 判断元素相等\n\n类似于 TreeSet 中判断两个元素相等的标准，TreeMap 中判断两个 key 相等的标准是：两个 key 通过 compareTo() 方法返回 0，TreeMap 即认为这两个 key 是相等的；判断两个 value 相等的标准是：两个 value 通过 equals() 方法比较返回 true。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e如果使用自定义类作为 TreeMap 的 key，且想让 TreeMap 良好地工作，则重写该类的 equals() 方法和 compareTo() 方法时应保持一致的返回结果：两个 key 通过 equals()方 法比较返回 true 时，它们通过 compareTo() 方法比较应该返回 0。如果两个方法的返回结果不一致，TreeMap 与 Map 接口的规则就会冲突。\n\n除此之外，与 TreeSet 类似，TreeMap 根据排序特性，也添加了一部分新的方法，与 TreeSet 中的一致。可以参考本文前面的内容。\n\n### 实现原理\n\nTreeMap 基于红黑树实现，而红黑树是一种自平衡二叉查找树，所以查找操作流程和二叉查找树一致。TreeMap 可保证在 log(n) 时间复杂度内完成 containsKey、get、put 和 remove 操作，效率很高。另一方面，由于 TreeMap 基于红黑树实现，这为 TreeMap 保持键的有序性打下了基础。总的来说，TreeMap 的核心是红黑树，其很多方法也是对红黑树增删查基础操作的一个包装。\n\n# fast-fail 机制\n\n#\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["Collection","Iterable","Java 容器类","Java"]},"/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8":{"title":"并发容器 ","content":"# 并发容器\n\n# ConcurentHashMap\n\n## Java 7 实现\n\nJava 7 版本的 ConcurrentHashMap 数据结构示意图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurent-Container/clipboard_20230323_094240.png)\n\nConcurrentHashMap 内部进行了 Segment 分段，Segment 继承了 ReentrantLock，可以理解为一把锁，各个 Segment 之间都是相互独立上锁的，互不影响。相比于之前的 Hashtable 每次操作都需要把整个对象锁住而言，大大提高了并发效率。因为它的锁与锁之间是独立的，而不是整个对象只有一把锁。\n\n每个 Segment 的底层数据结构与 HashMap 类似，仍然是数组和链表组成的拉链法结构。默认有 0~15 共 16 个 Segment，所以最多可以同时支持 16 个线程并发操作（操作分别分布在不同的 Segment 上）。16 这个默认值可以在初始化的时候设置为其他值，但是一旦确认初始化以后，是不可以扩容的。\n\n### 构造方法\n\n```java\npublic ConcurrentHashMap(int initialCapacity,\n                         float loadFactor, int concurrencyLevel) {\n    if (!(loadFactor \u003e 0) || initialCapacity \u003c 0 \n            || concurrencyLevel \u003c= 0)\n        throw new IllegalArgumentException();\n    if (concurrencyLevel \u003e MAX_SEGMENTS)\n        concurrencyLevel = MAX_SEGMENTS;\n    // Find power-of-two sizes best matching arguments\n    int sshift = 0;\n    int ssize = 1;\n    while (ssize \u003c concurrencyLevel) {\n        ++sshift;\n        ssize \u003c\u003c= 1;\n    }\n    this.segmentShift = 32 - sshift;\n    this.segmentMask = ssize - 1;\n    if (initialCapacity \u003e MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    int c = initialCapacity / ssize;\n    if (c * ssize \u003c initialCapacity)\n        ++c;\n    int cap = MIN_SEGMENT_TABLE_CAPACITY;\n    while (cap \u003c c)\n        cap \u003c\u003c= 1;\n    // create segments and segments[0]\n    Segment\u003cK,V\u003e s0 =\n        new Segment\u003cK,V\u003e(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry\u003cK,V\u003e[])new HashEntry[cap]);\n    Segment\u003cK,V\u003e[] ss = (Segment\u003cK,V\u003e[])new Segment[ssize];\n    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n    this.segments = ss;\n}\n```\n\n### Segment\n\n```java\nstatic final class Segment\u003cK,V\u003e extends ReentrantLock {\n    static final int MAX_SCAN_RETRIES =\n        Runtime.getRuntime().availableProcessors() \u003e 1 ? 64 : 1;\n        \n    transient volatile HashEntry\u003cK,V\u003e[] table;\n    \n    transient int count;\n    \n    transient int modCount;\n    \n    transient int threshold;\n    \n    final float loadFactor;\n    \n    ...\n    final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n        HashEntry\u003cK,V\u003e node = tryLock() ? null :\n            scanAndLockForPut(key, hash, value);\n        V oldValue;\n        try {\n            HashEntry\u003cK,V\u003e[] tab = table;\n            int index = (tab.length - 1) \u0026 hash;\n            HashEntry\u003cK,V\u003e first = entryAt(tab, index);\n            for (HashEntry\u003cK,V\u003e e = first;;) {\n                if (e != null) {\n                    K k;\n                    if ((k = e.key) == key ||\n                        (e.hash == hash \u0026\u0026 key.equals(k))) {\n                        oldValue = e.value;\n                        if (!onlyIfAbsent) {\n                            e.value = value;\n                            ++modCount;\n                        }\n                        break;\n                    }\n                    e = e.next;\n                }\n                else {\n                    if (node != null)\n                        node.setNext(first);\n                    else\n                        node = new HashEntry\u003cK,V\u003e(hash, \n                                key, value, first);\n                    int c = count + 1;\n                    if (c \u003e threshold \u0026\u0026 \n                          tab.length \u003c MAXIMUM_CAPACITY)\n                        rehash(node);\n                    else\n                        setEntryAt(tab, index, node);\n                    ++modCount;\n                    count = c;\n                    oldValue = null;\n                    break;\n                }\n            }\n        } finally {\n            unlock();\n        }\n        return oldValue;\n    }\n    \n    private HashEntry\u003cK,V\u003e scanAndLockForPut(K key, \n            int hash, V value) {\n        HashEntry\u003cK,V\u003e first = entryForHash(this, hash);\n        HashEntry\u003cK,V\u003e e = first;\n        HashEntry\u003cK,V\u003e node = null;\n        int retries = -1; // negative while locating node\n        while (!tryLock()) {\n            HashEntry\u003cK,V\u003e f; // to recheck first below\n            if (retries \u003c 0) {\n                if (e == null) {\n                    if (node == null) // speculatively create node\n                        node = new HashEntry\u003cK,V\u003e(hash, \n                                key, value, null);\n                    retries = 0;\n                }\n                else if (key.equals(e.key))\n                    retries = 0;\n                else\n                    e = e.next;\n            }\n            else if (++retries \u003e MAX_SCAN_RETRIES) {\n                lock();\n                break;\n            }\n            else if ((retries \u0026 1) == 0 \u0026\u0026\n                 (f = entryForHash(this, hash)) != first) {\n                e = first = f; // re-traverse if entry changed\n                retries = -1;\n            }\n        }\n        return node;\n    }\n    \n    private void rehash(HashEntry\u003cK,V\u003e node) {\n        HashEntry\u003cK,V\u003e[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        int newCapacity = oldCapacity \u003c\u003c 1;\n        threshold = (int)(newCapacity * loadFactor);\n        HashEntry\u003cK,V\u003e[] newTable =\n            (HashEntry\u003cK,V\u003e[]) new HashEntry[newCapacity];\n        int sizeMask = newCapacity - 1;\n        for (int i = 0; i \u003c oldCapacity ; i++) {\n            HashEntry\u003cK,V\u003e e = oldTable[i];\n            if (e != null) {\n                HashEntry\u003cK,V\u003e next = e.next;\n                int idx = e.hash \u0026 sizeMask;\n                if (next == null)   //  Single node on list\n                    newTable[idx] = e;\n                  else { // Reuse consecutive sequence at same slot\n                   HashEntry\u003cK,V\u003e lastRun = e;\n                    int lastIdx = idx;\n                    for (HashEntry\u003cK,V\u003e last = next;\n                         last != null;\n                         last = last.next) {\n                        int k = last.hash \u0026 sizeMask;\n                        if (k != lastIdx) {\n                            lastIdx = k;\n                            lastRun = last;\n                        }\n                    }\n                    newTable[lastIdx] = lastRun;\n                    // Clone remaining nodes\n                    for (HashEntry\u003cK,V\u003e p = e; p != lastRun; \n                            p = p.next) {\n                        V v = p.value;\n                        int h = p.hash;\n                        int k = h \u0026 sizeMask;\n                        HashEntry\u003cK,V\u003e n = newTable[k];\n                        newTable[k] = new HashEntry\u003cK,V\u003e(h, \n                                p.key, v, n);\n                    }\n                }\n            }\n        }\n        int nodeIndex = node.hash \u0026 sizeMask; // add the new node\n        node.setNext(newTable[nodeIndex]);\n        newTable[nodeIndex] = node;\n        table = newTable;\n    }\n}\n```\n\n### put 流程分析\n\n```java\npublic V put(K key, V value) {\n    Segment\u003cK,V\u003e s;\n    if (value == null)\n        throw new NullPointerException();\n    int hash = hash(key);\n    int j = (hash \u003e\u003e\u003e segmentShift) \u0026 segmentMask;\n    if ((s = (Segment\u003cK,V\u003e)UNSAFE.getObject  // nonvolatile; recheck\n         (segments, (j \u003c\u003c SSHIFT) + SBASE)) == null) \n        //in ensureSegment\n        s = ensureSegment(j);\n    return s.put(key, hash, value, false);\n}\n\nprivate Segment\u003cK,V\u003e ensureSegment(int k) {\n    final Segment\u003cK,V\u003e[] ss = this.segments;\n    long u = (k \u003c\u003c SSHIFT) + SBASE; // raw offset\n    Segment\u003cK,V\u003e seg;\n    if ((seg = (Segment\u003cK,V\u003e)UNSAFE\n            .getObjectVolatile(ss, u)) == null) {\n        Segment\u003cK,V\u003e proto = ss[0]; // use segment 0 as prototype\n        int cap = proto.table.length;\n        float lf = proto.loadFactor;\n        int threshold = (int)(cap * lf);\n        HashEntry\u003cK,V\u003e[] tab = (HashEntry\u003cK,V\u003e[])new HashEntry[cap];\n        if ((seg = (Segment\u003cK,V\u003e)UNSAFE.getObjectVolatile(ss, u))\n            == null) { // recheck\n            Segment\u003cK,V\u003e s = new Segment\u003cK,V\u003e(lf, threshold, tab);\n            while ((seg = (Segment\u003cK,V\u003e)UNSAFE\n                      .getObjectVolatile(ss, u))\n                   == null) {\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n```\n\n### get 流程分析\n\n```java\npublic V get(Object key) {\n    Segment\u003cK,V\u003e s; // manually integrate access methods to reduce overhead\n    HashEntry\u003cK,V\u003e[] tab;\n    int h = hash(key);\n    long u = (((h \u003e\u003e\u003e segmentShift) \u0026 segmentMask) \u003c\u003c SSHIFT) + SBASE;\n    if ((s = (Segment\u003cK,V\u003e)UNSAFE.getObjectVolatile(segments, u)) \n              != null \u0026\u0026 (tab = s.table) != null) {\n        for (HashEntry\u003cK,V\u003e e = (HashEntry\u003cK,V\u003e)         \n                UNSAFE.getObjectVolatile(tab, \n                ((long)(((tab.length - 1) \u0026 h)) \u003c\u003c TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h \u0026\u0026 key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n```\n\n## Java 8 实现\n\nJava 8 版本的 ConcurrentHashMap 数据结构示意图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurent-Container/clipboard_20230323_094255.png)\n\n### Node 节点\n\n内部存储结构 Node 源码：\n\n```java\nstatic class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {\n    final int hash;\n    final K key;\n    volatile V val;\n    volatile Node\u003cK,V\u003e next;\n    // ...\n}\n```\n\n可以看出，每个 Node 里面是 key-value 的形式，并且把 value 用 volatile 修饰，以便保证可见性，同时内部还有一个指向下一个节点的 next 指针，方便产生链表结构。\n\n### put 方法源码分析\n\n```java\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\n\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) {\n        throw new NullPointerException();\n    }\n    //计算 hash 值\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node\u003cK, V\u003e[] tab = table; ; ) {\n        Node\u003cK, V\u003e f;\n        int n, i, fh;\n        //如果数组是空的，就进行初始化\n        if (tab == null || (n = tab.length) == 0) {\n            tab = initTable();\n        }\n        // 找该 hash 值对应的数组下标\n        else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) {\n            //如果该位置是空的，就用 CAS 的方式放入新值\n            if (casTabAt(tab, i, null,\n                    new Node\u003cK, V\u003e(hash, key, value, null))) {\n                break;\n            }\n        }\n        //hash值等于 MOVED 代表在扩容\n        else if ((fh = f.hash) == MOVED) {\n            tab = helpTransfer(tab, f);\n        }\n        // 槽点上是有值的情况\n        else {\n            V oldVal = null;\n            // 用 synchronized 锁住当前槽点，保证并发安全\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    // 如果是链表的形式\n                    if (fh \u003e= 0) {\n                        binCount = 1;\n                        // 遍历链表\n                        for (Node\u003cK, V\u003e e = f; ; ++binCount) {\n                            K ek;\n                            // 如果发现该 key 已存在，\n                            // 就判断是否需要进行覆盖，然后返回\n                            if (e.hash == hash \u0026\u0026\n                                    ((ek = e.key) == key ||\n                                    (ek != null \u0026\u0026 key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent) {\n                                    e.val = value;\n                                }\n                                break;\n                            }\n                            Node\u003cK, V\u003e pred = e;\n                            // 到了链表的尾部也没有发现该 key，\n                            // 说明之前不存在，就把新值添加到链表的最后\n                            if ((e = e.next) == null) {\n                                pred.next = new Node\u003cK, V\u003e(hash, key,\n                                        value, null);\n                                break;\n                            }\n                        }\n                    }\n                    //如果是红黑树的形式\n                    else if (f instanceof TreeBin) {\n                        Node\u003cK, V\u003e p;\n                        binCount = 2;\n                        //调用 putTreeVal 方法往红黑树里增加数据\n                        if ((p = ((TreeBin\u003cK, V\u003e) f).putTreeVal(hash,         \n                                key, value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent) {\n                                p.val = value;\n                            }\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                // 检查是否满足条件并把链表转换为红黑树的形式，       \n                // 默认的 TREEIFY_THRESHOLD 阈值是 8\n                if (binCount \u003e= TREEIFY_THRESHOLD) {\n                    treeifyBin(tab, i);\n                }\n                // putVal 的返回是添加前的旧值，所以返回 oldVal\n                if (oldVal != null) {\n                    return oldVal;\n                }\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n通过以上的源码分析，我们对于 putVal 方法有了详细的认识，可以看出，方法中会逐步根据当前槽点是未初始化、空、扩容、链表、红黑树等不同情况做出不同的处理。\n\n### get 方法源码分析\n\nget 方法比较简单，同样用源码注释的方式来分析一下：\n\n```java\npublic V get(Object key) {\n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e e, p; int n, eh; K ek;\n    // 计算 hash 值\n    int h = spread(key.hashCode());\n    // 如果整个数组是空的，或者当前槽点的数据是空的，\n    // 说明 key 对应的 value 不存在，直接返回 null\n    if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026\n            (e = tabAt(tab, (n - 1) \u0026 h)) != null) {\n        // 判断头结点是否就是我们需要的节点，如果是则直接返回\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek)))\n                return e.val;\n        }\n        // 如果头结点 hash 值小于 0，说明是红黑树或者正在扩容，\n        // 就用对应的 find 方法来查找\n        else if (eh \u003c 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        // 遍历链表来查找\n        while ((e = e.next) != null) {\n            if (e.hash == h \u0026\u0026 ((ek = e.key) == key \n                  || (ek != null \u0026\u0026 key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\n\n总结一下 get 的过程：\n\n1. 计算 Hash 值，并由此值找到对应的槽点；\n2. 如果数组是空的或者该位置为 null，那么直接返回 null 就可以了；\n3. 如果该位置处的节点刚好就是我们需要的，直接返回该节点的值；\n4. 如果该位置节点是红黑树或者正在扩容，就用 find 方法继续查找；\n5. 否则那就是链表，就进行遍历链表查找。\n\n## 对比 Java7 和 Java8 版本的异同和优缺点\n\n- 数据结构\n\n正如最开始的两个结构示意图所示，Java 7 采用 Segment 分段锁来实现，而 Java 8 中的 ConcurrentHashMap 使用数组 + 链表 + 红黑树，在这一点上它们的差别非常大。\n\n- 并发度\n\nJava 7 中，每个 Segment 独立加锁，最大并发个数就是 Segment 的个数，默认是 16。\n\n但是到了 Java 8 中，锁粒度更细，理想情况下 table 数组元素的个数（也就是数组长度）就是其支持并发的最大个数，并发度比之前有提高。\n\n- 保证并发安全的原理\n\nJava 7 采用 Segment 分段锁来保证安全，而 Segment 是继承自 ReentrantLock。\n\nJava 8 中放弃了 Segment 的设计，采用 Node + CAS + synchronized 保证线程安全。\n\n- 处理 Hash 冲突\n\nJava 7 在 Hash 冲突时，会使用拉链法，也就是链表的形式。\n\nJava 8 先使用拉链法，在链表长度超过一定阈值时，将链表转换为红黑树，来提高查找效率。\n\n- 查询时间复杂度\n\nJava 7 遍历链表的时间复杂度是 O(n)，n 为链表长度。\n\nJava 8 如果变成遍历红黑树，那么时间复杂度降低为 O(log(n))，n 为树的节点个数。\n\n# CopyOnWriteArrayList\n\n在 CopyOnWriteArrayList 出现之前，已经有了 ArrayList 和 LinkedList 作为 List 的数组和链表的实现，而且也有了线程安全的 Vector 和 Collections.synchronizedList() 可以使用。\n\nVector 内部是使用 synchronized 来保证线程安全的，并且锁的粒度比较大，都是方法级别的锁，在并发量高的时候，很容易发生竞争，并发效率相对比较低。在这一点上，Vector 和 Hashtable 很类似。\n\n并且，前面这几种 List 在迭代期间不允许编辑，如果在迭代期间进行添加或删除元素等操作，则会抛出 ConcurrentModificationException 异常，这样的特点也在很多情况下给使用者带来了麻烦。\n\n所以从 JDK1.5 开始，Java 并发包里提供了使用 CopyOnWrite 机制实现的并发容器  CopyOnWriteArrayList 作为主要的并发 List，CopyOnWrite 的并发集合还包括 CopyOnWriteArraySet，其底层正是利用 CopyOnWriteArrayList 实现的。\n\n## 适用场景\n\n- 读操作可以尽可能的快，而写即使慢一些也没关系\n\n在很多应用场景中，读操作可能会远远多于写操作。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。\n\n- 读多写少\n\n黑名单是最典型的场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单并不需要实时更新，可能每天晚上更新一次就可以了。当用户搜索时，会检查当前关键字在不在黑名单中，如果在，则提示不能搜索。这种读多写少的场景也很适合使用 CopyOnWrite 集合。\n\n## 读写规则\n\n- 读写锁的规则\n\n读写锁的思想是：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥），原因是由于读操作不会修改原有的数据，因此并发读并不会有安全问题；而写操作是危险的，所以当写操作发生时，不允许有读操作加入，也不允许第二个写线程加入。\n\n- 对读写锁规则的升级\n\nCopyOnWriteArrayList 的思想比读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。\n\n## 特点\n\n- CopyOnWrite 的含义\n\n从 CopyOnWriteArrayList 的名字就能看出它是满足 CopyOnWrite 的 ArrayList，CopyOnWrite 的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，完成修改之后，再将原容器的引用指向新的容器。这样就完成了整个修改过程。\n\n这样做的好处是，CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本，所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改。\n\nCopyOnWriteArrayList 的所有修改操作（add，set 等）都是通过创建底层数组的新副本来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，读和写使用不同的容器。\n\n- 迭代期间允许修改集合内容\n\n我们知道 ArrayList 在迭代期间如果修改集合的内容，会抛出 ConcurrentModificationException 异常。CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了，CopyOnWriteArrayList 不会报 ConcurrentModificationException 的异常，因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了\n\n## 源码分析\n\n### 数据结构\n\n```java\npublic class CopyOnWriteArrayList\u003cE\u003e implements List\u003cE\u003e,\n             RandomAccess {\n    /** The lock protecting all mutators */\n    final transient ReentrantLock lock = new ReentrantLock();\n    /** The array, accessed only via getArray/setArray. */\n    private transient volatile Object[] array;\n\n    final Object[] getArray() {\n        return array;\n    }\n\n    final void setArray(Object[] a) {\n        array = a;\n    }\n\n    public CopyOnWriteArrayList() {\n        setArray(new Object[0]);\n    }\n   \n    public CopyOnWriteArrayList(Collection\u003c? extends E\u003e c) {\n        Object[] elements;\n        if (c.getClass() == CopyOnWriteArrayList.class)\n            elements = ((CopyOnWriteArrayList\u003c?\u003e)c).getArray();\n        else {\n            elements = c.toArray();\n            if (c.getClass() != ArrayList.class)\n                elements = Arrays.copyOf(elements, elements.length, Object[].class);\n        }\n        setArray(elements);\n    }\n    \n    ...\n}\n```\n\n在这个类中首先会有一个 ReentrantLock 锁，用来保证修改操作的线程安全。下面被命名为 array 的 Object[] 数组是被 volatile 修饰的，可以保证数组的可见性，这正是存储元素的数组，同样，我们可以从 getArray()、setArray 以及它的构造方法看出，CopyOnWriteArrayList 的底层正是利用数组实现的，这也符合它的名字。\n\n### \u003cstrong\u003eadd 方法\u003c/strong\u003e\n\n```java\npublic boolean add(E e) {\n    // 加锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 得到原数组的长度和元素\n        Object[] elements = getArray();\n        int len = elements.length;\n        // 复制出一个新数组\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        // 添加时，将新元素添加到新数组中\n        newElements[len] = e;\n        // 将volatile Object[] array 的指向替换成新数组\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\nadd 方法的作用是往 CopyOnWriteArrayList 中添加元素，是一种修改操作。首先需要利用 ReentrantLock 的 lock 方法进行加锁，获取锁之后，得到原数组的长度和元素，也就是利用 getArray 方法得到 elements 并且保存 length。之后利用 Arrays.copyOf 方法复制出一个新的数组，得到一个和原数组内容相同的新数组，并且把新元素添加到新数组中。完成添加动作后，需要转换引用所指向的对象，利用 setArray(newElements) 操作就可以把 volatile Object[] array 的指向替换成新数组，最后在 finally 中把锁解除。\n\n总结流程：在添加的时候首先上锁，并复制一个新数组，增加操作在新数组上完成，然后将 array 指向到新数组，最后解锁。\n\n上面的步骤实现了 CopyOnWrite 的思想：写操作是在原来容器的拷贝上进行的，并且在读取数据的时候不会锁住 list。而且可以看到，如果对容器拷贝操作的过程中有新的读线程进来，那么读到的还是旧的数据，因为在那个时候对象的引用还没有被更改。\n\n### get 方法\n\n```java\npublic E get(int index) {\n    return get(getArray(), index);\n}\nfinal Object[] getArray() {\n    return array;\n}\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n```\n\n可以看出，get 相关的操作没有加锁，保证了读取操作的高速。\n\n### \u003cstrong\u003e迭代器 COWIterator 类\u003c/strong\u003e\n\n这个迭代器有两个重要的属性，分别是 Object[] snapshot 和 int cursor。其中 snapshot 代表数组的快照，也就是创建迭代器那个时刻的数组情况，而 cursor 则是迭代器的游标。迭代器的构造方法如下：\n\n```java\nprivate COWIterator(Object[] elements, int initialCursor) {\n    cursor = initialCursor;\n    snapshot = elements;\n}\n```\n\n可以看出，迭代器在被构建的时候，会把当时的 elements 赋值给 snapshot，而之后的迭代器所有的操作都基于 snapshot 数组进行的，比如：\n\n```java\npublic E next() {\n    if (! hasNext())\n        throw new NoSuchElementException();\n    return (E) snapshot[cursor++];\n}\n```\n\n在 next 方法中可以看到，返回的内容是 snapshot 对象，所以，后续就算原数组被修改，这个 snapshot 既不会感知到，也不会受影响，执行迭代操作不需要加锁，也不会因此抛出异常。迭代器返回的结果，和创建迭代器的时候的内容一致。\n\n# CopyOnWriteArraySet\n\n# ConcurrentLinkedQueue\n\nJava 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。\n\n从名字可以看出，ConcurrentLinkedQueue 这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。\n\nConcurrentLinkedQueue 内部代码这里就不分析了，主要使用 CAS 非阻塞算法来实现线程安全。\n\nConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。\n","lastmodified":"2023-03-23T02:32:34.058210059Z","tags":[]},"/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0":{"title":"我的日记","content":"### 今日开发工作\n### 今日感想","lastmodified":"2023-03-23T02:32:34.054210061Z","tags":[]},"/%E6%9C%AA%E5%91%BD%E5%90%8D":{"title":"未命名","content":"","lastmodified":"2023-03-23T02:32:34.054210061Z","tags":[]},"/%E6%B3%9B%E5%9E%8B":{"title":"泛型","content":"# 什么是泛型？\n\n声明中具有一个或者多个类型参数(type parameter)的类或者接口，就是泛型类或者接口。泛型类和接口统称为泛型(generic type)。\n\n每种泛型定义一组类型形参(formal type parameters)，这些类型形参有时也被简称为类型参数(type parameter)，例如对于 `List\u003cE\u003e` 而言，`List\u003cString\u003e` 就是一个参数化的类型(parameterized type)，String 就是对应于类型形参(formal type parameters)的类型实参(actual type parameter)。\n\n而如果 `List\u003cE\u003e` 不使用泛型参数，List 则为原生类型(raw type)。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。\n\n每个泛型定义一个原生类型(raw type)，即不带任何类型参数的类型名称，例如，与 `List\u003cString\u003e` 对应的原生类型是 List。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。\n\nJava 泛型是自 JDK5 起引入的一种参数化类型特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型泛型的本质是参数类型，也就是说所操作的数据类型被指定为一个参数。因为类型擦除机制，泛型不存在于 JVM 虚拟机。\n\n# 为什么使用泛型？\n\n1.使代码更健壮\n\n2.使代码更简洁(不用强转)\n\n3.使代码可复用性更高，程序更灵活\n\n通俗地说，泛型是「有远⻅的创造者」创造的「方便使用者」的工具。也就是说，使用泛型能够让开发这编写出更加灵活的代码。\n\n## 泛型的使用\n\n## 作为类/接口的类型参数\n\n可以在一个类或者接口里定义一个类型参数，等着子类/实现类去写出不同的实现：\n\n```java\npublic interface Comparable\u003cT\u003e {\n  int compareTo(T o);\n  ...\n}\n\npublic String implements Comparable\u003cString\u003e {\n  int compareTo(String anotherString);\n  ...\n}\n\npublic class Stack\u003cE\u003e extends Vector\u003cE\u003e {\n  ...\n}\n\nStack\u003cString\u003e stack = new Stack\u003c\u003e();\n```\n\n## 作为方法的返回值类型\n\n```java\nT buy();\n```\n\n## 用于类型约束\n\n由于泛型语法自身特性，某些情形下也可以用于类型约束\n\n```java\n// 约束类型参数上界\npublic \u003cE extends Runnable, Serializable\u003e void someMethod(E param);\n\n// 约束方法参数之间的关系\npublic \u003cT\u003e void merge(T item, List\u003cT\u003e list) {\n  list.add(item);\n}\n```\n\n# 泛型擦除的过程\n\n1. 类型检查：在生成字节码之前提供类型检查\n2. 类型擦除：所有类型参数都用他们的限定类型替换，包括类、变量和方法（类型擦除）\n3. 如果类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决\n4. 如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转换\n\n# 泛型的限制\n\n1. 不能用基本类型作为泛型参数\n2. 不能在运行时获取泛型类型\n3. 不能静态字段或方法中引用泛型变量\n4. 不能创建参数化类型数组\n5. 不能实例化类型变量\n6. 不能捕获泛型类的实例，类不能继承自 Exception，只能派生自 Throwable\n\n```java\npublic \u003cT extends Throwable\u003e void fun1(T t) {\n  try {\n    ...\n  } catch(T x) {//不允许\n  }\n}\n\npublic \u003cT extends Throwable\u003e void fun2(T t) throws T {\n  try {\n    ...\n  } catch(Throwable t) {\n    throw t;\n  }\n}\n```\n\n# 编译时和运行时类型\n\n```java\npublic class Fruit {}\n\npublic class Apple extends Fruit {}\n\npublic class GreenApple extends Apple {}\n\nApple apple = new Apple();//普通变量声明和初始化\n\nFruit apple = new Apple();//向上转型\n```\n\nJava 允许把一个子类对象（Apple 对象）直接赋值给一个父类引用变量（Fruit 类变量），一般我们称之为「向上转型」。apple 变量所指向的对象，其在编译时的类型是 Fruit 类型，而在运行时的类型就是 Apple 类型。\n\n因为在编译的时候，JVM 只知道 Fruit 类变量指向了一个对象，并且这个对象是 Fruit 的子类对象或自身对象，其具体的类型并不确定，有可能是 Apple 类型，也有可能是 Orange 类型。而为了安全方面的考虑，JVM 此时将 apple 属性指向的对象定义为 Fruit 类型。因为无论其是 Apple 类型还是 Orange 类型，它们都可以安全转为 Fruit 类型。\n\n而在运行时阶段，JVM 通过初始化知道了它指向了一个 Apple 对象，所以其在运行时的类型就是 Apple 类型。\n\n# 泛型类型实例化的边界\n\n在前面的例子的基础上，定义一个容器类：\n\n```java\npublic class Plate\u003cT\u003e {\n  private List\u003cT\u003e list;\n\n  public Plate(){}\n\n  public void add(T item) {\n    list.add(item);\n  }\n\n  public T get() {\n    return list.get(0);\n  }\n}\n```\n\n如果想要一个装水果的盘子，则有如下定义：\n\n```java\nPlate\u003cFruit\u003e plate = new Plate\u003cFruit\u003e();\n```\n\n这里直接定义了一个 Plate 对象，并且指定其泛型类型为 Fruit 类。这样我们就可以往里面加水果了：\n\n```java\nplate.add(new Fruit());\n\nplate.add(new Apple());\n```\n\n按照 Java 向上转型的原则，Java 泛型可以向上转型，上面关于水果盘子的定义可以变为这样：\n\n```java\nPlate\u003cFruit\u003e plate = new Plate\u003cApple\u003e();  //编译错误\n```\n\n错误的原因就是：\tJava 并不支持支持泛型的向上转型，所以不能够使用上面的写法，这样的写法在 Java 中是不被支持的。\n\n解决方法就是：使用通配符。\n\n## `\u003c? extends Xxx\u003e` 限定上界通配符\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cApple\u003e();\n```\n\n上面的这行代码表示：plate 实例可以指向任何 Fruit 类对象，或者任何 Fruit 的子类对象。Apple 是 Fruit 的子类，自然就可以正常编译了。\n\n虽然通过这种方式，Java 支持了 Java 泛型的向上转型，但是这种方式是有缺陷的：\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cApple\u003e();\n\nplate.add(new Apple()); //Compile Error\n\nplate.add(new Fruit()); //Compile Error\n\nplate.get();    // Compile Success\n```\n\n这时候发现：无法向 Plate 中添加任何对象，只能从中读取对象。\n\n这是什么原因？还得从 plate 的定义说起：\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cXXX\u003e();\n```\n\n上面对盘子的定义中，plate 可以指向任何 Fruit 类对象，或者任何 Fruit 的子类对象。也就是说，plate 属性指向的对象其在运行时可以是 Apple 类型，也可以是 Orange 类型，也可以是 Banana 类型，只要它是 Fruit 类，或任何 Fruit 的子类即可。\n\n这样子的话，在我们还未具体运行时，JVM 并不知道我们要往盘子里放的是什么水果，到底是苹果，还是橙子，还是香蕉，完全不知道。既然我们不能确定要往里面放的类型，那 JVM 就干脆什么都不给放，避免出错。\n\n那为什么又可以取出数据呢？因为无论是取出苹果，还是橙子，还是香蕉，我们都可以通过向上转型用 Fruit 类型的变量指向它，这在 Java 中都是允许的：\n\n```java\nFruit apple = plate.get(); //能够保证取出来的是水果\n\nApple apple = plate.get(); //编译报错，JVM 不能保证取出来的就是苹果\n```\n\n我们通过 extends 关键字可以实现向上转型。但是我们却失去了部分的灵活性，即我们不能往其中添加任何东西，只能取出东西。\n\n## `\u003c? super Xxx\u003e` 限定下界通配符\n\n与 extends 通配符相似的另一个通配符是 super 通配符，其特性与 extends 完全相反。\tsuper 通配符可以存入对象，但是取出对象的时候受到限制。\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n```\n\n上面这行代码表示 plate 属性可以指向一个特定类型的 Plate 对象，只要这个特定类型是 Apple 或 Apple 的父类。上面的 Fruit 类就是 Apple 类的父级，所以上面的语法是对的。\n\n也就是说，如果 Food 类是 Fruit 的父级，那么则有下面的声明：\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n\nPlate\u003c? super Apple\u003e plate2 = new Plate\u003cApple\u003e();\n\nPlate\u003c? super Apple\u003e plate3 = new Plate\u003cGreenApple\u003e(); //Error\n```\n\n既然这样，也就是说 plate 指向的具体类型可以是任何 Apple 的父级，JVM 在编译的时候肯定无法判断具体是哪个父类型。但 JVM 能确定的是：任何 Apple 的子类都可以转为 Apple 类型，但任何 Apple 的父类都无法转为 Apple 类型。\n\n所以对于使用了 super 通配符的情况，我们只能存入 T 类型及 T 类型的子类对象。\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n\nplate.add(new Apple());\n\nplate.add(new GreenApple());\n\nplate.add(new Fruit()); //Error\n```\n\n当我们向 plate 存入 Apple 对象时，编译正常。但是存入 Fruit 对象，就会报编译错误。\n\n而当我们取出数据的时候，也是类似的道理。JVM 在编译的时候知道，我们具体的运行时类型可以是任何 Apple 的父级，那么为了安全起见，我们就用一个最顶层的父级来指向取出的数据，这样就可以避免发生强制类型转换异常了。\n\n```java\nObject object = plate.get();\n\nApple apple = plate.get();  //Error\n\nFruit fruit = plate.get();  //Error\n```\n\n当使用 Apple 类型或 Fruit 类型的变量指向 plate 取出的对象，会出现编译错误。而使用 Object 类型的额变量指向 plate 取出的对象，则可以正常通过。\n\n也就是说对于使用了 super 通配符的情况，我们取出的时候只能用 Object 类型的属性指向取出的对象。\n\n## `\u003c?\u003e` 无限定边界通配符\n\n也就是不限定泛型参数的边界，所以对 Plate\u003c?\u003e 实例来说可以存放任何任意类型的对象，由于所有类型都继承自 Object，因此 Plate\u003c?\u003e等价于 `Plate\u003c? extends Object\u003e`。所以只能够对该集合进行读操作，并且只能把读取到的元素当成 Object 实例来对待。\n\n## 小结\n\n- 对于 extends 通配符，我们无法向其中加入任何对象，但是我们可以进行正常的取出。\n- 对于 super 通配符，我们可以存入 T 类型对象或 T 类型的子类对象，但是我们取出的时候只能用 Object 类变量指向取出的对象。\n\n从上面的总结可以看出，extends 通配符偏向于内容的获取，而 super 通配符更偏向于内容的存入。我们有一个 PECS 原则（Producer Extends Consumer Super）很好的解释了这两个通配符的使用场景。\n\nProducer Extends 说的是当你的情景是生产者类型，需要获取资源以供生产时，我们建议使用 extends 通配符，因为使用了 extends 通配符的类型更适合获取资源。\n\nConsumer Super 说的是当你的场景是消费者类型，需要存入资源以供消费时，我们建议使用 super 通配符，因为使用 super 通配符的类型更适合存入资源。\n\n但如果既想存入，又想取出，那么最好还是不要使用 extends 或 super 通配符。\n\n# 面试题\n\n## `List\u003cT\u003e` 和数组的区别\n\n```java\nApple apple = new Fruit();\n\nApple[] appleArr = new Fruit[5];\n```\n\n在 Java 语言中，数组是协变的，即 Apple extends Fruit，那么子类 Apple[] 数组实例是可以赋值给父类 Fruit[] 数组实例的。那是由于 Java 中的数组类型本质上会由虚拟机运行时动态生成一个类型，这个类型除了记录数组的必要属性，如长度，元素类型等，会有一个指针指向内存某个位置，这个位置就是该数组元素的起始位置。\n\n所以子类数组实例赋值父类数组实例时，只是意味着父类数组实例的引用指向堆中子类数组而已，并不会有所冲突，因此是 Java 允许这种操作的。\n\n而泛型是不允许这么做的：\n\n```java\nArrayList\u003cNumber\u003e numbers = new ArrayList\u003cInteger\u003e(); \n\nnumbers = integers;//假设编译器是能通过的 \n\nnumbers.add(23.5);//将一个浮点数放入了整型容器中\n```\n\n前面已经说过，假设 Java 允许泛型协变，那么上述代码在编译器看来是没问题的，但运行时就会出现问题。这个 add 方法实际上就将一个浮点数放入了整型容器中了，虽然由于类型擦除并不会对程序运行造成问题，但显然违背了泛型的设计初衷，容易造成逻辑混乱，所以 Java 干脆禁止泛型协变。\n\n所以虽然 `ArrayList\u003cInteger\u003e` 和 `ArrayList\u003cNumber\u003e`编译器类型擦除之后都是 ArrayList 的实例，但是起码在编译器看来，这两者是两种不同的类型。\n\n但是对于数组，尽管 Apple 可以向上转型为 Fruit，但是 fruits 对象在运行时却是 Apple[] 类型的，因此只能向数组中放入 Apple 或者其子类对象。尽管在编译时不会报错，到了运行时仍然是会报错的。\n\n```java\nFruit[] fruits = new Apple[5];\n\nfruits[0] = new Apple();\n\nfruits[1] = new GreenApple();\n\nfruits[2] = new Fruit(); //RTE：ArrayStoreException\n```\n\n## Java 为什么不支持创建泛型数组\n\n首先对于 Java 数组，必须明确知道内部元素的类型，而且 JVM 会“记住”这个类型。每次往数组里插入新元素都会进行类型检查，不匹配则抛出 ArrayStoreException 错误。\n\n而由于泛型擦除机制的存在，因此 JVM 并不能确定数组中的泛型类型，因此创建泛型数组被编译器拦下来了。\n\n```java\nList\u003cInteger\u003e[] intListArray = new List\u003cInteger\u003e[10]; //Error\n```\n\n前面说过，因为泛型是协变的，而且 Object 是所有类的共同父类。如果允许创建泛型数组，则有：\n\n```java\nList\u003cInteger\u003e[] listArr= new ArrayList\u003cInteger\u003e[10];\n\nObject[] objArr= listArr;\n\nobjArr[0] = new ArrayList\u003cString\u003e(Arrays.asList(new String[]{\"abc\"}));\n\n这样做不但编译器不能发现类型错误，就连运行时的数组存储检查对它也无能为力。它能看到的是我们往里面放 List 的对象，我们定义的 `\u003cInteger\u003e` 在这个时候已经被抹掉了。于是而对它而言，只要是 List，都是合法的。\n```\n\n想想看，我们本来定义的是存放 `List\u003cInteger\u003e` 的数组，结果我们却可以往里面放任何 List，接下来如果有代码试图按原有的定义去取值，后果可想而知。\n\n实际上，泛型数组是可以定义出来的，然后通过强制转型，也是可以为其赋值的。\n\n```java\nList\u003cInteger\u003e[] listArr= (List\u003cInteger\u003e[])new ArrayList[10];\n\nObject[] objArr= listArr;\n\nobjArr[0] = new ArrayList\u003cString\u003e(Arrays.asList(new String[]{\"abc\"}));\n```\n\n这样不但编译可以通过，而且运行时也不会报任何错误。\n\n## `List`、`List\u003c?\u003e`、`List\u003cObject\u003e`的区别\n\n容器类使用泛型的好处：\n\n- 安全性：在对参数化类型的容器中放入了错误即不匹配的类型的时候，编译器将会强制性进行错误提示。\n- 便利性：当从容器中取出元素的时候不用自己手动将 Object 转换为元素的实际类型了，编译器将隐式地进行自动转换。\n- 表述性：带有类型实参的泛型即参数化类型，可以让人看到实参就知道里面的元素 E 都是什么类型。\n\n从以上三点出发，`List\u003cObject\u003e`、`List\u003c?\u003e` 和 `List` 的区别如下：\n\n| 类型    | 名称                               | 可以接受的类型                            | 能否添加元素           | 安全性 | 便利性 | 表述性 |\n| ------- | ---------------------------------- | ----------------------------------------- | ---------------------- | ------ | ------ | ------ |\n| List    | 原始类型                           | 任何对应 List 的参数化类型， 包括 List\u003c?\u003e | 可以添加任意类型的元素 | 无     | 无     | 无     |\n| List\u003c?\u003e | 通配符类型                         | 任何对应 List 的参数化类型，包括 List     | 不能添加任何元素       | 有     | 无     | 有     |\n| List    | 实际类型参数为 Object 的参数化类型 | 仅可以接受 List 和其本身类型              | 可以添加任意类型元素   | 有     | 有     | 有     |\n\n## JVM 如何解决泛型类型擦除导致多态冲突\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["泛型","Java"]},"/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84":{"title":"注解和反射","content":"\n# \u003cstrong\u003e注解是什么？有何作用？\u003c/strong\u003e\n\nJava 注解（Annotation）又称 Java 标注，是 JDK1.5 引入的一种注释机制。是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。\n\n注解本身没有任何意义，单独的注解就是一种注释，他需要结合其他如反射、插桩等技术才有意义。\n\n# \u003cstrong\u003e元注解\u003c/strong\u003e\n\n在 JDK 中提供了 4 个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：\n\n#### \u003cstrong\u003e@Target\u003c/strong\u003e\nTarget 注解的作用是：描述注解的使用范围(即被修饰的注解可以用在什么地方).\n\nTarget 注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数），在定义注解类时使用了 @Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在 ElementType 枚举中.\n\n源码：\n```java\n@Documented \n@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) \npublic @interface Target { \n  ElementType[] value(); \n}\nElementType定义：\npublic enum ElementType { \n  TYPE, // 类、接口、枚举类 \n  FIELD, // 成员变量（包括：枚举常量） \n  METHOD, // 成员方法 \n  PARAMETER, // 方法参数 \n  CONSTRUCTOR, // 构造方法 \n  LOCAL_VARIABLE, // 局部变量 \n  ANNOTATION_TYPE, // 注解类 \n  PACKAGE, // 可用于修饰：包 \n  TYPE_PARAMETER, // 类型参数，JDK 1.8 新增 \n  TYPE_USE // 使用类型的任何地方，JDK 1.8 新增 \n}\n```\n\n#### \u003cstrong\u003e@Retention\u003c/strong\u003e\nReteniton 注解的作用是：描述注解保留的时间范围(即：被描述的注解在它所修饰的类中可以被保留到何时).\n\nReteniton 注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在 RetentionPolicy 枚举中.\n\n```java\npublic enum RetentionPolicy {\n    SOURCE,    // 只会在源文件中保留，随后会被编译器忽略\n    CLASS,     // 保留至编译期，会被 JVM 忽略，默认值\n    RUNTIME    // 保留至运行时，可通过反射去获取注解信息\n}\n```\n\n使用场景：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Annotation%26Reflection/clipboard_20230322_115319.png)\n\n#### \u003cstrong\u003e@Documented\u003c/strong\u003e\n描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。\n\n#### \u003cstrong\u003e@Inherited\u003c/strong\u003e\n使被它修饰的注解具有继承性（如果某个类使用了被 @Inherited 修饰的注解，则其子类将自动具有该注解）。\n\n# \u003cstrong\u003e反射是什么？有何作用？\u003c/strong\u003e\n\n一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的，并且能够获得此类的引用。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。\n\n如果一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。这时候，我们使用 JDK 提供的反射 API 进行反射调用。反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且都能改变它的属性。这也是 Java 被视为动态语言的关键。\n\nJava 反射机制主要提供了以下功能：\n\n- 在运行时构造任意一个类的对象\n- 在运行时获取或者修改任意一个类所具有的成员变量和方法\n- 在运行时调用任意一个对象的方法（属性）\n\n# Class 类\n\n反射始于 Class，\u003cstrong\u003eClass 是一个类，封装了当前对象所对应的类的信息。\u003c/strong\u003e一个类中有属性，方法，构造器等，比如说有一个 Person 类，一个 Order 类，一个 Book 类，这些都是不同的类，现在需要一个类，用来描述类，这就是 Class，它应该有类名，属性，方法，构造器等。Class 是用来描述类的类。\n\nClass 类是一个对象照镜子的结果，对象可以看到自己有哪些属性，方法，构造器，实现了哪些接口等等。对于每 个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 对象只能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个 Class 实例。 \n\n### 获取 Class 的方式\n\n#### 通过类名获取\n\n通过调用“类名.class”即可获取该类的 Class 对象\n\n```java\nClass\u003c?\u003e klass = int.class;\nClass\u003c?\u003e classInt = Integer.TYPE;\n```\n\n#### 通过对象获取\n\n获取到对象实例后，通过“对象名.getClass()”或者“对象名.getSuperClass”即可获取该类或者父类的 Class 对象。\n\n```java\nStringBuilder str = new StringBuilder(\"abc\");\nClass\u003c?\u003e klass = str.getClass(); \n```\n\n#### 通过全类名获取\n\n使用 Class.forName(全类名) 或者 classLoader.loadClass(全类名) 也可以得到 Class 对象。\n\n```java\nClass.forName(\"android.content.Intent\");\ngetClassLoader().loadClass(\"android.content.Intent\");\n```\n\n### 使用 Class 创建实例\n\n通过反射来生成对象主要有两种方式。\n\n#### 直接调用 newInstance()\n\n使用 Class 对象的 newInstance() 方法来创建 Class 对象对应类的实例。 \n\n```java\nClass\u003c?\u003e c = String.class;\nObject str = c.newInstance(); \n```\n\n#### 通过 Constructor 调用 newInstance()\n\n如果需要通过某个构造方法创建对象，则须通过 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建实例。\n\n```java\nClass\u003c?\u003e c = String.class;\n//获取String类带一个String参数的构造器\nConstructor constructor = c.getConstructor(String.class);\n//根据构造器创建实例\nObject obj = constructor.newInstance(\"abc\");\n```\n\n### 获取构造方法\n\n```java\n//获得使用特殊的参数类型的public构造函数(包括父类）\nConstructor getConstructor(Class[] params)\n//获得类的所有公共构造函数\nConstructor[] getConstructors()\n获得使用特定参数类型的构造函数(包括私有)\nConstructor getDeclaredConstructor(Class[] params)\n//获得类的所有构造函数(与接入级别无关) \nConstructor[] getDeclaredConstructors()\n```\n\n### 获取成员变量（字段）信息\n\n```java\n//获得命名的公共字段\nField getField(String name)\n//获得类的所有公共字段\nField[] getFields()\n//获得类声明的命名的字段\nField getDeclaredField(String name)\n//获得类声明的所有字段\nField[] getDeclaredFields()\n```\n\n### 调用方法\n\n```java\n//使用特定的参数类型，获得命名的公共方法\nMethod getMethod(String name, Class[] params)\n//获得类的所有公共方法\nMethod[] getMethods()\n//使用特写的参数类型，获得类声明的命名的方法\nMethod getDeclaredMethod(String name, Class[] params)\n//获得类声明的所有方法 \nMethod[] getDeclaredMethods()\n获取到 Method 对象后，调用 invoke 方法即可调用该方法，invoke 方法定义：\npublic Object invoke(Object obj, Object... args)\n```\n\n# 获取泛型的真实类型\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Annotation%26Reflection/clipboard_20230322_115426.png)\n\n当我们对一个泛型类进行反射时，需要的到泛型中的真实数据类型，来完成如 json 反序列化的操作。此时需要通过 Type 体系来完成。Type 接口包含了一个实现类(Class)和四个实现接口，他们分别是：\n\n#### TypeVariable\n\n泛型类型变量。可以泛型上下限等信息；\n\n```java\nclass TestType\u003cK extends Comparable \u0026 Serializable, V\u003e {\n    K key;\n    V value;\n}\n\n@Test\npublic void test() {\n    // 获取字段的类型\n    Field fk = null;\n    Field fv = null;\n    try {\n        fk = TestType.class.getDeclaredField(\"key\");\n        fv = TestType.class.getDeclaredField(\"value\");\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    }\n    TypeVariable keyType = (TypeVariable)fk.getGenericType();\n    TypeVariable valueType = (TypeVariable)fv.getGenericType();\n    \n    // getName 方法\n    System.out.println(keyType.getName()); // K\n    System.out.println(valueType.getName()); // V\n    \n    // getGenericDeclaration 方法\n    System.out.println(keyType.getGenericDeclaration()); \n    System.out.println(valueType.getGenericDeclaration());\n    \n    System.out.println(\"K 的上界:\"); // 有两个\n    for (Type type : keyType.getBounds()) {\n        System.out.println(type);\n    }\n    \n    System.out.println(\"V 的上界:\"); // 没明确声明上界的, 默认上界是 Object\n    for (Type type : valueType.getBounds()) {// class java.lang.Object\n        System.out.println(type);\n    }\n}\n\n输出为：\nK\nV\nclass com.test.ExampleUnitTest$TestType\nclass com.test.ExampleUnitTest$TestType\n```\n\nK 的上界:\n\n`interface java.lang.Comparable`\n\n`interface java.io.Serializable`\n\nV 的上界:\n\n`class java.lang.Object`\n\n#### ParameterizedType\n\n具体的泛型类型，可以获得元数据中泛型签名类型(泛型真实类型)\n\n```java\nclass TestType {\n    Map\u003cString, String\u003e map;\n}\n\n@Test\npublic void test() {\n    Field f = null;\n    try {\n        f = TestType.class.getDeclaredField(\"map\");\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    }\n    System.out.println(f.getGenericType());\n    ParameterizedType pType = (ParameterizedType) f.getGenericType();\n    System.out.println(pType.getRawType());\n    for (Type type : pType.getActualTypeArguments()) {\n        System.out.println(type);\n    }\n}\n\n输出为：\njava.util.Map\u003cjava.lang.String, java.lang.String\u003e\ninterface java.util.Map\nclass java.lang.String\nclass java.lang.String\n```\n\n#### GenericArrayType\n\n当需要描述的类型是\u003cstrong\u003e泛型类的数组\u003c/strong\u003e时，比如 List[],Map[]，此接口会作为 Type 的实现。\n\n```java\npublic class TestType\u003cT\u003e {\n    List\u003cString\u003e[] lists;\n}\n@Test\npublic void test() {\n    Field f = null;\n    try {\n        f = TestType.class.getDeclaredField(\"lists\");\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    }\n    GenericArrayType genericType = (GenericArrayType) f.getGenericType();\n    System.out.println(genericType.getGenericComponentType());\n}\n\n输出为：\njava.util.List\u003cjava.lang.String\u003e\nWildcardType \n```\n\n通配符泛型，获得上下限信息；\n\n```java\npublic class TestType {\n    private List\u003c? extends Number\u003e a;\n    private List\u003c? super String\u003e b;\n}\n\n@Test\npublic void test() throws NoSuchFieldException {\n    Field fieldA = TestType.class.getDeclaredField(\"a\");\n    Field fieldB = TestType.class.getDeclaredField(\"b\");\n    ParameterizedType pTypeA = (ParameterizedType) fieldA.getGenericType();\n    ParameterizedType pTypeB = (ParameterizedType) fieldB.getGenericType();\n    WildcardType wTypeA = (WildcardType) pTypeA.getActualTypeArguments()[0];\n    WildcardType wTypeB = (WildcardType) pTypeB.getActualTypeArguments()[0];\n    System.out.println(wTypeA.getUpperBounds()[0]);\n    System.out.println(wTypeB.getLowerBounds()[0]);\n    System.out.println(wTypeA);\n    System.out.println(wTypeB);\n}\n\n输出为：\nclass java.lang.Number\nclass java.lang.String\n? extends java.lang.Number\n? super java.lang.String\n```\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Annotation%26Reflection/clipboard_20230322_115500.png)\n\n问题：为什么 Gson 反序列化时候需要借助 TypeToken 获取 Type？\n\n//todo\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["注解","反射","Java"]},"/%E7%AD%89%E5%BE%85_%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6":{"title":"等待_通知机制","content":"# 等待_通知机制\n\n# wait/notify 模式\n\npublic class MyBlockingQueueForWaitNotify {\n\n   private int maxSize = 16;\n\n   private LinkedList\u003cObject\u003e storage;\n\n \n\n   public MyBlockingQueueForWaitNotify (int size) {\n\n       this.maxSize = size;\n\n       storage = new LinkedList\u003c\u003e();\n\n   }\n\n \n\n   public synchronized void put() throws InterruptedException {\n\n       while (storage.size() == maxSize) {\n\n           this.wait();\n\n       }\n\n       storage.add(new Object());\n\n       this.notifyAll();\n\n   }\n\n \n\n   public synchronized void take() throws InterruptedException {\n\n       while (storage.size() == 0) {\n\n           this.wait();\n\n       }\n\n       System.out.println(storage.remove());\n\n       this.notifyAll();\n\n   }\n\n}\n\n# Condition 模式\n\npublic class MyBlockingQueueForCondition {\n\n \n\n   private Queue queue;\n\n   private int max = 16;\n\n   private ReentrantLock lock = new ReentrantLock();\n\n   private Condition notEmpty = lock.newCondition();\n\n   private Condition notFull = lock.newCondition();\n\n \n\n   public MyBlockingQueueForCondition(int size) {\n\n       this.max = size;\n\n       queue = new LinkedList();\n\n   }\n\n \n\n   public void put(Object o) throws InterruptedException {\n\n       lock.lock();\n\n       try {\n\n           while (queue.size() == max) {\n\n               notFull.await();\n\n           }\n\n           queue.add(o);\n\n           notEmpty.signalAll();\n\n       } finally {\n\n           lock.unlock();\n\n       }\n\n   }\n\n \n\n   public Object take() throws InterruptedException {\n\n       lock.lock();\n\n       try {\n\n           while (queue.size() == 0) {\n\n               notEmpty.await();\n\n           }\n\n           Object item = queue.remove();\n\n           notFull.signalAll();\n\n           return item;\n\n       } finally {\n\n           lock.unlock();\n\n       }\n\n   }\n\n}\n\n# 两种方式对比\n\n![](static/boxcnAqX93mnHV8T8UY1Tm93mxf.png)\n","lastmodified":"2023-03-23T02:32:34.058210059Z","tags":[]},"/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C":{"title":"线程协作 ","content":"\n## Thread.join()\n\n#### 使用\n\n```java\npublic class UseJoin {\n    public static void main(String[] args) {\n        final Thread thread1 = new Thread(() -\u003e {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"thread 1 is running\");\n        });\n        final Thread thread2 = new Thread(() -\u003e {\n            try {\n                thread1.join();\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"thread 2 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        Thread thread3 = new Thread(() -\u003e {\n            try {\n                thread2.join();\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"thread 3 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        thread3.start();\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n#### 实现原理\n\n```java\npublic final void join() throws InterruptedException {\n    join(0);\n}\n\npublic final synchronized void join(long millis) \n          throws InterruptedException {\n    long base = System.currentTimeMillis();\n    long now = 0;\n\n    if (millis \u003c 0) {\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    }\n\n    if (millis == 0) {\n        // 1\n        while (isAlive()) {\n            wait(0);\n        }\n    } else {\n        while (isAlive()) {\n            long delay = millis - now;\n            if (delay \u003c= 0) {\n                break;\n            }\n            wait(delay);\n            now = System.currentTimeMillis() - base;\n        }\n    }\n}\n```\n\n首先进入 join 方法时，调用 join 的线程获取了 threadA 线程的对象锁；注释 1 处 while 循环这段的代码的意思是：如果 threadA 线程是活跃的，则循环调用 threadA.wait(0)，此时调用 join 的线程释放 threadA 线程的对象锁，其他线程可以竞争锁并进入 threadA.join(0)。一旦 threadA 线程执行完毕（状态为 TERMINATED），JVM 会调用 lock.notify_all(thread)，唤醒持有 threadA 这个对象锁的线程，至此阻塞在 threadA 对象上的线程可以继续执行后面的内容。\n\n## Object.wait()/Object.notify()\n\n#### 使用\n\n```java\npublic class UseWaitNotify {\n    private static Object myLock1 = new Object();\n    private static Object myLock2 = new Object();\n    \n    private static Boolean t1Run = false;\n    private static Boolean t2Run = false;\n    \n    public static void main(String[] args) {\n        final Thread thread1 = new Thread(() -\u003e {\n            synchronized (myLock1) {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"thread 1 is running\");\n                t1Run = true;\n                myLock1.notify();\n            }\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            synchronized (myLock1) {\n                try {\n                    if (!t1Run) {\n                        myLock1.wait();\n                    }\n                    synchronized (myLock2) {\n                        Thread.sleep(1000);\n                        System.out.println(\"thread 2 is running\");\n                        myLock2.notify();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            synchronized (myLock2) {\n                try {\n                    if (!t2Run) {\n                        myLock2.wait();\n                    }\n                    Thread.sleep(1000);\n                    System.out.println(\"thread 3 is running\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        \n        thread3.start();\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n#### 实现原理\n\n## Condition\n\n#### 使用\n\n```java\npublic class UseCondition {\n    private static Lock lock = new ReentrantLock();\n    private static Condition condition1 = lock.newCondition();\n    private static Condition condition2 = lock.newCondition();\n    \n    private static Boolean t1Run = false;\n    private static Boolean t2Run = false;\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            lock.lock();\n            try {\n                Thread.sleep(2000);\n                System.out.println(\"thread 1 is running\");\n                t1Run = true;\n                condition1.signal();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            lock.lock();\n            try {\n                if (!t1Run) {\n                    condition1.await();\n                }\n                Thread.sleep(1000);\n                System.out.println(\"thread 2 is running\");\n                t2Run = true;\n                condition2.signal();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            lock.lock();\n            try {\n                if (!t2Run) {\n                    condition2.await();\n                }\n                Thread.sleep(1000);\n                System.out.println(\"thread 3 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        });\n        \n        thread3.start();\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n#### 实现原理\n\n## Semaphore\n\n#### 使用\n\n```java\npublic class UseSemaphore {\n    private static Semaphore semaphore1 = new Semaphore(1);\n    private static Semaphore semaphore2 = new Semaphore(0);\n    private static Semaphore semaphore3 = new Semaphore(0);\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            try {\n                semaphore1.acquire();\n                Thread.sleep(2000);\n                System.out.println(\"thread 1 is running\");\n                semaphore2.release();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            try {\n                semaphore2.acquire();\n                Thread.sleep(1000);\n                System.out.println(\"thread 2 is running\");\n                semaphore3.release();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            try {\n                semaphore3.acquire();\n                Thread.sleep(1000);\n                System.out.println(\"thread 3 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n        thread3.start();\n    }\n}\n```\n\n#### 实现原理\n\n## CountDownLatch\n\n#### 使用\n\n```java\npublic class UseCountDownLatch {\n    private static CountDownLatch c1 = new CountDownLatch(1);\n    private static CountDownLatch c2 = new CountDownLatch(1);\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"thread 1 is running\");\n            c1.countDown();\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            try {\n                c1.await();\n                Thread.sleep(1000);\n                System.out.println(\"thread 2 is running\");\n                c2.countDown();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            try {\n                c2.await();\n                Thread.sleep(1000);\n                System.out.println(\"thread 3 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        thread3.start();\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n#### 实现原理\n\nCountDownLatch 最核心的方法只有两个，一个是 countDown 方法，每调用一次，就会将当前的 count 减一，当 count 值为 0 时，就会唤醒所有等待中的线程；另一个是 await 方法，它有两种形式，一种是阻塞式，一种是带超时机制的形式，该方法用于将当前等待“门闩”开启的线程挂起，直到 count 值为 0，这一点很类似于条件队列，相当于等待的条件就是 count 值为 0，\u003cstrong\u003e然而其底层的实现并不是用条件队列，而是共享锁。\u003c/strong\u003e\n\nCountDownLatch 主要是通过 AQS 的共享锁机制实现的，因此它的核心属性只有一个 sync，它继承自 AQS，同时覆写了 tryAcquireShared 和 tryReleaseShared，以完成具体的实现共享锁的获取与释放的逻辑。\n\n## CyclicBarrier\n\n#### 使用\n\n```java\npublic class UseCyclicBarrier {\n    static CyclicBarrier barrier1 = new CyclicBarrier(2);\n    static CyclicBarrier barrier2 = new CyclicBarrier(2);\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            try {\n                Thread.sleep(2000);\n                System.out.println(\"thread 1 is running\");\n                barrier1.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            try {\n                barrier1.await();\n                Thread.sleep(1000);\n                System.out.println(\"thread 2 is running\");\n                barrier2.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            try {\n                barrier2.await();\n                Thread.sleep(1000);\n                System.out.println(\"thread 3 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        thread3.start();\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n#### 实现原理\n\nCountDownLatch 是一次性的，当 count 值被减为 0 后，不会被重置;\n\n而 CyclicBarrier 在线程通过栅栏后，通过调用 reset() 方法，count 值会被重置，因此可以重复使用。\n\n## ThreadPool\n\n#### 使用\n\n```java\npublic class UseThreadPool {\n    static ExecutorService executorService = \n            Executors.newSingleThreadExecutor();\n            \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"thread 1 is running\");\n        });\n        \n        Thread thread2 =new Thread(() -\u003e {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"thread 2 is running\");\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"thread 3 is running\");\n        });\n        \n        executorService.submit(thread1);\n        executorService.submit(thread2);\n        executorService.submit(thread3);\n        executorService.shutdown();\n    }\n}\n```\n\n#### 实现原理\n\nnewSingleThreadExecutor 创建的线程池核心线程数和最大线程数都为 1，因此 thread1 提交后，每个线程都会进入阻塞队列并按照提交顺序执行。\n\n## 面试题\n\n#### CyclicBarrier 和 CountDownLatch 有何区别？\n\n- 工作方式：CyclicBarrier 要等固定数量的线程都到达了栅栏位置才能继续执行，而 CountDownLatch 只需等待数字倒数到 0，也就是说 CountDownLatch 作用于事件，但 CyclicBarrier 作用于线程；CountDownLatch 是在调用了 countDown 方法之后把数字倒数减 1，而 CyclicBarrier 是在某线程开始等待后把计数减 1。\n- 能否重复使用：CountDownLatch 是一次性的，当 count 值被减为 0 后，不会被重置，因此不能重复使用；而 CyclicBarrier 在线程通过栅栏后，会开启新的一代，count 值会被重置，因此可重复使用。\n- 使用锁的类型：CountDownLatch 使用的是共享锁，count 值不为 0 时，线程在 sync queue 中等待，自始至终只牵涉到 sync queue，由于使用共享锁，唤醒操作不必等待锁释放后再进行，唤醒操作很迅速；CyclicBarrier 使用的是独占锁，count 值不为 0 时，线程进入 condition queue 中等待，当 count 值降为 0 后，将被 signalAll() 方法唤醒到 sync queue 中去，然后挨个去争锁（因为是独占锁），在前驱节点释放锁以后，才能继续唤醒后继节点。\n","lastmodified":"2023-03-23T02:32:34.058210059Z","tags":[]},"/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80":{"title":"线程基础 ","content":"# 线程基础\n\n# CPU 核心数和线程数的关系\n\n增加 CPU 核心数目就是为了增加线程数，因为操作系统是通过线程来执行任务的，一般情况下它们是 1:1 对应关系，也就是说四核 CPU 一般拥有四个线程。但 Intel 引入超线程技术后，使核心数与线程数形成 1:2 的关系。\n\n# 进程和线程\n\n#### 进程是程序运行资源分配的最小单位\n\n进程是操作系统进行资源分配的最小单位，其中资源包括：CPU、内存空间、磁盘等，同一进程中的多条线程共享该进程中的全部系统资源，而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。\n\n进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的、静态的，进程是活的、动态的。\n\n进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身，用户进程就是所有由你启动的进程。\n\n#### 线程是 CPU 调度的最小单位，必须依赖于进程而存在\n\n线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的、能独立运行的基本单位。\n\n线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\n\n线程无处不在，任何一个程序都必须要创建线程。特别是 Java，不管任何程序都必须启动一个 main 函数的主线程；Java Web 开发里面的定时任务、定时器、JSP 和 Servlet、异步消息处理机制，远程访问接口 RM 等；Android 中的任何一个 onClick 事件的触发事件等都离不开线程和并发的知识。\n\n# 并行和并发\n\n举个例子，如果有条高速公路 A 上面并排有 8 条车道，那么最大的并行车辆就是 8 辆，此条高速公路 A 同时并排行走的车辆小于等于 8 辆的时候，车辆就可以并行运行。CPU 也是这个原理，一个 CPU 相当于一个高速公路 A，核心数或者线程数就相当于并排可以通行的车道；而多个 CPU 就相当于并排有多条高速公路，而每个高速公路并排有多个车道。\n\n当谈论并发的时候一定要加个单位时间，也就是说单位时间内并发量是多少？离开了单位时间其实是没有意义的。\n\n原则上一个 CPU 只能分配给一个进程，以便运行这个进程。我们通常使用的计算机中只有一个 CPU，也就是说只有一颗心，要让它一心多用同时运行多个进程，就必须使用并发技术。实现并发技术相当复杂，最容易理解的是“时间片轮转进程调度算法”。\n\n综合来说：\n\n#### 并发\n\n指应用能够交替执行不同的任务，比如单 CPU 核心下执行多线程并非是同时执行多个任务，如果你开两个线程执行，就是在你几乎不可能察觉到的速度不断去切换这两个任务，已达到\"同时执行效果\"，其实并不是的，只是计算机的速度太快，我们无法察觉到而已.\n\n#### 并行\n\n指应用能够同时执行不同的任务，比如吃饭的时候可以边吃饭边打电话，这两件事情可以同时执行。\n\n两者的区别：一个是交替执行，一个是同时执行。\n\n# CPU 时间片轮转机制\n\n时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法，又称 RR 调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。\n\n如果在时间片结束时进程还在运行，则 CPU 将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来，则 CPU 当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。\n\n时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的，包括保存和装入寄存器值及内存映像，更新各种表格和队列等。假如进程切(processwitch)，有时称为上下文切换(context switch)，需要 5ms，再假设时间片设为 20ms，则在做完 20ms 有用的工作之后，CPU 将花费 5ms 来进行进程切换。CPU 时间的 20% 被浪费在了管理开销上了。\n\n为了提高 CPU 效率，我们可以将时间片设为 5000ms。这时浪费的时间只有 0.1%。但考虑到在一个分时系统中，如果有 10 个交互用户几乎同时按下回车键，将发生什么情况？假设所有其他进程都用足它们的时间片的话，最后一个不幸的进程不得不等待 5s 才获得运行机会。多数用户无法忍受一条简短命令要 5s 才能做出响应，同样的问题在一台支持多道程序的个人计算机上也会发生。\n\n结论可以归结如下：时间片设得太短会导致过多的进程切换，降低了 CPU 效率；而设得太长又可能引起对短的交互请求的响应变差。将时间片设为 100ms 通常是一个比较合理的折衷。\n\n# 线程的启动\n\n#### 继承自 Thread\n\n```java\nprivate static class UseThread extends Thread {\n   @Override\n   public void run() {\n      super.run();\n      //do my work\n      System.out.println(\"I am extends Thread\");\n   }\n}\n\nUseThread useThread = new UseThread();\nuseThread.start();\n```\n\n#### 通过 Runnable 交给 Thread 执行\n\n```java\nprivate static class UseRunnable implements Runnable {\n   @Override\n   public void run() {\n      System.out.println(\"I am implements Runnable\");\n   }\n}\n\nUseRunnable runable = new UseRunnable();\nnew Thread(runable).start();\n```\n\n#### 通过 Callable 交给 Thread 执行\n\n```java\nprivate static class UseCallable implements Callable\u003cString\u003e {\n   @Override\n   public String call() throws Exception {\n      System.out.println(\"I am implements Callable\");\n      return \"CallResult\";\n   }\n}\n\nUseCallable callable = new UseCallable();\nFutureTask\u003cString\u003e futureTask = new FutureTask\u003c\u003e(callable);\nnew Thread(futureTask).start();\n//do something\nSystem.out.println(futureTask.get());\n```\n\n#### 小结\n\n前面两种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。从 Java 1.5 开始，就提供了 Callable 和 Future 类，通过它们可以在任务执行完毕之后得到任务执行结果。\n\nRunnable 是一个接口，在它里面只声明了一个 run 方法，由于 run 方法返回值为 void 类型，所以在执行完任务之后无法返回任何结果。\n\nCallable 位于 java.util.concurrent 包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做 call，这是一个泛型接口，call 方法返回的类型就是传递进来的 V 类型。\n\nFuture 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过 get 方法获取执行结果，该方法会阻塞直到任务返回结果。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095747.png)\n\nFutureTask 是 Future 接口的实现类：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095800.png)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095802.png)\n\nFutureTask 类实现了 RunnableFuture 接口，而 RunnableFuture 继承了 Runnable 接口和 Future 接口，而 FutureTask 实现了 RunnableFuture 接口。所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。\n\n事实上，FutureTask 是 Future 接口的一个唯一实现类。要 new 一个 FutureTask 的实例，将 Runnable 或者 Callable 对象传入即可。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095805.png)\n\n# 线程的终止\n\n#### 被动终止\n\n如果 run 执行完成或者执行过程中抛出了一个未处理的异常则会导致线程终止。\n\n#### 手动终止\n\n虽然 Thread 的 API 中提供了 \u003cstrong\u003esuspend()、resume() 和 stop() \u003c/strong\u003e方法，对应线程的暂停、恢复和停止操作 ，但是这些 API 是过期的，也就是不建议使用的。不建议使用的原因主要有：以 suspend() 方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop() 方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为 suspend()、resume() 和 stop() 方法带来的副作用，这些方法才被标注为不建议使用的过期方法。\n\n安全的中止则是其他线程通过调用某个线程 A 的 \u003cstrong\u003einterrupt() \u003c/strong\u003e方法对其进行中断操作， 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程 A 会立即停止自己的工作，同样的 A 线程完全可以不理会这种中断请求。因为 java 里的线程是\u003cstrong\u003e协作式\u003c/strong\u003e的，不是抢占式的。\n\n线程可通过 \u003cstrong\u003eisInterrupted() \u003c/strong\u003e方法检查自身的中断标志位是否被置为 true 来进行响应，也可以调用静态方法\u003cstrong\u003eThread.interrupted() \u003c/strong\u003e来进行判断当前线程是否被中断，不过它会同时将中断标识位改写为 false。\n\n如果一个线程处于了阻塞状态（如线程调用了 thread.sleep、thread.join、thread.wait），则在线程在检查中断标示时如果发现中断标示为 true，则会在这些阻塞方法调用处抛出 InterruptedException 异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为 false。\n\n```java\nprivate static class UseThread extends Thread {\n   @Override\n   public void run() {\n      //while(!isInterrupted()) 不会重置中断状态,一般不会使用\n      while(!Thread.interrupted()) { //会重置中断状态\n         try {\n            System.out.println(\"thread is still running\");\n            Thread.sleep(3000);\n         } catch (InterruptedException e) { //同样会重制中断状态\n            interrupt(); //所以如果不再次中断，则程序不会终止\n            e.printStackTrace();\n         }        \n      }\n   }\n}\n\nThread useThread = new UseThread();\nuseThread.start();\nThread.sleep(800);\nuseThread.interrupt();\n```\n\n不建议自定义一个取消标志位来中止线程的运行。因为 run 方法里\u003cstrong\u003e有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志\u003c/strong\u003e。这种情况下，使用中断会更好，因为，一、一般的阻塞方法，如 sleep 等本身就支持中断的检查，二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。\n\n\u003cstrong\u003e注意：处于死锁状态的线程无法被中断\u003c/strong\u003e\n\n# 线程的状态\n\nJava 中线程的状态分为  6 种：\n\n1. \u003cstrong\u003e初始(NEW)：\u003c/strong\u003e新创建了一个线程对象，但还没有调用 start()方法。\n2. \u003cstrong\u003e运行(RUNNABLE)：\u003c/strong\u003eJava 线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 CPU 的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得 CPU 时间片后变为运行中状态（running）。\n3. \u003cstrong\u003e阻塞(BLOCKED)：\u003c/strong\u003e表示线程阻塞于锁。\n4. \u003cstrong\u003e等待(WAITING)：\u003c/strong\u003e进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。\n5. \u003cstrong\u003e超时等待(TIMED_WAITING)：\u003c/strong\u003e该状态不同于 WAITING，它可以在指定的时间后自行返回。\n6. \u003cstrong\u003e终止(TERMINATED)：\u003c/strong\u003e表示该线程已经执行完毕。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095810.png)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095813.png)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095816.png)\n\n# 线程中的方法\n\n#### run 和 start\n\nThread 类是 Java 里对线程概念的抽象，可以这样理解：我们通过 new Thread 其实只是创建出一个 Thread 的实例，还没有操作系统中真正的线程挂起钩来。只有执行了 start 方法后，才实现了真正意义上的启动线程。\n\nstart 方法被调用后会让一个线程进入就绪队列等待分配 cpu，分到 cpu 后才调用 run 方法。\n\nstart 方法不能重复调用。而 run 方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，可以被单独调用。\n\n#### yield\n\n使当前线程让出 CPU 占有权，但让出的时间是不可设定的。它会让当前正在运行的线程暂停，但是它不会阻塞线程，它只是让该线程直接转入到就绪状态。也就是 yield 方法只是让当前线程暂停了一下，让系统的线程调度器重新调度一次，所以很可能出现这种情况：当该线程调用了 yield 方法，之后该线程又立马被调度了。\n\n#### join\n\n把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。当在某个线程执行过程中，调用其他线程的 join 方法时，调用者将会被阻塞，直到其他线程执行完成为止。比如在线程 B 中调用了线程 A 的 Join 方法，则需要在线程 A 执行完毕后，才会继续执行线程 B。\n\n# 线程间的共享和协作\n\n### 线程间的共享\n\n线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。\n\n#### synchronized\n\nJava 支持多个线程同时访问一个对象或者对象的成员变量，关键字 \u003cstrong\u003esynchronized\u003c/strong\u003e 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。\n\n\u003cstrong\u003e对象锁\u003c/strong\u003e\n\n对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的 class 对象上的。\n\n使用对象锁的方式如下：\n\n```java\npublic class ObjectLock {\n    private Object lock = new Object();\n    /**\n     * 锁住非静态变量\n     */\n    public void lockObjectField() throws InterruptedException {\n        synchronized (lock) {\n            System.out.println(Thread.currentThread().getName());\n            Thread.sleep(1000);\n        }\n    }\n    \n    /**\n     * 锁住 this 对象 this 就是当前对象实例\n     */\n    public void lockThis() throws InterruptedException {\n        synchronized (this) {\n            System.out.println(Thread.currentThread().getName());\n            Thread.sleep(1000);\n        }\n    }\n    \n    /**\n     * 直接锁住非静态方法\n     */\n    public synchronized void methodLock() throws InterruptedException {\n        System.out.println(Thread.currentThread().getName());\n        Thread.sleep(1000);\n    }\n    \n    public static void main(String[] args){\n        for (int i = 0; i \u003c 5; i++) {\n            Thread worker = new Thread(new ObjectLockWorker());\n            worker.setName(\"thread-\" + i);\n            worker.start();\n        }\n    }\n    \n    public static class ObjectLockWorker implements Runnable {\n        @Override\n        public void run() {\n            try {\n                ObjectLock objectLock = new ObjectLock();\n                // 方式 1\n                objectLock.lockObjectField();\n                // 方式 2\n                //objectLock.lockThis();\n                // 方式 3\n                //objectLock.methodLock();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n结果为瞬间打印出如下内容：\nthread-3\nthread-0\nthread-4\nthread-1\nthread-2\n```\n\n\u003cstrong\u003e类锁\u003c/strong\u003e\n\n类的对象实例可以有很多个，但是每个类只有一个 class 对象，所以不同对象实例的对象锁是互不干扰的，每个类只有一个类锁。\n\n类锁的使用如下：\n\n```java\npublic class ClassLock {\n    private static Object lock = new Object();\n    /**\n     * 锁住静态变量\n     */\n    public void lockStaticObjectField() throws InterruptedException {\n        synchronized (lock){\n            System.out.println(Thread.currentThread().getName());\n            Thread.sleep(1000);\n        }\n    }\n    \n    /**\n     * 锁住静态方法\n     */\n    public static synchronized void methodLock() throws InterruptedException {\n        System.out.println(Thread.currentThread().getName());\n        Thread.sleep(1000);\n    }\n    \n    /**\n     * 锁住 xxx.class\n     */\n    public void lockClass() throws InterruptedException{\n        synchronized (ClassLock.class){\n            System.out.println(Thread.currentThread().getName());\n            Thread.sleep(1000);\n        }\n    }\n    \n    public static void main(String[] args) {\n        for (int i = 0; i \u003c 5; i++) {\n            Thread worker = new Thread(new ClassLockWorker());\n            worker.setName(\"thread-\" + i);\n            worker.start();\n        }\n    }\n    \n    public static class ClassLockWorker implements Runnable {\n        @Override\n        public void run() {\n            try {\n                ClassLock classLock = new ClassLock();\n                // 方式 1\n                classLock.lockStaticObjectField();\n                // 方式 2\n                //ClassLock.methodLock();\n                // 方式 3\n                //classLock.lockClass();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n结果为依次打印如下内容：\nthread-1\nthread-0\nthread-3\nthread-4\nthread-2\n```\n\n但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的 class 对象。类锁和对象锁之间也是互不干扰的。\n\n#### volatile\n\n适合于只有一个线程写，多个线程读的场景，因为它只能确保可见性和有序性，并不保证原子性。\n\n#### ThreadLocal\n\n即线程变量，是一个以 ThreadLocal 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值，ThreadLocal 往往用来实现变量在线程之间的隔离。\n\nThreadLocal 类接口很简单，只有 4 个方法，我们先来了解一下：\n\n- \u003cstrong\u003epublic void set(Object value) \u003c/strong\u003e\n\n设置当前线程的线程局部变量的值。\n\n- \u003cstrong\u003epublic Object get() \u003c/strong\u003e\n\n该方法返回当前线程所对应的线程局部变量。\n\n- \u003cstrong\u003epublic void remove() \u003c/strong\u003e\n\n将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是 JDK 5.0 新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。\n\n- \u003cstrong\u003eprotected Object initialValue() \u003c/strong\u003e\n\n返回该线程局部变量的初始值，该方法是一个 protected 的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第 1 次调用 get() 或 set(Object) 时才执行，并且仅执行 1 次。ThreadLocal 中的缺省实现直接返回一个 null。\n\n```java\npublic static ThreadLocal\u003cString\u003e res = new ThreadLocal\u003c\u003e();\n```\n\nres 代表一个能够存放 String 类型的 ThreadLocal 对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。\n\n### 线程间的协作\n\n线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在 while 循环中设置不满足的条件，如果条件满足则退出 while 循环，从而完成消费者的工作。却存在如下问题：\n\n1. 难以确保及时性。\n2. 难以降低开销。如果降低睡眠的时间，比如休眠 1 毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。\n\n#### wait/notify/notifyAll\n\n\u003cstrong\u003ewait()/wait(long)/wait (long,int)\u003c/strong\u003e\n\n一般是由于某些条件不满足，阻塞当前线程（进入 WAITING 状态），\u003cstrong\u003e让出监视器锁\u003c/strong\u003e，不再参与锁竞争，直到其他线程来通知（告知必要的条件已经满足了），或者直到设定的超时等待时间到了。\n\n\u003cstrong\u003enotify()\u003c/strong\u003e\n\n通知一个在对象上等待的线程，使其从 wait 方法返回，而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入 WAITING 状态。\n\n\u003cstrong\u003enotifyAll()：\u003c/strong\u003e\n\n通知所有等待在该对象上的线程。\n\n#### 实现等待/通知机制\n\n指一个线程 A 调用了对象 O 的 wait 方法进入等待状态，而另一个线程 B 调用了对象 O 的 notify 或者 notifyAll 方法，线程 A 收到通知后从对象 O 的 wait 方法返回，进而执行后续操作。上述两个线程通过对象 O 来完成交互，而对象上的 wait 和 notify/notifyAll 的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。\n\n等待方遵循如下原则。\n\n1）获取对象的锁。\n2）如果条件不满足，那么调用对象的 wait 方法，被通知后仍要检查条件。\n3）条件满足则执行对应的逻辑。\n\n```java\nsynchronized(对象) {\n\twhile(条件不满足) {\n\t\t对象.wait();\n\t}\n\t对应逻辑处理\n}\n```\n\n通知方遵循如下原则。\n\n1）获得对象的锁。\n2）改变条件。\n3）通知所有等待在对象上的线程。\n\n```java\nsynchronized(对象) {\n\t改变条件\n\t对象.notifyAll();\n}\n```\n\n在调用 wait 方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait 方法；\n\n调用了 wait 后， 该线程会释放该对象的锁， 然后该线程会被添加到该对象的等待队列中（waiting queue），只要该线程在等待队列中， 就会一直处于阻塞状态，\u003cstrong\u003e不会被调度执行\u003c/strong\u003e。 要注意 wait 方法会强迫线程先进行释放锁操作，所以在调用 wait 时， 该线程必须已经获得锁，否则会抛出异常。\n\n当一个线程调用一个对象的 notify（线程退出调用了 notify 的 synchronized 代码块的时候） 方法时， 调度器会从所有处于该对象等待队列（waiting queue）的线程中取出任意一个线程， 将其添加到入口队列（entry queue）中。然后在入口队列中的多个线程就会竞争对象的锁， 得到锁的线程就可以继续执行。 如果等待队列中（waiting queue）没有线程， notify 方法不会产生任何作用。\n\nnotifyAll 和 notify 工作机制一样， 区别在于 notifyAll 会将等待队列（waiting queue）中所有的线程都添加到入口队列中（entry queue）。\n\n注意：尽可能用 notifyAll，谨慎使用 notify。因为 notify 方法只能唤醒一个线程，而唤醒哪个线程是不确定的，而 notifyAll 方法则可以唤醒所有正在等待的线程。\n\n# 面试题\n\n#### \u003cstrong\u003e调用 yield() 、sleep()、wait()、notify() 等方法对锁有何影响？\u003c/strong\u003e\n\n- yield()：让出时间片，不会释放锁。\n- sleep()：线程进入睡眠状态，不会释放锁。且必须定义一个时间，时间到期后会主动恢复。\n- wait()：调动方法之前，必须要持有锁。调用了 wait 方法以后，锁就会被释放，进入锁的等待队列，方法返回后重新拿到锁。需要被中断或者唤醒才能恢复，不能主动恢复。\n- notify()：调动方法之前，必须要持有锁，调用 notify 方法本身不会释放锁的。而是通知等待队列中的某一个线程，同步代码块执行完毕后才会释放锁。\n- notifyAll()：同 notify，有一点不同在于，notifyAll 会发出 n 个信号（n=等待线程数），而 notify 只会发出一个信号，通常情况下，尽量选择 notifyAll。\n- wait 和 sleep 方法都可以让线程阻塞，并且在等待的过程中如果收到中断信号，都可以进行响应（事实上是必须捕获中断异常），并抛出 InterruptedException 异常。\n- wait()方法与 sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的 wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。\n- sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是 sleep()方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。\n\n#### 如何实现线程按照顺序执行？\n\n```java\npublic class UseJoin {\n    static class JumpQueue implements Runnable {\n        private Thread thread;//用来插队的线程\n        \n        public JumpQueue(Thread thread) {\n            this.thread = thread;\n        }\n        \n        public void run() {\n           try {\n              System.out.println(thread.getName() + \" will be join before \" + Thread.currentThread().getName());\n            thread.join();\n         } catch (InterruptedException e) {\n            e.printStackTrace();\n         }\n           System.out.println(Thread.currentThread().getName() + \" terminted.\");\n        }\n    }\n    \n    public static void main(String[] args) throws Exception {\n        Thread previous = Thread.currentThread();//现在是主线程\n        for (int i = 0; i \u003c 10; i++) {\n            Thread thread = new Thread(new JumpQueue(previous), String.valueOf(i));\n            thread.start();\n            previous = thread;\n        }\n        SleepTools.second(2);//让主线程休眠2秒\n        System.out.println(Thread.currentThread().getName() + \" terminate.\");\n    }\n}\n```\n\n#### 如何实现两个线程交替执行？\n\n```java\npublic class ThreadPrintDemo2 {\n\n  public static void main(String[] args) {\n    final ThreadPrintDemo2 demo2 = new ThreadPrintDemo2();\n    Thread t1 = new Thread(demo2::print1);\n    Thread t2 = new Thread(demo2::print2);\n    t1.start();\n    t2.start();\n  }\n  \n  public synchronized void print2() {\n    for (int i = 1; i \u003c= 100; i += 2) {\n      System.out.println(i);\n      this.notify();\n      try {\n        this.wait();\n        Thread.sleep(100);// 防止打印速度过快导致混乱\n      } catch (InterruptedException e) {\n        // NO\n      }\n    }\n  }\n  \n  public synchronized void print1() {\n    for (int i = 0; i \u003c= 100; i += 2) {\n      System.out.println(i);\n      this.notify();\n      try {\n        this.wait();\n        Thread.sleep(100);// 防止打印速度过快导致混乱\n      } catch (InterruptedException e) {\n        // NO\n      }\n    }\n  }\n}\n```\n\n#### 为什么 wait 和 notify/notifyAll 必须在 synchronized 保护的同步代码中使用？\n\n前面提到等待/通知机制的时候提到过，wait/notify 标准用法如下：\n\n```java\nsynchronized(对象) {\n\twhile(条件不满足) {//1\n\t\t对象.wait();//2\n\t}\n\t对应逻辑处理\n}\n\nsynchronized(对象) {\n\t改变条件\n\t对象.notifyAll();\n}\n```\n\n先看 wait 方法，如果没有在 synchronized 代码代码块中，意味着在多线程环境下程序执行到任意位置都可能会发生上下文切换。而 1 和 2 处的操作不是原子的，如果线程 A 在这两处之间发生上下文切换，则有可能进入 while 后，其它线程修改了条件并且发出 notify 通知，但是此时线程 A 是收不到通知的；待上下文切换回来后，A 线程会一直等待其它线程 notify。\n\n这就是所谓的 Lost Wake-Up Problem：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095828.png)\n\n另外，wait 方法会释放 monitor 锁，这也要求我们必须首先进入到 synchronized 内持有这把锁。\n\n#### 为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？\n\n1. 因为 Java 中每个对象都有一把称之为 monitor 监视器的锁，由于每个对象都可以上锁，这就要求在对象头中有一个用来保存锁信息的位置。这个锁是对象级别的，而非线程级别的，wait/notify/notifyAll 也都是锁级别的操作，它们的锁属于对象，所以把它们定义在 Object 类中是最合适，因为 Object 类是所有对象的父类。\n2. 因为如果把 wait/notify/notifyAll 方法定义在 Thread 类中，会带来很大的局限性，比如一个线程可能持有多把锁，以便实现相互配合的复杂逻辑，假设此时 wait 方法定义在 Thread 类中，如何实现让一个线程持有多把锁呢？又如何明确线程等待的是哪把锁呢？既然我们是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现，而不是操作线程。\n","lastmodified":"2023-03-23T02:32:34.058210059Z","tags":[]},"/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-BlockingQueue":{"title":"线程池和 BlockingQueue","content":"# 线程池和 BlockingQueue\n\n# BlockingQueue 阻塞队列\n\n## 队列 \n\n队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。\n\n在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。\n\n## 什么是阻塞队列\n\n`public interface BlockingQueue\u003cE\u003e extends Queue\u003cE\u003e`\n\n- 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。\n- 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。\n\n阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095000.png)\n\n- \u003cstrong\u003e抛出异常：\u003c/strong\u003e当队列满时，如果再往队列里插入元素，会抛出 IllegalStateException（\"Queuefull\"）异常。当队列空时，从队列里获取元素会抛出 NoSuchElementException 异常。\n- \u003cstrong\u003e返回特殊值：\u003c/strong\u003e当往队列插入元素时，会返回元素是否插入成功，成功返回 true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回 null。\n- \u003cstrong\u003e一直阻塞：\u003c/strong\u003e当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里 take 元素，队列会阻塞住消费者线程，直到队列不为空。\n- \u003cstrong\u003e超时退出：\u003c/strong\u003e当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。\n\n## 常用阻塞队列\n\n#### \u003cstrong\u003eArrayBlockingQueue\u003c/strong\u003e\n\n用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列。可在初始化时通过参数设置，默认是非公平的。\n\n所谓公平访问队列是指阻塞的线程可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。\n\n#### \u003cstrong\u003eLinkedBlockingQueue\u003c/strong\u003e\n\n用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。\n\n#### \u003cstrong\u003ePriorityBlockingQueue\u003c/strong\u003e\n\n支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。\n\n#### \u003cstrong\u003eDelayQueue\u003c/strong\u003e\n\n支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。DelayQueue 非常有用，可以将 DelayQueue 运用在\u003cstrong\u003e缓存系统的设计：\u003c/strong\u003e用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。\n\n#### \u003cstrong\u003eSynchronousQueue\u003c/strong\u003e\n\n不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。\n\n#### \u003cstrong\u003eLinkedTransferQueue\u003c/strong\u003e\n\n多了 tryTransfer 和 transfer 方法。\n\n1. \u003cstrong\u003etransfer\u003c/strong\u003e\u003cstrong\u003e 方法。\u003c/strong\u003e如果当前有消费者正在等待接收元素（消费者使用 take 方法或带时间限制的 poll 方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。\n2. \u003cstrong\u003etryTransfer\u003c/strong\u003e\u003cem\u003e 方法。\u003c/em\u003e tryTransfer 方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回，而 transfer 方法是必须等到消费者消费了才返回。\n\n#### \u003cstrong\u003eLinkedBlockingDeque\u003c/strong\u003e\n\n由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。\n\n同时，它还多了 addFirst、addLast、offerFirst、offerLast、peekFirst 和 peekLast 等方法，以 First 单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 JDK 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。在初始化 LinkedBlockingDeque 时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。\n\n\u003cstrong\u003e有界和无界\u003c/strong\u003e\n\n有限队列就是长度有限，满了以后生产者会阻塞，无界队列就是里面能放无数的东西而不会因为队列长度限制被阻塞，当然空间限制来源于系统资源的限制，如果处理不及时，导致队列越来越大越来越大，超出一定的限制致使内存超限，操作系统或者 JVM 会直接杀死进程。\n\n无界也会阻塞，为何？因为阻塞不仅仅体现在生产者放入元素时会阻塞，消费者拿取元素时，如果没有元素，同样也会阻塞。\n\n\u003cstrong\u003eArray 实现和 Linked 实现的区别\u003c/strong\u003e\n\n1. 队列中锁的实现不同。ArrayBlockingQueue 实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue 实现的队列中的锁是分离的，即生产用的是 putLock，消费是 takeLock。\n2. 生产或消费时操作不同。ArrayBlockingQueue 实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；LinkedBlockingQueue 实现的队列中在生产和消费的时候，需要把枚举对象转换为 `Node\u003cE\u003e`进行插入或移除，会影响性能。\n3. 队列大小初始化方式不同。ArrayBlockingQueue 实现的队列中必须指定队列的大小；LinkedBlockingQueue 实现的队列中可以不指定队列的大小，但是默认是 Integer.MAX_VALUE。\n\n# 线程池\n\n## 为什么要用线程池？\n\nJava 中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来三个好处：\n\n1. \u003cstrong\u003e降低资源消耗。\u003c/strong\u003e通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n2. \u003cstrong\u003e提高响应速度。\u003c/strong\u003e当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。如果 T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整 T1,T3 时间的技术，从而提高服务器程序性能的。它把 T1，T3 分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有 T1，T3 的开销了。\n3. \u003cstrong\u003e提高线程的可管理性。\u003c/strong\u003e线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。\n\n## 线程池的创建各个参数含义\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue\u003cRunnable\u003e workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n```\n\n#### \u003cstrong\u003ecorePoolSize\u003c/strong\u003e\n\n线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于 corePoolSize；\n\n如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；\n\n如果执行了线程池的 prestartAllCoreThreads() 方法，线程池会提前创建并启动所有核心线程。\n\n#### \u003cstrong\u003emaximumPoolSize\u003c/strong\u003e\n\n线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize\n\n#### \u003cstrong\u003ekeepAliveTime\u003c/strong\u003e\n\n线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于 corePoolSize 时才有用\n\n#### \u003cstrong\u003eTimeUnit\u003c/strong\u003e\n\nkeepAliveTime 的时间单位\n\n#### \u003cstrong\u003eworkQueue\u003c/strong\u003e\n\nworkQueue 必须是 BlockingQueue 阻塞队列。当线程池中的线程数超过它的 corePoolSize 的时候，线程会进入阻塞队列进行阻塞等待。通过 workQueue，线程池实现了阻塞功能。\n\n一般来说，我们应该\u003cstrong\u003e尽量使用有界队列\u003c/strong\u003e，因为使用无界队列作为工作队列会对线程池带来如下影响:\n\n1. 当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize。\n2. 由于 1，使用无界队列时 maximumPoolSize 将是一个无效参数。\n3. 由于 1 和 2，使用无界队列时 keepAliveTime 将是一个无效参数。\n4. 更重要的，使用无界 queue 可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。\n\n#### \u003cstrong\u003ethreadFactory\u003c/strong\u003e\n\n创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。Executors 静态工厂里默认的 threadFactory，线程的命名规则是“pool-数字-thread-数字”。\n\n#### \u003cstrong\u003eRejectedExecutionHandler\u003c/strong\u003e\n\n线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了 4 种策略：\n\n1. AbortPolicy：直接抛出异常，默认策略；\n2. CallerRunsPolicy：用调用者所在的线程来执行任务；\n3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；\n4. DiscardPolicy：直接丢弃任务；\n\n当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。\n\n## 线程池的工作机制\n\n```\n1）如果当前运行的线程少于 corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。\n\n2）如果运行的线程等于或多于 corePoolSize，则将任务加入 BlockingQueue。\n\n3）如果无法将任务加入 BlockingQueue（队列已满），则创建新的线程来处理任务。\n\n4）如果创建新线程将使当前运行的线程超出 maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution() 方法。\n```\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095008.png)\n\n## Executor 框架\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095011.png)\n\n#### \u003cstrong\u003eExecutor \u003c/strong\u003e\n\n\u003cstrong\u003eExecutor\u003c/strong\u003e\u003cstrong\u003e \u003c/strong\u003e是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的执行分离开来。\n\n#### \u003cstrong\u003eExecutorService \u003c/strong\u003e\n\nExecutorService 接口继承了 Executor，在其上做了一些 shutdown()、submit() 的扩展，可以说是真正的线程池接口；\n\n#### \u003cstrong\u003eAbstractExecutorService \u003c/strong\u003e\n\nAbstractExecutorService 抽象类实现了 ExecutorService 接口中的大部分方法；\n\n#### \u003cstrong\u003eThreadPoolExecutor\u003c/strong\u003e\u003cem\u003e \u003c/em\u003e\n\nThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。\n\n#### \u003cstrong\u003eScheduledExecutorService \u003c/strong\u003e\n\nScheduledExecutorService 接口继承了 ExecutorService 接口，提供了带\"周期执行\"功能 ExecutorService；\n\n#### \u003cstrong\u003eScheduledThreadPoolExecutor \u003c/strong\u003e\n\nScheduledThreadPoolExecutor 是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor 比 Timer 更灵活，功能更强大。\n\n#### \u003cem\u003eForkJoinPool（since 1.7）\u003c/em\u003e\n\nForkJoinPool 是自 JDK 7 起引入的线程池，核心思想是将大的任务拆分成多个小任务（fork），然后在将多个小任务处理汇总到一个结果上（join），非常像 MapReduce 处理原理。同时，它提供基本的线程池功能，支持设置最大并发线程数，支持任务队，支持线程池停止，支持线程池使用情况监控，也是 AbstractExecutorService 的子类，主要引入了“工作窃取”机制，在多 CPU 计算机上处理性能更佳。\n\nForkJoinPool 提供了一个更有效的利用线程的机制，当 ThreadPoolExecutor 还在用单个队列存放任务时，ForkJoinPool 已经分配了与线程数相等的队列；当有任务加入线程池时，会被平均分配到对应的队列上，各线程进行正常工作；当有线程提前完成时，会从队列的末端“窃取”其他线程未执行完的任务。\n\n## \u003cstrong\u003eExecutors 类\u003c/strong\u003e\n\nExcutors 类相当于一个线程池工厂，可以创建不同类型的线程池：\n\n#### \u003cem\u003enewFixedThreadPool\u003c/em\u003e\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads){\n    return new ThreadPoolExecutor(nThreads, nThreads, 0L, \n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e());\n}\n\npublic static ExecutorService newFixedThreadPool(int nThreads,     \n            ThreadFactory threadFactory){\n    return new ThreadPoolExecutor(nThreads, nThreads, 0L,   \n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e  \n        (), threadFactory);\n}\n```\n\n它的核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。\n\n#### \u003cem\u003enewSingleThreadExecutor\u003c/em\u003e\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue\u003cRunnable\u003e()));\n}\n\npublic static ExecutorService newSingleThreadExecutor(ThreadFactory   \n            threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue\u003cRunnable\u003e(), threadFactory));\n}\n```\n\n它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于\u003cstrong\u003e所有任务都需要按被提交的顺序依次执行\u003c/strong\u003e的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。\n\n#### \u003cem\u003ennewCachedThreadPoo\u003c/em\u003e\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L,   \n              TimeUnit.SECONDS, new SynchronousQueue\u003cRunnable\u003e());\n}\n\npublic static ExecutorService newCachedThreadPool(ThreadFactory \n            threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L,   \n              TimeUnit.SECONDS, new SynchronousQueue\u003cRunnable\u003e(),\n              threadFactory);\n}\n```\n\n可以称作可缓存线程池，它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为  0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。\n\n当提交一个任务后，线程池会判断已创建的线程中是否有空闲线程，如果有空闲线程则将任务直接指派给空闲线程，如果没有空闲线程，则新建线程去执行任务，这样就做到了动态地新增线程。\n\n#### \u003cem\u003enewScheduledThreadPool\u003c/em\u003e\n\n```java\npublic static ScheduledExecutorService \n        newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPoolExecutor(corePoolSize);\n}\n  \npublic static ScheduledExecutorService newScheduledThreadPool(\n        int corePoolSize, ThreadFactory threadFactory) {\n    return new ScheduledThreadPoolExecutor(corePoolSize,   \n          threadFactory);\n}\n\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue());\n}\n\npublic ScheduledThreadPoolExecutor(int corePoolSize,\n        ThreadFactory threadFactory) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue(), threadFactory);\n}\n```\n\nScheduledExecutorService 有三种方法执行定时任务：\n\n```java\nScheduledExecutorService service = Executors.newScheduledThreadPool(10);\n \nservice.schedule(new Task(), 10, TimeUnit.SECONDS);\n \nservice.scheduleAtFixedRate(new Task(), 10, 10, TimeUnit.SECONDS);\n \nservice.scheduleWithFixedDelay(new Task(), 10, 10, TimeUnit.SECONDS);\n```\n\n\u003cstrong\u003eschedule \u003c/strong\u003e比较简单，表示延迟指定时间后执行一次任务，如果代码中设置参数为 10 秒，也就是 10 秒后执行一次任务后就结束。\n\n\u003cstrong\u003escheduleAtFixedRate\u003c/strong\u003e 表示以固定的频率执行任务，它的第二个参数 initialDelay 表示第一次延时时间，第三个参数 period 表示周期，也就是第一次延时后每次延时多长时间执行一次任务。\n\n\u003cstrong\u003escheduleWithFixedDelay \u003c/strong\u003e与第二种方法类似，也是周期执行任务，区别在于对周期的定义，之前的 scheduleAtFixedRate 是以任务开始的时间为时间起点开始计时，时间到就开始执行第二次任务，而不管任务需要花多久执行；而 scheduleWithFixedDelay 方法以任务结束的时间为下一次循环的时间起点开始计时。\n\n#### \u003cem\u003enewSingleThreadScheduledExecutor\u003c/em\u003e\n\n```java\npublic static ScheduledExecutorService \n       newSingleThreadScheduledExecutor() {\n    return new ScheduledThreadPoolExecutor(1);\n}\n\npublic static ScheduledExecutorService \n       newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {\n    return new ScheduledThreadPoolExecutor(1, threadFactory);\n}\n```\n\n它只是 ScheduledThreadPool 的一个特例，内部只有一个线程。它只是将核心线程数设置为了 1。\n\n#### 五种线程池参数对比\n\n总结上述的五种线程池，我们以核心线程数、最大线程数，以及线程存活时间三个维度进行对比：\n\n\u003cstrong\u003eFixedThreadPool\u003c/strong\u003e，它的核心线程数和最大线程数都是由构造函数直接传参的，而且它们的值是相等的。重点是使用的队列是容量没有上限的 LinkedBlockingQueue，如果我们对任务的处理速度比较慢，那么随着请求的增多，队列中堆积的任务也会越来越多，最终大量堆积的任务会占用大量内存，并发生 OOM ，也就是 OutOfMemoryError，这几乎会影响到整个程序，会造成很严重的后果。\n\n\u003cstrong\u003eSingleThreadExecutor\u003c/strong\u003e，newSingleThreadExecutor 和 newFixedThreadPool 的原理是一样的，只不过把核心线程数和最大线程数都直接设置成了 1，但是任务队列仍是无界的 LinkedBlockingQueue，所以也会导致同样的问题。\n\n\u003cstrong\u003eCachedThreadPool\u003c/strong\u003e，和前面两种线程池不一样的地方在于任务队列使用的是 SynchronousQueue，SynchronousQueue 本身并不存储任务，而是对任务直接进行转发，这本身是没有问题的，但你会发现构造函数的第二个参数被设置成了 Integer.MAX_VALUE，这个参数的含义是最大线程数，所以由于 CachedThreadPool 并不限制线程的数量，当任务数量特别多的时候，就可能会导致创建非常多的线程，最终超过了操作系统的上限而无法创建新线程，或者导致内存不足。\n\n\u003cstrong\u003eScheduledThreadPool\u003c/strong\u003e  和 \u003cstrong\u003eSingleThreadScheduledExecutor  \u003c/strong\u003e的原理是一样的，它采用的任务队列是 DelayedWorkQueue，这是一个延迟队列，同时也是一个无界队列，所以和 LinkedBlockingQueue 一样，如果队列中存放过多的任务，就可能导致 OOM。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095020.png)\n\n#### \u003cem\u003enewWorkStealingPool (since 1.8)\u003c/em\u003e\n\n```java\npublic static ExecutorService newWorkStealingPool() {\n    return new ForkJoinPool\n        (Runtime.getRuntime().availableProcessors(),\n         ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n         null, true);\n}\n\npublic static ExecutorService newWorkStealingPool(int parallelism) {\n    return new ForkJoinPool\n        (parallelism,\n         ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n         null, true);\n}\n\npublic ForkJoinPool(int parallelism,\n                    ForkJoinWorkerThreadFactory factory,\n                    UncaughtExceptionHandler handler,\n                    boolean asyncMode) {\n    this(checkParallelism(parallelism),\n         checkFactory(factory),\n         handler,\n         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,\n         \"ForkJoinPool-\" + nextPoolId() + \"-worker-\");\n    checkPermission();\n}\n```\n\n这个线程池是在 JDK 7 加入的，它的名字 ForkJoin 也描述了它的执行机制，主要用法和之前的线程池是相同的，也是把任务交给线程池去执行，线程池中也有任务队列来存放任务。但是 ForkJoinPool 线程池和之前的线程池有两点非常大的不同之处。第一点它非常适合执行可以产生子任务的任务。\n\n如图所示，我们有一个 Task，这个 Task 可以产生三个子任务，三个子任务并行执行完毕后将结果汇总给 Result，比如说主任务需要执行非常繁重的计算任务，我们就可以把计算拆分成三个部分，这三个部分是互不影响相互独立的，这样就可以利用 CPU 的多核优势，并行计算，然后将结果进行汇总。这里面主要涉及两个步骤，第一步是拆分也就是 Fork，第二步是汇总也就是 Join，到这里你应该已经了解到 ForkJoinPool 线程池名字的由来了。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095024.png)\n\n比如，处理斐波那契数列问题：\n\n```java\nclass Fibonacci extends RecursiveTask\u003cInteger\u003e { \n    int n;\n \n    public Fibonacci(int n) { \n        this.n = n;\n    } \n \n    @Override\n    public Integer compute() { \n        if (n \u003c= 1) { \n            return n;\n        } \n        Fibonacci f1 = new Fibonacci(n - 1);\n        f1.fork();\n        Fibonacci f2 = new Fibonacci(n - 2);\n        f2.fork();\n        return f1.join() + f2.join();\n    } \n }\n\npublic static void main(String[] args) throws ExecutionException, \n            InterruptedException { \n    ForkJoinPool forkJoinPool = new ForkJoinPool();\n    for (int i = 0; i \u003c 10; i++) { \n        ForkJoinTask task = forkJoinPool.submit(new Fibonacci(i));\n        System.out.println(task.get());\n    } \n }\n\n输出内容：\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n```\n\n第二点不同之处在于内部结构，之前的线程池所有的线程共用一个队列，但 ForkJoinPool 线程池中每个线程都有自己独立的任务队列，如图所示。\n\nForkJoinPool 线程池内部除了有一个共用的任务队列之外，每个线程还有一个对应的双端队列 deque，这时一旦线程中的任务被 Fork 分裂了，分裂出来的子任务放入线程自己的 deque 里，而不是放入公共的任务队列中。如果此时有三个子任务放入线程 t1 的 deque 队列中，对于线程 t1 而言获取任务的成本就降低了，可以直接在自己的任务队列中获取而不必去公共队列中争抢也不会发生阻塞（除了后面会讲到的 steal 情况外），减少了线程间的竞争和切换，是非常高效的。\n\n再考虑一种情况，此时线程有多个，而线程 t1 的任务特别繁重，分裂了数十个子任务，但是 t0 此时却无事可做，它自己的 deque 队列为空，这时为了提高效率，t0 就会想办法帮助 t1 执行任务，这就是“work-stealing”的含义。\n\n双端队列 deque 中，线程 t1 获取任务的逻辑是后进先出，也就是 LIFO（Last In Frist Out），而线程 t0 在“steal”偷线程 t1 的 deque 中的任务的逻辑是先进先出，也就是 FIFO（Fast In Frist Out），如下图所示，图中很好的描述了两个线程使用双端队列分别获取任务的情景。你可以看到，使用“work-stealing”算法和双端队列很好地平衡了各线程的负载。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095028.png)\n\n用一张全景图来描述 ForkJoinPool 线程池的内部结构，可以看到 ForkJoinPool 线程池和其他线程池很多地方都是一样的，但重点区别在于它每个线程都有一个自己的双端队列来存储分裂出来的子任务。ForkJoinPool 非常适合用于递归的场景，例如树的遍历、最优路径搜索等场景。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095032.png)\n\n综合以上，Excutors 创建各种线程池对应的适用场景如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095035.png)\n\n## 提交任务\n\n- \u003cstrong\u003eexecute \u003c/strong\u003e方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。\n- \u003cstrong\u003esubmit \u003c/strong\u003e方法用于提交需要返回值的任务。线程池会返回一个 future 类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过 future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，而使用 get(long timeout，TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。\n\n## 关闭线程池\n\n#### shutdown()\n\n它可以安全地关闭一个线程池，调用 shutdown 方法之后线程池并不是立刻就被关闭，因为这时线程池中可能还有很多任务正在被执行，或是任务队列中有大量正在等待被执行的任务，调用 shutdown 方法后线程池会\u003cstrong\u003e在执行完正在执行的任务和队列中等待的任务后才彻底关闭\u003c/strong\u003e。但这并不代表 shutdown 操作是没有任何效果的，调用 shutdown 方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。\n\n#### isShutdown()\n\n它可以返回 true 或者 false 来判断线程池是否已经开始了关闭工作，也就是是否执行了 shutdown 或者 shutdownNow 方法。这里需要注意，如果调用 isShutdown 方法的返回的\u003cstrong\u003e结果为 true 并不代表线程池此时已经彻底关闭了，这仅仅代表线程池开始了关闭的流程\u003c/strong\u003e，也就是说，此时可能线程池中依然有线程在执行任务，队列里也可能有等待被执行的任务。\n\n#### isTerminated()\n\n这个方法可以检测线程池是否真正“终结”了，这不仅代表线程池已关闭，同时代表线程池中的所有任务都已经都执行完毕了。因为刚才说过，调用 shutdown 方法之后，线程池会继续执行里面未完成的任务，不仅包括线程正在执行的任务，还包括正在任务队列中等待的任务。比如此时已经调用了 shutdown 方法，但是有一个线程依然在执行任务，那么此时调用 isShutdown 方法返回的是 true ，而调用 isTerminated 方法返回的便是 false ，因为线程池中还有任务正在在被执行，线程池并没有真正“终结”。\u003cstrong\u003e直到所有任务都执行完毕了，调用 isTerminated 方法才会返回 true\u003c/strong\u003e，这表示线程池已关闭并且线程池内部是空的，所有剩余的任务都执行完毕了。\n\n#### awaitTermination()\n\n此方法本身并不是用来关闭线程池的，而是主要用来判断线程池状态的。比如我们给 awaitTermination 方法传入的参数是 10 秒，那么它就会陷入 10 秒钟的等待，直到发生以下三种情况之一：\n\n等待期间（包括进入等待状态之前）线程池已关闭并且所有已提交的任务（包括正在执行的和队列中等待的）都执行完毕，相当于线程池已经“终结”了，方法便会返回 true；\n\n等待超时时间到后，第一种线程池“终结”的情况始终未发生，方法返回 false；\n\n等待期间线程被中断，方法会抛出 InterruptedException 异常。\n\n也就是说，调用 awaitTermination 方法后\u003cstrong\u003e当前线程会尝试等待一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正“终结”了，那么方法就返回 true，否则超时返回 fasle。\u003c/strong\u003e\n\n我们可以根据 awaitTermination 返回的布尔值来判断下一步应该执行的操作。\n\n#### shutdownNow()\n\n最后一个方法是 shutdownNow()，也是 5 种方法里功能最强大的，它与第一种 shutdown 方法不同之处在于名字中多了一个单词 Now，也就是表示立刻关闭的意思。在执行 shutdownNow 方法之后，首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务 List 来进行一些补救的操作，例如记录在案并在后期重试。\n\n这里需要注意的是，由于 Java 中不推荐强行停止线程的机制的限制，即便我们调用了 shutdownNow 方法，如果被中断的线程对于中断信号不理不睬，那么依然有可能导致任务不会停止。可见我们在开发中落地最佳实践是很重要的，我们自己编写的线程应当具有响应中断信号的能力，正确停止线程的方法在前面有讲过，应当利用中断信号来协同工作。\n\n在掌握了这 5 种关闭线程池相关的方法之后，就可以根据自己的业务需要，选择合适的方法来停止线程池，比如通常可以用 shutdown 方法来关闭，这样可以让已提交的任务都执行完毕，但是如果情况紧急，那就可以用 shutdownNow 方法来加快线程池“终结”的速度。\n\n合\n\n## 合理地配置线程池\n\n要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。\n\n- 任务的性质：CPU 密集型任务、IO 密集型任务和混合型任务。\n- 任务的优先级：高、中和低。\n- 任务的执行时间：长、中和短。\n- 任务的依赖性：是否依赖其他系统资源，如数据库连接。\n\n性质不同的任务可以用不同规模的线程池分开处理：\n\n1. CPU 密集型任务应配置尽可能小的线程池，如配置 Ncpu + 1 个线程的线程池。比如加密、解密、压缩、计算等。\n2. IO 密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如 2*Ncpu。比如数据库、文件的读写，网络通信等任务等。\n3. 《Java 并发编程实战》的作者 Brain Goetz 推荐的计算方法：\u003cstrong\u003e线程数 = CPU 核心数 *（1+ 平均等待时间/平均工作时间）。\u003c/strong\u003e通过这个公式，我们可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于我们上面的 CPU 密集型任务，线程数就随之减少。太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行压测，监控 JVM 的线程情况以及 CPU 的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。\n4. 混合型的任务，如果可以拆分，将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过 Runtime.getRuntime().availableProcessors() 方法获得当前设备的 CPU 个数。\n5. 优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理。它可以让优先级高的任务先执行。\n6. 执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。\n7. 建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。\n8. 如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。\n\n```java\npublic class FairAndUnfair {\n\n    public static void main(String args[]) {\n        PrintQueue printQueue = new PrintQueue();\n\n\n        Thread thread[] = new Thread[10];\n        for (int i = 0; i \u003c 10; i++) {\n            thread[i] = new Thread(new Job(printQueue), \"Thread \" + i);\n        }\n\n\n        for (int i = 0; i \u003c 10; i++) {\n            thread[i].start();\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\nclass Job implements Runnable {\n\n    private PrintQueue printQueue;\n\n    public Job(PrintQueue printQueue) {\n        this.printQueue = printQueue;\n    }\n\n    @Override\n    public void run() {\n        System.out.printf(\"%s: Going to print a job\\n\", Thread.currentThread().getName());\n        printQueue.printJob(new Object());\n        System.out.printf(\"%s: The document has been printed\\n\", Thread.currentThread().getName());\n    }\n}\n\n\nclass PrintQueue {\n\n    private final Lock queueLock = new ReentrantLock(false);\n\n    public void printJob(Object document) {\n        queueLock.lock();\n\n        try {\n            Long duration = (long) (Math.random() * 10000);\n            System.out.printf(\"%s: PrintQueue: Printing a Job during %d seconds\\n\",\n                    Thread.currentThread().getName(), (duration / 1000));\n            Thread.sleep(duration);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            queueLock.unlock();\n        }\n\n        queueLock.lock();\n        try {\n            Long duration = (long) (Math.random() * 10000);\n            System.out.printf(\"%s: PrintQueue: Printing a Job during %d seconds\\n\",\n                    Thread.currentThread().getName(), (duration / 1000));\n            Thread.sleep(duration);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            queueLock.unlock();\n        }\n    }\n}\n\n```\n","lastmodified":"2023-03-23T02:32:34.058210059Z","tags":[]},"/%E9%94%81":{"title":"锁","content":"# 锁\n\n# 锁的分类\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Lock/clipboard_20230323_094809.png)\n\n### 偏向锁/轻量级锁/重量级锁\n\nJava SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级但不能降级。\n\n这些状态被记录在对象头中的 mark word 中。\n\n#### \u003cstrong\u003e偏向锁\u003c/strong\u003e\n\n如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。\n\n#### \u003cem\u003e轻量级锁\u003c/em\u003e\n\nJVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。\n\n#### \u003cem\u003e重量级锁\u003c/em\u003e\n\n重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。\n\n#### \u003cstrong\u003e对比\u003c/strong\u003e\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Lock/clipboard_20230323_094817.png)\n\n### 可重入锁/非可重入锁\n\n可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。同理，不可重入锁指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。\n\n对于可重入锁而言，最典型的就是 ReentrantLock 了，正如它的名字一样，reentrant 的意思就是可重入，它也是 Lock 接口最主要的一个实现类。synchronized 锁也属于可重入锁。\n\n### 共享锁/独占锁（排他锁）\n\n共享锁指的是我们同一把锁可以被多个线程同时获得；而独占锁（排他锁）指的就是，这把锁只能同时被一个线程获得。读写锁就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。\n\n### 公平锁/非公平锁\n\n#### \u003cem\u003e概念\u003c/em\u003e\n\n公平锁之公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。\n\n那么什么“一定情况下”呢？假设当前线程在请求获取锁的时候，恰巧前一个持有锁的线程释放了这把锁，那么当前申请锁的线程就可以不顾已经等待的线程而选择立刻插队。但是如果当前线程请求的时候，前一个线程并没有在那一时刻释放锁，那么当前线程还是一样会进入等待队列。\n\n#### \u003cem\u003e原理\u003c/em\u003e\n\n分析公平和非公平锁的源码，具体看下它们是怎样实现的：\n\n```java\npublic class ReentrantLock implements Lock,   \n        java.io.Serializable {\n    ...\n    //ReentrantLock 类包含一个 Sync 类的成员变量\n    private final Sync sync;\n    ...\n}\n\n//Sync 类的定义\nabstract static class Sync extends AbstractQueuedSynchronizer {...}\n\n//Sync 有公平锁 FairSync 和非公平锁 NonfairSync两个子类\nstatic final class NonfairSync extends Sync {...}\nstatic final class FairSync extends Sync {...}\n\n//公平锁与非公平锁的加锁方法\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (!hasQueuedPredecessors() \u0026\u0026 //只有公平锁在这里判断了队列是否为空\n                compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    } else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc \u003c 0) {\n            throw new Error(\"Maximum lock count exceeded\");\n        }\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取锁时多了一个限制条件：hasQueuedPredecessors() 为 false，这个方法就是判断在等待队列中是否已经有线程在排队了。这也就是公平锁和非公平锁的核心区别。\n\n\u003cstrong\u003e如果是公平锁，那么一旦已经有线程在排队了，当前线程就不再尝试获取锁；对于非公平锁而言，无论是否已经有线程在排队，都会尝试获取一下锁，获取不到的话，再去排队。\u003c/strong\u003e\n\n#### \u003cem\u003e对比\u003c/em\u003e\n\n| 类型     | 优点                                               | 缺点                                           |\n| -------- | -------------------------------------------------- | ---------------------------------------------- |\n| 公平锁   | 各线程公平竞争，每个线程等待一段时间后都有机会执行 | 更慢，吞入量更小                               |\n| 非公平锁 | 更快，吞吐量更大                                   | 有可能产生饥饿，某些线程可能始终得不到机会执行 |\n\n### 悲观锁/乐观锁\n\n#### 概念\n\n悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。而乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。\n\nJava 中悲观锁的实现包括 synchronized 关键字和 Lock 相关类等，我们以 Lock 接口为例，例如 Lock 的实现类 ReentrantLock，类中的 lock() 等方法就是执行加锁，而 unlock() 方法是执行解锁。处理资源之前必须要先加锁并拿到锁，等到处理完了之后再解开锁，这就是非常典型的悲观锁思想。\n\n乐观锁的典型案例就是原子类，例如 AtomicInteger 在更新数据时，就使用了乐观锁的思想，多个线程可以同时操作同一个原子变量。\n\n#### 对比\n\n| 类型   | 优点                                             | 缺点                                                                           | 使用场景                                                                                                       |\n| ------ | ------------------------------------------------ | ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------- |\n| 乐观锁 | 开销比较锁小                                     | 如果一直拿不到锁，或者并发量大，竞争激烈，导致不停重试，消耗的资源也会越来越多 | 大部分是读取，少部分是修改，或者虽然读写都很多，但是并发并不激烈的场景下，乐观锁不加锁的特点能让性能大幅提高。 |\n| 悲观锁 | 开销固定，就算一直拿不到锁，也不会造成额外的影响 | 操作比较重量级，不能多个线程并行执行，还会有上下文切换等动作造成性能问题       | 并发写入多、临界区代码复杂、竞争激烈等场景，可以避免大量的无用的反复尝试等消耗。                               |\n\n### 自旋锁/非自旋锁\n\n自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。\n\n相反，非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。\n\n### 自旋的利与弊\n\n首先，阻塞和唤醒线程都是需要高昂的开销的，如果同步代码块中的内容不复杂，那么可能转换线程带来的开销比实际业务代码执行的开销还要大。\n\n在很多场景下，同步代码块的内容并不多，所以需要的执行时间也很短，如果仅仅为了这点时间就去切换线程状态，那么其实不如让线程不切换状态，而是让它自旋地尝试获取锁，等待其他线程释放锁，有时只需要稍等一下，就可以避免上下文切换等开销，提高了效率。\n\n用一句话总结自旋锁的好处，那就是自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。\n\n它最大的缺点就在于虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。\n\n#### 适用场景\n\n首先，自旋锁适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。\n\n如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。\n\n### 可中断锁/不可中断锁\n\n在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。\n\n# synchronized 实现原理\n\n## 同步代码块\n\n每个 Java 对象都可以用作一个实现同步的锁，这个锁也被称为内置锁或 monitor 锁，获得 monitor 锁的唯一途径就是进入由这个锁保护的同步代码块或同步方法，线程在进入被 synchronized 保护的代码块之前，会自动获取锁，并且无论是正常路径退出，还是通过抛出异常退出，在退出的时候都会自动释放锁。\n\n举个例子，当使用 synchronized 关键字修饰代码块的时候：\n\n```java\npublic class SynTest {\n    public void synBlock() {\n        synchronized (this) {\n            System.out.println(\"abc\");\n        }\n    }\n}\n```\n\n生成的字节码经过反汇编后如下：\n\n```java\npublic void synBlock();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: aload_0\n         1: dup\n         2: astore_1\n         3: monitorenter\n         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         7: ldc           #3                      // String abc\n         9: invokevirtual #4               // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        12: aload_1\n        13: monitorexit\n        14: goto          22\n        17: astore_2\n        18: aload_1\n        19: monitorexit\n        20: aload_2\n        21: athrow\n        22: return\n```\n\n从里面可以看出，synchronized 代码块上多了 monitorenter 和 monitorexit 指令（第 3、13、19 行）。这里有一个 monitorenter，却有两个 monitorexit 指令的原因是，JVM 要保证每个 monitorenter 必须有与之对应的 monitorexit，monitorenter 指令被插入到同步代码块的开始位置，而 monitorexit 需要插入到方法正常结束处和异常处两个地方，这样就可以保证抛异常的情况下也能释放锁。\n\n可以把执行 monitorenter 理解为加锁，执行 monitorexit 理解为释放锁，每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为 0，具体的含义如下：\n\n\u003cstrong\u003emonitorenter\u003c/strong\u003e\n\n执行 monitorenter 的线程尝试获得 monitor 的所有权，会发生以下这三种情况之一：\n\n1. 如果该 monitor 的计数为 0，则线程获得该 monitor 并将其计数设置为 1。然后，该线程就是这个 monitor 的所有者。\n2. 如果线程已经拥有了这个 monitor ，则它将重新进入，并且累加计数。\n3. 如果其他线程已经拥有了这个 monitor，那个这个线程就会被阻塞，直到这个 monitor 的计数变成为 0，代表这个 monitor 已经被释放了，于是当前这个线程就会再次尝试获取这个 monitor。\n\n\u003cstrong\u003emonitorexit\u003c/strong\u003e\n\nmonitorexit 的作用是将 monitor 的计数器减 1，直到减为 0 为止。代表这个 monitor 已经被释放了，已经没有任何线程拥有它了，也就代表着解锁，所以，其他正在等待这个 monitor 的线程，此时便可以再次尝试获取这个 monitor 的所有权。\n\n## 同步方法\n\n从上面可以看出，同步代码块是使用 monitorenter 和 monitorexit 指令实现的。而对于 synchronized 方法，它的实现不太相同。\n\n同步方法使用示例：\n\n```java\npublic synchronized void synMethod() {\n  ...\n}\n```\n\n对应的汇编指令如下：\n\n```java\npublic synchronized void synMethod();\n    descriptor: ()V\n    flags: ACC_PUBLIC, ACC_SYNCHRONIZED\n    Code:\n      stack=0, locals=1, args_size=1\n         0: return\n      LineNumberTable:\n        line 16: 0\n```\n\n对比前面使用 synchronized 代码块生成的汇编指令，可以看出，被 synchronized 修饰的方法会有一个 ACC_SYNCHRONIZED 标志。当某个线程要访问某个方法的时候，会首先检查方法是否有 ACC_SYNCHRONIZED 标志，如果有则需要先获得 monitor 锁，然后才能开始执行方法，方法执行之后再释放 monitor 锁。其他方面， synchronized 方法和刚才的 synchronized 代码块是很类似的，例如这时如果其他线程来请求执行方法，也会因为无法获得 monitor 锁而被阻塞。\n\n# Lock 类\n\n## 简介\n\nLock 接口是 Java 5 引入的，最常见的实现类是 ReentrantLock，可以起到“锁”的作用。\n\n通常情况下，Lock 只允许一个线程来访问这个共享资源。不过有的时候，一些特殊的实现也可允许并发访问，比如 ReadWriteLock 里面的 ReadLock。\n\n## 方法纵览\n\nLock 接口的各个方法，如代码所示。\n\n```java\npublic interface Lock {\n    void lock();\n    void lockInterruptibly() throws InterruptedException;\n    boolean tryLock();\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n    void unlock();\n    Condition newCondition();\n}\n```\n\n#### lock()\n\n首先，lock() 是最基础的获取锁的方法。在线程获取锁时如果锁已被其他线程获取，则进行等待，是最初级的获取锁的方法。\n\n对于 Lock 接口而言，获取锁和释放锁都是显式的，不像 synchronized 那样是隐式的，所以 Lock 不会像 synchronized 一样在异常时自动释放锁（synchronized 即使不写对应的代码也可以释放），lock 的加锁和释放锁都必须以代码的形式写出来，所以使用 lock() 时必须由我们自己主动去释放锁，因此最佳实践是执行 lock() 后，首先在 try{} 中操作同步资源，如果有必要就用 catch{} 块捕获异常，然后在 finally{} 中释放锁，以保证发生异常时锁一定被释放，示例代码如下所示。\n\n```java\nLock lock = ...;\nlock.lock();\ntry {\n    //获取到了被本锁保护的资源，处理任务\n    //捕获异常\n} finally {\n    lock.unlock();   //释放锁\n}\n```\n\n一定不要忘记在 finally 中添加 unlock() 方法，以便保障锁的绝对释放。\n\n如果不遵守在 finally 里释放锁的规范，就会让 Lock 变得非常危险，因为你不知道未来什么时候由于异常的发生，导致跳过了 unlock() 语句，使得这个锁永远不能被释放了，其他线程也无法再获得这个锁。\n\n与此同时，lock() 方法不能被中断，这会带来很大的隐患：一旦陷入死锁，lock() 就会陷入永久等待，所以一般我们用 tryLock() 等其他更高级的方法来代替 lock()，下面我们就看一看 tryLock() 方法。\n\n#### tryLock()\n\ntryLock() 用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回 true，否则返回 false，代表获取锁失败。相比于 lock()，这样的方法显然功能更强大，我们可以根据是否能获取到锁来决定后续程序的行为。\n\n因为该方法会立即返回，即便在拿不到锁时也不会一直等待，所以通常情况下，我们用 if 语句判断 tryLock() 的返回结果，根据是否获取到锁来执行不同的业务逻辑，典型使用方法如下。\n\n```java\nLock lock = ...;\nif (lock.tryLock()) {\n     try {\n         //处理任务\n     } finally {\n         lock.unlock();   //释放锁\n     } \n} else {\n    //如果不能获取锁，则做其他事情\n}\n```\n\n如果 if 语句返回 false 就会进入 else 语句，代表它暂时不能获取到锁，可以先去做一些其他事情，比如等待几秒钟后重试，或者跳过这个任务，有了这个强大的 tryLock() 方法我们便可以解决死锁问题。\n\n#### tryLock(long time, TimeUnit unit)\n\ntryLock() 的重载方法是 tryLock(long time, TimeUnit unit)，这个方法和 tryLock() 很类似，区别在于 tryLock(long time, TimeUnit unit) 方法会有一个超时时间，在拿不到锁时会等待一定的时间，如果在时间期限结束后，还获取不到锁，就会返回 false；如果一开始就获取锁或者等待期间内获取到锁，则返回 true。\n\n这个方法解决了 lock() 方法容易发生死锁的问题，使用 tryLock(long time, TimeUnit unit) 时，在等待了一段指定的超时时间后，线程会主动放弃这把锁的获取，避免永久等待；在等待的期间，也可以随时中断线程，这就避免了死锁的发生。\n\n#### lockInterruptibly()\n\n这个方法的作用也是去获取锁，如果这个锁当前是可以获得的，那么这个方法会立刻返回，但是如果这个锁当前是不能获得的（被其他线程持有），那么当前线程便会开始等待，除非它等到了这把锁或者是在等待的过程中被中断了，否则这个线程便会一直在这里执行这行代码。一句话总结就是，除非当前线程在获取锁期间被中断，否则便会一直尝试获取直到获取到为止。\n\n顾名思义，lockInterruptibly() 是可以响应中断的。相比于不能响应中断的 synchronized 锁，lockInterruptibly() 可以让程序更灵活，可以在获取锁的同时，保持对中断的响应。我们可以把这个方法理解为超时时间是无穷长的 tryLock(long time, TimeUnit unit)，因为 tryLock(long time, TimeUnit unit) 和 lockInterruptibly() 都能响应中断，只不过 lockInterruptibly() 永远不会超时。\n\n这个方法本身是会抛出 InterruptedException 的，所以使用的时候，如果不在方法签名声明抛出该异常，那么就要写两个 try 块，如下所示。\n\n```java\npublic void lockInterruptibly() {\n    try {\n        lock.lockInterruptibly();\n        try {\n            System.out.println(\"操作资源\");\n        } finally {\n            lock.unlock();\n        }\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n在这个方法中我们首先执行了 lockInterruptibly() 方法，并且对它进行了 try catch 包装，然后同样假设我们能够获取到这把锁，和之前一样，就必须要使用 try finall 来保障锁的绝对释放。\n\n#### unlock()\n\n最后要介绍的方法是 unlock() 方法，是用于解锁的，此方法比较简单，对于 ReentrantLock 而言，执行 unlock() 的时候，内部会把锁的“被持有计数器”减 1，直到减到 0 就代表当前这把锁已经完全释放了，如果减 1 后计数器不为 0，说明这把锁之前被“重入”了，那么锁并没有真正释放，仅仅是减少了持有的次数。\n\n#### newCondition()\n\nCondition 接口也提供了类似 Object 的监视器方法，与 Lock 配合可以实现等待/通知模式。\n\n假设线程 1 需要等待某些条件满足后，才能继续运行，这个条件会根据业务场景不同，有不同的可能性，比如等待某个时间点到达或者等待某些任务处理完毕。在这种情况下，可以执行 Condition 的 await 方法，一旦执行了该方法，这个线程就会进入 WAITING 状态。\n\n通常会有另外一个线程，我们把它称作线程 2，它去达成对应的条件，直到这个条件达成之后，那么，线程 2 调用 Condition 的 signal 方法 [或 signalAll 方法]，代表“这个条件已经达成了，之前等待这个条件的线程现在可以苏醒了”。这个时候，JVM 就会找到等待该 Condition 的线程，并予以唤醒，根据调用的是 signal 方法或 signalAll 方法，会唤醒 1 个或所有的线程。于是，线程 1 在此时就会被唤醒，然后它的线程状态又会回到 Runnable 可执行状态。\n\n```java\npublic class ConditionDemo {\n    private ReentrantLock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    void method1() throws InterruptedException {\n        lock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName()+\":条件不满足，开始await\");\n            condition.await();\n            System.out.println(Thread.currentThread().getName()+\":条件满足了，开始执行后续的任务\");\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    void method2() throws InterruptedException {\n        lock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName()+\":需要5秒钟的准备时间\");\n            Thread.sleep(5000);\n            System.out.println(Thread.currentThread().getName()+\":准备工作完成，唤醒其他的线程\");\n            condition.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args)\n                throws InterruptedException {\n        ConditionDemo conditionDemo = new ConditionDemo();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    conditionDemo.method2();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n        conditionDemo.method1();\n    }\n}\n\n输出结果：\nmain:条件不满足，开始 await\nThread-0:需要 5 秒钟的准备时间\nThread-0:准备工作完成，唤醒其他的线程\nmain:条件满足了，开始执行后续的任务\n```\n\n- \u003cstrong\u003emethod1\u003c/strong\u003e，它代表主线程将要执行的内容，首先获取到锁，打印出“条件不满足，开始 await”，然后调用 condition.await() 方法，直到条件满足之后，则代表这个语句可以继续向下执行了，于是打印出“条件满足了，开始执行后续的任务”，最后会在 finally 中解锁。\n- \u003cstrong\u003emethod2\u003c/strong\u003e，它同样也需要先获得锁，然后打印出“需要 5 秒钟的准备时间”，接着用 sleep 来模拟准备时间；在时间到了之后，则打印出“准备工作完成”，最后调用 condition.signal() 方法，把之前已经等待的线程唤醒。\n\n# 读写锁\n\n在没有读写锁之前，假设使用普通的 ReentrantLock，那么虽然保证了线程安全，但是也浪费了一定的资源，因为如果多个读操作同时进行，其实并没有线程安全问题，可以允许让多个读操作并行，以便提高程序效率。\n\n但是写操作不是线程安全的，如果多个线程同时写，或者在写的同时进行读操作，便会造成线程安全问题。\n\n读写锁就解决了这样的问题，它设定了一套规则，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。\n\n\u003cstrong\u003e使用读写锁时遵守下面的获取规则\u003c/strong\u003e\n\n- 如果有一个线程已经占用了读锁，则此时其他线程如果要申请读锁，可以申请成功。\n- 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁，因为读写不能同时操作。\n- 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，都必须等待之前的线程释放写锁，同样也因为读写不能同时，并且两个线程不应该同时写。\n\n用一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。也可以总结为：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥）。\n\n#### \u003cstrong\u003e使用示例\u003c/strong\u003e\n\nReentrantReadWriteLock 是 ReadWriteLock 的实现类，最主要的有两个方法：readLock() 和 writeLock() 用来获取读锁和写锁。\n\n```java\npublic class ReadWriteLockDemo {\n\n    private static final ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(false);\n    private static final ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();\n    private static final ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();\n\n    private static void read() {\n        readLock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \"得到读锁，正在读取\");\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            System.out.println(Thread.currentThread().getName() + \"释放读锁\");\n            readLock.unlock();\n        }\n    }\n\n    private static void write() {\n        writeLock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \"得到写锁，正在写入\");\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            System.out.println(Thread.currentThread().getName() + \"释放写锁\");\n            writeLock.unlock();\n        }\n    }\n\n    public static void main(String[] args) \n            throws InterruptedException {\n        new Thread(() -\u003e read()).start();\n        new Thread(() -\u003e read()).start();\n        new Thread(() -\u003e write()).start();\n        new Thread(() -\u003e write()).start();\n    }\n}\n\n输出结果：\nThread-0得到读锁，正在读取\nThread-1得到读锁，正在读取\nThread-0释放读锁\nThread-1释放读锁\nThread-2得到写锁，正在写入\nThread-2释放写锁\nThread-3得到写锁，正在写入\nThread-3释放写锁\n```\n\n可以看出，读锁可以同时被多个线程获得，而写锁不能。\n\n#### 适用场景\n\n相比于 ReentrantLock 适用于一般场合，ReadWriteLock 适用于读多写少的情况，合理使用可以进一步提高并发效率。\n\n# JVM 对锁的优化\n\n相比于 JDK 1.5，在 JDK 1.6 中 HotSopt 虚拟机对 synchronized 内置锁的性能进行了很多优化，包括自适应的自旋、锁消除、锁粗化、偏向锁、轻量级锁等。有了这些优化措施后，synchronized 锁的性能得到了大幅提高，下面我们分别介绍这些具体的优化。\n\n#### 自适应的自旋锁\n\n在 JDK 1.6 中引入了自适应的自旋锁来解决长时间自旋的问题。自适应意味着自旋的时间不再固定，而是会根据最近自旋尝试的成功率、失败率，以及当前锁的拥有者的状态等多种因素来共同决定。自旋的持续时间是变化的，自旋锁变“聪明”了。比如，如果最近尝试自旋获取某一把锁成功了，那么下一次可能还会继续使用自旋，并且允许自旋更长的时间；但是如果最近自旋获取某一把锁失败了，那么可能会省略掉自旋的过程，以便减少无用的自旋，提高效率。\n\n#### 锁消除\n\n经过逃逸分析之后，如果发现某些对象不可能被其他线程访问到，那么就可以把它们当成栈上数据，栈上数据由于只有本线程可以访问，自然是线程安全的，也就无需加锁，所以会把这样的锁给自动去除掉。\n\n#### 锁粗化\n\n如果释放了锁，紧接着什么都没做，又重新获取锁，那么其实这种释放和重新获取锁是完全没有必要的，如果我们把同步区域扩大，也就是只在最开始加一次锁，并且在最后直接解锁，那么就可以把中间这些无意义的解锁和加锁的过程消除，相当于是把几个 synchronized 块合并为一个较大的同步块。这样做的好处在于在线程执行这些代码时，就无须频繁申请与释放锁了，这样就减少了性能开销。\n\n#### 锁升级\n\n前面说到过，从无锁到偏向锁，再到轻量级锁，最后到重量级锁的升级过程也是 JVM 自动完成的。JVM 默认会优先使用偏向锁，如果有必要的话才逐步升级，这大幅提高了锁的性能。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Lock/clipboard_20230323_094831.png)\n","lastmodified":"2023-03-23T02:32:34.058210059Z","tags":[]},"/2023-03-15":{"title":"2023-03-15","content":"弄完了同步，牛逼","lastmodified":"2023-03-23T02:32:34.054210061Z","tags":[]},"/2023-03-16":{"title":"2023-03-16","content":"","lastmodified":"2023-03-23T02:32:34.054210061Z","tags":[]},"/2023-03-18":{"title":"2023-03-18","content":"# 2023-03-18\n### 今日开发工作\n### 今日感想","lastmodified":"2023-03-23T02:32:34.054210061Z","tags":["哈哈","好"]},"/2023-03-19":{"title":"2023-03-19","content":"### 今日开发工作\n### 今日感想","lastmodified":"2023-03-23T02:32:34.054210061Z","tags":[]},"/2023-03-20":{"title":"2023-03-20","content":"### 今日开发工作\n### 今日感想\nsadlfjsal \n\nfrom windows\n\n之类主页是[[AboutTheGarden]]","lastmodified":"2023-03-23T02:32:34.054210061Z","tags":[]},"/2023-03-22":{"title":"Troubleshooting and FAQ","content":"\nStill having trouble? Here are a list of common questions and problems people encounter when installing Quartz.\n\nWhile you're here, join our [Discord](https://discord.gg/cRFFHYye7t) :)\n\n### Does Quartz have Latex support?\nYes! See [CJK + Latex Support (测试)](notes/CJK%20+%20Latex%20Support%20(测试).md) for a brief demo.\n\n### Can I use \\\u003cObsidian Plugin\\\u003e in Quartz?\nUnless it produces direct Markdown output in the file, no. There currently is no way to bundle plugin code with Quartz.\n\nThe easiest way would be to add your own HTML partial that supports the functionality you are looking for.\n\n### My GitHub pages is just showing the README and not Quartz\nMake sure you set the source to deploy from `master` (and not `hugo`) using `/ (root)`! See more in the [hosting](/notes/hosting) guide\n\n### Some of my pages have 'January 1, 0001' as the last modified date\nThis is a problem caused by `git` treating files as case-insensitive by default and some of your posts probably have capitalized file names. You can turn this off in your Quartz by running this command.\n\n```shell\n# in the root of your Quartz (same folder as config.toml)\ngit config core.ignorecase true\n\n# or globally (not recommended)\ngit config --global core.ignorecase true\n```\n\n### Can I publish only a subset of my pages?\nYes! Quartz makes selective publishing really easy. Heres a guide on [excluding pages from being published](notes/ignore%20notes.md).\n\n### Can I host this myself and not on GitHub Pages?\nYes! All built files can be found under `/public` in the `master` branch. More details under [hosting](notes/hosting.md).\n\n### `command not found: hugo-obsidian`\nMake sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize `hugo-obsidian` as an executable.\n\n```shell\n# Add the following 2 lines to your ~/.bash_profile (~/.zshrc if you are on Mac)\nexport GOPATH=/Users/$USER/go\nexport PATH=$GOPATH/bin:$PATH\n\n# In your current terminal, to reload the session\nsource ~/.bash_profile # again, (~/.zshrc if you are on Mac)\n```\n\n### How come my notes aren't being rendered?\nYou probably forgot to include front matter in your Markdown files. You can either setup [Obsidian](notes/obsidian.md) to do this for you or you need to manually define it. More details in [the 'how to edit' guide](notes/editing.md).\n\n### My custom domain isn't working!\nWalk through the steps in [the hosting guide](notes/hosting.md) again. Make sure you wait 30 min to 1 hour for changes to take effect.\n\n### How do I setup analytics?\nQuartz by default uses [Plausible](https://plausible.io/) for analytics. \n\nIf you would prefer to use Google Analytics, you can follow this [guide in the Hugo documentation](https://gohugo.io/templates/internal/#google-analytics). \n\nAlternatively, you can also import your Google Analytics data into Plausible by [following this guide](https://plausible.io/docs/google-analytics-import).\n\n\n### How do I change the content on the home page?\nTo edit the main home page, open `/content/_index.md`.\n\n### How do I change the colours?\nYou can change the theme by editing `assets/custom.scss`. More details on customization and themeing can be found in the [customization guide](notes/config.md).\n\n### How do I add images?\nYou can put images anywhere in the `/content` folder.\n\n### My Interactive Graph and Backlinks aren't up to date\nBy default, the `linkIndex.json` (which Quartz needs to generate the Interactive Graph and Backlinks) are not regenerated locally. To set that up, see the guide on [local editing](notes/editing.md)\n\n### Can I use React/Vue/some other framework?\nNot out of the box. You could probably make it work by editing `/layouts/_default/single.html` but that's not what Quartz is designed to work with. 99% of things you are trying to do with those frameworks you can accomplish perfectly fine using just vanilla HTML/CSS/JS.\n\n## Still Stuck?\nQuartz isn't perfect! If you're still having troubles, file an issue in the GitHub repo with as much information as you can reasonably provide. Alternatively, you can message me on [Twitter](https://twitter.com/_jzhao) and I'll try to get back to you as soon as I can.\n\n🐛 [Submit an Issue](https://github.com/jackyzha0/quartz/issues)\n","lastmodified":"2023-03-23T02:32:34.358209968Z","tags":[]},"/About-Atlas":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: tutorial\ntitle: \"About Atlas\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\nAtlas意思是地图集。\n\n单个案例或项目的MOC，考虑直接放在对应文件夹里面，相当于起到一个个文件夹的readme和导览的作用。这里专门放这些MOC的MOC。\n\n围绕本库和obsidian的使用教程、方法和细节，也放到这里，就像是地图的指南针。\n","lastmodified":"2023-03-23T02:32:34.358209968Z","tags":[]},"/About-Extras":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: tutorial\ntitle: \"About Extras\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n[[图片保存：图床or本地]]\n","lastmodified":"2023-03-23T02:32:34.358209968Z","tags":[]},"/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86":{"title":"CAS 和 AQS 原理","content":"\n# CAS\n\n### 介绍\n\nCAS 英文全称是 Compare-And-Swap，中文叫做“比较并交换”，它是一种思想、一种算法。\n\n在大多数处理器的指令中，都会实现 CAS 相关的指令，这一条指令就可以完成“比较并交换”的操作，也正是由于这是一条（而不是多条）CPU 指令，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以无需我们程序员来操心。\n\nCAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。CAS 最核心的思路就是，\u003cstrong\u003e仅当预期值 A 和当前的内存值 V 相同时，才将内存值修改为 B。\u003c/strong\u003e\n\n### \u003cstrong\u003e使用及原理\u003c/strong\u003e\n\n#### ConcurrentHashMap\n\n截取 ConcurrentHashMap 部分 putVal 方法的代码，如下所示：\n\n```java\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new   \n                   NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node\u003cK,V\u003e[] tab = table;;) {\n        Node\u003cK,V\u003e f; int n, i, fh;\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) {\n            if (casTabAt(tab, i, null,\n                         new Node\u003cK,V\u003e(hash, key, value, null)))\n                break; // no lock when adding to empty bin\n        }\n    ...\n}\n\nstatic final \u003cK,V\u003e boolean casTabAt(Node\u003cK,V\u003e[] tab, int i,\n                                    Node\u003cK,V\u003e c, Node\u003cK,V\u003e v) {\n    return U.compareAndSwapObject(tab, ((long)i \u003c\u003c ASHIFT) + ABASE, c, v);\n}\n```\n\n该方法里面只有一行代码，即调用变量 U 的 compareAndSwapObject 的方法，U 是 Unsafe 类型的实例。\n\n#### ConcurrentLinkedQueue\n\n接下来看并发容器的第二个案例。非阻塞并发队列 ConcurrentLinkedQueue 的 offer 方法里也有 CAS 的身影，offer 方法的代码如下所示：\n\n```java\npublic boolean offer(E e) {\n    checkNotNull(e);\n    final Node\u003cE\u003e newNode = new Node\u003cE\u003e(e);\n\n    for (Node\u003cE\u003e t = tail, p = t;;) {\n        Node\u003cE\u003e q = p.next;\n        if (q == null) {\n            if (p.casNext(null, newNode)) {\n                if (p != t) \n                    casTail(t, newNode); \n                return true;\n            }\n        }\n        else if (p == q)\n            p = (t != (t = tail)) ? t : head;\n        else\n            p = (p != t \u0026\u0026 t != (t = tail)) ? t : q;\n    }\n}\n\nboolean casNext(Node\u003cE\u003e cmp, Node\u003cE\u003e val) {\n    return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n}\n```\n\n可以看出，在 offer 方法中，有一个 for 循环，这是一个死循环，在第 8 行有一个与 CAS 相关的方法，是 casNext 方法，用于更新节点。那么如果执行 p 的 casNext 方法失败的话，casNext 会返回 false，那么显然代码会继续在 for 循环中进行下一次的尝试。而 casNext 方法中也用到了 UnSafe 类。\n\n#### 原子类\n\n在编程领域里，原子性意味着“一组操作要么全都操作成功，要么全都失败，不能只操作成功其中的一部分”。而 java.util.concurrent.atomic 下的类，就是具有原子性的类，可以原子性地执行添加、递增、递减等操作。\n\n原子类的作用和锁有类似之处，是为了保证并发情况下线程安全。不过原子类相比于锁，有一定的优势：\n\n- 粒度更细：原子变量可以把竞争范围缩小到变量级别，通常情况下，锁的粒度都要大于原子变量的粒度。\n- 效率更高：除了高度竞争的情况之外，使用原子类的效率通常会比使用同步互斥锁的效率更高，因为原子类底层利用了 CAS 操作，不会阻塞线程。\n\n原子类一共可以分为以下这 6 类：\n\n| 类型                               | 具体类                                                                         |\n| ---------------------------------- | ------------------------------------------------------------------------------ |\n| Atomic* 基本类型原子类             | AtomicInteger、AtomicLong、AtomicBoolean                                       |\n| Atomic*Array 数组类型原子类        | AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray                      |\n| Atomic*Reference 引用类型原子类    | AtomicReference、AtomicStampedReference、AtomicMarkableReference               |\n| Atomic*FieldUpdater 升级类型原子类 | AtomicIntegerfieldupdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater |\n| Adder 累加器                       | LongAdder、DoubleAdder                                                         |\n| Accumulator 积累器                 | LongAccumulator、DoubleAccumulator                                             |\n\n下面以 AtomicInteger 为例，分析在 Java 中如何利用 CAS 实现原子操作。\n\ngetAndAdd 方法是 AtomicInteger 类的重要方法，这个方法的代码在 Java 1.8 中的实现如下：\n\n```java\npublic final int getAndAdd(int delta) {    \n    return unsafe.getAndAddInt(this, valueOffset, delta);\n}\n```\n\n可以看出，里面再次用到了 Unsafe 这个类，并且调用了 unsafe.getAndAddInt 方法。\n\n#### 实现原理\n\n从以上示例可以看出，Unsafe 其实是 CAS 的核心类，并且其核心方法都是由 native 层面来实现的。由于 Java 无法直接访问底层操作系统，而是需要通过 native 方法来实现。不过尽管如此，JVM 还是留了一个后门，Unsafe 类提供了硬件级别的原子操作，可以利用它直接操作内存数据。\n\n看一下 AtomicInteger 的一些重要代码，如下所示：\n\n```java\npublic class AtomicInteger extends Number \n           implements java.io.Serializable {\n   // setup to use Unsafe.compareAndSwapInt for updates\n   private static final Unsafe unsafe = Unsafe.getUnsafe();\n   private static final long valueOffset;\n \n   static {\n       try {\n           valueOffset = unsafe.objectFieldOffset\n               (AtomicInteger.class.getDeclaredField(\"value\"));\n       } catch (Exception ex) { throw new Error(ex); }\n   }\n \n   private volatile int value;\n   public final int get() {return value;}\n   ...\n}\n```\n\n可以看出，在数据定义的部分，首先获取了 Unsafe 实例，并且定义了 valueOffset。接下来 static 代码块会在类加载的时候执行，执行时会调用 Unsafe 的 objectFieldOffset 方法，从而得到当前这个原子类的 value 的偏移量，并且赋给 valueOffset 变量，这样就获取到了 value 的偏移量，它的含义是在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的原值的，这样就能通过 Unsafe 来实现 CAS 了。\n\nvalue 是用 volatile 修饰的，它就是原子类存储的值的变量，由于它被 volatile 修饰，可以保证在多线程之间看到的 value 是同一份，保证了可见性。\n\n接下来继续看 Unsafe 的 getAndAddInt 方法的实现，代码如下：\n\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n   int var5;\n   do {\n       var5 = this.getIntVolatile(var1, var2);\n   } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n   return var5;\n}\n```\n\n首先，它是一个 do-while 循环，所以这是一个死循环，直到满足循环的退出条件时才可以退出。\n\n接下来看 do 后面的这一行代码 var5 = this.getIntVolatile(var1, var2) ，这是个 native 方法，作用就是获取在 var1 中的 var2 偏移处的值。\n\n传入的两个参数，第一个就是当前原子类，第二个就是最开始获取到的 offset，这样一来我们就可以获取到当前内存中偏移量的值，并且保存到 var5 里面。此时 var5 实际上代表当前时刻下的原子类的数值。\n\n现在再来看 while 的退出条件，也就是 compareAndSwapInt 这个方法，它一共传入了 4 个参数，这 4 个参数是 var1、var2、var5、var5 + var4，为了方便理解，我们给它们取了新了变量名，分别 object、offset、expectedValue、newValue，具体含义如下：\n\n- 第一个参数 object 就是将要操作的对象，传入的是 this，也就是 atomicInteger 这个对象本身；\n- 第二个参数是 offset，也就是偏移量，借助它就可以获取到 value 的数值；\n- 第三个参数 expectedValue，代表“期望值”，传入的是刚才获取到的 var5；\n- 而最后一个参数 newValue 是希望修改的数值 ，等于之前取到的数值 var5 再加上 var4，而 var4 就是我们之前所传入的 delta，delta 就是我们希望原子类所改变的数值，比如可以传入 +1，也可以传入 -1。\n\n所以 compareAndSwapInt 方法的作用就是，判断如果现在原子类里 value 的值和之前获取到的 var5 相等的话，那么就把计算出来的 var5 + var4 给更新上去，所以说这行代码就实现了 CAS 的过程。\n\n一旦 CAS 操作成功，就会退出这个 while 循环，但是也有可能操作失败。如果操作失败就意味着在获取到 var5 之后，并且在 CAS 操作之前，value 的数值已经发生变化了，证明有其他线程修改过这个变量。\n\n这样一来，就会再次执行循环体里面的代码，重新获取 var5 的值，也就是获取最新的原子变量的数值，并且再次利用 CAS 去尝试更新，直到更新成功为止，所以这是一个死循环。\n\n总结一下，Unsafe 的 getAndAddInt 方法是通过循环 + CAS 的方式来实现的，在此过程中，它会通过 compareAndSwapInt 方法来尝试更新 value 的值，如果更新失败就重新获取，然后再次尝试更新，直到更新成功。\n\n### CAS 造成的三个问题\n\n#### ABA 问题\n\n决定 CAS 是否进行 swap 的判断标准是“当前的值和预期的值是否一致”，如果一致，就认为在此期间这个数值没有发生过变动，这在大多数情况下是没有问题的。\n\n但是在有的业务场景下，我们想确切知道从上一次看到这个值以来到现在，这个值是否发生过变化。例如，这个值假设从 A 变成了 B，再由 B 变回了 A，此时，它不仅可以认为发生了变化，而且变化了两次。\n\n解决 ABA 问题，可以在在变量值自身之外，再添加一个版本号，通过对比版本号来判断值是否变化过。\n\n#### 自旋时间过长\n\n由于单次 CAS 不一定能执行成功，所以 CAS 往往是配合着循环来实现的。在高并发场景下有的时候甚至是死循环，不停地进行重试，直到线程竞争不激烈的时候，才能修改成功。\n\n因此要根据实际情况来选择是否使用 CAS，在高并发的场景下，通常 CAS 的效率是不高的。\n\n#### 范围不能灵活控制\n\n通常执行 CAS 的时候，是针对某一个而不是多个共享变量的，这个变量可能是 Integer 类型，也有可能是 Long 类型、对象类型等，但是不能针对多个共享变量同时进行 CAS 操作，因为这多个变量之间是独立的，简单的把原子操作组合到一起，并不具备原子性。因此如果想对多个对象同时进行 CAS 操作并想保证线程安全的话，是比较困难的。\n\n有一个解决方案，那就是利用一个新的类，来整合刚才这一组共享变量，这个新的类中的多个成员变量就是刚才的那多个共享变量，然后再利用 atomic 包中的 AtomicReference 来把这个新对象整体进行 CAS 操作，这样就可以保证线程安全。\n\n相比之下，如果使用 synchronized 关键字则会比较方便。\n\n# AQS\n\n### 介绍\n\n队列同步器 AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个 int 类型的 state 变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的 ReentrantLock、Semaphore、CountDownLatch 和 CyclicBarrior 等。\n\n同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系：\n\n锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；\n\n同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。\n\n实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/CAS-AQS/clipboard_20230323_101329.png)\n\n### 使用及原理\n\n如果想使用 AQS 来写一个自己的线程协作工具类，通常而言是分为以下三步，这也是 JDK 里利用 AQS 类的主要步骤：\n\n1. 新建一个自己的线程协作工具类，在内部写一个 Sync 类，该 Sync 类继承 AbstractQueuedSynchronizer，即 AQS；\n2. 想好设计的线程协作工具类的协作逻辑，在 Sync 类里，根据是否是独占，来重写对应的方法。如果是独占，则重写 tryAcquire 和 tryRelease 等方法；如果是非独占，则重写 tryAcquireShared 和 tryReleaseShared 等方法；\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/CAS-AQS/clipboard_20230323_101333.png)\n3. 在自己的线程协作工具类中，实现获取/释放的相关方法，并在里面调用 AQS 对应的方法，如果是独占则调用 acquire 或 release 等方法，非独占则调用 acquireShared 或 releaseShared 或 acquireSharedInterruptibly 等方法。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/CAS-AQS/clipboard_20230323_101337.png)\n\nAQS 最核心的三大部分就是状态（state）、FIFO 等待队列和期望协作工具类去实现的获取）/释放等重要方法。\n\n#### state\n\nstate 的含义并不是一成不变的，它会根据具体实现类的作用不同而表示不同的含义。比如说在 Semaphore 中，state 表示的是剩余许可证的数量；在 CountDownLatch 工具类里面，state 表示的是需要“倒数”的数量。他的定义如下：\n\n```java\n/**\n * The synchronization state.\n */\nprivate volatile int state;\n```\n\nstate 的访问方式有三种：\n\n- getState()：获取当前同步状态。\n- setState(int newState)：设置当前同步状态，volatile 保证了它的多线程状态下的可见性。\n- compareAndSetState(int expect, int update)：使用 CAS 设置当前状态，保证状态设置的原子性。\n\n#### FIFO 队列\n\n即先进先出队列，这个队列最主要的作用是存储等待的线程。假设很多线程都想要同时抢锁，那么大部分的线程是抢不到的，那怎么去处理这些抢不到锁的线程呢？就得需要有一个队列来存放、管理它们。所以 AQS 的一大功能就是充当线程的“排队管理器”。\n\n当多个线程去竞争同一把锁的时候，就需要用排队机制把那些没能拿到锁的线程串在一起；而当前面的线程释放锁之后，这个管理器就会挑选一个合适的线程来尝试抢刚刚释放的那把锁。所以 AQS 就一直在维护这个队列，并把等待的线程都放到队列里面。\n\n在队列中，分别用 head 和 tail 来表示头节点和尾节点，两者在初始化的时候都指向了一个空节点。头节点可以理解为“当前持有锁的线程”，而在头节点之后的线程就被阻塞了，它们会等待唤醒，唤醒也是由 AQS 负责操作的。\n\n#### 获取/释放方法\n\n##### \u003cstrong\u003e获取\u003c/strong\u003e\n\n获取操作通常会依赖 state 变量的值，根据 state 值不同，协作工具类也会有不同的逻辑，并且在获取的时候也经常会阻塞。\n\n比如 ReentrantLock 中的 lock 方法就是其中一个“获取方法”，执行时，如果发现 state 不等于 0 且当前线程不是持有锁的线程，那么就代表这个锁已经被其他线程所持有了。这个时候，当然就获取不到锁，于是就让该线程进入阻塞状态。\n\n再比如，Semaphore 中的 acquire 方法就是其中一个“获取方法”，作用是获取许可证，此时能不能获取到这个许可证也取决于 state 的值。如果 state 值是正数，那么代表还有剩余的许可证，数量足够的话，就可以成功获取；但如果 state 是 0，则代表已经没有更多的空余许可证了，此时这个线程就获取不到许可证，会进入阻塞状态，所以这里同样也是和 state 的值相关的。\n\n再举个例子，CountDownLatch 获取方法就是 await 方法（包含重载方法），作用是“等待，直到倒数结束”。执行 await 的时候会判断 state 的值，如果 state 不等于 0，线程就陷入阻塞状态，直到其他线程执行倒数方法把 state 减为 0，此时就代表现在这个门闩放开了，所以之前阻塞的线程就会被唤醒。\n\n##### \u003cstrong\u003e释放\u003c/strong\u003e\n\n释放方法是站在获取方法的对立面的，通常和刚才的获取方法配合使用。我们刚才讲的获取方法可能会让线程阻塞，比如说获取不到锁就会让线程进入阻塞状态，但是释放方法通常是不会阻塞线程的。\n\n比如在 Semaphore 信号量里面，释放就是 release 方法（包含重载方法），release() 方法的作用是去释放一个许可证，会让 state 加 1；而在 CountDownLatch 里面，释放就是 countDown 方法，作用是倒数一个数，让 state 减 1。所以也可以看出，在不同的实现类里面，他们对于 state 的操作是截然不同的，需要由每一个协作类根据自己的逻辑去具体实现。\n\n#### CountDownLatch 的实现\n\n```java\npublic class CountDownLatch {\n\n    public CountDownLatch(int count) {\n        if (count \u003c 0) throw new IllegalArgumentException(\"count \u003c 0\");\n        this.sync = new Sync(count);\n    }\n    \n    public void countDown() {\n        //AQS 类中的方法\n        sync.releaseShared(1);\n    }\n    \n    public void await() throws InterruptedException {\n        //AQS 类中的方法\n        sync.acquireSharedInterruptibly(1);\n    }\n    \n    private final Sync sync;\n   \n    private static final class Sync \n              extends AbstractQueuedSynchronizer {\n        Sync(int count) {\n            setState(count);\n        }\n\n        int getCount() {\n            return getState();\n        }\n\n        protected int tryAcquireShared(int acquires) {\n            return (getState() == 0) ? 1 : -1;\n        }\n\n        protected boolean tryReleaseShared(int releases) {\n            for (;;) {\n                int c = getState();\n                if (c == 0)\n                    return false;\n                int nextc = c-1;\n                if (compareAndSetState(c, nextc))\n                    return nextc == 0;\n            }\n        }\n\n       public final void acquireSharedInterruptibly(int arg) \n              throws InterruptedException {\n           if (Thread.interrupted())\n               throw new InterruptedException();\n           if (tryAcquireShared(arg) \u003c 0)\n               doAcquireSharedInterruptibly(arg);\n       }\n        \n        protected int tryAcquireShared(int acquires) {\n            return (getState() == 0) ? 1 : -1;\n        }\n    }\n    \n}\n```\n","lastmodified":"2023-03-23T02:32:34.058210059Z","tags":[]},"/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90":{"title":"HashMap 源码解析","content":"# 前言  \n  \nHashMap 是 Java 中最常用 K-V 容器，使用哈希值来确定元素存储的位置，HashMap 对 Entry 进行了扩展（Node），使其形成以链表或者树的形式存储在 HashMap 的容器里。  \n  \n在 Java 8 之前和之后，HashMap 的实现有较大的不同，因此对于 put 流程、扩容机制等主要过程分析将会采用两个版本进行对比。  \n  \n# 成员变量  \n  \nHashMap 成员变量和构造方法声明如下（Java 7 和 8 大致相同，以下为 Java 8 版本）：  \n  \n```java  \npublic class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e  \n  \n    implements Map\u003cK,V\u003e, Cloneable, Serializable {  \n\n    // 初始容量 16  \n    static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16  \n  \n    // 最大容量，该数组最大值为2^31一次方。  \n    static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30;  \n  \n    // 默认的加载因子，如果构造的时候不传则为 0.75  \n    static final float DEFAULT_LOAD_FACTOR = 0.75f;  \n  \n    // @1.8：数组某个位置下的 node 链表转化为红黑树对该链表的最小长度要求  \n    static final int TREEIFY_THRESHOLD = 8;  \n  \n    // @1.8：当一个反树化的阈值，当这个 node 长度减少到该值就会从树转化成链表  \n    static final int UNTREEIFY_THRESHOLD = 6;  \n  \n    // @1.8：数组某个位置下的 node 链表转化为红黑树对元素个数的最小要求  \n    static final int MIN_TREEIFY_CAPACITY = 64;  \n  \n    // 具体存放数据的数组  \n    transient Node\u003cK,V\u003e[] table;  \n  \n    // entrySet，一个存放 k-v 缓冲区  \n    transient Set\u003cMap.Entry\u003cK,V\u003e\u003e entrySet;  \n  \n    // 存放键值对的个数。  \n    transient int size;  \n  \n    // 记录更改 map 结构次数(添加、删除、扩容？)  \n    transient int modCount;  \n  \n    // 临界值，当实际大小(容量*填充因子)超过临界值时，会进行扩容  \n  \n    int threshold;  \n  \n    // 填充因子  \n    final float loadFactor;  \n  \n    // 指定初始容量  \n    public HashMap(int initialCapacity) {  \n        this(initialCapacity, DEFAULT_LOAD_FACTOR);  \n    }  \n\n    // 默认构造函数  \n    public HashMap() {  \n        // 默认 threshold 在首次 put 时才复制，Java 7 则是调用  \n        // this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR)  \n        this.loadFactor = DEFAULT_LOAD_FACTOR;   \n    }  \n\n    // 包含另一个 Map  \n    public HashMap(Map\u003c? extends K, ? extends V\u003e m) {  \n        this.loadFactor = DEFAULT_LOAD_FACTOR;  \n  \n        putMapEntries(m, false);  \n    }  \n\n    // 指定初始容量和填充因子  \n    public HashMap(int initialCapacity, float loadFactor) {  \n        if (initialCapacity \u003c 0) // 容量不能为负数  \n  \n            throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);  \n  \n        // 当容量大于 2^31 就取最大值 1\u003c\u003c30;   \n  \n        if (initialCapacity \u003e MAXIMUM_CAPACITY)  \n  \n            initialCapacity = MAXIMUM_CAPACITY;  \n  \n        if (loadFactor \u003c= 0 || Float.isNaN(loadFactor))  \n  \n            throw new IllegalArgumentException(\"Illegal load factor: \"                + loadFactor);  \n  \n        this.loadFactor = loadFactor;  \n  \n        // tableSizeFor 保证了数组长度一定是 2 的幂次方，是大于等于    initialCapacity 最接近的值。  \n        // 这里使用 threshold 暂时保存计算后的 initialCapacity 值  \n        this.threshold = tableSizeFor(initialCapacity);  \n  \n    }  \n    ...  \n}  \n```  \n  \n# 数据结构  \n  \nJava 7 采用数组 + 链表方式进行存储，元素类型为 Entry：  \n  \n```java  \nstatic class Entry\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {  \n  \n    final K key;  \n  \n    V value;  \n  \n    Entry\u003cK,V\u003e next;  \n  \n    int hash;  \n\n    ...  \n}  \n```  \n  \n元素的存储结构如下：  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_035018.png)\nJava 8 开始，采用数组 + 链表 + 红黑树方式进行存储，元素类型为 Node 和 TreeNode：  \n  \n```java  \nstatic class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {  \n  \n    final int hash;  \n  \n    final K key;  \n  \n    V value;  \n  \n    Node\u003cK,V\u003e next;  \n\n    ...  \n}  \n  \n  \n  \nstatic final class TreeNode\u003cK,V\u003e extends LinkedHashMap.Entry\u003cK,V\u003e {  \n  \n    TreeNode\u003cK,V\u003e parent;  // red-black tree links  \n  \n    TreeNode\u003cK,V\u003e left;  \n  \n    TreeNode\u003cK,V\u003e right;  \n  \n    TreeNode\u003cK,V\u003e prev;    // needed to unlink next upon deletion  \n  \n    boolean red;  \n    \n    ...  \n}  \n```  \n  \n元素的存储结构如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_041741.png)\n\n# put 流程分析  \n  \n## Java 7 put 流程  \n  \n### 代码分析  \n  \nJava 7 put 流程主要方法源码如下：  \n  \n```java  \npublic V put(K key, V value)  \n    if (table == EMPTY_TABLE) {  \n        // 初始化 table  \n        inflateTable(threshold);  \n    }  \n  \n    if (key == null) {  \n        // 在 table[0] 处插入 key 为 null 元素并返回  \n        return putForNullKey(value);  \n    }  \n  \n    // 先进行一次 hash 计算     \n    int hash = hash(key);  \n  \n    // 根据 hash 值计算 table 下标  \n    int i = indexFor(hash, table.length);  \n  \n    // 遍历 table[i] 处的链表  \n    for (Entry\u003cK,V\u003e e = table[i]; e != null; e = e.next) {  \n        Object k;  \n        // hash 一样且 key 相等或者 equals 方法返回 true 才进行替换  \n        if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) {  \n            V oldValue = e.value;  \n  \n            e.value = value;  \n  \n            e.recordAccess(this);  \n  \n            return oldValue;  \n        }  \n    }  \n    // 出循环意味着 table[i] 这条链表没有此元素  \n    // 更新 modCount  \n    modCount++;  \n    // 插入新元素  \n    addEntry(hash, key, value, i);  \n  \n    return null;  \n}  \n  \nprivate void inflateTable(int toSize) {  \n    // 获取大于  \n    int capacity = roundUpToPowerOf2(toSize);  \n    // 重新计算阈值  \n    threshold = (int) Math.min(capacity * loadFactor,   \n            MAXIMUM_CAPACITY + 1);  \n  \n    // 创建数组  \n    table = new Entry[capacity];  \n  \n    // 根据配置判断是否初始化 hashSeed  \n    initHashSeedAsNeeded(capacity);  \n}  \n  \nprivate V putForNullKey(V value) {  \n    // 最多循环一次，因为这个位置最多只有一个元素  \n    for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) {  \n        // key 为 null 直接替换  \n        if (e.key == null) {  \n            V oldValue = e.value;  \n            e.value = value;  \n            e.recordAccess(this);  \n  \n            return oldValue;  \n        }  \n    }  \n  \n    // 更新 modCount  \n    modCount++;  \n  \n    // 在 table[0] 处插入元素  \n    addEntry(0, null, value, 0);  \n  \n    return null;  \n}  \n  \nvoid addEntry(int hash, K key, V value, int bucketIndex) {  \n    // 元素数量达到临界值且 table[bucketIndex] 位置不为空才进行扩容  \n    if ((size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])) {  \n        // 两倍容量  \n        resize(2 * table.length);  \n  \n        // 重新计算 hash  \n        hash = (null != key) ? hash(key) : 0;  \n  \n        // 重新确定数组下标  \n        bucketIndex = indexFor(hash, table.length);  \n    }\n    // 创建并插入新元素  \n    createEntry(hash, key, value, bucketIndex);  \n}  \n  \n// 在链表头部插入新元素  \nvoid createEntry(int hash, K key, V value, int bucketIndex) {  \n    // 保存原头结点  \n    Entry\u003cK,V\u003e e = table[bucketIndex];  \n    // 创建新元素、把 next 指向头节点，并替换原来 bucketIndex 位置的链表  \n    table[bucketIndex] = new Entry\u003c\u003e(hash, key, value, e);  \n    // 元素数量++  \n    size++；  \n}  \n```  \n  \n### 流程图示  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040358.png)\n## Java 8 put 流程  \n  \n### 代码分析  \n  \nJava 8 put 流程主要方法源码如下：  \n  \n```java  \npublic V put(K key, V value) {  \n      // onlyIfAbsent 默认为 false，即元素存在时进行替换  \n    return putVal(hash(key), key, value, false, true);  \n}  \n  \nfinal V putVal(int hash, K key, V value,   \n          boolean onlyIfAbsent, boolean evict) {  \n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i;  \n  \n    // table 未初始化或者长度为 0，进行扩容  \n    if ((tab = table) == null || (n = tab.length) == 0)  \n        n = (tab = resize()).length;  \n  \n    // (n - 1) \u0026 hash 确定元素存放位置，位置为空则直接放入该位置  \n    if ((p = tab[i = (n - 1) \u0026 hash]) == null)  \n        tab[i] = newNode(hash, key, value, null);  \n  \n    // 数组对应位置已经存在元素  \n    else {  \n        Node\u003cK,V\u003e e; K k;  \n  \n        // 比较数组中第一个元素  \n        if (p.hash == hash \u0026\u0026  \n            ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n  \n                // 将第一个元素赋值给 e  \n                e = p;  \n        // 是否为红黑树结点  \n        else if (p instanceof TreeNode)  \n            // 放入树中  \n            e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab,   \n                        hash, key, value);  \n        // 链表结点  \n        else {  \n            // 遍历链表  \n            for (int binCount = 0; ; ++binCount) {  \n                // 到达链表的尾部，说明没有找到相等的 key  \n                if ((e = p.next) == null) {  \n                    // 在尾部插入新结点  \n                    p.next = newNode(hash, key, value, null);  \n  \n                    // 判断结点数量是否达到阈值(TREEIFY_THRESHOLD 默认为 8)  \n                    if (binCount \u003e= TREEIFY_THRESHOLD - 1) {  \n                        // 根据数组长度决定是否树化  \n                        treeifyBin(tab, hash);  \n                    }  \n  \n                    // 跳出循环  \n                    break;  \n                }  \n  \n                // 判断链表中结点的 key 值是否与插入的 key 相等  \n                if (e.hash == hash \u0026\u0026  \n                    ((k = e.key) == key ||   \n                          (key != null \u0026\u0026 key.equals(k))))  \n                    // key 相等，跳出循环，此时 e 就是目标结点  \n                    break;  \n  \n                // 与前面的 e = p.next 组合遍历链表  \n                p = e;  \n            }  \n        }  \n  \n        // 找到 key 值相等的目标结点  \n        if (e != null) {  \n  \n            V oldValue = e.value;  \n  \n            // onlyIfAbsent 为 false 或者目标接点值为 null  \n            if (!onlyIfAbsent || oldValue == null)  \n  \n                //用新值替换旧值  \n                e.value = value;  \n  \n            // 空实现，用于访问后回调给子类，如 LinkedHashMap  \n            afterNodeAccess(e);  \n  \n            // 返回旧值  \n            return oldValue;  \n        }  \n    }  \n  \n    // 结构修改，更新 modCount  \n    ++modCount;  \n  \n    // 实际大小大于阈值则扩容  \n    if (++size \u003e threshold)  \n        resize();  \n  \n    // 插入后回调  \n    afterNodeInsertion(evict);  \n  \n    return null;  \n}  \n```  \n  \n#### 流程图示  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040522.png)\n# hash 计算与元素位置确定  \n  \n## Java 7  \n  \n```java  \nint hash = hash(key);  \n  \nint i = indexFor(hash, table.length);  \n  \nfinal int hash(Object k) {  \n  \n    // 默认为 0，初始化方法见后文  \n    int h = hashSeed;  \n  \n    // 如果 hashSeed 不为零且 key 是 String 类型  \n    if (0 != h \u0026\u0026 k instanceof String) {  \n        // 返回特定 hash 值  \n        return sun.misc.Hashing.stringHash32((String) k);  \n    }  \n  \n    h ^= k.hashCode();  \n  \n    // 多次异或  \n    h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12);  \n  \n    return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4);  \n}  \n  \nstatic int indexFor(int h, int length) {  \n    // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";  \n    return h \u0026 (length-1);  \n}  \n```  \n  \n## Java 8  \n  \n```java  \npublic V put(K key, V value) {  \n    return putVal(hash(key), key, value, false, true);  \n}  \n\nstatic final int hash(Object key) {  \n    int h;  \n  \n    // 让高 16 位和低 16 位异或  \n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16);  \n}  \n\np = tab[index = (n - 1) \u0026 hash]；  \n```  \n  \n# 扩容流程  \n  \n扩容过程涉及到 rehash、复制数据等操作，非常消耗性能。  \n  \n和扩容相关的全局变量及其含义：  \n  \n| 全局变量   | 含义                                                                                                                                                                                                                                                                                                                                                                                                      |  \n| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |  \n| capacity   | table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。                                                                                                                                                                                                                                                                                                                               |  \n| size       | 存放键值对数量。                                                                                                                                                                                                                                                                                                                                                                                          |  \n| threshold  | size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。threshold = (int) (capacity * loadFactor)                                                                                                                                                                                                                                                                                                   |  \n| loadFactor | 填充因子，table 能够使用的比例。loadFactor 能够控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。\u003cbr/\u003eloadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。 |  \n  \n## Java 7 扩容流程  \n  \n### 代码分析  \n  \nJava 7 的 resize 方法相关代码：  \n  \n```java  \nvoid resize(int newCapacity) {  \n    Entry[] oldTable = table;  \n  \n    // 记录旧容量  \n    int oldCapacity = oldTable.length;  \n  \n    // 如果容量已达到上限，则扩容阈值设置成不可能达到的最大值，即后续不再扩容  \n    if (oldCapacity == MAXIMUM_CAPACITY) {  \n        threshold = Integer.MAX_VALUE;  \n  \n        return;  \n    }  \n  \n    // 根据新容量创建出新数组  \n    Entry[] newTable = new Entry[newCapacity];  \n  \n    // 将旧数组的节点转移到新数组  \n    transfer(newTable, initHashSeedAsNeeded(newCapacity));  \n  \n    // 新旧易主  \n    table = newTable;  \n  \n    // 根据新容量重新确定新阈值  \n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);  \n}  \n \n// 从配置中获取是否启用备用 hash，用于减少字符串 hash 冲突  \nfinal boolean initHashSeedAsNeeded(int capacity) {  \n    // 是否已经启用备用 hash  \n    boolean currentAltHashing = hashSeed != 0;  \n  \n    // 虚拟机已经启动且数组容量大于 ALTERNATIVE_HASHING_THRESHOLD  \n    boolean useAltHashing = sun.misc.VM.isBooted() \u0026\u0026  \n            (capacity \u003e= Holder.ALTERNATIVE_HASHING_THRESHOLD);  \n  \n    // 异或操作判断是否切换  \n    boolean switching = currentAltHashing ^ useAltHashing;  \n    if (switching) {  \n        // useAltHashing 为 true 则 hashSeed 初始化为也给随机 hash 值  \n        hashSeed = useAltHashing  \n            ? sun.misc.Hashing.randomHashSeed(this)  \n            : 0;  \n    }  \n    return switching;  \n}  \n\nvoid transfer(Entry[] newTable, boolean rehash) {  \n    int newCapacity = newTable.length;  \n  \n    // 遍历旧数组  \n    for (Entry\u003cK,V\u003e e : table) {  \n        // 遍历数组上的链表  \n        while(null != e) {  \n            // 记录下一个位置  \n            Entry\u003cK,V\u003e next = e.next;  \n  \n            // 判断是否重新计算 hash 值  \n            if (rehash) {  \n  \n                e.hash = null == e.key ? 0 : hash(e.key);  \n  \n            }  \n  \n            // 根据新容量重新计算位置  \n            int i = indexFor(e.hash, newCapacity);  \n  \n            // 按旧链表的正序遍历链表、在新链表的头部依次插入  \n            // 因此扩容后可能出现逆序  \n            e.next = newTable[i];  \n  \n            newTable[i] = e;  \n  \n            e = next;  \n        }  \n    }  \n}  \n```  \n  \n### 扩容流程在多线程环境下的隐患  \n  \n在 resize 扩容过程中，在将旧数组上的数据转移到新数组上时，转移数据操作是按旧链表的正序遍历链表、在新链表的头部依次插入的。在多线程的环境下，由于这些操作不具有原子性和内存可见性，转移数据、扩容后，容易出现环形链表的情况。  \n  \n## Java 8 扩容流程  \n  \n### 代码分析  \n  \nJava 8 中的 resize 和 treeifyBin 方法：  \n  \n```java  \nfinal void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) {  \n    int n, index; Node\u003cK,V\u003e e;  \n    // 如果数组为空或者数组长度小于 64，则进行扩容  \n    if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY)  \n        resize();  \n    // 根据 hash 获取数组下标，该位置有值再进行树化  \n    else if ((e = tab[index = (n - 1) \u0026 hash]) != null) {  \n        TreeNode\u003cK,V\u003e hd = null, tl = null;  \n        // 遍历链表  \n        do {  \n            // Node 节点转换成 TreeNode 节点  \n            TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null);  \n  \n            if (tl == null)  \n                hd = p;  \n            else {  \n                p.prev = tl;  \n  \n                tl.next = p;  \n            }  \n  \n            tl = p;  \n        } while ((e = e.next) != null);  \n        \n        if ((tab[index] = hd) != null)  \n            hd.treeify(tab);  \n    }  \n}  \n\nfinal Node\u003cK,V\u003e[] resize() {  \n  \n    Node\u003cK,V\u003e[] oldTab = table;  \n  \n    int oldCap = (oldTab == null) ? 0 : oldTab.length;  \n  \n    int oldThr = threshold;  \n  \n    int newCap, newThr = 0;  \n  \n    if (oldCap \u003e 0) {  \n        // 超过最大值后续不再扩容  \n        if (oldCap \u003e= MAXIMUM_CAPACITY) {  \n            threshold = Integer.MAX_VALUE;  \n            return oldTab;  \n        }  \n  \n        // 否则扩充为原来的2倍  \n        else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 oldCap \u003e= DEFAULT_INITIAL_CAPACITY)  \n            newThr = oldThr \u003c\u003c 1; // double threshold  \n    }  \n  \n    else if (oldThr \u003e 0) // initial capacity was placed in threshold  \n        newCap = oldThr;  \n    else {  \n        // signifies using defaults  \n        newCap = DEFAULT_INITIAL_CAPACITY;  \n  \n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  \n    }  \n  \n    // 计算新的 resize 上限  \n  \n    if (newThr == 0) {  \n        float ft = (float)newCap * loadFactor;  \n        newThr = (newCap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);  \n    }  \n  \n    threshold = newThr;  \n  \n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})  \n  \n    Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap];  \n  \n    table = newTab;  \n\n    if (oldTab != null) {  \n        // 旧数组迁移至新数组  \n        for (int j = 0; j \u003c oldCap; ++j) {  \n            Node\u003cK,V\u003e e;  \n            if ((e = oldTab[j]) != null) {  \n                oldTab[j] = null;  \n                if (e.next == null)  \n                    newTab[e.hash \u0026 (newCap - 1)] = e;  \n                else if (e instanceof TreeNode)  \n                    ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap);  \n                else {  \n                    Node\u003cK,V\u003e loHead = null, loTail = null;  \n                    Node\u003cK,V\u003e hiHead = null, hiTail = null;  \n                    Node\u003cK,V\u003e next;  \n                    do {  \n                        next = e.next;  \n                        // 原索引  \n                        if ((e.hash \u0026 oldCap) == 0) {  \n                            if (loTail == null)  \n                                loHead = e;  \n                            else  \n                                loTail.next = e;  \n                            loTail = e;  \n                        }  \n  \n                        // 原索引+oldCap  \n                        else {  \n                            if (hiTail == null)  \n                                hiHead = e;  \n                            else  \n                                hiTail.next = e;  \n                            hiTail = e;  \n                        }  \n                    } while ((e = next) != null);  \n  \n                    // 原索引元素放到新数组中  \n                    if (loTail != null) {  \n                        loTail.next = null;  \n                        newTab[j] = loHead;  \n                    }  \n  \n                    // 原索引 +oldCap 元素放到新数组中  \n                    if (hiTail != null) {  \n                        hiTail.next = null;  \n                        newTab[j + oldCap] = hiHead;  \n                    }  \n                }  \n            }  \n        }  \n    }  \n    return newTab;  \n}  \n```  \n  \nresize 方法中的前半段，关于 newCap 和 newThr 的计算过程，简化后如下：  \n  \n```java  \nif (oldCap \u003e 0) {  \n    // 嵌套条件分支  \n    if (oldCap \u003e= MAXIMUM_CAPACITY) {...}  \n    else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026  \n                 oldCap \u003e= DEFAULT_INITIAL_CAPACITY) {...}  \n}   \nelse if (oldThr \u003e 0) {...}  \n  \nelse {...}  \n```  \n  \n这些判断分别对应以下几种条件：  \n  \n| 条件                       | 覆盖情况                            | 备注                                                                                                                         |  \n| -------------------------- | ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |  \n| oldCap \u003e 0                 | 桶数组 table 已经被初始化           |                                                                                                                              |  \n| oldThr \u003e 0                 | threshold \u003e 0，且桶数组未被初始化   | 调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况，此种情况下 newCap = oldThr，newThr 在第二个条件分支中算出 |  \n| oldCap == 0 \u0026\u0026 oldThr == 0 | 桶数组未被初始化，且 threshold 为 0 | 调用 HashMap() 构造方法会产生这种情况。                                                                                      |  \n  \noldCap \u003e 0 时表示 table 数组已经被初始化过，这时需要再次计算容量和阈值：  \n  \n| 条件                        | 覆盖情况                                      | 备注                                                      |  \n| --------------------------- | --------------------------------------------- | --------------------------------------------------------- |  \n| oldCap \u003e= 230               | 桶数组容量大于或等于最大桶容量 230            | 后续不再扩容                                              |  \n| newCap \u003c 230 \u0026\u0026 oldCap \u003e 16 | 新桶数组容量小于最大值，且旧桶数组容量大于 16 | 该种情况下新阈值 newThr = oldThr \u003c\u003c 1，移位可能会导致溢出 |  \n  \nresize 方法后续过程中可以看出，Java 8 转移数据操作是按旧链表的正序遍历链表、在新链表的尾部依次插入的，所以不会出现链表 逆序、倒置的情况，故不容易出现环形链表的情况。但仍然还是线程不安全，因为没有加同步锁保护。  \n  \n## 扩容流程对比  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040805.png)\n# get 流程分析  \n  \n## Java 7\n  \n```java  \npublic V get(Object key) {  \n    if (key == null)  \n        return getForNullKey();  \n    Entry\u003cK,V\u003e entry = getEntry(key);  \n    return null == entry ? null : entry.getValue();  \n}  \n  \nprivate V getForNullKey() {  \n    if (size == 0) {  \n        return null;  \n    }  \n  \n    // 下标为 0 处获取 key 为 null 的元素  \n    for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) {  \n        if (e.key == null)  \n            return e.value;  \n    }  \n    return null;  \n}  \n\nfinal Entry\u003cK,V\u003e getEntry(Object key) {  \n    if (size == 0) {  \n        return null;  \n    }  \n  \n    int hash = (key == null) ? 0 : hash(key);  \n    for (Entry\u003cK,V\u003e e = table[indexFor(hash, table.length)];  \n             e != null; e = e.next) {  \n        Object k;  \n        if (e.hash == hash \u0026\u0026  \n            ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n            return e;  \n    }  \n    return null;  \n}  \n```  \n  \n## Java 8\n  \n```java  \npublic V get(Object key) {  \n    Node\u003cK,V\u003e e;  \n    return (e = getNode(hash(key), key)) == null ? null : e.value;  \n}  \n\nfinal Node\u003cK,V\u003e getNode(int hash, Object key) {  \n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n; K k;  \n    if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026  \n        (first = tab[(n - 1) \u0026 hash]) != null) {  \n        // 先判断 tab[index] 中的第一个元素  \n        if (first.hash == hash \u0026\u0026 // always check first node  \n            ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n            return first;  \n        if ((e = first.next) != null) {  \n            // 结点为红黑树则使用 TreeNode 的方法获取  \n            if (first instanceof TreeNode)  \n                return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key);  \n            do { //否则遍历链表  \n                if (e.hash == hash \u0026\u0026  \n                    ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n                    return e;  \n            } while ((e = e.next) != null);  \n        }  \n    }  \n    return null;  \n}  \n```  \n  \n遍历方式  \n  \n```java  \nMap\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e() {{  \n    put(\"a\", 10);  \n    put(\"b\", 20);  \n}};  \n  \n// 方式一：迭代 entrySet  \n  \nfor (Map.Entry\u003cString, Integer\u003e entry : map.entrySet()) {  \n    String key = entry.getKey();  \n    int value = entry.getValue();  \n}  \n\n// 方式二：单独迭代 keySet 或 values  \n// 迭代键  \nfor (String key : map.keySet()) {  \n    System.out.println(\"Key = \" + key);  \n}  \n  \n// 迭代值  \nfor (Integer value : map.values()) {  \n    System.out.println(\"Value = \" + value);  \n}  \n\n// 方式三：使用 iterator  \n  \nIterator\u003cMap.Entry\u003cString, Integer\u003e\u003e entries =         \n          map.entrySet().iterator();  \n  \nwhile (entries.hasNext()) {  \n    Map.Entry\u003cString, Integer\u003e entry = entries.next();  \n    String key = entry.getKey();  \n    int value = entry.getValue();  \n}  \n\n// 方式四：Lambda 表达式  \nmap.forEach((k, v) -\u003e System.out.println(\"key: \" + k + \" value:\" + v));  \n```  \n  \n# 面试题  \n  \n## 为什么 HashMap 数组长度为 2 的幂次方？  \n  \n如果数组中 hash 冲突太过频繁，某些位置的元素形成过长的链表，就会导致数据存取效率过低，因此要使元素均匀地分布在数组中，hash 碰撞就不能太频繁。而 hash 值范围为 -2147483648 到 2147483647，如果用如此长的数组来进行存放加上合理 hash 映射确实可以使 hash 碰撞降到很低的水平，但这明显是不现实的。  \n  \n因此这个 hash 值是不能直接使用的，首先需要进行二次 hash 使得结果更加随机，这时理论上可以使用 hash % length 得到一个不小于数组长度 length 的 index 值，这样不但能避免产生数组越界，并且可以使元素均匀分布，事实上很多 hash 算法都是采用该方法。但是在计算机中，% 取模运算比位 \u0026 运算的效率要低得多，而当 length 为 2 的幂次方时，hash % length 刚好等于 hash \u0026 (length - 1) ，从而能够将 % 运算转换成 \u0026 运算，更加快速地得到 index 值。  \n  \n因此采用 2 的幂次方作为数组的长度的好处是：使元素均匀分部以降低 hash 冲突的基础上，大大加快了计算元素所在数组位置的速度。  \n  \n## hash 冲突有哪些解决方法？HashMap 是怎样解决的？  \n  \n1. 二次 hash，通过高 16 位与低 16 位异或运算，使得结果更加随机；  \n2. 拉链地址法，将 hash 值相同的元素串成一个链表或者转为红黑树。  \n  \n## HashMap 会造成哪些安全问题？怎么解决？  \n  \n如前面文章所述，在 Java 7 中，HashMap 在扩容的时候是通过遍历旧数组，然后在新数组中使用头插法进行转移元素的。这在单线程环境中是没有问题的，但是到了多线程环境下，由于 JMM 的特性，会以一定的概率形成环形链表的情况。在 Java 8 中这个问题通过使用尾插法得到解决，但是多线程下很多操作仍然会导致线程安全问题，比如多个线程 put 后某些元素丢失等。因此多线程环境下要保证线程安全，可以使用 ConcurentHashMap 代替 HashMap。  \n  \n## 使用对象作为 HashMap 的 key 应该注意什么？  \n  \n应当重写对象的 hashCode() 和 equals() 方法。如前面代码所示，HashMap 在 put 一个元素的时候，会调用此元素的 key 值的 hashCode 方法确定元素存放位置，并且会调用 hashCode 和 equals 方法判断元素是否相等。因此如果没有重写这两个方法，或者方法重写的时候没有遵守规则，HashMap 通过 put 存入一组元素后，再通过此元素的 key 值去 get 对象的时候就有可能出现跟预期结果不一致的情况。  \n  \n在重写 equals 方法的时候，需要遵守下面的通用约定：  \n  \n- \u003cstrong\u003e自反性\u003c/strong\u003e：对于任何非空引用 x，x.equals(x) 必须返回 true；  \n- \u003cstrong\u003e对称性\u003c/strong\u003e：对于任何非空引用 x 和 y，如果且仅当 y.equals(x) 返回 true 时 x.equals(y) 必须返回 true；  \n- \u003cstrong\u003e传递性\u003c/strong\u003e：对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 必须返回 true；  \n- \u003cstrong\u003e一致性\u003c/strong\u003e：对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 x.equals(y) 的多次调用必须始终返回 true 或始终返回 false；  \n- \u003cstrong\u003e非空性\u003c/strong\u003e：对于任何非空引用 x，x.equals(null) 必须返回 false。  \n  \n\u003cstrong\u003e重写 hashCode 方法的大致方式（非强制）：\u003c/strong\u003e  \n  \n1. 把某个非零常数值，比如说 31（最好是素数，考虑到 HashMap 源码中的异或操作），保存在一个叫 result 的 int 类型的变量中。  \n2. 对于对象中每一个关键域 f（值 equals 方法中考虑的每一个域），完成以下步骤：  \n3. 为该域计算 int 类型的散列码 c:  \n  \n```  \n1. 如果该域是 boolean 类型，则计算 (f?0:1)  \n  \n2. 如果该域是 byte、char、short 或者 int 类型，则计算 (int)f  \n  \n3. 如果该域是 float 类型，则计算 Float.floatToIntBits(f)  \n  \n4. 如果该域是 long 类型，则计算 (int)(f ^ (f\u003e\u003e\u003e32))  \n  \n5. 如果该域是double类型，则计算 Double.doubleToLongBits(f) 得到一个 long 类型的值，然后按照步骤 4，对该 long 型值计算散列值  \n  \n6. 如果该域是一个对象引用，并且该类的 equals 方法通过递归调用 equals 的方式来比较这个域，则同样对这个对象递归调用 hashCode 方法。  \n  \n7. 如果该域是一个数组，则把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤下面的做法把这些散列值组合起来。  \n```  \n  \n2. 按照下面的公式，把步骤 1 中计算得到的散列码 c 组合到 result 中：result = 31 x result+c。  \n3. 返回 result。  \n4. 写完 hashCode 方法之后，确认是否相等的实例具有相等的散列码。如果不是的话，找出原因，并修改。  \n  \n样例：  \n```java  \npublic class Student {  \n  \n    private String name;  \n  \n    private int age;  \n  \n    private Grades grades;  \n  \n    public Student(String name, int age, Grades grades) {  \n        this.name = name;  \n        this.age = age;  \n        this.grades = grades;  \n    }  \n\n    @Override  \n    public int hashCode() {  \n        final int prime = 31;  \n        int result = 1;  \n        \n        result = prime * result + age;  \n        result = prime * result +  \n                ((name == null) ? 0 : name.hashCode());  \n        result = prime * result +  \n                (grades == null ? 0 : grades.hashCode());  \n  \n        return result;  \n    }  \n  \n    @Override  \n    public boolean equals(Object obj) {  \n        if (this == obj) return true;  \n  \n        if (obj == null || getClass() != obj.getClass()) return false;  \n  \n        Student other = (Student) obj;  \n  \n        if (age != other.age) return false;  \n  \n        if (name != null ? !name.equals(other.name) :   \n              other.name != null) return false;  \n  \n        if (grades != null ? !grades.equals(other.grades) :           \n              other.grades != null) return false;  \n  \n        return true;  \n    }  \n}  \n```","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["HashMap","源码解析","Java"]},"/IO":{"title":"IO","content":"","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["Java","IO"]},"/Index-for-Atlases":{"title":"Untitled Page","content":"---\ndate created: 2022-06-22\ndate modified: 2022-08-20\ntags: dataview\ntitle: \"Index for Atlases\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n```dataviewjs\n// 获取当前文件所在的文件夹\nconst currentFolder = dv.current().file.folder\n// 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息\nconst groups =  dv.pages(`\"${currentFolder}\"`).groupBy(p =\u003e p.file.folder)\nfor (let group of groups) {\n\tdv.header(4, group.key);\n\tdv.table([\"Name\",\"标签\",\"入链\", \"创建日期\", \"修改日期\"],\n\t\tgroup.rows\n\t\t\t.sort(k =\u003e k.file.name, 'asc')\n\t\t\t.map(k =\u003e [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday]))\n}\n```\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":[]},"/Index-for-Extras":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: dataview\ntitle: \"Index for Extras\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n```dataviewjs\n// 获取当前文件所在的文件夹\nconst currentFolder = dv.current().file.folder\n// 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息\nconst groups =  dv.pages(`\"${currentFolder}\"`).groupBy(p =\u003e p.file.folder)\nfor (let group of groups) {\n\tdv.header(4, group.key);\n\tdv.table([\"Name\",\"标签\",\"入链\", \"创建日期\", \"修改日期\"],\n\t\tgroup.rows\n\t\t\t.sort(k =\u003e k.file.name, 'asc')\n\t\t\t.map(k =\u003e [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday]))\n}\n```\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":[]},"/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6":{"title":"JVM 中的对象和垃圾回收","content":"\n# 虚拟机中的对象\n\n了解了 JVM 运行时数据区域之后，大致明白了 JVM 内存模型的概况，对内存中的存放内容也有了初步了解。更进一步地，如果要了解内存中的数据的创建过程、在内存中如何布局、以及访问方式等，就必须要把范围限定到具体的虚拟机类型和集中在某一个内存区域上才有意义。下面以最常用的 HotSpot 虚拟机和最常用的内存区域 Java 堆为例，深入探索对象分配、布局和访问过程。\n\n## 对象的创建\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123009.png)\n\n虚拟机遇到一条 new 指令时，首先检查是否被类加载器加载，如果没有，则必须先执行相应的类加载过程。类加载就是把 class 加载到 JVM 的运行时数据区的过程。\n\n### \u003cstrong\u003e1、检查加载\u003c/strong\u003e\n\n首先检查这个指令的参数是否能在常量池中定位到一个类的\u003cstrong\u003e符号引用\u003c/strong\u003e（以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。\n\n### \u003cstrong\u003e2、分配内存\u003c/strong\u003e\n\n如果上一步检查加载成功，接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。\n\n分配内存主要有两种方式\n\n#### \u003cstrong\u003e指针碰撞\u003c/strong\u003e\n\n如果 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“\u003cstrong\u003e指针碰撞\u003c/strong\u003e”。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123013.png)\n\n#### \u003cstrong\u003e空闲列表\u003c/strong\u003e\n\n如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“\u003cstrong\u003e空闲列表\u003c/strong\u003e”。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123019.png)\n\n选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n\n如果是 Serial、ParNew 等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞的方式，既简单又高效。\n\n如果是使用 CMS 这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。\n\n#### \u003cstrong\u003e内存分配的并发安全问题\u003c/strong\u003e\n\n除如何划分可用空间之外，还有另外一个需要考虑的问题是：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的。\n\n解决方案有以下两种：\n\n\u003cstrong\u003eCAS 机制\u003c/strong\u003e\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123025.png)\n\n对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。虽然这种方式解决了并发问题，但是我们不难发现，这种方式增加了复杂度，降低了内存的分配的功效性。\n\n\u003cstrong\u003e分配缓冲\u003c/strong\u003e\n\n另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer, 简称 TLAB）。JVM 在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个 Buffer，如果需要分配内存，就在自己的 Buffer 上分配，这样就不存在竞争的情况，可以大大提升分配效率，当 Buffer 容量不够的时候，再重新从 Eden 区域申请一块继续使用。\n\nTLAB 的目的是在为新对象分配内存空间时，让每个 Java 应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。\n\nTLAB 只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个 TLAB 用满（分配指针 top 撞上分配极限 end 时），就新申请一个 TLAB。\n\n分配缓冲较 CAS 机制少了比较、预处理，失败重试步骤，极其高效，所以我们一般使用 TLAB 方式，JVM 默认也是此方式。要禁用 TLAB，需指定 -XX:-UseTLAB。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123030.png)\n\n### \u003cstrong\u003e3、内存空间初始化\u003c/strong\u003e\n\n内存分配完成后，虚拟机需要将分配到的内存空间（不包括对相投）都初始化为零值（如 int 值为 0，boolean 值为 false 等等）。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n\n\u003cstrong\u003e注意：此过程没有调用构造方法！\u003c/strong\u003e\n\n### \u003cstrong\u003e4、设置\u003c/strong\u003e\n\n接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes 在 Java hotspot VM 内部表示为类元数据）、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头之中。\n\n### \u003cstrong\u003e5、对象初始化\u003c/strong\u003e\n\n在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但从 Java 程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行 new 指令之后会接着把对象按照程序员的意愿进行初始化(构造方法)，这样一个真正可用的对象才算完全产生出来。\n\n## 对象内存布局\n\n在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。\n\n对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。\n\n对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n\n如果对象是一个 Java 数组，那么在对象头中还有一块用于记录数组长度的数据。\n\n第三部分对齐填充并不是必须的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot 的自动内存管理系统要求对对象的大小必须是 8 字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。数据对齐的作用就是\u003cstrong\u003e方便进行垃圾回收\u003c/strong\u003e。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123035.png)\n\n## 对象访问定位\n\n建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。\n\n### \u003cstrong\u003e句柄\u003c/strong\u003e\n\nJava 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123040.png)\n\n- \u003cstrong\u003e优点：\u003c/strong\u003ereference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改.\n- \u003cstrong\u003e缺点：\u003c/strong\u003e需要在堆中维护一个句柄池，而且由于中间多了个句柄池引用过程也多了一个步骤，执行效率受到影响。\n\n### \u003cstrong\u003e直接指针\u003c/strong\u003e\n\n如果使用直接指针访问， reference 中存储的直接就是对象地址。\n\n这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。\n\n使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123100.png)\n\n对 HotSpot 而言，它是使用直接指针访问方式进行对象访问的。\n\n# 垃圾收集\n\n## 判断对象存活\n\n在堆里面存放着几乎所有的对象实例，垃圾回收器在对进行回收前，要做的事情就是确定这些对象中哪些还是“存活”着，哪些已经“死去”（死去代表着不可能再被任何途径使用得对象了）。JVM 中有两种算法判断对象的存活。\n\n### 引用计数法\n\n在对象中添加一个引用计数器，每当有一个地方引用他时，计数器的值就加一；当引用失效时，计数器的值就减一，任何时刻计数器为零的对象就是不可能再被使用的。\n\n优点：原理简单、判断效率高\n\n缺点：必须要配合大量的额外处理才能保证正确的工作，如单纯的引用计数法很难解决对象之间相互循环引用的问题。\n\n主流的 Java 虚拟机没有采用引用计数法管理内存。\n\n### 引用链法（可达性分析法）\n\n#### 可达性分析\n\n通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的说法就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。\n\n主流的商用程序（Java、C#）的内存管理子系统都是通过可达性（Reachability Analysis）分析算法来判断对象是否存活。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123106.png)\n\n#### GC Roots 分类\n\n作为 GC Roots 的对象包括下面几种（重点是前面 4 种）：\n\n\u003cstrong\u003e1、虚拟机栈（栈帧中的本地变量表）中引用的对象。比如各个现场被调用方法堆栈中使用到的参数、局部变量、临时变量等。\u003c/strong\u003e\n\n\u003cstrong\u003e2、方法区中类静态属性引用的对象。比如 Java 类的引用类型静态变量。\u003c/strong\u003e\n\n\u003cstrong\u003e3、方法区中常量引用的对象。比如字符串常量池里的引用。\u003c/strong\u003e\n\n\u003cstrong\u003e4、本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。\u003c/strong\u003e\n\n5、JVM 的内部引用（class 对象、异常对象 NullPointException、OutofMemoryError，系统类加载器）。\n\n6、所有被同步锁（synchronized）持有的对象。\n\n7、JVM 内部的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。\n\n8、JVM 实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收只回收部分代的对象，这个后续会细讲，先大致了解概念）。\n\n#### 决定对象是否死亡\n\n- 可达性分析仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡\n- 当在可达性分析 中判断不可达的对象，只是“被判刑”= 还没真正死亡\n- 不可达对象会被放在”即将回收“的集合里\n- 要判断一个对象真正死亡，还需要经历两个阶段：\n\n##### \u003cstrong\u003e第一次标记 \u0026 筛选\u003c/strong\u003e\n\n如果一个对象在可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。如果对象没有覆盖 finalize() 方法或者 finalize() 方法已被虚拟机调用过，那么虚拟机都将视为“没有必要执行”，这时对象将被继续留在“即将回收”集合。\n\n##### \u003cstrong\u003e第二次标记 \u0026 筛选\u003c/strong\u003e\n\n如果这个对象被判断为有必要执行 finalize() 方法，那么该对象就会被放到 F-Queue 中，稍后收集器将对 F-Queue 中的对象进行小规模标记。在执行 finalize() 过程中，如果对象重新与引用链上的任意一个对象建立关系，那么第二次标记的时候就会被移除“即将回收”的集合。\n\n经过上面两次标记 \u0026 筛选，仍然留在“即将回收”集合里的对象将会在 GC 到来的时候被回收。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123112.png)\n\n\u003cstrong\u003e尽量不要依赖 finalize，因为这个方法太不可靠，在生产中很难控制方法的执行或者对象的调用顺序。可以忽略 finalize 方法，因为在 finalize 方法能做的工作，Java 中有更好的方式，比如 try-finally。\u003c/strong\u003e\n\n## 引用类型\n\nJava 中一共有四种引用，分别为强引用、弱引用、软引用和虚引用。\n\n### \u003cstrong\u003e强引用\u003c/strong\u003e\n\n一般的 Object obj = new Object() 就属于强引用。在任何情况下，只要有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n### \u003cstrong\u003e软引用 SoftReference\u003c/strong\u003e\n\n如果内存空间足够，垃圾回收器就不会回收它，\u003cstrong\u003e如果内存空间不足了，就会回收这些对象的内存\u003c/strong\u003e。只要垃圾回收器没有回收它，该对象就可以被程序使用。\n\n软引用可用来实现内存敏感的高速缓存。例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。\n\n### \u003cstrong\u003e弱引用 WeakReference\u003c/strong\u003e\n\n弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，\u003cstrong\u003e不管当前内存空间足够与否，都会回收它的内存\u003c/strong\u003e。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e软引用和弱引用可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。\n\n实际运用（WeakHashMap、ThreadLocal）\n\n### \u003cstrong\u003e虚引用 PhantomReference\u003c/strong\u003e\n\n幽灵引用，最弱（随时会被回收掉）。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。唯一的作用就是垃圾回收的时候收到一个通知，可以用来监控垃圾回收器是否正常工作。\n\n## 垃圾收集算法\n\n#### 分代收集理论\n\n当前虚拟机的垃圾收集器大多数都采用分代收集的理论进行设计，分代收集名为理论，实质事一套符合大多数程序运行实际情况的经验法则，，它建立在两个分代假说之上：\n\n1. 弱分代假说：绝大多数对象都是朝生夕灭的。\n2. 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。\n\n这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（即熬过垃圾收集过程的次数）分配到不同区域中存储。\n\n在 Java 堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型划分；也才能够针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出“标记 - 复制算法”“标记 - 清除算法”和“标记 - 整理算法”等针对性的垃圾收集算法。\n\n一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123124.png)\n\n- 新生代：复制算法。每次收集都会有大量对象死去，复制算法只需要付出少量对象的复制成本就可以完成每次垃圾收集。当年轻代中的 Eden 区分配满的时候，就会触发年轻代的 GC（Minor GC）。具体过程如下：\n\n  - 在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区（From 区）；\n  - Eden 区再次 GC，这时会采用复制算法，将 Eden 和 From 区一起清理。存活的对象会被复制到 To 区；接下来，只需要清空 From 区就可以了。\n  - 所以在这个过程中，总会有一个 Survivor 分区是空置的。Eden、From、To 的默认比例是 8:1:1，所以只会造成 10% 的空间浪费。\n- 老年代：标记 - 清除或者标记 - 整理算法。老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保。对象进入老年代有多个途径：\n\n（1）提升（Promotion）\n\n每当发生一次 Minor GC，存活下来的对象年龄（对象头中纪录）都会加 1。直到达到一定的阈值，就会把这些“老年”对象给提升到老年代。\n\n这些对象如果变的不可达，直到老年代发生 GC 的时候，才会被清理掉。\n\n这个阈值，可以通过参数 ‐XX:+MaxTenuringThreshold 进行配置，最大值是 15，因为它是用 4bit 存储的。\n\n（2）空间分配担保\n\nGC 过程每次存活的对象，都会放入其中一个 Survivor 区，这个区域默认的比例是 10%。但是无法保证每次存活的对象都小于 10%，当 Survivor 空间不够，就需要依赖其他内存（指老年代）进行分配担保。这个时候，对象也会直接在老年代上分配。\n\n（3）大对象直接在老年代分配\n\n超出某个大小的对象将直接在老年代分配。这个值是通过参数 -XX:PretenureSizeThreshold 进行配置的。默认为 0，意思是全部首选 Eden 区进行分配。\n\n（4）动态对象年龄判定\n\n有的垃圾回收算法，并不要求 age 必须达到 15 才能晋升到老年代，它会使用一些动态的计算方法。比如，从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 将作为新的阈值，年龄大于此阈值的对象直接进入老年代。\n\n#### 垃圾回收类型介绍\n\n- 部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：\n\n  - 新生代收集（Minor GC/Young GC）：目标只是新生代的垃圾收集。\n  - 老年代收集（Major GC/Old GC）：目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独回收老年代的行为。\n  - 混合收集（Mixed GC）：指目标是收集整个新生代及老年代的垃圾收集。目前只有 G1 收集器有这种行为。\n- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。\n\n#### 标记 - 清除\n\n在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。\n\n在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。\n\n在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123130.png)\n\n不足：\n\n- 标记和清除过程效率都不高；\n- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。\n\n#### 标记 - 复制\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123135.png)\n\n将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。\n\n主要不足是只使用了内存的一半空间。\n\n现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间（分别叫做 From 和 To，也可以叫做 Survivor0 和 Survivor1 ），每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。\n\nHotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。\n\n#### 标记 - 整理\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_1231340.png)\n\n标记的过程与“标记 - 清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n优点:\n\n- 不会产生内存碎片\n\n不足:\n\n- 需要移动大量对象，处理效率比较低。\n\n## 经典垃圾收集器\n\n如果说垃圾收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。《Java 虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器都有可能会有很大的差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123145.png)\n\n以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。它们之间涉及到的某些概念，在谈论垃圾收集器的上下文语境中，可以有如下理解：\n\n- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；\n- 串行（Serial）：串行指的是垃圾收集器与用户程序交替执行，意味着在执行垃圾收集的时候需要停顿用户程序；\n- 并行（Parallel） ：指的是多条垃圾收集线程并行工作，默认用户线程仍然处于等待状态。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。\n- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（不一定是并行，可能会交替执行）。用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。\n\n#### Serial 收集器\n\nSerial 翻译为串行，也就是说它以串行的方式执行。\n\n它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123150.png)\n\n\u003cstrong\u003e优点\u003c/strong\u003e\n简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。\n\n\u003cstrong\u003e缺点\u003c/strong\u003e\n进行垃圾收集工作的时候必须暂停其他所有的工作线程（Stop The World），直到收集结束。\n\n#### ParNew 收集器\n\n它是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123155.png)\n\n#### Parallel Scavenge 收集器\n\n与 ParNew 一样是多线程收集器。其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。\n\n停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。\n\n缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。\n\n#### Serial Old 收集器\n\n是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用，同样也是一个单线程收集器，使用“标记-整理”算法。如果用在 Server 场景下，它有两大用途：\n\n- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。\n- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。\n\n#### Parallel Old 收集器\n\nParallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。\n\n#### CMS 收集器\n\nCMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。它是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\n\n从名字中的 Mark Sweep 这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n\n- 初始标记： \u003cstrong\u003e暂停所有的其他线程\u003c/strong\u003e，并记录下\u003cstrong\u003e与 GC root 直接相连\u003c/strong\u003e的对象，速度很快。\n- 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n- 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段也需要\u003cstrong\u003e暂停所有的其他线程\u003c/strong\u003e。但停顿时间一般会比初始标记阶段的时间稍长，而又远远比并发标记阶段时间短。\n- 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123203.png)\n\n在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。\n\n从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：\n\n- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。\n- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将\u003cstrong\u003e临时启用 Serial Old 来替代 CMS\u003c/strong\u003e。\n- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。\n\n#### G1 收集器\n\nG1 (Garbage-First) 是一款\u003cstrong\u003e面向服务器\u003c/strong\u003e的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。\n\n堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。它把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。\n\n每一个 Region 都可以根据需要，扮演新生代的 Eden、Survivor 和老年代空间，G1 能够对扮演不同觉得的 Region 采用不同的策略区处理。Region 中还有一类特殊的 Humongous（巨大的） 区域，专门用来储存大对象。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123208.png)\n\nG1 收集器的运作大致分为以下几个步骤：\n\n- 初始标记\n- 并发标记\n- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。\n- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123216.png)\n\nG1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\n\nG1 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：\n\n- 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。\n- 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\n- 空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。\n- 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。\n\n| 收集器            | 收集对象/算法                      | 收集器类型      | 说明                                                                                                                           | 适用场景                                                                                                     |\n| ----------------- | ---------------------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ |\n| Serial            | 新生代/复制                        | 单线程          |                                                                                                                                | 简单高效；\u003cbr/\u003e适合内存不大的情况；\u003cbr/\u003eClient 场景下的默认新生代收集器。                                    |\n| ParNew            | 新生代/复制                        | 并行\u003cbr/\u003e多线程 | 是 Serial 收集器的多线程版本                                                                                                   | Server 场景下默认的新生代收集器；\u003cbr/\u003e搭配 CMS 垃圾回收器的首选。                                            |\n| Parallel Scavenge | 新生代/复制                        | 并行\u003cbr/\u003e多线程 | 类似 ParNew，更加关注吞吐量，达到一个可控制的吞吐量；                                                                          | Server 场景多 CPU 机器上的默认收集器，主要适合后台运算不需要太多交互的任务；                                 |\n| Serial Old        | 老年代/标记整理                    | 单线程          |                                                                                                                                | Client 模式下虚拟机使用                                                                                      |\n| Parallel Old      | 老年代/标记整理                    | 并行\u003cbr/\u003e多线程 | Parallel Scavenge 收集器的老年代版本，为了配合 Parallel Scavenge 的面向吞吐量的特性而开发的对应组合；                          | 在注重吞吐量以及 CPU 资源敏感的场合采用                                                                      |\n| CMS               | 老年代/标记清除                    | 并行\u003cbr/\u003e并发   | 尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：\u003cbr/\u003e1.内存碎片\u003cbr/\u003e2.需要更多 cpu 资源\u003cbr/\u003e3.浮动垃圾问题，需要更大的堆空间 | 重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者 B/S 系统。互联网后端目前 CMS 是主流的垃圾回收器。 |\n| G1                | 新生代和老年代/标记整理 + 化整为零 | 并行\u003cbr/\u003e并发   | JDK 1.7 才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势；             | 面向服务端应用的垃圾回收器，目标为取代 CMS。                                                                 |\n\n# 内存分配与 GC 策略\n\n## 1. 对象优先在 Eden 分配\n\n大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。\n\n## 2. 大对象直接进入老年代\n\n大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。\n\n经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。\n\n-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。\n\n## 3. 长期存活的对象进入老年代\n\n为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。\n\n-XX:MaxTenuringThreshold 用来定义年龄的阈值。\n\n## 4. 动态对象年龄判定\n\n虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。\n\n## 5. 空间分配担保\n\n在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。\n\n如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123223.png)\n\n## Full GC 的触发条件\n\n对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：\n\n### 1. 调用 System.gc()\n\n只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。\n\n### 2. 老年代空间不足\n\n老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。\n\n为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。\n\n### 3. 空间分配担保失败\n\n使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。\n\n### 4. 永久代空间不足（JDK 1.8 之前）\n\n在 JDK 1.8 之前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。\n\n当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。\n\n为避免以上原因引起的 Full GC，可采用的方法为\u003cstrong\u003e增大永久代空间\u003c/strong\u003e或\u003cstrong\u003e转为使用 CMS 收集器\u003c/strong\u003e。\n\n### 5. Concurrent Mode Failure\n\n执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123229.png)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123234.png)\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["JVM","垃圾回收","GC","Java"]},"/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F":{"title":"JVM 内存区域","content":"\n# 简介\n\n## 什么是 JVM？\n\nJava 虚拟机（Java Virtual Machine，简称 JVM），它能识别 .class 后缀的字节码文件（Java bytecode），并且能够解析它的指令，最终调用操作系统上的函数以完成指定操作。\n\n## 为什么需要 JVM？\n\nJava 程序使用 javac 编译成 .class 文件之后，还需要使用 Java 命令去主动执行它，操作系统并不认识这些 .class 文件，JVM 则充当了翻译官的角色。JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120503.png)\n\n从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现跨平台了。JVM 只需要保证能够正确执行 .class 文件，就可以运行在诸如 Linux、Windows、MacOS 等平台上了。\n\nJVM 解释的是类似于汇编语言的字节码，需要一个抽象的运行时环境。同时，这个虚拟环境也需要解决字节码加载、自动垃圾回收、并发等一系列问题。JVM 其实是一个规范，定义了 .class 文件的结构、加载机制、数据存储、运行时栈等诸多内容，最常用的 JVM 实现就是 Hotspot。\n\n一个 Java 程序，首先经过 javac 编译成 .class 文件，然后 JVM 将其加载到 `元数据` 区，执行引擎将会通过 `混合模式` 执行这些字节码。执行时，会翻译成操作系统相关的函数。JVM 作为 .class 文件的黑盒存在，输入字节码，调用操作系统函数。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120537.png)\n## JVM、JRE 和 JDK 三者关系\n\nJVM 只是一个翻译官，它负责把字节码翻译成机器码，但是需要注意，JVM 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到 JRE。\n\nJRE 除了包含 JVM 之外，提供了很多的类库（就是我们说的 jar 包，它可以提供一些即插即用的功能，比如读取或者操作文件，连接网络，使用 I/O 等等之类的）这些东西就是 JRE 提供的基础类库。JVM 标准加上实现的一大堆基础类库，就组成了 Java 的运行时环境，也就是我们常说的 JRE（Java Runtime Environment）。有了 JRE 之后，Java 程序便可以运行来了。\n\n但对于程序员来说，JRE 还不够。还需要编译代码、调试代码、打包代码，有时候还需要反编译代码等等。因此需要使用 JDK，除了 JRE 之外，JDK 还提供了一些非常好用的小工具，比如 javac（编译代码）、java、jar （打包代码）、javap（反编译 \u003c 反汇编 \u003e）等。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120708.png)\n\n# JVM 运行时数据区\n\n相对于 C 和 C++ 的手动内存管理和复杂难以理解的指针等特性，Java 引以为豪的就是它的自动内存管理机制，这使得 Java 程序写起来方便得多。然而这种呼之即来挥之即去的内存申请和释放方式，自然也有它的代价。为了管理这些快速的内存申请释放操作，就必须引入一个池子来延迟这些内存区域的回收操作。另外，Java 程序的数据结构是非常丰富的，比如有静态成员变量、动态成员变量、区域变量、短小紧凑的对象声明和庞大复杂的内存申请等等。这么多不同的数据结构，到底是在什么地方存储的，它们之间又是怎么进行交互的呢？这就有了内存区域划分的概念，如图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120716.png)\n\nJVM 内存区域划分如图所示，从图中我们可以看出：\n\n- JVM 堆中的数据是共享的，是占用内存最大的一块区域。\n- 可以执行字节码的模块叫作执行引擎。\n- 执行引擎在线程切换时依靠的就是程序计数器来进行恢复。\n- JVM 的内存划分与多线程是息息相关的。程序中运行时用到的栈，以及本地方法栈，它们的维度都是线程。\n- 本地内存包含元数据区和一些直接内存。\n\n![](static/boxcnFXQjU3d0urFc9C5qGM6ISd.png)\n\n## 程序计数器\n\n程序计数器（Program Counter Register）是一块较小的内存空间，由于 JVM 可以并发执行线程，因此会存在线程之间的切换，而这个时候就程序计数器会记录下当前程序执行到的位置，以便在其他线程执行完毕后，恢复现场继续执行。\n\nJVM 会为每个线程分配一个程序计数器，与线程的生命周期相同。\n\n如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行虚拟机字节码指令的地址。如果正在执行的是 Native 本地方法，计数器的值则为空。\n\n\u003cstrong\u003e程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。\u003c/strong\u003e\n\n## 虚拟机栈\n\n虚拟机栈描述的是 Java 方法执行的内存模型：\n\n每个方法在执行的同时都会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n\n虚拟机栈是每个线程独有的，随着线程的创建而存在，线程结束而死亡。\n\n在虚拟机栈内存不够的时候会 OutOfMemoryError，在线程运行中需要更大的虚拟机栈时会出现 StackOverFlowError。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120721.png)\n\n从上图可以看出，虚拟机栈包含很多\u003cstrong\u003e栈帧\u003c/strong\u003e，每个方法执行的同时会创建一个栈帧，栈帧又存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。\n\n### 虚拟机栈运行的原理\n\n- JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循\"先进后出\"的原则。\n- 每一次函数调用都会有一个对应的栈帧被压入虚拟机栈中，每一个函数调用结束后，都会有一个栈帧被弹出。\n- 在一条活动的线程中，一个时间点上，只会有一个数据的栈帧。即只有当前正在执行的方法的栈帧是有效的。这个栈帧称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。\n- 执行引擎运行的所有字节码指令只针对当前的栈帧进行操作。\n- 如果该方法调用了其他方法，对应新的栈帧会创建处理，放在栈的顶部，成为新的当前栈。\n- 不同线程中所包含的栈帧是不允许相互作用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。\n- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的返回结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，是的前一个栈帧重新成为当前栈帧。\n- Java 方法有两种返回方式：return 语句和抛出异常，不管哪种返回方式都会导致栈帧被弹出。\n\n### 局部变量表\n\n局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAdress 类型（指向了一条字节码指令的地址）。\n\n### 操作数栈\n\n主要用于\u003cstrong\u003e保存计算过程的中间结果\u003c/strong\u003e，同时作为计算过程中\u003cstrong\u003e临时的存储空间\u003c/strong\u003e。\n\n当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。\n\n操作数栈、局部变量表和程序计数器的工作过程：\n\n![](static/boxcnIP1LPtHC6Df6FWYsQDun3z.png)\n\n### 动态连接\n\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。\n\n方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)，这也是 Java 强大的扩展能力，在运行期间才能确定目标方法的\u003cstrong\u003e直接引用\u003c/strong\u003e。\n\n所有\u003cstrong\u003e方法调用中的目标方法\u003c/strong\u003e在 Class 文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。\n\n在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池中。比如：描述一个方法调用另外的其他方法时，就是通过常量池中指向方法的引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120904.png)\n\n下面从字节码的角度分析动态连接的过程：\n\n```java\npublic class DynamicLinkingTest {\n    int num = 10;\n    public void methodA() {\n        System.out.println(\"methodA...\");\n    }\n    public void method() {\n        System.out.println(\"methodB...\");\n        methodA();\n        num++;\n    }\n}\n```\n\n上面代码反编译以后可以看到如下指令：\n\n```java\n Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokevirtual #2                  // Method a:()V\n         4: return\n```\n\ninvokevirtual 后面的 #2 符号引用对应的就是运行时常量池中的直接引用。\n\n#2 对应了方法引用，#3，#17……最终对应到 methodA：\n\n```java\nConstant pool:\n   #1 = Methodref          #4.#16         // java/lang/Object.\"\u003cinit\u003e\":()V\n   #2 = Methodref          #3.#17         // com/suanfa/jvm/OperandStackTest.a:()V\n   #3 = Class              #18            // com/suanfa/jvm/OperandStackTest\n   #4 = Class              #19            // java/lang/Object\n   #5 = Utf8               \u003cinit\u003e\n   #6 = Utf8               ()V\n   #7 = Utf8               Code\n   #8 = Utf8               LineNumberTable\n   #9 = Utf8               LocalVariableTable\n  #10 = Utf8               this\n  #11 = Utf8               Lcom/suanfa/jvm/OperandStackTest;\n  #12 = Utf8               a\n  #13 = Utf8               b\n  #14 = Utf8               SourceFile\n  #15 = Utf8               OperandStackTest.java\n  #16 = NameAndType        #5:#6          // \"\u003cinit\u003e\":()V\n  #17 = NameAndType        #12:#6         // a:()V\n  #18 = Utf8               com/suanfa/jvm/OperandStackTest\n  #19 = Utf8               java/lang/Object\n```\n\n#### \u003cstrong\u003e方法调用\u003c/strong\u003e\n\n在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。\n\n1. 静态链接、早期绑定：当一个字节码文件别装入 JVM 内部，如果被调用的目标方法在编译器可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。对应的方法绑定机制为\u003cstrong\u003e早期绑定\u003c/strong\u003e。\n2. 动态链接、晚期绑定：如果方法被调用的时候在编译期无法确定下来，就是说，只能在运行时将调用方法的符号引用转换为直接引用，引用这种引用转换过程具备动态性，因此称之为动态链接。对应的方法绑定机制为\u003cstrong\u003e晚期绑定\u003c/strong\u003e。\n\n#### \u003cstrong\u003e虚方法与非虚方法\u003c/strong\u003e\n\n- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称之为非虚方法。\n- 静态变量、私有方法、final 方法、实例构造器、父类方法都是非虚方法。\n- 其它方法称之为虚方法。\n\n##### 普通调用指令\n\n- invokestatic ：静态方法，解析阶段确定唯一方法版本\n- invokespecial ：调用`\u003cinit\u003e`方法、私有方法以及父类方法，解析阶段确定唯一方法版本\n- invokevirtual ：调用所有虚方法\n- invokeinterface ：调用接口方法\n\n##### 动态调用指令\n\n- invokedynamic ： 动态解析所需要调用的方法，然后执行。invokedynamic 指令是在 Java 7 中增加的，为了实现动态类型语言支持而做的一种改进，但在 Java 7 中并没有提供直接生成的 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具才能够生成 invokedynamic 指令。直到 JDK 8 的 Lambda 表达式的出现，invokedynamic 指令在 Java 中才有了直接生成的方式。\n\n前四条指令固化在虚拟机的内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定版本。其中 invokevirtual 和 invokestatic 指令调用的方法称为非虚方法，其余的（final 修饰除外）称为虚方法。\n\n下面以具体实例展示以上介绍的各种调用指令：\n\n```java\n/**\n * 解析调用中非虚方法、虚方法的测试\n */\nclass Father {\n    public Father(){\n        System.out.println(\"Father 默认构造器\");\n    }\n\n    public static void showStatic(String s){\n        System.out.println(\"Father show static \" + s);\n    }\n\n    public final void showFinal(){\n        System.out.println(\"Father show final\");\n    }\n\n    public void showCommon(){\n        System.out.println(\"Father show common\");\n    }\n\n}\n\npublic class Son extends Father{\n    public Son(){\n        super();\n    }\n\n    public Son(int age){\n        this();\n    }\n\n    public static void main(String[] args) {\n        Son son = new Son();\n        son.show();\n    }\n\n    //不是重写的父类方法，因为静态方法不能被重写\n    public static void showStatic(String s) {\n        System.out.println(\"Son show static \" + s);\n    }\n\n    private void showPrivate(String s) {\n        System.out.println(\"Son show private \" + s);\n    }\n\n    public void show() {\n        //invokestatic\n        showStatic(\"大头儿子\");\n        //invokestatic\n        super.showStatic(\"大头儿子\");\n        //invokespecial\n        showPrivate(\"hello!\");\n        //invokespecial\n        super.showCommon();\n        //invokevirtual 因为此方法声明有final，不能被子类重写\n        //所以也认为该方法是非虚方法\n        showFinal();\n        //虚方法如下\n        //invokevirtual\n        //没有显式加super，被认为是虚方法，因为子类可能重写showCommon\n        showCommon();\n        info();\n\n        MethodInterface in = null;\n        //invokeinterface  \n        //不确定接口实现类是哪一个 需要重写\n        in.methodA();\n        //invokedynamic\n        lambda(()-\u003e {\n          \n        });\n    }\n\n    public void info(){\n\n    }\n    \n    public void lambda(MethodInterface interface) {\n        methodInterface.methodA();\n    }\n\n}\n\ninterface MethodInterface {\n    void methodA();\n}\n```\n\n### 方法出口\n\n指方法返回地址，是存放调用该方法的程序计数器的值。\n\n方法返回分为正常返回和异常退出。无论何种退出情况，都将返回至方法当前被调用的位置，这样程序才能继续执行。\n\n本质上，方法的退出就是当前栈帧出栈的过程。此时需要回复上层方法的局部变量表、操作数栈、将返回值压入调用者的栈帧的操作数栈、设置程序计数器的值等，让调用者方法继续执行下去。正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值。\n\n### 本地方法栈\n\nJava 虚拟机栈是用来为 Java 方法服务，相应地，本地方法栈则是用来为 native 方法服务的，可以认为是通过 JNI (Java Native Interface) 直接调用本地 C/C++ 库，不受 JVM 控制。需要注意的是，HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一了。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120910.png)\n\n本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 异常。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120920.png)\n\n## 堆\n\n堆是 JVM 上最大的内存区域，我们申请的\u003cstrong\u003e几乎所有的对象\u003c/strong\u003e，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。\n\n一个对象创建的时候，决定是堆上分配还是在栈上分配，和两个方面有关：对象的类型和在 Java 类中存在的位置。\n\n- 对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。\n- 对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况。由于每个线程拥有一个虚拟机栈，当在方法体内声明了基本数据类型的对象，就会在栈上直接分配。其他情况，则都是在堆上分配。\n\n堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。\n\n随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。由于对象的大小不一，在长时间运行后，堆空间会被许多细小的碎片占满，造成空间浪费。所以，仅仅销毁对象是不够的，还需要堆空间整理。\n\n现在的虚拟机（包括 HotSpot）都是采用分代回收算法。在分代回收的思想中， 把堆分为：新生代 + 老年代 + 永久代（Java 1.8 之前的方法区的实现方式）； 新生代又分为 Eden + From Survivor + To Survivor 区。几乎所有的 Java 对象都在 Eden 区被 new 出来的。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121108.png)\n\n在 Hotspot 中，Eden、 From 和 To 区空间大小默认比例是 8：1：1。\n\n也可以使用 -XX:SurvivorRatio 调整这个空间比例，比如 -XX:SruvivorRatio=8。\n\n## 方法区\n\n方法区（Method Area）与 Java 堆一样，是所有\u003cstrong\u003e线程共享\u003c/strong\u003e的内存区域。\n\n方法区用于存储已经被虚拟机加载的类信息（即加载类、接口、枚举、注解时需要的信息，包括版本、field、方法、接口等信息）、final 常量、静态变量、编译器即时编译的代码等。\n\n方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。\n\n### 版本演进\n\nJava 8 之前，许多 Java 程序员都习惯在 HotSpot 虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或者将两者混为一谈。本质上这两者是不等价的，因为仅仅是当时的 HotSpot 虚拟机设计团队把垃圾收集器的分代设计思想扩展到方法区，或者说使用永久代来实现方法区而已，这样使得 Hotspot 的垃圾收集器能够像管理 Java 堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机（如 JRockit 和 J9）来说是不存在永久代的概念的，因为《Java 虚拟机规范》对方法区的实现要求比较宽松。\n\n在 Java 6 的时候 Hotspot 开发团队就有放弃永久代，逐步改为采用本地内存来实现方法区的计划了。到了 Java 7，Hotspot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆里；而从 Java 8 开始，则放弃了永久代的概念，改用与 JRockit 和 J9 一样在本地内存中实现的元空间（MetaSpace）来代替，并把之前永久代剩余的内容（运行时常量池和其他类信息等）全部移动到元空间中\n\nJava 7 之前：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121115.png)\n\nJava 7:\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121121.png)\n\nJava 8 开始：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121132.png)\n\n### 采用元空间替代永久代实现方法区的优点\n\n1. 字符串存在永久代中，容易出现性能问题和内存溢出。\n2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。而元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制。\n3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。\n4. 将 HotSpot 与 JRockit 合二为一。\n\n### 方法区中的内容\n\n#### \u003cstrong\u003e类型信息\u003c/strong\u003e\n\n对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：\n\n1. 这个类型的完整有效名称（即包名.类名）\n2. 这个类型直接父类的完整有效名（对于 interface 或是 java. lang.Object，都没有父类）\n3. 这个类型的修饰符（public、 abstract、 final 的某个子集）\n4. 这个类型直接接口的一个延续列表\n\n#### \u003cstrong\u003e域（Field）信息\u003c/strong\u003e\n\nJVM 必须在方法区中保存类型的所有域的相关信息以及域的生命顺序。\n\n域的相关信息包括：域名称、域类型、域修饰符（pubic、private、protected、static、final、volatile、transient 的某个子集）。\n\n#### \u003cstrong\u003e方法（method）信息\u003c/strong\u003e\n\nJVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：\n\n1. 方法名称。\n2. 方法的返回类型（或 void）\n3. 方法参数的数量和类型（按顺序）\n4. 方法的修饰符（public、private、protected、static、final、synchronized、native、abstract 的一个子集）\n5. 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）\n6. 异常表（abstract 和 native 方法除外），每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。\n\n#### \u003cstrong\u003e静态变量（static 变量）\u003c/strong\u003e\n\n1. 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。\n2. 类变量被类的所有实例所共享，即使没有类实例你也可以访问它。\n\n#### \u003cstrong\u003e全局常量（static final 变量）\u003c/strong\u003e\n\n与 non-final 的类变量的处理方法则不同，每个全局常量在编译的时候就被分配了。\n\n```java\npublic static int count = 1;\npublic static final int number = 2;\n```\n\n反编译后就可以看到如下代码：\n\n```java\npublic static int count;\n    descriptor: I\n    flags: ACC_PUBLIC, ACC_STATIC\n\npublic static final int number;\n    descriptor: I\n    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL\n    ConstantValue: int 2\n```\n\n## 直接内存\n\n直接内存并不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。它是处于 Java 堆外的、直接向内存申请的系统内存区间。\n\n直接内存源自 NIO，通过存在堆外内存的 DirectByteBuffer 操作 Native 本地内存。通常，访问直接内存的速度会优于 Java 堆内存，即读写性能高。因此出于性能考虑，读写频繁的场合可能考虑使用直接内存。因此 Java 的 NIO 库使用直接内存进行数据缓冲器。\n\n直接内存也可能导致 OOM，由于它处于 Java 堆外，因此它的大小不会直接受限于 -Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统给出的最大内存。可以通过 -XX:MaxDirectMemorySize 设置它的大小，默认与堆的最大值 -Xmx 参数值一致。\n\n直接内存的缺点是分配回收成本较高、不受 JVM 内存回收管理。\n\n# 常量池和 String\n\n## 常量池概念\n\n### 静态常量池\n\n一个有效的 Class 文件中除了包含了类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息就是\u003cstrong\u003e常量池（Constant Pool）\u003c/strong\u003e，用于存放编译期生成的各种\u003cstrong\u003e字面量（Literal）\u003c/strong\u003e和\u003cstrong\u003e对类型、域和方法的符号引用（Symbolic References）\u003c/strong\u003e。\n\n### 运行时常量池\n\n运行时常量池是方法区中的一部分。Class 文件中静态常量池的内容将在类加载后存放到方法区的运行时常量池中。也就是说，每个 Class 都有一个静态常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。\n\n运行时常量池相对于 Class 文件常量池的一个重要特征就是它具备动态性。运行期间也可以将新产生的常量放入常量池中，典型的实现方式就是 String 类的 intern() 方法。\n\n### 字符串常量池\n\n字符串的分配和其他的对象分配一样，需要耗费高昂的时间和空间为代价，如果需要大量频繁的创建字符串，会极大程度地影响程序的性能，因此 JVM 为了提高性能和减少内存开销引入了字符串常量池的概念。\n\n#### 特点\n\n字符串常量池中是不会存储相同的字符串的。\n\n字符串常量池（String Pool）由 StringTable 类实现，它是一个固定大小的 Hashtable。因此，如果 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长会直接造成调用 String.intern 时性能大幅度下降。\n\n```java\npublic class StringTable extends sun.jvm.hotspot.utilities.Hashtable {\n    ...\n}\n```\n\nJDK6、7 中，StringTable 默认是 1009，所以如果常量池中的字符串过多就会导致效率下降很快，此时可以通过参数进行调整。\n\nJDK8 开始，StringTable 默认是 60013，也可以通过参数进行调整，但限制最小长度不低于 1009。\n\nStringTable 存储的不是 String 对象的内容，而是一个个 HashtableEntry，HashtableEntry 里面的 value 指向的才是 String 对象一般我们说一个字符串进入了字符串常量池其实是说在这个 StringTable 中保存了对它的引用；反之，如果说没有在其中就是说 StringTable 中没有对它的引用。\n\n#### 字符串常量池位置变化\n\n字符串常量池自 Java 7 开始从永久代移动到堆中。因为永久代的回收频率很低，在 Full GC 的时候才会触发，而 Full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了 StringTable 回收效率不高。而开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。因此，只有放到堆里才能及时回收这部分内存。\n\n## String\n\n无论是服务端还是 Android 客户端开发，String 对象无疑是用得最多的数据类型之一，String 类的代码简化后有如下内容：\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    \n    ...\n}\n```\n\n实际上，value[] 数组才是真正存放字符串的容器。\n\n### String 对象的内存分配\n\n以下使用 String 对象最常用的两种方式，下面进行深入分析。\n\n#### 通过字面量赋值创建\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"xyz\";\n        ...\n    }\n}\n```\n\n这段代码执行后（假如 main 线程还存活），内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121313png)\n\n执行 String s = \"xyz\" 时，首先会在字符串常量池中查找（遍历 StringTable 逐个获取 HashtableEntry 对象，判断 HashtableEntry 的 value 是否 equals(\"xyz\")），看能不能找到“xyz”\u003cstrong\u003e字符串的引用\u003c/strong\u003e，如果字符串常量池中找不到这个引用，则：\n\n1. 创建一个 String 对象和 char 数组对象；\n2. 将创建的 String 对象封装成 HashtableEntry，作为 StringTable 的 value 进行存储；\n3. 返回创建的 String 对象。\n\n如果能找到这个引用：\n\n- 直接返回找到引用对应的 String 对象。\n\n#### 通过 new 关键字创建\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = new String(\"xyz\");\n        ...\n    }\n}\n```\n\n这段代码执行后（假如 main 线程还存活），内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121321.png)\n\n执行 String s = new String(\"xyz\") 时，首先会在字符串常量池中查找，看能不能找到“xyz”\u003cstrong\u003e字符串对应对象的引用\u003c/strong\u003e，如果字符串常量池中找不到这个引用，则：\n\n1. 创建一个 String 对象和 char 数组对象；\n2. 将创建的 String 对象封装成 HashtableEntry，作为 StringTable 的 value 进行存储；\n3. new String(\"xyz\") 会在堆区又创建一个 String 对象，char 数组直接指向创建好的 char 数组对象。\n\n如果能找到这个引用：\n\n- new String(\"xyz\") 会在堆区创建一个对象，char 数组直接指向已经存在的 char 数组对象。\n\n#### 对比\n\n对于 String s = \"xyz\" 这种形式创建字符串对象，如果字符串常量池中能找到，不会创建 String 对象；如果如果字符串常量池中找不到，创建一个 String 对象。\n\n对于 String s = new String(\"xyz\") 这种形式创建字符串对象，如果字符串常量池中能找到，创建一个 String 对象；如果如果字符串常量池中找不到，创建两个 String 对象。\n\n所以，在日常开发中，能用 String s = \"xyz\" 尽量不用 String s = new String(\"xyz\")，因为可以少创建一个对象，节省一部分空间。\n\n事实上，运行程序用到 Test 类的时候，Test.class 文件的信息会被解析到内存的方法区里，例子中的“xyz”作为字面量，它的一个引用会被存到在堆中的字符串常量池里。而“xyz”本体还是和所有对象一样，创建在堆中的 Eden 区，但因为一直有一个引用驻留在字符串常量池，所以不会被 GC 清理掉。这个对象“xyz”会生存到整个线程结束。主线程中的 s 变量这时候都还没有被创建，但“xyz”的实例已经在堆里了，对它的引用也已经在字符串常量池里了。\n\n有了前面的基础，再来分析下面代码：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s1 = new String(\"xyz\");\n        String s2 = \"xyz\";\n        System.out.println(s1 == s2);\n        System.out.println(s1.equals(s2));\n        ...\n    }\n}\n输出结果：\nfalse\ntrue\n```\n\n这段代码执行后（假如 main 线程还存活），内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121328.png)\n\n很明显，s1 和 s2 指向的是不同的对象。而 equals 方法比较的真正的 char 数据，并且从图中可以看出 s1 和 s2 最终指向的都是同一个 char 数组对象，所以 s1.equals(s2) 等于 true。关于它们是否指向同一个数组，下图也可以证实：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121334.png)\n\n#### 通过字符串拼接创建\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s1 = \"aa\";\n        String s2 = \"bb\";\n        String str0 = new String(\"aa\") + new String(\"bb\");\n        String str1 = s1 + s2;\n        String str2 = \"aabb\";\n        String str3 = \"aa\" + \"bb\";\n        System.out.println(str0 == str1);\n        System.out.println(str1 == str2);\n        System.out.println(str2 == str3);\n        ...\n    }\n}\n输出结果：\nfalse\nfalse\ntrue\n```\n\n首先，对于 str3 来说，编译期会优化成 “aabb”，因此只有它与 str2 是同一个对象。\n\n对于 str0 和 str1 来说，会被编译器会优化成 new StringBuilder().append(\"aa\").append(\"bb\").toString();\n\nStringBuilder 里面的 append 方法就是对 char 数组进行操作，查看 StringBuilder 的 toString 方法：\n\n```java\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    /**\n     * The value is used for character storage.\n     */\n    char[] value;\n    \n    ...\n\n    @Override\n    public String toString() {\n        // Create a copy, don't share the array\n        return new String(value, 0, count);\n    }\n    \n    ...\n}\n```\n\n再看 String 的这个构造方法：\n\n```java\npublic String(char value[], int offset, int count) {\n    if (offset \u003c 0) {\n        throw new StringIndexOutOfBoundsException(offset);\n    }\n    if (count \u003c= 0) {\n        if (count \u003c 0) {\n            throw new StringIndexOutOfBoundsException(count);\n        }\n        if (offset \u003c= value.length) {\n            this.value = \"\".value;\n            return;\n        }\n    }\n    // Note: offset or count might be near -1\u003e\u003e\u003e1.\n    if (offset \u003e value.length - count) {\n        throw new StringIndexOutOfBoundsException(offset + count);\n    }\n    this.value = Arrays.copyOfRange(value, offset, offset+count);\n}\n```\n\n它关键做了如下操作：\n\n- 根据参数\u003cstrong\u003e复制一份\u003c/strong\u003e char 数组对象。\n- 创建一个 String 对象，String 对象的 value 指向复制的 char 数组对象。\n\n也就是说 str1 指向的 String 对象的 value 值直接指向了一个已经存在的数组，而且没有驻留到字符串常量池，而 str2 指向的对象驻留到字符串常量池里面去了。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121345.png)\n\n因此 str0、str1 和 str2 都是指向不同的对象，并且分别指向不同的 char 数组对象。下图再次验证：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121351.png)\n\n### String.intern() 方法\n\n上面说到，调用 StringBuilder 的 toString 方法创建的 String 对象是不会驻留到字符串常量池的，那还有没有办法将这个对象驻留到字符串常量池呢？有的，这就是 String.intern 方法的作用。\n\n以这段代码为例：\n\n```java\nString s1 = \"aa\";\nString s2 = \"bb\";\nString str = s1 + s2;\nstr.intern();\n```\n\n在执行 str.intern() 之前，内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121400.png)\n\n在执行 str.intern();之后，内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121406.png)\n\nintern 方法就是创建了一个 HashtableEntry 对象，并把 value 指向 String 对象，然后把 HashtableEntry 通过 hash 定位存到对应的字符串成常量池中。当然，前提是字符串常量池中原来没有对应的 HashtableEntry。如果字符串常量池中已经有对应的 HashtableEntry，则返回 HashtableEntry 的 value，即它所对应 String 对象的地址。\n\n#### 版本区别\n\nJDK6 中，将字符串对象尝试放入字符串常量池中：\n\n如果字符串常量池中有，则不会放入，并返回已有的字符串常量池中的对象。\n\n如果没有，会把此对象复制一份，返回字符串池常量池，并返回字符串常量池的地址。\n\nJDK7 开始，将字符串对象尝试放入字符串池常量池中：\n\n如果字符串常量池中有，则不会放入，并返回已有的字符串常量池中的对象。\n\n如果没有，会把对象的引用地址复制一份，放入字符串常量池中，并返回字符串常量池中的引用地址。\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["JVM","内存区域","内存布局","Java"]},"/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B":{"title":"JVM 字节码指令简介","content":"Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需的参数（操作数）构成。\n\n在 Java 虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。比如， iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在 Class 文件中它们必须拥有各自独立的操作码。\n\n编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的对 int 类型作为运算类型来进行的。\n\n### 加载和存储指令\n\n加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。这些指令如下：\n\n- 将一个局部变量加载到操作栈:iload、iload_、lload、lload_、fload、fload_、dload、dload_、aload、aload_\n- 将一个数值从操作数栈存储到局部变量表:istore、istore_、lstore、lstore_、fstore、fstore_、dstore、dstore_、astore、astore_\n- 将一个常量加载到操作数栈:bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_、lconst_、fconst_、dconst_\n- 扩充局部变量表的访问索引的指令:wide\n\n### 运算指令\n\n算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。\n\n- 加法指令:iadd、ladd、fadd、dadd\n- 减法指令:isub、lsub、fsub、dsub\n- 乘法指令:imul、lmul、fmul、dmul\n- 除法指令:idiv、ldiv、fdiv、ddiv\n- 求余指令:irem、lrem、frem、drem\n- 取反指令:ineg、lneg、fneg、dneg\n- 位移指令:ishl、ishr、iushr、lshl、lshr、lushr\n- 按位或指令:ior、lor ·按位与指令:iand、land\n- 按位异或指令:ixor、lxor ·局部变量自增指令:iinc\n- 比较指令:dcmp g、dcmp l、fcmp g、fcmp l、lcmp\n\n### 类型转换指令\n\n类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码的显示类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。\n\nJava 虚拟机直接支持以下数值类型的宽化类型转换：\n\n- int 类型到 long、float 或者 double 类型\n- long 类型到 float、double 类型\n- float 类型到 double 类型\n\n相对的，处理窄化类型转换时，就必须显示地使用转换指令来完成：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l 和 d2f\n\n在将 int 或 long 类型窄化转换为整数类型 T 的时候，转换过程仅仅是简单丢弃除最低位 N 字节以外的内容，N 是类型 T 的数据类型长度，这将可能导致转换结果与输入值有不同的正负号（把前面的符号位给舍去了）。\n\n### 对象创建与访问指令\n\n虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素。\n\n- 创建类实例的指令:new\n- 创建数组的指令:new array 、anew array 、mult ianew array\n- 访问类字段(static 字段，或者称为类变量)和实例字段(非 static 字段，或者称为实例变量)的 指令:getfield、putfield、getstatic、putstatic\n- 把一个数组元素加载到操作数栈的指令:baload、caload、saload、iaload、laload、faload、 daload、aaload\n- 将一个操作数栈的值储存到数组元素中的指令:bastore、castore、sastore、iastore、fastore、 dastore、aastore\n- 取数组长度的指令:array lengt h - 检查类实例类型的指令:inst anceof、checkcast\n\n### 操作数栈管理指令\n\n如同操作一个普通数据结构中的堆栈那样，Java 虚拟机提供了一些用于直接操作操作数栈的指令：\n\n- 将操作数栈的栈顶一个或两个元素出栈:p op 、p op 2\n- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶:dup 、dup 2、dup _x1、 dup 2_x1、dup _x2、dup 2_x2\n- 将栈最顶端的两个数值互换:swap\n\n### 控制转移指令\n\n控制转移指令可以让 Java 虚拟机有条件或无条件地从指定位置指令(而不是控制转移指令)的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改 PC 寄存器的值。\n\n- 条件分支:ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq 和 if_acmpne\n- 复合条件分支:tableswitch、lookupswitch\n- 无条件分支:goto、goto_w、jsr、jsr_w、ret\n\n与前面的算术运算的规则一致，对于 boolean、byte、char 和 short 类型的条件分支比较操作，都使用 int 类型的比较指令完成，而对于 long、float 和 double 类型的条件分支比较操作，则会先执行相应类型的比较运算指令，预算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。因此，各种类型的比较最终都会转换为 int 类型的比较操作。\n\n### 方法调用和返回指令\n\n方法调用：分派、执行过程。\n\n- invokevirt ual 指令:用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)， 这也是 Java 语言中最常见的方法分派方式。\n- invokeinterface 指令:用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找 出适合的方法进行调用。\n- invokespecial 指令:用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和 父类方法。\n- invokestatic 指令:用于调用类静态方法(static 方法)。\n- invokedynamic 指令:用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面 四条调用指令的分派逻辑都固化在 Java 虚拟机内部，用户无法改变，而 invokedy namic 指令的分派逻辑 是由用户所设定的引导方法决定的。\n\n方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、dreturn 和 areturn，另外还有一条 return 指令供声明为 void 的方法、实例初始化方法、类和接口的类初始化方法使用。\n\n### 异常处理指令\n\n在 Java 程序中显式抛出异常的操作(throw 语句)都由 athrow 指令来实现，除了用 throw 语句显式抛出异常的情况之外，《Java 虚拟机规范》还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状态时自动抛出。例如整数运算中，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出 ArithmeticException 异常。\n\n而在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（很久之前曾经使用 jsr 和 ret 指令来实现，现在已经不用了），而是采用异常表来完成。\n\n### 10. 同步指令\n\nJava 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来实现的。\n\n方法级的同步是隐式的，无法通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。\n\n同步一段指令集序列通常是由 Java 语言中的 synchronized 语句块来表示，Java 虚拟机的指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义，正确实现 synchronized 关键字需要 javac 编译器与 Java 虚拟机两者共同协作支持。\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["JVM","字节码","Java"]},"/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90":{"title":"JVM 字节码结构分析","content":"\n# 概述\n\n提到字节码，首先想到的就是 Java，Java 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。\n\n​其实不止是 Java，其他很多编程语言如 Scala、Kotlin 和 Groovy 等都是运行在 JVM 的语言，因此它们对应的编译器也能够生成 .class 字节码。\n\n源代码中的各种变量，关键字和运算符号的语义最终都会编译成多条字节码命令。而字节码命令所能提供的语义描述能力是要明显强于 Java 本身的，所以有其他一些同样基于 JVM 的语言能提供许多 Java 所不支持的语言特性。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124332.png)\n\n在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个 .java 文件从编译到运行的示例如下。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124336.png)\n\nJVM 的指令由一个字节长度的操作码（opcode）和紧随其后的可选的操作数（operand）构成。“字节码”这个名字的由来也是因为操作码的长度用一个字节表示。\n\n`\u003copcode\u003e [\u003coperand1\u003e, \u003coperand2\u003e]`\n\n比如将整型常量 100 压栈到栈顶的指令是 “bipush 100”，其中 bipush 就是操作码，100 就是操作数。\n\n因为操作码长度只有 1 个字节长度，这使得编译后的字节码文件非常小巧紧凑，但同时也直接限制了整个 JVM 操作码指令集的数量最多只能有 256 个，目前已经使用了 200+。\n\n大部分字节码指令都包含了所要操作的类型信息。比如 “ireturn” 用于返回一个 int 类型的数据，“dreturn” 用于返回一个 double 类型的的数据，“freturn” 指令用于返回一个 float 类型的数据，这种方式也使得字节码实际的指令类型远小于 200 个。\n\n字节码使用大端序（Big-Endian）表示，即高位在前，低位在后的方式，比如字节码 “getfield 00 02”，表示的是 “getfiled 0x00\u003c\u003c8 | 0x02（getfield #2)”。\n\n字节码并不是某种虚拟 CPU 的机器码，而是一种介于源码和机器码中间的一种抽象表示方法，不过字节码通过 JIT（Just in time）技术可以被进一步编译成机器码。\n\n# 字节码结构\n\n根据 Java 虚拟机规范，Class 文件通过 \u003cstrong\u003eClassFile\u003c/strong\u003e 定义，有点类似 C 语言的结构体。\n\nClassFile 的结构如下：\n\n```plain text\nClassFile {\n    u4             magic; //魔数\n    u2             minor_version;//小版本号\n    u2             major_version;//大版本号\n    u2             constant_pool_count;//常量数量\n    cp_info        constant_pool[constant_pool_count-1];//常量池\n    u2             access_flags;//类访问标记\n    u2             this_class;//当前类\n    u2             super_class;//父类\n    u2             interfaces_count;//接口数量\n    u2             interfaces[interfaces_count];//接口表\n    u2             fields_count;//字段数量\n    field_info     fields[fields_count];//字段表\n    u2             methods_count;//方法数量\n    method_info    methods[methods_count];//方法表\n    u2             attributes_count;//属性数量\n    attribute_info attributes[attributes_count];//属性表\n}\n```\n\n可以看出，class 文件由下面十个部分组成：\n\n- 魔数（Magic Number）\n- 版本号（Minor\u0026Major Version）\n- 常量池（Constant Pool）\n- 类访问标记(Access Flags)\n- 类索引（This Class）\n- 超类索引（Super Class）\n- 接口表索引（Interfaces）\n- 字段表（Fields）\n- 方法表（Methods）\n- 属性表（Attributes）\n\n它们的按照以下顺序进行排放：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124342.png)\n\n《Optimizing Java》的作者编了一句顺口溜帮忙记住上面这十部分：\"My Very Cute Animal Turns Savage In Full Moon Areas.\"\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124346.png)\n\n以下面这个类为例：\n\n```java\npublic class ByteCodeDemo {\n   private int a = 1;\n\n   public int add() {\n      int b = 2;\n      int c = a + b;\n      System.out.println(c);\n      return c;\n   }\n}\n```\n\n编译生成的字节码如下：\n\n```plain text\n➜  Test hexdump ByteCodeDemo.class\n0000000 ca fe ba be 00 00 00 34 00 24 0a 00 06 00 16 09\n0000010 00 05 00 17 09 00 18 00 19 0a 00 1a 00 1b 07 00\n0000020 1c 07 00 1d 01 00 01 61 01 00 01 49 01 00 06 3c\n0000030 69 6e 69 74 3e 01 00 03 28 29 56 01 00 04 43 6f\n0000040 64 65 01 00 0f 4c 69 6e 65 4e 75 6d 62 65 72 54\n0000050 61 62 6c 65 01 00 12 4c 6f 63 61 6c 56 61 72 69\n0000060 61 62 6c 65 54 61 62 6c 65 01 00 04 74 68 69 73\n0000070 01 00 0e 4c 42 79 74 65 43 6f 64 65 44 65 6d 6f\n0000080 3b 01 00 03 61 64 64 01 00 03 28 29 49 01 00 01\n0000090 62 01 00 01 63 01 00 0a 53 6f 75 72 63 65 46 69\n00000a0 6c 65 01 00 11 42 79 74 65 43 6f 64 65 44 65 6d\n00000b0 6f 2e 6a 61 76 61 0c 00 09 00 0a 0c 00 07 00 08\n00000c0 07 00 1e 0c 00 1f 00 20 07 00 21 0c 00 22 00 23\n00000d0 01 00 0c 42 79 74 65 43 6f 64 65 44 65 6d 6f 01\n00000e0 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65\n00000f0 63 74 01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 53\n0000100 79 73 74 65 6d 01 00 03 6f 75 74 01 00 15 4c 6a\n0000110 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65\n0000120 61 6d 3b 01 00 13 6a 61 76 61 2f 69 6f 2f 50 72\n0000130 69 6e 74 53 74 72 65 61 6d 01 00 07 70 72 69 6e\n0000140 74 6c 6e 01 00 04 28 49 29 56 00 21 00 05 00 06\n0000150 00 00 00 01 00 02 00 07 00 08 00 00 00 02 00 01\n0000160 00 09 00 0a 00 01 00 0b 00 00 00 38 00 02 00 01\n0000170 00 00 00 0a 2a b7 00 01 2a 04 b5 00 02 b1 00 00\n0000180 00 02 00 0c 00 00 00 0a 00 02 00 00 00 01 00 04\n0000190 00 02 00 0d 00 00 00 0c 00 01 00 00 00 0a 00 0e\n00001a0 00 0f 00 00 00 01 00 10 00 11 00 01 00 0b 00 00\n00001b0 00 5c 00 02 00 03 00 00 00 12 05 3c 2a b4 00 02\n00001c0 1b 60 3d b2 00 03 1c b6 00 04 1c ac 00 00 00 02\n00001d0 00 0c 00 00 00 12 00 04 00 00 00 05 00 02 00 06\n00001e0 00 09 00 07 00 10 00 08 00 0d 00 00 00 20 00 03\n00001f0 00 00 00 12 00 0e 00 0f 00 00 00 02 00 10 00 12\n0000200 00 08 00 01 00 09 00 09 00 13 00 08 00 02 00 01\n0000210 00 14 00 00 00 02 00 15\n0000218\n```\n\n通过反编译后可得到如下信息：\n\n```plain text\n➜  Test javap -v ByteCodeDemo\nClassfile /Users/Jie/IdeaProjects/Test/out/production/Test/ByteCodeDemo.class\n  Last modified 2021年8月30日; size 536 bytes\n  MD5 checksum aa05281ffe821ab9f1e1c192a69a5688\n  Compiled from \"ByteCodeDemo.java\"\npublic class ByteCodeDemo\n  minor version: 0\n  major version: 52\n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER\n  this_class: #5                          // ByteCodeDemo\n  super_class: #6                         // java/lang/Object\n  interfaces: 0, fields: 1, methods: 2, attributes: 1\nConstant pool:\n   #1 = Methodref          #6.#22    // java/lang/Object.\"\u003cinit\u003e\":()V\n   #2 = Fieldref           #5.#23    // ByteCodeDemo.a:I\n   #3 = Fieldref           #24.#25   // java/lang/System.out:Ljava/io/PrintStream;\n   #4 = Methodref          #26.#27   // java/io/PrintStream.println:(I)V\n   #5 = Class              #28       // ByteCodeDemo\n   #6 = Class              #29       // java/lang/Object\n   #7 = Utf8               a\n   #8 = Utf8               I\n   #9 = Utf8               \u003cinit\u003e\n  #10 = Utf8               ()V\n  #11 = Utf8               Code\n  #12 = Utf8               LineNumberTable\n  #13 = Utf8               LocalVariableTable\n  #14 = Utf8               this\n  #15 = Utf8               LByteCodeDemo;\n  #16 = Utf8               add\n  #17 = Utf8               ()I\n  #18 = Utf8               b\n  #19 = Utf8               c\n  #20 = Utf8               SourceFile\n  #21 = Utf8               ByteCodeDemo.java\n  #22 = NameAndType        #9:#10         // \"\u003cinit\u003e\":()V\n  #23 = NameAndType        #7:#8          // a:I\n  #24 = Class              #30            // java/lang/System\n  #25 = NameAndType        #31:#32        // out:Ljava/io/PrintStream;\n  #26 = Class              #33            // java/io/PrintStream\n  #27 = NameAndType        #34:#35        // println:(I)V\n  #28 = Utf8               ByteCodeDemo\n  #29 = Utf8               java/lang/Object\n  #30 = Utf8               java/lang/System\n  #31 = Utf8               out\n  #32 = Utf8               Ljava/io/PrintStream;\n  #33 = Utf8               java/io/PrintStream\n  #34 = Utf8               println\n  #35 = Utf8               (I)V\n{\n  public ByteCodeDemo();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1  // Method java/lang/Object.\"\u003cinit\u003e\":()V\n         4: aload_0\n         5: iconst_1\n         6: putfield      #2  // Field a:I\n         9: return\n      LineNumberTable:\n        line 1: 0\n        line 2: 4\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      10     0  this   LByteCodeDemo;\n\n  public int add();\n    descriptor: ()I\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: iconst_2\n         1: istore_1\n         2: aload_0\n         3: getfield      #2 // Field a:I\n         6: iload_1\n         7: iadd\n         8: istore_2\n         9: getstatic     #3 // Field java/lang/System.out:Ljava/io/PrintStream;\n        12: iload_2\n        13: invokevirtual #4 // Method java/io/PrintStream.println:(I)V\n        16: iload_2\n        17: ireturn\n      LineNumberTable:\n        line 5: 0\n        line 6: 2\n        line 7: 9\n        line 8: 16\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      18     0  this   LByteCodeDemo;\n            2      16     1     b   I\n            9       9     2     c   I\n}\nSourceFile: \"ByteCodeDemo.java\"\n```\n\n反编译的过程将看似毫无规律的十六进制数字还原出了更直观易懂的信息，可见字节码的生成必然遵循着某个固定而特殊的规律，下面将一一对它们进行解析。\n\n## 魔数（Magic Number）\n\n.class 文件的头四个字节称为魔数（Magic Number），可以看到 .class 的魔数为 0xCAFEBABE。很多文件都以魔数来进行文件类型的区分，比如 PDF 文件的魔数是 %PDF-(16 进制 0x255044462D)，png 文件的魔数是\\x89PNG（0x89504E47）。文件格式的制定者可以自由的选择魔数值，只要魔数值还没有被广泛的采用过且不会引起混淆即可。\n\n魔数放在文件开头，JVM 可以根据文件的开头来判断这个文件是否可能是一个 .class 文件，如果是，才会继续进行之后的操作。\n\n## 版本号（Minor \u0026 Major Version）\n\n版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。上面示例中版本号对应的字节码为“00 00 00 34”，次版本号转化为十进制为 0，主版本号转化为十进制为 52，对应的主版本号为 1.8，所以编译该文件的 Java 版本号为 1.8.0（每次 Java 发布大版本时，主版本号加 1）。\n\n## 常量池（Constant Pool）\n\n紧接着主版本号之后的字节为常量池入口。常量池整体上分为两部分：常量池计数器（存储常量池大小计数）以及常量池数据区（存储常量池项），如下图所示。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124353.png)\n\n### 常量池计数器（constant_pool_count）\n\n由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。本文示例中的代码常量池计数对应的字节码为“00 24”，将十六进制的 24 转化为十进制值为 36，排除掉下标“0”，也就是说，这个类文件中共有 35 个常量。\n\n### 常量池数据区（constant_pool[constant_pool_count-1]）\n\n常量池项中存储两类常量：字面量与符号引用。字面量如声明为 Final 的常量值和文本字符串等，符号引用分为类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。\n\n数据区是由（constant_pool_count-1）个 cp_info 结构组成，一个 cp_info 结构对应一个常量。\n\n目前在字节码中共有 14 种类型的 cp_info（如下图所示），每种类型的结构都是固定的。\n\n| 类型                             | 标志（tag） | 描述                 |\n| -------------------------------- | ----------- | -------------------- |\n| CONSTANT_utf8_info               | 1           | UTF-8 编码的字符串   |\n| CONSTANT_Integer_info            | 3           | 整形字面量           |\n| CONSTANT_Float_info              | 4           | 浮点型字面量         |\n| CONSTANT_Long_info               | ５          | 长整型字面量         |\n| CONSTANT_Double_info             | ６          | 双精度浮点型字面量   |\n| CONSTANT_Class_info              | ７          | 类或接口的符号引用   |\n| CONSTANT_String_info             | ８          | 字符串类型字面量     |\n| CONSTANT_Fieldref_info           | ９          | 字段的符号引用       |\n| CONSTANT_Methodref_info          | 10          | 类中方法的符号引用   |\n| CONSTANT_InterfaceMethodref_info | 11          | 接口中方法的符号引用 |\n| CONSTANT_NameAndType_info        | 12          | 字段或方法的符号引用 |\n| CONSTANT_MothodType_info         | 16          | 方法类型             |\n| CONSTANT_MethodHandle_info       | 15          | 方法句柄             |\n| CONSTANT_InvokeDynamic_info      | 18          | 动态方法调用点       |\n\n具体以 CONSTANT_utf8_info 为例，它的结构如下图所示。首先一个字节“tag”，它的值取自上图中对应项的 Tag，由于它的类型是 utf8_info，所以值为“01”。接下来两个字节标识该字符串的长度 Length，然后 Length 个字节为这个字符串具体的值。\n\n从前文示例中的字节码摘取一个 cp_info 结构，如下图所示。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124358.png)\n\n将它翻译过来后，其含义为：该常量类型为 utf8 字符串，长度为一字节，数据为“a”。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124404.png)\n\n下面来逐一详细介绍这些常量池项。\n\n#### CONSTANT_Utf8_info\n\nCONSTANT_Utf8_info 存储的是经过 MUTF-8(modified UTF-8) 编码的字符串，结构如下:\n\n```plain text\nCONSTANT_Utf8_info {\n    u1 tag;\n    u2 length;\n    u1 bytes[length];\n}\n```\n\n它由三部分构成：\n\n1. 第一部分 tag 值为固定为 1\n2. 第二部分 length 表示字符串的长度\n3. 第三部分是采用 MUTF-8 编码的长度为 length 的字节数组\n\n如果要存储的字符串是\"hello\"，存储结构如下图所示\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124834.png)\n\nMUTF-8 编码与标准的 UTF-8 编码大部分情况下是相同的，但也有一些细微的区别，比如在 MUTF-8 里空字符(\"\\u0000\")用两个字节 0xC080 表示，而在标准的 UTF-8 编码里的表述方式为 0x00，还有一些其它的差异这里不做深入的展开。\n\n#### CONSTANT_Integer_info 和 CONSTANT_Float_info\n\n这两种结构分别用来表示 int 和 float 类型的常量，这两种类型的结构很类似，都用四个字节来表示具体的数值常量，它们的结构定义如下：\n\n```plain text\nCONSTANT_Integer_info {\n    u1 tag;\n    u4 bytes;\n}\nCONSTANT_Float_info {\n    u1 tag;\n    u4 bytes;\n}\n```\n\n以整型常量 18(0x12) 为例，它在常量池中的布局结构如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124910.png)\n\nJava 语言规范还定义了 boolean、byte、short 和 char 类型的变量，在常量池中都会被当做 int 来处理，比如用代码定义了下面的常量：\n\n```plain text\npublic class MyConstantTest {\n    public final boolean bool = true; //  1(0x01)\n    public final char c = 'A';        // 65(0x41)\n    public final byte b = 66;         // 66(0x42)\n    public final short s = 67;        // 67(0x43)\n    public final int i = 68;          // 68(0x44)\n}\n```\n\n编译生成的 class 文件如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124929.png)\n\n#### CONSTANT_Long_info 和 CONSTANT_Double_info\n\n这两种结构分别用来表示 long 和 double 类型的常量，这两个结构类似，都用 8 个字节表示具体的常量数值。它们的结构如下：\n\n```plain text\nCONSTANT_Long_info {\n    u1 tag;\n    u4 high_bytes;\n    u4 low_bytes;\n}\n\nCONSTANT_Double_info {\n    u1 tag;\n    u4 high_bytes;\n    u4 low_bytes;\n}\n```\n\n对应的结构如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124949.png)\n\n以下面的代码为例\n\n```plain text\npublic class HelloWorldMain {\n    public final long a = Long.MAX_VALUE; \n}\n```\n\njavap 输出的常量池信息如下：\n\n```plain text\nConstant pool:\n   #1 = Methodref          #7.#17         // java/lang/Object.\"\u003cinit\u003e\":()V\n   #2 = Class              #18            // java/lang/Long\n   #3 = Long               9223372036854775807l\n   #5 = Fieldref           #6.#19         // HelloWorldMain.a:J\n```\n\n前面提到过，CONSTANT_Long_info 和 CONSTANT_Double_info 占用两个常量池位置，可以看到常量 a 占用了 #3 和 #4 两个位置，下一个常量从索引值 5 开始。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125043.png)\n\n#### CONSTANT_Class_info\n\nCONSTANT_Class_info 结构用来表示类或接口，它的结构如下：\n\n```plain text\nCONSTANT_Class_info {\n    u1 tag;\n    u2 name_index;\n}\n```\n\n它由两部分组成，第一个字节是 tag，值为 7，tag 后面的两个字节 name_index 是一个常量池索引，指向类型为 CONSTANT_Utf8_info 常量，这个字符串存储的是类或接口的全限定名。如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125114.png)\n\n#### CONSTANT_String_info\n\nCONSTANT_String_info 用来表示 java.lang.String 类型的常量对象，同样由两部分构成：\n\n```plain text\nCONSTANT_String_info {\n    u1 tag;\n    u2 string_index;\n}\n```\n\n第一个字节是 tag，值为 8，tag 后面的两个字节是一个叫 string_index 的索引值，指向常量池中的 CONSTANT_Utf8_info，这个 CONSTANT_Utf8_info 中存储的才是真正的字符串常量。\n\n以下面的代码为例：\n\n```java\npublic class HelloWorldMain {\n    private String a = \"hello\";\n}\n```\n\nCONSTANT_String_info 的存储布局方式为：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125138.png)\n\n#### CONSTANT_Fieldref_info、CONSTANT_Methodref_info 和 CONSTANT_InterfaceMethodref_info\n\n这三种常量类型结构比较类似\n\n```plain text\nCONSTANT_Fieldref_info {\n    u1 tag;\n    u2 class_index;\n    u2 name_and_type_index;\n}\n\nCONSTANT_Methodref_info {\n    u1 tag;\n    u2 class_index;\n    u2 name_and_type_index;\n}\n\nCONSTANT_InterfaceMethodref_info {\n    u1 tag;\n    u2 class_index;\n    u2 name_and_type_index;\n}\n```\n\n下面以 CONSTANT_Methodref_info 为例来介绍如何描述一个方法。\n\n方法 = 方法所属的类 + 方法名 + 方法参数和返回值描述符\n\n这就是 CONSTANT_Methodref_info 的作用，它表示类中方法的符号引用\n\n它由三部分构成\n\n- 第一部分也是 tag，值为 10\n- 第二个部分是 class_index，是一个指向 CONSTANT_Class_info 的常量池索引值\n- 第三部分是 name_and_type_index，是一个指向 CONSTANT_NameAndType_info 的常量池索引值，表示方法的参数类型和返回值的签名\n\n```java\npublic class HelloWorldMain {\n    public static void main(String[] args) {\n        new HelloWorldMain().testMethod(1, \"hi\");\n    }\n    public void testMethod(int id, String name) {\n    }\n}\n```\n\nConstant pool:\n\n```plain text\n   #2 = Class              #18            // HelloWorldMain\n   #5 = Methodref          #2.#20         // HelloWorldMain.testMethod:(ILjava/lang/String;)V\n  #20 = NameAndType        #13:#14        // testMethod:(ILjava/lang/String;)V\n```\n\n结构布局示意图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125200.png)\n\n#### CONSTANT_NameAndType_info\n\nCONSTANT_NameAndType_info 结构用来表示字段或者方法，格式如下：\n\n```plain text\nCONSTANT_NameAndType_info {\n    u1 tag;\n    u2 name_index;\n    u2 descriptor_index;\n}\n```\n\n它由三部分组成：\n\n- tag : 值为 12\n- name_index : 指向常量池中的 CONSTANT_Utf8_info，存储的是字段名或者方法名\n- descriptor_index : 也是指向常量池中的 CONSTANT_Utf8_info，存储的是字段描述符或者方法描述符\n\n以下面的方法为例：\n\n```java\npublic void testMethod(int id, String name) {\n}\n```\n\nCONSTANT_NameAndType_info 的结构布局示意图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125221.png)\n\n#### CONSTANT_MethodType_info、CONSTANT_MethodHandle_info 和 CONSTANT_InvokeDynamic_info\n\n从 JDK1.7 开始，为了更好的支持动态语言调用，新增了以上 3 种常量池类型。\n\n以 CONSTANT_InvokeDynamic_info 为例，它主要为 invokedynamic 指令提供启动引导方法，它由三部分构成：\n\n```plain text\nCONSTANT_InvokeDynamic_info {\n    u1 tag;\n    u2 bootstrap_method_attr_index;\n    u2 name_and_type_index;\n}\n```\n\n- tag：值为 18\n- bootstrap_method_attr_index：指向引导方法表 bootstrap_methods[] 数组的索引\n- name_and_type_index：指向索引类常量池里 CONSTANT_NameAndType_info，表示方法描述符\n\n比如下面的的代码：\n\n```java\npublic void foo() {\n    new Thread (()-\u003e {\n        System.out.println(\"hello\");\n    }).start();\n}\n```\n\njavap 输出的常量池的部分如下：\n\n```plain text\nConstant pool:\n   #3 = InvokeDynamic      #0:#25         // #0:run:()Ljava/lang/Runnable;\n   ...\n  #25 = NameAndType        #37:#38        // run:()Ljava/lang/Runnable;\n\nBootstrapMethods:\n  0: #22 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #23 ()V\n      #24 invokestatic HelloWorldMain.lambda$foo$0:()V\n      #23 ()V\n```\n\n整体的结构如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125251.png)\n\n## 类访问标记(Access Flags)\n\n常量池之后存储的是访问标记（Access flags），用来标识一个类是是不是 final、abstract 等，由两个字节表示总共可以有 16 个标记位可供使用，目前只使用了其中的 8 个。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125310.png)\n\n具体的标记位含义如下\n\n| Flag Name      | Value | Interpretation                         |\n| -------------- | ----- | -------------------------------------- |\n| ACC_PUBLIC     | 1     | 标识是否是 public                      |\n| ACC_FINAL      | 10    | 标识是否是 final                       |\n| ACC_SUPER      | 20    | 已经不用了                             |\n| ACC_INTERFACE  | 200   | 标识是类还是接口                       |\n| ACC_ABSTRACT   | 400   | 标识是否是 abstract                    |\n| ACC_SYNTHETIC  | 1000  | 编译器自动生成，不是用户源代码编译生成 |\n| ACC_ANNOTATION | 2000  | 标识是否是注解类                       |\n| ACC_ENUM       | 4000  | 标识是否是枚举类                       |\n\nJVM 并没有穷举所有的访问标志，而是使用按位或操作来进行描述的，比如某个类的修饰符为 Public Final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010=0x0011。\n\n## 类索引（This Class）、超类索引（Super Class）和接口表索引（Interfaces）\n\n这三个部分用来确定类的继承关系，this_class 表示类索引，super_name 表示父类索引，interfaces 表示类或者接口的直接父接口。以 this_class 为例，它是一个两字节组成，执行常量池。\n\n以下面代码为例：\n\n```java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World\");\n    }\n}\n```\n\nthis_class 为 0x0005，指向常量池中下标为 5 的元素，这个元素是由两部分组成，第一部分是类型，这里是 Class 表示是一个类，第二部分是指向常量池下标 21 的元素，这个元素是字符串 \"HelloWorldMain\"。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125327.png)\n\nsuper_class 和 interfaces 的原理与之类似。\n\n## 字段表（Fields）\n\n### 字段表概述\n\n紧随接口索引表之后的是字段表（Fields），类中定义的字段会被存储到这个集合中，包括类中定义的静态和非静态的字段，不包括方法内部定义的变量。\n\n结构如下:\n\n```java\n{\n    u2             fields_count;\n    field_info     fields[fields_count];\n}\n```\n\n由两部分组成\n\n- 字段数量（fields_count）：字段表也是一个变长的结构，类中定义的若干个字段的个数会被存储到字段数量里。\n- 字段集合（fields）：字段集合是一个类数组的结构，共有 fields_count 个，对应类中定义的若干个字段，每一个字段 field_info 的结构会在下面介绍。\n\n如下图所示:\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125345.png)\n\n### 字段结构\n\n每个字段（field_info）的格式如下：\n\n```plain text\nfield_info {\n    u2             access_flags; \n    u2             name_index;\n    u2             descriptor_index;\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n字段结构分为四部分：\n\n- access_flags：字段的访问标记。是 public、private 还是 protected，是否是 static，是否是 final 等。\n- name_index：字段名的索引值，指向常量池的的字符串常量。\n- descriptor_index：字段描述符的索引，指向常量池的字符串常量。\n- attributes_count、attribute_info：属性的个数和属性集合。\n\n这些组成部分接下来的会有详细介绍。\n\n### 字段访问标记\n\n与类一样，字段也拥有自己的字段访问标记，不过要比类的访问标记要更丰富一些，共有 9 种，详细的列表如下：\n\n| 访问标记名    | 十六进制值 | 描述                                                      |\n| ------------- | ---------- | --------------------------------------------------------- |\n| ACC_PUBLIC    | 0x0001     | 声明为 public                                             |\n| ACC_PRIVATE   | 0x0002     | 声明为 private                                            |\n| ACC_PROTECTED | 0x0004     | 声明为 protected                                          |\n| ACC_STATIC    | 0x0008     | 声明为 static                                             |\n| ACC_FINAL     | 0x0010     | 声明为 final                                              |\n| ACC_VOLATILE  | 0x0040     | 声明为 volatile，解决内存可见性的问题                     |\n| ACC_TRANSIENT | 0x0080     | 声明为 transient，被 transient 修饰的字段默认不会被序列化 |\n| ACC_SYNTHETIC | 0x1000     | 表示这个字段是由编译器自动生成，而不是用户代码编译产生    |\n| ACC_ENUM      | 0x4000     | 表示这是一个枚举类型的变量                                |\n\n如果在类中定义了如下的字段：\n\n```java\npublic static final int DEFAULT_SIZE = 128;\n```\n\n编译后 DEFAULT_SIZE 字段在类文件中存储的访问标记值为 0x0019，则它的访问标记为 ACC_PUBLIC | ACC_STATIC | ACC_FINAL，表示它是一个 public static final 类型的变量。如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125404.png)\n\n### 字段描述符\n\n当定义一个 int 类型的变量时，类文件中存储的类型并不是字符串的 “int”，而是使用了更精简的 I 来表示。\n\n\u003cstrong\u003e引用类型\u003c/strong\u003e使用 “L;” 的方式来表示为了防止多个连续的引用类型描述符出现混淆，引用类型描述符最后都加上了一个 “;” 作为分隔。比如字符串类型 String 的描述符为  “Ljava/lang/String;\"，\n\nJVM 使用一个前置的 “[” 来表示数组类型，如 int[] 类型描述符为 “[I”，字符串数组 String[] 的描述符为 “[Ljava/lang/String;”。多维数组描述符只是多加了几个 “[” 而已，比如 Object[][][] 类型描述符为 “[[[Ljava/lang/Object;”。\n\n完整的字段类型描述符映射表如下所示：\n\n| 描述符        | 类型                                     |\n| ------------- | ---------------------------------------- |\n| B             | byte 类型                                |\n| C             | char 类型                                |\n| D             | double 类型                              |\n| F             | float 类型                               |\n| I             | int 类型                                 |\n| J             | long 类型                                |\n| S             | short 类型                               |\n| Z             | bool 类型                                |\n| L ClassName ; | 引用类型，\"L\" + 对象类型的全限定名 + \";\" |\n| [             | 一维数组                                 |\n\n### 字段属性表\n\n与字段相关的属性有下面这几个：ConstantValue、Synthetic 、Signature、Deprecated、RuntimeVisibleAnnotations 和 RuntimeInvisibleAnnotations 这六个，比较常见的是 ConstantValue 这属性，用来表示一个常量字段的值。\n\n### 案例分析\n\n以文章开头 ByteCodeDemo 类的字节码中的字段表为例，如下图所示。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125423.png)\n\n0001：字段表计数。实例代码中只有一个字段，故值为 1\n\n剩下为字段属性，一共由四个部分组成：\n\n1. 0002：表示字段的访问标志。对应为 Private\n2. 0007：字段名称。指向常量池中第 7 项：字符 “a”\n3. 0008：字段描述符。指向常量池中第 8 项：字符 “I”（代表 int）\n4. 0000：字段属性个数。没有属性，值为 0\n\n综上，就可以唯一确定出一个类中声明的变量：private int a。\n\n## 方法表（Methods）\n\n### 方法表概述\n\n在字段表后面的是方法表，类中定义的方法会被存储在这里，与前面介绍的字段表很类似，方法表也是一个变长结构：\n\n```java\n{\n    u2             methods_count;\n    method_info    methods[methods_count];\n}\n```\n\n由表示方法个数的 methods_count 和对应个数的方法项集合组成，如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125440.png)\n\n### 方法结构\n\n每个字段（method_info）的格式如下：\n\n```plain text\nmethod_info {\n    u2             access_flags;\n    u2             name_index;\n    u2             descriptor_index;\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n字段结构分为四部分：\n\n- access_flags：方法的访问标记。是 public、private 还是 protected，是否是 static，是否是 final 等。\n- name_index：方法名的索引值，指向常量池的的字符串常量。\n- descriptor_index：方法描述符的索引，指向常量池的字符串常量。\n- attributes_count、attribute_info：属性的个数和属性集合。\n\n### 方法访问标记\n\n方法的访问标记比类和字段的访问标记类型更丰富，有 12 种之多，如下表所示：\n\n| 方法访问标记     | 值     | 描述                                                          |\n| ---------------- | ------ | ------------------------------------------------------------- |\n| ACC_PUBLIC       | 0x0001 | 声明为 public                                                 |\n| ACC_PRIVATE      | 0x0002 | 声明为 private                                                |\n| ACC_PROTECTED    | 0x0004 | 声明为 protected                                              |\n| ACC_STATIC       | 0x0008 | 声明为 static                                                 |\n| ACC_FINAL        | 0x0010 | 声明为 final                                                  |\n| ACC_SYNCHRONIZED | 0x0020 | 声明为 synchronized                                           |\n| ACC_BRIDGE       | 0x0040 | bridge 方法, 由编译器生成                                     |\n| ACC_VARARGS      | 0x0080 | 方法包含可变长度参数，比如 String... args                     |\n| ACC_NATIVE       | 0x0100 | 声明为 native                                                 |\n| ACC_ABSTRACT     | 0x0400 | 声明为 abstract                                               |\n| ACC_STRICT       | 0x0800 | 声明为 strictfp，表示使用 IEEE-754 规范的精确浮点数，极少使用 |\n| ACC_SYNTHETIC    | 0x1000 | 表示这个方法是由编译器自动生成，而不是用户代码编译产生        |\n\n以下面的代码为例：\n\n```java\nprivate static synchronized void foo() {\n}\n```\n\n生成的类文件中 foo 方法的访问标记等于 0x002a（ACC_PRIVATE | ACC_STATIC | ACC_SYNCHRONIZED），，表示这是一个 private static synchronized 的方法，如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125456.png)\n\n### 方法名与描述符\n\n紧随方法访问标记是方法名索引 name_index，指向常量池中 CONSTANT_Utf8_info 类型的字符串常量，比如有这样一个方法定义 “private void foo()”，编译器会生成一个类型为 CONSTANT_Utf8_info 的字符串常量项，里面存储了 “foo”，方法名索引 name_index 指向了这个常量项。\n\n方法描述符索引 descriptor_index，它也是方法名指向常量池中类型为 CONSTANT_Utf8_info 的字符串常量项。方法描述符用来表示一个方法所需参数和返回值，格式为：\n\n(参数 1 类型 参数 2 类型 参数 3 类型 ...)返回值类型\n\n比如方法 “Object foo(int i, double d, Thread t)” 的描述符为“(IDLjava/lang/Thread;)Ljava/lang/Object;”，其中 “I” 表示第一个参数 i 的参数类型 int，“D” 表示第二个参数 d 的类型 double，“Ljava/lang/Thread;” 表示第三个参数 t 的类型 Thread，“Ljava/lang/Object;” 表示返回值类型 Object。\n\n如下图所示:\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125513.png)\n\n### 方法属性表\n\n前面介绍了方法的访问标记、方法签名，还有一些重要的信息没有出现，如方法声明抛出的异常，方法的字节码，方法是否被标记为 deprecated，这些信息存在哪里呢？这就是方法属性表的作用。跟方法相关的属性有很多，其中重要的是 Code 和 Exceptions 属性，其中 Code 属性存放方法体的字节码指令，Exceptions 属性用于存储方法声明抛出的异常。\n\n### 案例分析\n\n还是以文章中 ByteCodeDemo 类的字节码中的字段表为例，如下图所示。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125530.png)\n\n共分为四个部分：\n\n1. 0001：方法访问标记。表示 public\n2. 0010：方法名的索引值。指向第 16 个常量，即 “add”\n3. 0011：方法描述符的索引。指向第 17 个常量，即 ()I（返回值类型为 int）\n4. 0001000b...：属性表。0001 表示只有一个属性，000b 表示属性名称为 “Code”，具体分析见下文\n\n## 属性表（Attributes）\n\n### 属性表概述\n\n在方法表之后的结构是 class 文件的最后一步部分属性表。\u003cstrong\u003e属性出现的地方比较广泛，不止出现在字段和方法中，在 class 文件中也会出现。\u003c/strong\u003e\n\n相比于常量池只有 14 种固定的类型，属性表是的类型是更加灵活的，不同的虚拟机实现厂商可以自定义自己的属性，JVM 运行时会忽略掉它不认识的属性。\n\n属性表的结构如下所示：\n\n```java\n{\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n与其它结构类似，属性表使用两个字节表示属性的个数 attributes_count，接下来是若干个属性项的集合，可以看做是一个数组，数组的每一项都是一个属性项 attribute_info，数组的大小为 attributes_count。\n\n### 属性结构\n\n每个属性（attribute_info）的格式如下：\n\n```plain text\nattribute_info {\n    u2 attribute_name_index;\n    u4 attribute_length;\n    u1 info[attribute_length];\n}\n```\n\n属性结构分为三部分：\n\n- attribute_name_index：属性名索引\n- attribute_length：属性长度\n- info[attribute_length]：属性数组\n\n属性表其实只是定义了属性的长度，里面还有一个不定长的数组，具体的结构需要自己定义。\n\n### 属性类型\n\n| 属性名称                            | 使用位置           | 含义                                                                                              |\n| ----------------------------------- | ------------------ | ------------------------------------------------------------------------------------------------- |\n| Code                                | 方法表             | Java 代码编译成的字节码指令                                                                       |\n| ConstantValue                       | 字段表             | final 关键字定义的常量池                                                                          |\n| Deprecated                          | 类，方法表，字段表 | 被声明为 deprecated 的方法和字段                                                                  |\n| Exceptions                          | 方法表             | 方法抛出的异常                                                                                    |\n| EnclosingMethod                     | 类文件             | 仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法              |\n| InnerClass                          | 类文件             | 内部类列表                                                                                        |\n| LineNumberTable                     | Code 属性          | Java 源码的行号与字节码指令的对应关系                                                             |\n| LocalVariableTable                  | Code 属性          | 方法的局部变量描述                                                                                |\n| StackMapTable                       | Code 属性          | JDK1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配 |\n| Signature                           | 类，方法表，字段表 | 用于支持泛型情况下的方法签名                                                                      |\n| SourceFile                          | 类文件             | 记录源文件名称                                                                                    |\n| SourceDebugExtension                | 类文件             | 用于存储额外的调试信息                                                                            |\n| Synthetic                           | 类，方法表，字段表 | 标志方法或字段为编译器自动生成的                                                                  |\n| LocalVariableTypeTable              | 类                 | 使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加                          |\n| RuntimeVisibleAnnotations           | 类，方法表，字段表 | 为动态注解提供支持                                                                                |\n| RuntimeInvisibleAnnotations         | 表，方法表，字段表 | 用于指明哪些注解是运行时不可见的                                                                  |\n| RuntimeVisibleParameterAnnotation   | 方法表             | 作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法                                   |\n| RuntimeInvisibleParameterAnnotation | 方法表             | 作用与 RuntimeInvisibleAnnotations 属性类似，作用对象哪个为方法参数                               |\n| AnnotationDefault                   | 方法表             | 用于记录注解类元素的默认值                                                                        |\n| BootstrapMethods                    | 类文件             | 用于保存 invokeddynamic 指令引用的引导方式限定符                                                  |\n\n### ConstantValue 属性\n\nConstantValue 属性只会出现字段 field_info 中，表示静态变量的初始值，它的结构如下：\n\n```plain text\nConstantValue_attribute {\n    u2 attribute_name_index;\n    u4 attribute_length;\n    u2 constantvalue_index;\n}\n```\n\n其中 attribute_name_index 是指向常量池中值为 \"ConstantValue\" 的常量项，ConstantValue 属性的 attribute_length 值恒定为 2，constantvalue_index 指向常量池中具体的常量值索引，根据变量的类型不同 constantvalue_index 指向不同的常量项。\n\n以 “public static final int DEFAULT_SIZE = 128;” 为例，字段对应的 class 文件如下图高亮部分：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125546.png)\n\n它对应的字段结构如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125607.png)\n\n### Code 属性\n\nCode 属性可以说是类文件中最重要的组成部分了，它包含了所有方法的字节码，结构如下：\n\n```plain text\nCode_attribute {\n    u2 attribute_name_index;\n    u4 attribute_length;\n    u2 max_stack;\n    u2 max_locals;\n    u4 code_length;\n    u1 code[code_length];\n    u2 exception_table_length;\n    {   u2 start_pc;\n        u2 end_pc;\n        u2 handler_pc;\n        u2 catch_type;\n    } exception_table[exception_table_length];\n    u2 attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\nCode 属性表的字段含义如下：\n\n- 属性名索引（attribute_name_index）占两个字节，指向常量池中 CONSTANT_Utf8_info 常量，表示属性的名字，比如这里对应的常量池的字符串常量\"Code\"。\n- 属性长度（attribute_length）占用两个字节，表示属性值大小。\n- max_stack 表示操作数栈的最大深度，方法执行的任意期间操作数栈的深度都不会超过这个值。它的计算规则是有入栈的指令 stack 增加，有出栈的指令 stack 减少，在整个过程中 stack 的最大值就是 max_stack 的值，增加和减少的值一般都是 1，但也有例外：LONG 和 DOUBLE 相关的指令入栈 stack 会增加 2，VOID 相关的指令则为 0。\n- max_locals 表示局部变量表的大小，它的值并不是等于方法中所有局部变量的数量之和。当一个局部作用域结束，它内部的局部变量占用的位置就可以被接下来的局部变量复用了。\n- code_length 和 code 用来表示字节码相关的信息，其中 code_length 表示字节码指令的长度，占用 4 个字节。code 是一个长度为 code_length 的字节数组，存储真正的字节码指令。\n- exception_table_length 和 exception_table 用来表示代码内部的异常表信息，如我们熟知的 try-catch 语法就会生成对应的异常表。\n- attributes_count 和 attributes[] 用来表示 Code 属性相关的附属属性，Java 虚拟机规定 Code 属性只能包含这四种可选属性：LineNumberTable、LocalVariableTable、LocalVariableTypeTable、StackMapTable。以 LineNumberTable 为例，LineNumberTable 用来存放源码行号和字节码偏移量之间的对应关系，这 LineNumberTable 属于调试信息，不是类文件运行的必需的属性，默认情况下都会生成。如果没有这两个属性，那么在调试时没有办法在源码中设置断点，也没有办法在代码抛出异常的时候在错误堆栈中显示出错的行号信息。\n\n以下面的代码为例：\n\n```java\npublic static void main(String[] args) {\n    try {\n        foo();\n    } catch (NullPointerException e) {\n        System.out.println();\n    } catch (IOException e) {\n        System.out.println();\n    }\n\n    try {\n        foo();\n    } catch (Exception e) {\n        System.out.println();\n    }\n}\n```\n\n如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125622.png)\n\n### 案例分析\n\n同样以 ByteCodeDemo 类的字节码为例，如下图所示。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125755.png)\n\n0001 表示为属性表计数，这里只有一个附加属性。属性表\n\n```plain text\nSourceFile_attribute {\n     u2 attribute_name_index;\n     u4 attribute_length;\n     u2 sourcefile_index;\n}\n```\n\nSourceFile_attribute 一共分为三个部分。\n\n0014：指向第 20 个常量，为 “SourceFile”，说明这个属性是 Source\n\n00000002：表示长度为 2\n\n0015：指向第 21 个常量，即 “ByteCodeDemo.java”\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["JVM","字节码","Java"]},"/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6":{"title":"JVM 类加载机制","content":"\n# 概述\n\nJVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 Java 类型，这个过程被称作 JVM 的类加载机制。\n\n与那些在编译时需要进行连接的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。\n\n# 类加载的时机\n\n一个类型从被加载到虚拟机内存中开始到卸载位置，整个生命周期会经历如下七个阶段，其中验证、准备、解析三个部分统称为连接。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/ClassLoader/clipboard_20230323_120031.png)\n上图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段后再开始，这是为了支持 Java 语言的运行时半丁特性（也被称为动态绑定或者晚期绑定）。\n\n## 主动引用\n\n关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java 虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java 虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证和准备阶段自然需要在此之前开始）：\n\n- 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这四条指令的场景是：\n\n  - 使用 new 关键字实例化对象的时候。\n  - 读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。\n  - 调用一个类的静态方法的时候。\n- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。\n- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；\n- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n- 当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\n\n## 被动引用\n\n以上六种场景中的行为称为对一个类型进行主动引用，除此之外所有引用类型的方式都不会触发初始化，被称为被动引用。\n\n```java\npublic class SuperClass {\n    static {\n        System.out.println(\"SuperClass init!\");\n    }\n\n    public static int value = 123;\n}\n\npublic class SubClass extends SuperClass {\n    static {\n        System.out.println(\"SubClass init!\");\n    }\n    \n    public static final String CONS = \"hello\";\n}\n```\n\n- 通过子类引用父类的静态字段，不会导致子类初始化\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(SubClass.value);\n    }\n}\n输出结果：\nSuperClass init!\n123\n```\n\n- 通过数组定义来引用类，不会触发此类的初始化\n\n该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        SuperClass[] sca = new SuperClass[10];\n    }\n}\n没有任何输出\n```\n\n- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(SubClass.CONS);\n    }\n}\n输出结果：\nhello\n```\n\n# 类加载的过程\n\n类加载的过程包含了加载、验证、准备、解析和初始化这 5 个阶段。\n\n## 加载\n\n这里的加载指的是类加载的一个阶段，注意不要混淆。\n\n加载过程完成以下三件事：\n\n- 通过类的\u003cstrong\u003e完全限定名称\u003c/strong\u003e获取定义该类的二进制字节流。\n- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。\n- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。\n\n其中二进制字节流可以从以下方式中获取：\n\n- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。\n- 从网络中获取，最典型的应用是 Applet。\n- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。\n- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。\n- 从数据库中读取，这种场景相对比较少见。\n- 从加密文件中获取，这是典型的防 Class 文件被反编译的保护措施，通过加载时解密 Class 文件来保障程序运行逻辑不被窥探。\n\n## 验证\n\n验证流程确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成下面四个阶段的动作。\n\n### 文件格式验证\n\n主要验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。\n\n### 元数据验证\n\n对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语言规范》的要求。\n\n### 字节码验证\n\n通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这个阶段就要对类的方法体（Class 文件中的 Code 属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。这个阶段是整个验证过程中最复杂的一个阶段。\n\n### 符号引用验证\n\n这个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配行校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。\n\n符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，JVM 将会抛出异常。\n\n## 准备\n\n准备阶段时正式为类中定义的变量（即被 static 修饰的静态变量）\u003cstrong\u003e分配内存并设置类变量初始值\u003c/strong\u003e的阶段。\n\n实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。\n\n类变量初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。\n\npublic static int value = 123;\n\n把 value 赋值为 123 的 putstatic 指令要到类的初始化阶段中执行类构造器 `\u003cclinit\u003e() `方法时才会被执行。\n\n如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。\n\npublic static final int value = 123;\n\n## 解析\n\n解析阶段是 JVM 将常量池的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行。\n\n解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。\n\n## 初始化\n\n初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 `\u003cclinit\u003e()` 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序制定的主观计划去初始化类变量和其它资源。\n\n- `\u003cclinit\u003e()` 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：\n\n```java\npublic class Test {\n    static {\n        i = 0;                // 给变量赋值可以正常编译通过\n        System.out.print(i);  // 这句编译器会提示“非法向前引用”\n    }\n    static int i = 1;\n}\n```\n\n- 由于父类的 `\u003cclinit\u003e()` 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：\n\n```java\nstatic class Parent {\n    public static int A = 1;\n    static {\n        A = 2;\n    }\n}\n\nstatic class Sub extends Parent {\n    public static int B = A;\n}\n\npublic static void main(String[] args) {\n     System.out.println(Sub.B);  // B 的值为 2\n}\n```\n\n- `\u003cclinit\u003e() `方法对于类或接口来说不是必需的。\n- 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 `\u003cclinit\u003e()` 方法。但接口与类不同的是，执行接口的 `\u003cclinit\u003e()` 方法不需要先执行父接口的 `\u003cclinit\u003e()` 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 `\u003cclinit\u003e()` 方法。\n- 虚拟机会保证一个类的 `\u003cclinit\u003e()` 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 `\u003cclinit\u003e()` 方法，其它线程都会阻塞等待，直到活动线程执行 `\u003cclinit\u003e()` 方法完毕。如果在一个类的 `\u003cclinit\u003e()` 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞往往是很隐蔽的。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/ClassLoader/clipboard_20230323_120337.png)\n\n# 类加载器\n\nJava 虚拟机设计团队有意把了加载阶段中的“通过一个类的全限定名称来获取描述该类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器（Class Loader）”。\n\n## 类与类加载器\n\n对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。\n\n换句话说，虚拟句认定两个类是否相等，除了需要比较类本身相等之外，并且还要判断它们是否使用同一个类加载器进行加载，因为每一个类加载器都拥有一个独立的类名称空间。\n\n这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。\n\n## 类加载器的分类\n\n从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：\n\n- 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；\n- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。\n\n从 Java 开发人员的角度看，类加载器可以划分得更细致一些：\n\n##### \u003cstrong\u003e启动类加载器（Bootstrap ClassLoader）\u003c/strong\u003e\n\n此类加载器负责将存放在 \u003cJRE_HOME\u003e\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（\u003cstrong\u003e仅按照文件名识别\u003c/strong\u003e，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。\n\n##### \u003cstrong\u003e扩展类加载器（Extension ClassLoader）\u003c/strong\u003e\n\n这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 \u003cJAVA_HOME\u003e/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。\n\n##### \u003cstrong\u003e应用程序类加载器（Application ClassLoader）\u003c/strong\u003e\n\n这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为\u003cstrong\u003e系统类加载器\u003c/strong\u003e。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n## 双亲委派模型\n\n应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。\n\n下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/ClassLoader/clipboard_20230323_120403.png)\n\n### 工作过程\n\n一个类加载器收到加载请求，首先将类加载请求转发到\u003cstrong\u003e父类加载器\u003c/strong\u003e，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类加载器无法完成时，子加载器才尝试自己去加载。\n\n### 优点\n\n1. 避免重复加载。\n2. 防止 Java 核心 api 被篡改\n\n### 实现过程\n\n以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。\n\n```java\npublic abstract class ClassLoader {\n    // The parent class loader for delegation\n    private final ClassLoader parent;\n\n    public Class\u003c?\u003e loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n\n    protected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class\u003c?\u003e c = findLoadedClass(name);\n            if (c == null) {\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    c = findClass(name);\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n\n    protected Class\u003c?\u003e findClass(String name) throws ClassNotFoundException {\n        throw new ClassNotFoundException(name);\n    }\n}\n\n```\n","lastmodified":"2023-03-23T02:32:34.362209967Z","tags":["JVM","类加载机制","Java"]},"/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B":{"title":"Java 内存模型","content":"\n## JMM 是什么？\n\nJMM 是和多线程相关的一组规范，它 定义了 JVM 在计算机内存中的工作方式，需要各个 JVM 的实现来遵守 JMM 规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。这样，即便同一个程序在不同的虚拟机上运行，得到的程序结果也是一致的，从而保证了“一次编译，处处运行”。\n\n因此，JMM 与处理器、缓存、并发、编译器有关。它解决了 CPU 多级缓存、处理器优化、指令重排等导致的结果不可预期的问题。\n\n比如关键字 synchronized，JVM 就会在 JMM 的规则下，“翻译”出合适的指令，包括限制指令之间的顺序，以便在即使发生了重排序的情况下，也能保证必要的“可见性”。这样一来，不同的 JVM 对于相同的代码的执行结果就变得可预期了，Java 程序员就只需要用同步工具和关键字就可以开发出正确的并发程序了。\n\n## JMM 抽象结构\n\nJava 作为高级语言，他向开发者屏蔽了多层缓存等底层细节，用 JMM 定义了一套读写数据的规范。Java 线程之间的通信由 JMM 控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：\n\n- 线程之间的共享变量存储在主内存中；\n- 每个线程只能够直接接触到本地内存，无法直接操作主内存；\n- 每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。\n\n本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Java-Memory-Model/clipboard_20230323_103037.png)\n\n## 内存间交互操作\n\nJava 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Java-Memory-Model/clipboard_20230323_103049.png)\n\n- read：把一个变量的值从主内存传输到工作内存中\n- load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中\n- use：把工作内存中一个变量的值传递给执行引擎\n- assign：把一个从执行引擎接收到的值赋给工作内存的变量\n- store：把工作内存的一个变量的值传送到主内存中\n- write：在 store 之后执行，把 store 得到的值放入主内存的变量中\n- lock：作用于主内存的变量\n- unlock\n\n## JMM 三大特性\n\n### 原子性\n\n如果一个或者一系列的操作，要么全部执行成功，要么全部不执行，不会出现执行一半就终止的情况，则认为此操作具有原子性。\n\n具有原子性的操作有：\n\n- （非 64 位 JDK）除 long 和 double 之外的基本类型（int、byte、boolean、short、char、float）的读 / 写操作；\n- 所有引用 reference 的读 / 写操作；\n- java.concurrent.Atomic.* 包中的一部分类的一部分方法是具备原子性的，比如 AtomicInteger 的 incrementAndGet 方法；\n- 加了 volatile 后，所有变量的读 / 写操作（包含 long 和 double）。这也就意味着 long 和 double 加了 volatile 关键字之后，对它们的读写操作同样具备原子性。\n\n### 可见性\n\n即内存可见性，是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n因为工作内存之间的通信，都需要通过主内存来中转。正是由于所有的共享变量都存在于主内存中，每个线程有自己的工作内存，其中存储的是变量的副本，所以这个副本就有可能是过期的，也就是与主内存不是同步的。比如，当 B 线程从主内存中同步共享变量 V 的时候，就有可能出现与 A 线程的变量 V 的副本不一致的情况，则称线程 A 对变量 V 的操作对于线程 B 不具备可见性了。\n\n主要有三种实现可见性的方式：\n\n- \u003cstrong\u003evolatile \u003c/strong\u003e—— 用于保证单个变量的可见性；\n- \u003cstrong\u003esynchronized \u003c/strong\u003e—— 对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。\n- \u003cstrong\u003efinal \u003c/strong\u003e—— 被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。\n\n单个变量要保证内存可见性，可以使用 volitale 关键字修饰。synchronized 关键字也可以保证内存可见性。\n\n### 有序性\n\n一个 Java 程序，包含一系列的语句，开发者默认期望这些语句的实际运行顺序和写的代码顺序一致。但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整，这就是重排序。\n\n这些重排序在单线程环境中不会影响程序执行，但是可能会导致\u003cstrong\u003e多线程程序\u003c/strong\u003e出现内存可见性问题。JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。\n\n要实现多线程环境下的有序性，可以通过两种方式实现：\n\n\u003cstrong\u003evolatile \u003c/strong\u003e—— 通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。\n\n\u003cstrong\u003esynchronized\u003c/strong\u003e —— 保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。\n\n## happens-before 规则\n\nHappens-before 关系是用来描述和可见性相关问题的：如果第一个操作 happens-before 第二个操作（也可以描述为，第一个操作和第二个操作之间满足 happens-before 关系），那么我们就说第一个操作对于第二个操作一定是可见的，也就是第二个操作在执行时就一定能保证看见第一个操作执行的结果。\n\n从 JDK 5 开始，Java 使用新的 JSR-133 内存模型，而 JSR-133 使用 happens-before 的概念来阐述操作之间的内存可见性。在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。\n\nhappens-before 规则如下：\n\n- 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。\n- 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。\n- volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\n- start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程 B），那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作。\n- join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。\n- interupt()规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。\n- 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。\n\n## volitale\n\n第一个作用是保证可见性。如果变量被 volatile 修饰，那么每次修改之后，接下来在读取这个变量的时候一定能读取到该变量最新的值。这是由 hanppens-before 规则保证的。\n\n第二个的作用就是禁止重排序。先介绍一下 as-if-serial 语义：不管怎么重排序，（单线程）程序的执行结果不会改变。在满足 as-if-serial 语义的前提下，由于编译器或 CPU 的优化，代码的实际执行顺序可能与我们编写的顺序是不同的，这在单线程的情况下是没问题的，但是一旦引入多线程，这种乱序就可能会导致严重的线程安全问题。用了 volatile 关键字就可以在一定程度上禁止这种重排序。\n\n但是特别注意，使用 volitale 修饰的变量并不能保证对它操作的原子性，比如 int 类型数据的 ++ 操作（它会分三步：Load、Add、Store）。\n\nvolatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。\n\n## synchronized\n\nsynchronized 包裹的代码块或者它所修饰的方法中的操作是具备原子性的。它会设立一个临界区，在一个线程操作临界区内的数据的时候，另一个线程无法进来同时操作。它利用对其他线程的排他性来实现保证操作原子性。\n\nsynchronized 不仅保证了临界区内最多同时只有一个线程执行操作，同时还保证了在前一个线程释放锁之后，之前所做的所有修改，都能被获得同一个锁的下一个线程所看到，也就是能读取到最新的值。因此 synchronized 也能够避免内存可见性问题。\n\n在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常称之为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。针对每个类也有一个锁，可以称为“类锁”，类锁实际上是就是类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。\n\nMonitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有\n\n一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中有\n\n一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。Monitor 是\n\n依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的线程同步。\n\n## final\n\nJMM 对 final 域遵守如下两个重排序规则：\n\n1. 在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。\n2. 初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。\n\n以上两个规则就限制了 final 域的初始化必须在构造函数内，不能重排序到构造函数之外，普通变量则可以。具体的操作为：\n\n1. JMM 在 final 域写入和构造函数返回之前，插入一个 StoreStore 内存屏障，静止处理器将 final 域重排序到构造函数之外。\n2. JMM 在初次读 final 域的对象和读对象内 final 域之间插入一个 LoadLoad 内存屏障。\n\n## 单例模式中的 DCL\n\nDCL 单例标准写法：\n\n```java\npublic class Singleton {\n\n    private static volatile Singleton singleton;\n\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n\n\u003cstrong\u003e为什么需要使用 volatile 关键字？\u003c/strong\u003e\n\nsingleton = new Singleton() ，它并非是一个原子操作，事实上，在 JVM 中上述语句至少做了以下这 3 件事：\n\n1. 给 singleton 分配内存空间；\n2. 调用 Singleton 的构造函数等，来初始化 singleton；\n3. 将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。\n\n因为存在指令重排序的优化，也就是说第 2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。\n\n如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，如果这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候就会报错。\n\n\u003cstrong\u003e为什么两次判断 singleton 是否为空？\u003c/strong\u003e\n\n如果去掉第一次 check，那么所有线程获取实例的时候都要进行同步，都会串行执行，效率低下。\n\n对于第二次 check，如果有两个线程同时调用 getInstance 方法，由于 singleton 是空的 ，因此两个线程都可以通过第一重的 if 判断；然后由于锁机制的存在，会有一个线程先进入同步语句，并进入第二重 if 判断 ，而另外的一个线程就会在 synchronized 处等待。当第一个线程执行完 new Singleton() 语句后，就会退出 synchronized 保护的区域，这时如果没有第二重 if (singleton == null) 判断，那么第二个线程也会创建一个实例。\n","lastmodified":"2023-03-23T02:32:34.058210059Z","tags":[]},"/boxcnKB98VZHgFIxeQRre50P10g.png":{"title":"boxcnKB98VZHgFIxeQRre50P10g.png","content":"","lastmodified":"2023-03-23T02:32:34.054210061Z","tags":[]},"/boxcnPibptsxhOwYAQw5Mft93wg.png":{"title":"boxcnPibptsxhOwYAQw5Mft93wg.png","content":"","lastmodified":"2023-03-23T02:32:34.054210061Z","tags":[]}}