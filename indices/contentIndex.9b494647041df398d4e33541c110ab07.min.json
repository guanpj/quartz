{"/":{"title":"AboutTheGardens","content":"## 111111\n\n### hello everyone!\n\n#### 哈哈哈哈哈\n\nsldfjlsajdfl sldfjlasjdlfjsld\nalsjfsd\nldjfsdf sld\n\n## 了散打减肥了\n\nsldfjlsdfj\nThis is my note:[[2023-03-20]]\n\n### 啊啊啊啊啊\n\n#### 手里的积分啦\n\n了散打发**教练**\n我这里讲了泛型：[[泛型]]\n我这里讲了IO：[[IO]]\n\ntoday's note:[[2023-03-22]]\n\nhashmap:[[HashMap 源码解析]]\n\nmore:[[容器类]]\n\nmore:[[JVM 内存区域]]\n\n\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":["本库教程"]},"/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88":{"title":"其他模版","content":"### 史蒂夫\n\nline1: \u003c% tp.file.cursor(1) %\u003e\nline2: \u003c% tp.file.cursor(2) %\u003e","lastmodified":"2023-03-22T16:21:32.006550035Z","tags":[]},"/%E5%AE%B9%E5%99%A8%E7%B1%BB":{"title":"容器类","content":"全家福：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095328.png)\n# Iterable 接口\n\n可迭代的意思，实现此接口允许对象成为“for-each”循环语句的目标，提供 iterator 方法用于遍历元素。\n\n```java\npublic interface Iterable\u003cT\u003e {\n    Iterator\u003cT\u003e iterator();\n\n    default void forEach(Consumer\u003c? super T\u003e action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }\n\n    default Spliterator\u003cT\u003e spliterator() {\n        return Spliterators.spliteratorUnknownSize(iterator(), 0);\n    }\n}\n```\n\nIterator 意思为迭代器，它的定义如下：\n\n```java\npublic interface Iterator\u003cE\u003e {\n    boolean hasNext();\n\n    E next();\n\n    default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n\n    default void forEachRemaining(Consumer\u003c? super E\u003e action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n```\n\n迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的接口。它是一个经典的设计模式——迭代器模式（Iterator）。 迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e当使用 Iterator 对集合元素进行迭代时，Iterator 并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量），所以修改迭代变量的值对集合元素本身没有任何影响。\n\n# Collection 接口\n\nCollection 接口为集合层次的根接口，Collection 框架概览如图：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095429.png)\nCollection 接口中的关键方法定义如下：\n\n```java\npublic interface Collection\u003cE\u003e extends Iterable\u003cE\u003e {\n    // 集合大小\n    int size();\n    // 是否为空\n    boolean isEmpty();\n    // 是否包含此元素 o\n    boolean contains(Object o);\n    // 迭代器\n    Iterator\u003cE\u003e iterator();\n    // 转换成数组\n    Object[] toArray();\n    // 转换成指定类型数组\n    \u003cT\u003e T[] toArray(T[] a);\n    // 添加元素 e\n    boolean add(E e);\n    // 移除元素 o\n    boolean remove(Object o);\n    // 是否包含另一集合 c\n    boolean containsAll(Collection\u003c?\u003e c);\n    // 移除所有集合 c 中的元素\n    boolean removeAll(Collection\u003c?\u003e c);\n    /**\n     * 移除符合条件的元素\n     * @since 1.8\n     */\n    default boolean removeIf(Predicate\u003c? super E\u003e filter) {\n        Objects.requireNonNull(filter);\n        boolean removed = false;\n        final Iterator\u003cE\u003e each = iterator();\n        while (each.hasNext()) {\n            if (filter.test(each.next())) {\n                each.remove();\n                removed = true;\n            }\n        }\n        return removed;\n    }\n    // 判断集合中是否有不存在集合 c 中的元素\n    boolean retainAll(Collection\u003c?\u003e c);\n    // 清空所有元素\n    void clear();\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, 0);\n    }\n    /**\n     * @since 1.8\n     */\n    default Stream\u003cE\u003e stream() {\n        return StreamSupport.stream(spliterator(), false);\n    }\n    /**\n     * @since 1.8\n     */\n    default Stream\u003cE\u003e parallelStream() {\n        return StreamSupport.stream(spliterator(), true);\n    }\n}\n可以看出 Collection 有添加、删除和清除元素等方法。\n```\n\nCollection 接口下属有三个关键子借口，分别为 Set、Queue 和 List。\n\n## Set 接口\n\nSet 集合与 Collection 集合基本相同，没有提供任何额外的方法。实际上 Set 就是 Collection，只是行为略有不同（Set 不允许包含重复元素）。\n\nSet 集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个 Set 集合中，则 add() 方法会返回 false，且新元素不会被加入。\n\n```java\npublic interface Set\u003cE\u003e extends Collection\u003cE\u003e {\n    int size();\n\n    boolean isEmpty();\n\n    boolean contains(Object o);\n\n    Iterator\u003cE\u003e iterator();\n    \n    Object[] toArray();\n\n    \u003cT\u003e T[] toArray(T[] a);\n\n    boolean add(E e);\n\n    boolean remove(Object o);\n\n    boolean containsAll(Collection\u003c?\u003e c);\n\n    boolean addAll(Collection\u003c? extends E\u003e c);\n    \n    boolean removeAll(Collection\u003c?\u003e c);\n\n    void clear();\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT);\n    }\n}\n```\n\n### HashSet 类\n\nHashSet 是 Set 接口的典型实现，实现了 Set 接口中的所有方法，并没有添加额外的方法，大多数时候使用 Set 集合时就是使用这个实现类。使用的底层结构是 HashMap，按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。它的实现如下：\n\n```java\npublic class HashSet\u003cE\u003e extends AbstractSet\u003cE\u003e implements Set\u003cE\u003e {\n    static final long serialVersionUID = -5024744406713321676L;\n\n    private transient HashMap\u003cE,Object\u003e map;\n\n    private static final Object PRESENT = new Object();\n\n    public HashSet() {\n        map = new HashMap\u003c\u003e();\n    }\n\n    public HashSet(Collection\u003c? extends E\u003e c) {\n        map = new HashMap\u003c\u003e(Math.max((int) (c.size()/.75f) + 1, 16));\n        addAll(c);\n    }\n\n    public HashSet(int initialCapacity, float loadFactor) {\n        map = new HashMap\u003c\u003e(initialCapacity, loadFactor);\n    }\n\n    public HashSet(int initialCapacity) {\n        map = new HashMap\u003c\u003e(initialCapacity);\n    }\n\n    // dummy 并没有作用，只是用来区分重载构造方法\n    HashSet(int initialCapacity, float loadFactor, boolean dummy) {\n        map = new LinkedHashMap\u003c\u003e(initialCapacity, loadFactor);\n    }\n\n    public Iterator\u003cE\u003e iterator() {\n        return map.keySet().iterator();\n    }\n\n    public int size() {\n        return map.size();\n    }\n\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    public boolean contains(Object o) {\n        return map.containsKey(o);\n    }\n\n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n\n    public boolean remove(Object o) {\n        return map.remove(o)==PRESENT;\n    }\n\n    public void clear() {\n        map.clear();\n    }\n}\n```\n\n可以看出 HashSet 内部其实是一个 HashMap。它的 add(E e) 方法会调用 HashMap 的 put 方法，插入的值会作为 put 的 key 并且把 PRESENT 作为 put 方法的 value 值进行插入，put 方法新增一个原来不存在的值会返回 null，如果原来存在的话会返回原来存在的值，所以是 HashMap 保证了元素不重复。\n\n#### 特点\n\n- 不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。\n- HashSet 不是线程安全的，如果多个线程同时访问一个 HashSet，则必须通过代码来保证其同步。\n- 集合元素值可以是 null。\n\n#### 添加元素规则\n\n两个对象比较，具体分为如下四个情况：\n\n1. equals() 方法返回 false，hashCode() 方法返回不相等，HashSet 将会把它们存储在不同的位置。\n2. equals() 方法返回 true，hashCode() 方法返回不相等，HashSet 将会把它们存储在不同的位置。\n3. equals() 方法返回 true，hashCode() 方法比较相等，HashSet 将会把它们存储在相同的位置，在这个位置以链表式结构来保存多个对象。这是因为当向 HashSet 集合中存入一个元素时，HashSet 会调用对象的 hashCode() 方法来得到对象的 hashCode 值，然后根据该 hashCode 值来决定该对象存储在 HashSet 中存储位置。\n4. equals() 方法返回 true，hashCode() 方法返回 true，HashSet 将不予添加。\n\n如果 HashSet 中两个以上的元素具有相同的 hashCode 值，将会导致性能下降。所以如果重写类的 equals() 方法和 hashCode() 方法时，应尽量保证两个对象通过 hashCode() 方法返回值相等时，通过 equals() 方法比较返回 true。\n\n### LinkedHashSet 类\n\nLinkedHashSet 是 HashSet 的子类，也是根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素是以插入的顺序来保存的。当遍历 LinkedHashSet 集合里的元素时，LinkedHashSet 将会按元素的添加顺序来访问集合里的元素。但是由于要维护元素的插入顺序，在性能上略低与 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。\n\n它的实现如下：\n\n```java\npublic class LinkedHashSet\u003cE\u003e extends HashSet\u003cE\u003e implements Set\u003cE\u003e {\n\n    private static final long serialVersionUID = -2851667679971038690L;\n\n    public LinkedHashSet(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor, true);\n    }\n\n    public LinkedHashSet(int initialCapacity) {\n        super(initialCapacity, .75f, true);\n    }\n\n    public LinkedHashSet() {\n        super(16, .75f, true);\n    }\n\n    public LinkedHashSet(Collection\u003c? extends E\u003e c) {\n        super(Math.max(2*c.size(), 11), .75f, true);\n        addAll(c);\n    }\n\n    @Override\n    public Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT | \nSpliterator.ORDERED);\n    }\n}\n\n```\n\n可以看到，它的构造方法都是通过调用父类 HashSet 的三个参数的构造方法。\n\nHashSet 的构造分方法如下：\n\n```java\nHashSet(int initialCapacity, float loadFactor, boolean dummy) {\n    map = new LinkedHashMap\u003c\u003e(initialCapacity, loadFactor)\n}\n```\n\nLinkedHashMap 的实现见后文。\n\n### TreeSet 类\n\nTreeSet 是 SortedSet 接口的实现类，正如 SortedSet 名字所暗示的，TreeSet 可以确保集合元素处于排序状态。此外，TreeSet 还提供了几个额外的方法。\n\n#### 主要方法\n\ncomparator()：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。\n\nfirst()：返回此 set 中当前第一个（最低）元素。\n\nlast()：返回此 set 中当前最后一个（最高）元素。\n\nlower(E e)：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。\n\nhigher(E e)：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。\n\nfloor(E e)：返回此 set 中小于等于给定元素的最小值；如果不存在这样的元素，则返回 null。\n\nceiling(E e)：返回此 set 中大于给定元素的最大值；如果不存在这样的元素，则返回 null。\n\nsubSet(E fromElement, E toElement)：返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。\n\nheadSet(E toElement)：返回此 set 的部分视图，其元素小于 toElement。\n\ntailSet(E fromElement)：返回此 set 的部分视图，其元素大于等于 fromElement。\n\n#### 排序方式\n\nTreeSet 中所谓的有序，不同于之前所讲的插入顺序，而是通过集合中元素属性进行排序方式来实现的。TreeSet 支持两种排序方法：自然排序和定制排序。在默认情况下，TreeSet 采用自然排序。\n\n##### \u003cstrong\u003e自然排序\u003c/strong\u003e\n\nTreeSet 会调用集合中元素所属类的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列，即把通过 compareTo(Object obj) 方法比较后比较大的的往后排。这种方式就是自然排序。\n\n除了已经实现 Comparable 接口类（String 和 Integer 等）之外，如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口，否则就会出现异常。\n\n\u003cstrong\u003e注意：\u003c/strong\u003eTreeSet 中只能添加同一种类型的对象，否则无法比较，会出现异常。\n\n当一个对象调用该方法与另一个对象比较时，例如 obj1.compareTo(obj2)，如果该方法返回 0，则表明两个对象相等；如果该方法返回一个正整数，则表明 obj1 大于 obj2；如果该方法返回一个负整数，则表明 obj1 小于 obj2。\n\n##### \u003cstrong\u003e定制排序\u003c/strong\u003e\n\n定制排序是通过 Comparator 接口实现的。该接口包含一个 int compare(T o1,T o2) 方法，该方法用于比较 o1, o2 的大小：如果该方法返回正整数，则表明 o1 大于 o2；如果该方法返回 0，则表明 o1 等于 o2；如果该方法返回负整数，则表明 o1 小于 o2。\n\n如果要实现定制排序，则需要在创建 TreeSet 时，调用一个带参构造器，传入 Comparator 对 象。并有该 Comparator 对象负责集合元素的排序逻辑，此时集合元素可以不必实现 Comparable 接口。\n\n#### 判断元素相等\n\n对于 TreeSet 集合而言，判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较是否返回 0——如果通过 compareTo(Object obj) 方法比较返回 0，TreeSet 则会认为它们相等，不予添加入集合内；否则就认为它们不相等，添加到集合内。\n\n\u003cstrong\u003eTreeSet 是根据红黑树结构找到集合元素的存储位置。\u003c/strong\u003e\n\n注意：\n\n1. 无论使用自然排序还是定制排序，都可以通过自定义比较逻辑实现各种各样的排序方式。\n2. 如果向 TreeSet 中添加了一个可变对象后，并且后面程序修改了该可变对象的实例变量，这将导致它与其他对象的大小顺序发生了改变，但 TreeSet 不会再次调整它们。\n3. TreeSet 也是非线程安全的。\n\n### HashSet 和 TreeSet 对比\n\n\u003cstrong\u003e性能：HashSet \u003e LinkedHashSet \u003eTreeSet\u003c/strong\u003e\n\n- HashSet 以 hash 算法进行位置存储，特别适合用于添加、查询操作。\n- LinkedHashSet 由于要维护链表，性能比 HashSet 差点，但是有了链表，LinkedHashSet 更适合于插入、删除以及遍历操作。\n- TreeSet 需要额外的红黑树算法来维护集合的次序，性能最次。\n\n但是具体使用要考虑具体的使用场景。\n\n当需要一个特定排序的集合时，使用 TreeSet 集合。\n\n当经常使用添加、查询操作时，使用 HashSet。\n\n当经常插入排序或使用删除、插入及遍历操作时，使用 LinkedHashSet。\n\n## Queue 接口\n\nQueue 用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常队列不允许随机访问其中的元素。\n\n```java\npublic interface Queue\u003cE\u003e extends Collection\u003cE\u003e {\n    // 插入元素，容量已满时抛出 IllegalStateException 异常\n    boolean add(E e);\n    // 插入元素，容量已满时返回 false\n    boolean offer(E e);\n    // 移除队列头部元素并返回，当集合为空时抛出异常\n    E remove();\n    // 移除队列头部元素并返回，当集合为空时返回 null\n    E poll();\n    // 获取队列中第一个元素，当集合为空时抛出异常\n    E element();\n    // 获取队列中第一个元素，当集合为空时返回 null\n    E peek();\n}\n```\n\n### Deque 接口\n\nDeque 接口是 Queue 接口的子接口，它代表一个双端队列。\n\n就是说对于这个队列容器，既可以从头部插入也可以从尾部插入，既可以从头部获取，也可以从尾部获取，其机制如下图所示：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095517.png)\nLinkedList 也实现了 Deque 接口，所以也可以被当作双端队列使用。\n\n#### 主要方法\n\nvoid addFirst(E e):将指定元素插入此列表的开头。\n\nvoid addLast(E e): 将指定元素添加到此列表的结尾。\n\nE getFirst(E e): 返回此列表的第一个元素。\n\nE getLast(E e): 返回此列表的最后一个元素。\n\nboolean offerFirst(E e): 在此列表的开头插入指定的元素。\n\nboolean offerLast(E e): 在此列表末尾插入指定的元素。\n\nE peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。\n\nE peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。\n\nE pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。\n\nE pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。\n\nE removeFirst(E e): 移除并返回此列表的第一个元素。\n\nboolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\n\nE removeLast(E e): 移除并返回此列表的最后一个元素。\n\nboolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n\n从上面方法中可以看出，Deque 不仅可以当成双端队列使用，而且可以被当成栈来使用，因为该类里还包含了 pop(出栈)、push(入栈)两个方法。\n\n#### 与 Queue、Stack 的关系\n\n当 Deque 当做 Queue 队列使用时（FIFO），添加元素是添加到队尾，删除时删除的是头部元素。从 Queue 接口继承的方法对应 Deque 的方法如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095628.png)\nDeque 也能当 Stack 栈用（LIFO）。这时入栈、出栈元素都是在双端队列的头部进行。Deque  中和 Stack 对应的方法如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095654.png)\n\u003cstrong\u003e注意：\u003c/strong\u003eStack 过于古老，并且实现地非常不好，因此现在基本已经不用了，可以直接用 Deque 来代替 Stack 进行栈操作。\n\n#### ArrayDeque 类\n\n顾名思义，就是用数组实现的 Deque。既然底层是数组那肯定也可以指定其 capacity，也可以不指定，\u003cstrong\u003e默认长度是 16\u003c/strong\u003e，然后根据添加的元素的个数，动态扩展。ArrayDeque 由于是两端队列，所以其顺序是按照元素插入数组中对应位置产生的（下面会具体说明）。\n\n由于本身数据结构的限制，ArrayDeque 没有像 ArrayList 中的 trimToSize 方法可以为自己瘦身。ArrayDeque 的使用方法就是上面的 Deque 的使用方法，基本没有对 Deque 拓展什么方法。\n\n##### \u003cstrong\u003e实现原理\u003c/strong\u003e\n\nArrayDeque 为了满足可以同时在数组两端插入或删除元素的需求，其内部的动态数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。\n\nArrayDeque 维护了两个变量，表示 ArrayDeque 的头和尾：\n\n```java\n//具体存放元素的数组，数组大小一定是2的幂次方\ntransient Object[] elements; // non-private to \n//队列头索引\ntransient int head;\n//队列尾索引\ntransient int tail;\n//默认的最小初始化容量，即传入的容量小于8容量为8，而默认容量是16\nprivate static final int MIN_INITIAL_CAPACITY = 8;\n```\n\n当向头部插入元素时，head 下标减一然后插入元素。而 tail 表示的索引为当前末尾元素表示的索引值加一。若当向尾部插入元素时，直接向 tail 表示的位置插入，然后 tail 再减一。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095736.png)\n\n最初头部和尾部索引都是 0，addLast 方向往右，addFirst 方向往左，所以数组中间可能是空的，当头指针和尾指针相遇的时候对数组进行扩容，并对元素位置进行调整。\n\n注意：ArrayDeque 不是线程安全的。 当作为栈使用时，性能比 Stack 好；当作为队列使用时，性能比 LinkedList 好。\n\n### PriorityQueue 类\n\nPriorityQueue 是 Java 中唯一一个 Queue 接口的直接实现。PriorityQueue 保存队列元素的顺序不是按加入队列的顺序，而是按特定规则进行排序的。因此当调用 peek() 或 poll() 方法取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列中按规则排序最小的元素。\n\n#### 方法概览\n\nPriorityQueue 实现了 Queue 接口，下面列举出 PriorityQueue 的方法。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095901.png)\n\n#### 排序方式\n\n与 TreeSet 相同，PriorityQueue 中的元素可以默认自然排序（也就是数字默认是小的在队列头，字符串则按字典序排列）或者通过提供的 Comparator（比较器）在队列实例化时指定的排序方式。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e\n\n1. 队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素——选择方法是任意的。\n2. 当 PriorityQueue 中没有指定 Comparator 时，加入 PriorityQueue 的元素必须实现 Comparable 接口（即元素是可比较的），否则会导致 ClassCastException。\n\n#### 实现原理\n\nPriorityQueue 本质也是一个动态数组，在这一方面与 ArrayList 是一致的。它的成员变量和构造方法如下：\n\n```java\npublic class PriorityQueue\u003cE\u003e extends AbstractQueue\u003cE\u003e\n    implements java.io.Serializable {\n    private static final int DEFAULT_INITIAL_CAPACITY = 11;\n\n    transient Object[] queue; // non-private to simplify nested class access\n\n\n    private int size = 0;\n\n    private final Comparator\u003c? super E\u003e comparator;\n\n    transient int modCount = 0; // non-private to simplify nested class access\n\n    public PriorityQueue() {\n      this(DEFAULT_INITIAL_CAPACITY, null);\n    }\n\n    public PriorityQueue(int initialCapacity) {\n      this(initialCapacity, null);\n    }\n\n    public PriorityQueue(int initialCapacity,\n                         Comparator\u003c? super E\u003e comparator) {\n      // Note: This restriction of at least one is not actually \n      needed,but continues for 1.5 compatibility\n      if (initialCapacity \u003c 1)\n        throw new IllegalArgumentException();\n      this.queue = new Object[initialCapacity];\n      this.comparator = comparator;\n    }\n    ...\n}\n```\n\nPriorityQueue 可由以下三种构造方法创建：\n\n- 调用默认的构造方法时，使用默认的初始容量（DEFAULT_INITIAL_CAPACITY=11），并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable）。\n- 使用指定的初始容量，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable）。\n- 使用指定的初始容量，并根据指定的比较器 comparator 来排序其元素。\n\n从第三个构造方法可以看出，内部维护了一个动态数组。当添加元素到集合时，会先检查数组是否还有余量，有余量则把新元素加入集合，没余量则调用  grow() 方法增加容量，然后调用 siftUp 将新加入的元素排序插入对应位置。\n\n```java\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i \u003e= queue.length)\n        grow(i + 1);\n    size = i + 1;\n    if (i == 0)\n        queue[0] = e;\n    else\n        siftUp(i, e);\n    return true;\n}\n```\n\n除此之外，还要注意：\n\n1. PriorityQueue 不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的 PriorityBlockingQueue 类。\n2. 不允许插入 null 元素。\n3. PriorityQueue 实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是 O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是 O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是 O(1)。所以在遍历时，若不需要删除元素，则以 peek 的方式遍历每个元素。\n4. 方法 iterator() 中提供的迭代器并不保证以有序的方式遍历优 PriorityQueue 中的元素。\n\n## List 接口\n\nList 集合代表一个\u003cstrong\u003e元素有序、可重复\u003c/strong\u003e的集合，集合中每个元素都有其对应的顺序索引。List 集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List 集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为 0，第二个添加的元素索引为 1......\n\nList 作为 Collection 接口的子接口，可以使用 Collection 接口里的全部方法。而且由于 List 是有序集合，因此 List 集合里增加了一些根据索引来操作集合元素的方法。\n\n```java\npublic interface List\u003cE\u003e extends Collection\u003cE\u003e {\n    int size();\n\n    boolean isEmpty();\n\n    boolean contains(Object o);\n\n    Iterator\u003cE\u003e iterator();\n\n    Object[] toArray();\n\n    \u003cT\u003e T[] toArray(T[] a);\n\n    boolean add(E e);\n\n    boolean remove(Object o);\n\n    boolean containsAll(Collection\u003c?\u003e c);\n    \n    boolean addAll(Collection\u003c? extends E\u003e c);\n    \n    boolean addAll(int index, Collection\u003c? extends E\u003e c);\n    \n    boolean removeAll(Collection\u003c?\u003e c);\n    \n    boolean retainAll(Collection\u003c?\u003e c);\n    /**\n     * 根据 operator 指定的计算规则重新设置 List 集合的所有元素\n     * @since 1.8\n     */\n    default void replaceAll(UnaryOperator\u003cE\u003e operator) {\n        Objects.requireNonNull(operator);\n        final ListIterator\u003cE\u003e li = this.listIterator();\n        while (li.hasNext()) {\n            li.set(operator.apply(li.next()));\n        }\n    }\n    /**\n     * 根据Comparator参数对List集合的元素排序\n     * @since 1.8\n     */\n    default void sort(Comparator\u003c? super E\u003e c) {\n        Object[] a = this.toArray();\n        Arrays.sort(a, (Comparator) c);\n        ListIterator\u003cE\u003e i = this.listIterator();\n        for (Object e : a) {\n            i.next();\n            i.set((E) e);\n        }\n    }\n\n    void clear();\n    // 根据下标获取元素\n    E get(int index);\n    // 替换指定下标位置的元素\n    E set(int index, E element);\n    // 在指定下标位置插入元素\n    void add(int index, E element);\n    // 根据下标删除元素\n    E remove(int index);\n    // 获取元素下标，不存在则返回 -1\n    int indexOf(Object o);\n    // 获取与元素最后一个下标，，不存在则返回 -1\n    int lastIndexOf(Object o);\n\n    ListIterator\u003cE\u003e listIterator();\n    \n    ListIterator\u003cE\u003e listIterator(int index);\n    \n    List\u003cE\u003e subList(int fromIndex, int toIndex);\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.ORDERED);\n    }\n}\n```\n\n可以看出，经过扩展之后，List 相比于 Collection 多了“顺序”的概念，并且支持根据下表对集合进行操作。\n\nisEmpty()、contains() 等方法重新声明是为了为了方便查看文档。比如在 java doc 文档里，在 List 接口里也能看到 Collecion 声明的相关接口。\n\n此外，Java 8 为 List 接口添加了如下两个默认方法：\n\n- \u003cstrong\u003evoid replaceAll(UnaryOperator operator)：\u003c/strong\u003e根据 operator 指定的计算规则重新设置 List 集合的所有元素。\n- \u003cstrong\u003evoid sort(Comparator c)：\u003c/strong\u003e根据 Comparator 参数对 List 集合的元素排序。\n\nListIterator 接口在 Iterator 接口基础上增加了如下方法：\n\n- \u003cstrong\u003eboolean hasPrevious()：\u003c/strong\u003e 如果以逆向遍历列表。如果迭代器有上一个元素，则返回 true。\n- \u003cstrong\u003eObject previous()：\u003c/strong\u003e返回迭代器的前一个元素。\n- \u003cstrong\u003evoid add(Object o)：\u003c/strong\u003e将指定的元素插入列表（可选操作）。\n\n与 Iterator 相比，ListIterator 增加了前向迭代的功能，还可以通过 add() 方法向 List 集合中添加元素。\n\n### ArrayList 类\n\nArrayList 作为 List 类的典型实现，完全支持之前介绍的 List 接口的全部功能。它的成员变量和构造方法声明如下：\n\n```java\npublic class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e\n        implements List\u003cE\u003e, RandomAccess {\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    transient Object[] elementData;\n    \n    private int size;\n    \n    /**\n     * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity \u003e 0) {//初始容量大于0\n            //创建 initialCapacity 大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            // 创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {// 初始容量小于 0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n   /**\n    * 构造包含指定 collection 元素的列表，这些元素利用该集合的迭代器按顺序返回\n    * 如果指定的集合为 null，throws NullPointerException。\n    */\n     public ArrayList(Collection\u003c? extends E\u003e c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n    ...\n}\n```\n\nArrayList 是基于数组实现的 List 类，所以 ArrayList 类封装了一个动态的、允许再分配的 Object[] 数组。ArrayList 对象使用 initalCapacity 参数来设置该数组的长度，当向 ArrayList 中添加元素超过了该数组的长度时，它们的 initalCapacity 会自动增加。下面我们通过阅读 JDK 8 ArrayList 源码来了解这些内容。\n\n#### 扩容机制\n\n以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 \n\nJDK 7 new 无参构造的 ArrayList 对象时，直接创建了长度是 10 的 Object[] 数组 elementData 。并且 JDK 7 中的 ArrayList 的对象的创建类似于单例的饿汉式，而 JDK 8 中的 ArrayList 的对象的创建类似于单例的懒汉式。\n\n添加元素时，首先调用 add 方法：\n\n```java\n/**\n * 将指定的元素追加到此列表的末尾。\n */\npublic boolean add(E e) {\n    //添加元素之前，先调用ensureCapacityInternal方法\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    //这里看到ArrayList添加元素的实质就相当于为数组赋值\n    elementData[size++] = e;\n    return true;\n}\n```\n\n先调用了一个 ensureCapacityInternal() 方法，该方法用来确保数组中是否还有足够容量。\n\n\u003cstrong\u003e注意 ：JDK 11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法 \u003c/strong\u003e\n\n经过一系列方法，最后有个判断：如果剩余容量足够存放这个数据，则进行下一步，如果不够，则需要执行一个重要的方法：\n\n```java\n/**\n * 要分配的最大数组大小\n */\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n/**\n * ArrayList 扩容的核心方法。\n */\nprivate void grow(int minCapacity) {\n   // oldCapacity 为旧容量，newCapacity 为新容量\n   int oldCapacity = elementData.length;\n   //将 oldCapacity 右移一位，其效果相当于 oldCapacity / 2，\n   int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1);\n   //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n   if (newCapacity - minCapacity \u003c 0)\n      newCapacity = minCapacity;\n   // 如果新容量大于 MAX_ARRAY_SIZE，进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n   //如果 minCapacity大 于最大容量，则新容量则为 Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即 Integer.MAX_VALUE - 8。\n   if (newCapacity - MAX_ARRAY_SIZE \u003e 0)\n      newCapacity = hugeCapacity(minCapacity);\n   // minCapacity is usually close to size, so this is a win:\n   elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n`int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1)`，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）。\n\n由此可见，ArrayList 是一个能够进行动态扩展的数组。\n\n#### System.arraycopy() 和 Arrays.copyOf() 方法\n\nArrays.copyOf() 内部调用了 System.arraycopy() 方法，arraycopy() 方法由 native 层实现：\n\n```java\npublic static int[] copyOf(int[] original, int newLength) {\n   // 申请一个新的数组\n   int[] copy = new int[newLength];\n   // 调用System.arraycopy，将源数组中的数据进行拷贝，并返回新的数组\n   System.arraycopy(original, 0, copy, 0,\n           Math.min(original.length, newLength));\n   return copy;\n}\n\n/**\n * @param src 源数组\n * @param srcPos 源数组中的起始位置\n * @param dest 目标数组\n * @param destPos 目标数组中的起始位置\n * @param length 要复制的数组元素的数量\n */\npublic static native void arraycopy(Object src,  int  srcPos,\n                                    Object dest, int destPos,\n                                    int length);\n```\n\nensureCapacity() 和 trimToSize() 方法\n\n- \u003cstrong\u003evoid ensureCapacity(int minCapacity): \u003c/strong\u003e如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。\u003cstrong\u003e在增加大量数据之前，调用此方法，可以减少扩容次数。\u003c/strong\u003e\n- \u003cstrong\u003evoid trimToSize(): \u003c/strong\u003e将此 ArrayList 实例的容量调整为列表的当前大小。\n\n#### transient 的作用\n\n从构造方法中可以看到，实际存放集合元素的数组声明时时被 transient 所修饰的：\n\n`transient Object[] elementData;`\n\n当一个对象被序行化的时候，transient 修饰的变量的值是不包括在序行化的表示中的。但是 ArrayList 又是可序行化的类，elementData 是 ArrayList 具体存放元素的成员，用 transient 来修饰 elementData，岂不是反序列化后的 ArrayList 丢失了原先的元素？\n\n来看下面两个方法：\n\n```java\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException{\n    // Write out element count, and any hidden stuff\n    int expectedModCount = modCount;\n    s.defaultWriteObject();\n\n    // Write out size as capacity for behavioural compatibility with clone()\n    s.writeInt(size);\n\n    // Write out all elements in the proper order.\n    for (int i=0; i\u003csize; i++) {\n        s.writeObject(elementData[i]);\n    }\n\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n\n/**\n * Reconstitute the \u003ctt\u003eArrayList\u003c/tt\u003e instance from a stream (that is,\n * deserialize it).\n */\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n    elementData = EMPTY_ELEMENTDATA;\n\n    // Read in size, and any hidden stuff\n    s.defaultReadObject();\n\n    // Read in capacity\n    s.readInt(); // ignored\n\n    if (size \u003e 0) {\n        // be like clone(), allocate array based upon size not capacity\n        int capacity = calculateCapacity(elementData, size);\n        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);\n        ensureCapacityInternal(size);\n\n        Object[] a = elementData;\n        // Read in all elements in the proper order.\n        for (int i=0; i\u003csize; i++) {\n            a[i] = s.readObject();\n        }\n    }\n}\n由于 elementData 的扩容机制，数组中可能有空元素。因此，每次序列化的时候调用 writeObject() 方法，进而调用 defaultWriteObject() 方法忽略 elementData 先序列化 ArrayList 中的非 transient 元素，然后再通过遍历 elementData 只序列化那些有的元素。\n```\n\n这样一来，既\u003cstrong\u003e加快了序列化的速度，又减小了序列化之后的文件大小 。\u003c/strong\u003e\n\n反序列化时调用 readObject，从 ObjectInputStream 获取 size 和 element，再恢复到 elementData。\n\n//todo\n\n#### 遍历方式\n\nArrayList 支持 3 种遍历方式\n\n\u003cstrong\u003e第一种，通过迭代器遍历：\u003c/strong\u003e\n\n```java\nInteger value = null;\nIterator iter = list.iterator();\nwhile (iter.hasNext()) {\n    value = ter.next();\n}\n```\n\n\u003cstrong\u003e第二种，随机访问，通过索引值去遍历：\u003c/strong\u003e\n\n由于 ArrayList 实现了 RandomAccess 接口，它支持通过索引值去随机访问元素。\n\n```java\nInteger value = null;\nfor (int i = 0; i \u003c list.size(); i++) {\n    value = list.get(i);        \n}\n```\n\n\u003cstrong\u003e第三种，for 循环遍历：\u003c/strong\u003e\n\n```java\nInteger value = null;\nfor (Integer item : list) {\n    value = item;\n}\n```\n\n\u003cstrong\u003e遍历 ArrayList 时，使用随机访问(通过索引序号访问)效率最高，而使用迭代器的效率最低。\u003c/strong\u003e\n\n\u003cstrong\u003e//todo\u003c/strong\u003e\n\n### Vector 类\n\nVector 和 ArrayList 的实现基本类似，以 remove 方法为例：\n\n```java\npublic synchronized E remove(int index) {\n    modCount++;\n    if (index \u003e= elementCount)\n        throw new ArrayIndexOutOfBoundsException(index);\n    E oldValue = elementData(index);\n\n    int numMoved = elementCount - index - 1;\n    if (numMoved \u003e 0)\n        //复制数组，假设数组移除了中间某元素，后边有效值前移1位\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--elementCount] = null; // Let gc do its work\n\n    return oldValue;\n}\n```\n\n它的关键方法都加上了 synchronized 关键字，所以它是\u003cstrong\u003e线程安全\u003c/strong\u003e的，并且也因此\u003cstrong\u003e降低了性能\u003c/strong\u003e。\n\n除此之外，它的扩容机制也与 ArrayList 有所不同：\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    //扩容大小\n    int newCapacity = oldCapacity + ((capacityIncrement \u003e 0) ?\n                                     capacityIncrement : oldCapacity);\n    if (newCapacity - minCapacity \u003c 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE \u003e 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n当构造没有设置 capacityIncrement 时，一次扩容数组变成原来两倍，否则每次容量增加  capacityIncrement。\n\n#### Stack 类\n\nStack 是 Vector 的子类，用于模拟“栈”这种数据结构，即“后进先出”(LIFO)的容器。它提供了如下方法：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095956.png)\n\n由于继承自 Vector，Stack 自然也继承了 Vecor 线程安全和性能较低的特点。因此 Stack 类基本处于废弃状态，实现栈结构可由 LinkedList 代替。\n\n### LinkedList 类\n\nLinkedList 类是 List 接口的实现类——这意味着它是一个 List 集合，可以根据索引来随机访问集合中的元素。\n\n```java\npublic class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e\n             implements List\u003cE\u003e, Deque\u003cE\u003e {\n    transient int size = 0;\n\n    transient Node\u003cE\u003e first;\n\n    transient Node\u003cE\u003e last;\n\n    public LinkedList() {\n    }\n\n    public LinkedList(Collection\u003c? extends E\u003e c) {\n        this();\n        addAll(c);\n    }\n    ...\n}\n```\n\n可以看出，LinkedList 还实现了 Deque 接口，可以被当作成双端队列来使用，因此既可以被当成\u003cstrong\u003e栈\u003c/strong\u003e来使用，也可以当成\u003cstrong\u003e队列\u003c/strong\u003e来使用。\n\nLinkedList 的实现机制与 ArrayList 完全不同。ArrayList 内部是以数组的形式来保存集合中的元素的，因此随机访问集合元素时有较好的性能；而 L inkedList 内部以链表的形式来保存集合中的元素，因此随机访问集合元素时性能较差，但在插入、删除元素时性能比较出色。\n\n由于 LinkedList 双端队列的特性，所以新增了一些方法。\n\n#### 方法概览\n\n```java\nvoid addFirst(E e):将指定元素插入此列表的开头。\nvoid addLast(E e): 将指定元素添加到此列表的结尾。\nE getFirst(E e): 返回此列表的第一个元素。\nE getLast(E e): 返回此列表的最后一个元素。\nboolean offerFirst(E e): 在此列表的开头插入指定的元素。\nboolean offerLast(E e): 在此列表末尾插入指定的元素。\nE peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。\nE peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。\nE pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。\nE pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。\nE removeFirst(E e): 移除并返回此列表的第一个元素。\nboolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\nE removeLast(E e): 移除并返回此列表的最后一个元素。\nboolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n```\n\n#### 实现原理\n\nLinkedList 调用默认构造函数，创建一个链表。由于维护了一个表头，表尾的 Node 对象的变量。可以进行后续的添加元素到链表中的操作，以及其他删除，插入等操作。也因此实现了双向队列的功能，即可向表头加入元素，也可以向表尾加入元素。\n\nNode 定义如下：\n\n```java\nprivate static class Node\u003cE\u003e {\n    E item;//节点值\n    Node\u003cE\u003e next;//后继节点\n    Node\u003cE\u003e prev;//前驱节点\n    Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n新增操作 add(E e)，默认使用尾插法添加元素：\n\n```java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n\nvoid linkLast(E e) {\n    final Node\u003cE\u003e l = last;\n    final Node\u003cE\u003e newNode = new Node\u003c\u003e(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n```\n\n删除指定元素 remove(Object o): \n\n```java\npublic boolean remove(Object o) {\n    //如果删除对象为null\n    if (o == null) {\n        //从头开始遍历\n        for (Node\u003cE\u003e x = first; x != null; x = x.next) {\n            //找到元素\n            if (x.item == null) {\n                //从链表中移除找到的元素\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        //从头开始遍历\n        for (Node\u003cE\u003e x = first; x != null; x = x.next) {\n            //找到元素\n            if (o.equals(x.item)) {\n                //从链表中移除找到的元素\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nE unlink(Node\u003cE\u003e x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node\u003cE\u003e next = x.next;//得到后继节点\n    final Node\u003cE\u003e prev = x.prev;//得到前驱节点\n    //删除前驱指针\n    if (prev == null) {\n        first = next;// 如果删除的节点是头节点,令头节点指向该节点的后继节点\n    } else {\n        prev.next = next;// 将前驱节点的后继节点指向后继节点\n        x.prev = null;\n    }\n    //删除后继指针\n    if (next == null) {\n        last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n获取制定下表元素 get(int index):\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);//检查索引是否有效\n    return node(index).item;\n}\n\nNode\u003cE\u003e node(int index) {\n    // assert isElementIndex(index);\n    if (index \u003c (size \u003e\u003e 1)) {\n        Node\u003cE\u003e x = first;\n        for (int i = 0; i \u003c index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node\u003cE\u003e x = last;\n        for (int i = size - 1; i \u003e index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\nnode 方法首先会比较“index”和“双向链表长度的 1/2”；若前者小，则从链表头开始往后查找，直到 index 位置；否则，从链表末尾开始先前查找，直到 index 位置。\n\n由此可见，LinkedList 在插入、删除元素时性能比较出色，随机访问集合元素时性能较差。\n\n#### 遍历方式\n\n//todo\n\n# Map 接口\n\nMap 用于保存具有映射关系的数据。它是一种键值对的结构，即 Key-Value 结构，一个 Map 就是很多这样 K-V 键值对组成的，一个 K-V 结构我们将其称作 Entry，Key 和 Value 都可以是任何引用类型的数据。Map 的 Key 不允许重复，即同一个 Map 对象的任何两个 Key 通过 equals 方法比较总是返回 false。\n\nKey 和 Value 之间存在单向一对一关系，即通过指定的 Key，总能找到唯一的、确定的 Value。从 Map 中取出数据时，只要给出指定的 Key，就可以取出对应的 Value。\n\nMap 框架概览：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_100030.png)\n\nMap 接口的定义如下：\n\n```java\npublic interface Map\u003cK,V\u003e {\n    int size();\n\n    boolean isEmpty();\n    \n    boolean containsKey(Object key);\n    \n    boolean containsValue(Object value);\n    \n    V get(Object key);\n    \n    V put(K key, V value);\n    \n    V remove(Object key);\n\n    void putAll(Map\u003c? extends K, ? extends V\u003e m);\n    \n    void clear();\n\n    Set\u003cK\u003e keySet();\n    \n    Collection\u003cV\u003e values();\n    \n    Entry\u003cK, V\u003e\u003e entrySet();\n    \n    interface Entry\u003cK,V\u003e {\n        K getKey();\n\n        V getValue();\n        \n        V setValue(V value);\n        \n        boolean equals(Object o);\n        \n        int hashCode();\n        /**\n         * @since 1.8\n         */\n        public static \u003cK extends Comparable\u003c? super K\u003e, V\u003e Comparator\u003cMap.Entry\u003cK,V\u003e\u003e comparingByKey() {\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e c1.getKey().compareTo(c2.getKey());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V extends Comparable\u003c? super V\u003e\u003e Comparator\u003cMap.Entry\u003cK,V\u003e\u003e comparingByValue() {\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e c1.getValue().compareTo(c2.getValue());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V\u003e Comparator\u003cMap.Entry\u003cK, V\u003e\u003e comparingByKey(Comparator\u003c? super K\u003e cmp) {\n            Objects.requireNonNull(cmp);\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e cmp.compare(c1.getKey(), c2.getKey());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V\u003e Comparator\u003cMap.Entry\u003cK, V\u003e\u003e comparingByValue(Comparator\u003c? super V\u003e cmp) {\n            Objects.requireNonNull(cmp);\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e cmp.compare(c1.getValue(), c2.getValue());\n        }\n    }\n\n    boolean equals(Object o);\n\n    int hashCode();\n    // Defaultable methods\n    /**\n     * @since 1.8\n     */\n    default V getOrDefault(Object key, V defaultValue) {\n        V v;\n        return (((v = get(key)) != null) || containsKey(key))\n            ? v\n            : defaultValue;\n    }\n    /**\n     * @since 1.8\n     */\n    default void forEach(BiConsumer\u003c? super K, ? super V\u003e action) {\n        Objects.requireNonNull(action);\n        for (Map.Entry\u003cK, V\u003e entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n            action.accept(k, v);\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default void replaceAll(BiFunction\u003c? super K, ? super V, ? extends V\u003e function) {\n        Objects.requireNonNull(function);\n        for (Map.Entry\u003cK, V\u003e entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n            // ise thrown from function is not a cme.\n            v = function.apply(k, v);\n            try {\n                entry.setValue(v);\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V putIfAbsent(K key, V value) {\n        V v = get(key);\n        if (v == null) {\n            v = put(key, value);\n        }\n        return v;\n    }\n    /**\n     * @since 1.8\n     */\n    default boolean remove(Object key, Object value) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, value) ||\n            (curValue == null \u0026\u0026 !containsKey(key))) {\n            return false;\n        }\n        remove(key);\n        return true;\n    }\n    /**\n     * @since 1.8\n     */\n    default boolean replace(K key, V oldValue, V newValue) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, oldValue) ||\n            (curValue == null \u0026\u0026 !containsKey(key))) {\n            return false;\n        }\n        put(key, newValue);\n        return true;\n    }\n    /**\n     * @since 1.8\n     */\n    default V replace(K key, V value) {\n        V curValue;\n        if (((curValue = get(key)) != null) || containsKey(key)) {\n            curValue = put(key, value);\n        }\n        return curValue;\n    }\n    /**\n     * @since 1.8\n     */\n    default V computeIfAbsent(K key,\n            Function\u003c? super K, ? extends V\u003e mappingFunction) {\n        Objects.requireNonNull(mappingFunction);\n        V v;\n        if ((v = get(key)) == null) {\n            V newValue;\n            if ((newValue = mappingFunction.apply(key)) != null) {\n                put(key, newValue);\n                return newValue;\n            }\n        }\n        return v;\n    }\n    /**\n     * @since 1.8\n     */\n    default V computeIfPresent(K key,\n            BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue;\n        if ((oldValue = get(key)) != null) {\n            V newValue = remappingFunction.apply(key, oldValue);\n            if (newValue != null) {\n                put(key, newValue);\n                return newValue;\n            } else {\n                remove(key);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V compute(K key,\n            BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue = get(key);\n        V newValue = remappingFunction.apply(key, oldValue);\n        if (newValue == null) {\n            // delete mapping\n            if (oldValue != null || containsKey(key)) {\n                // something to remove\n                remove(key);\n                return null;\n            } else {\n                // nothing to do. Leave things as they were.\n                return null;\n            }\n        } else {\n            // add or replace old mapping\n            put(key, newValue);\n            return newValue;\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V merge(K key, V value,\n            BiFunction\u003c? super V, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        Objects.requireNonNull(value);\n        V oldValue = get(key);\n        V newValue = (oldValue == null) ? value :\n                   remappingFunction.apply(oldValue, value);\n        if(newValue == null) {\n            remove(key);\n        } else {\n            put(key, newValue);\n        }\n        return newValue;\n    }\n}\n```\n\nMap 接口处于整个框架的顶层，由一堆 Map 自身接口方法和一个 Entry 接口组成，Entry 接口定义了主要是关于 Key-Value 自身的一些操作，Map 接口定义的是一些属性和关于属性查找修改的一些接口方法。\n\n## HashMap\n\n见《HashMap 源码解析》\n\n### LinkedHashMap\n\nHashSet 有一个 LinkedHashSet 子类，HashMap 也有一个 LinkedHashMap 子类；LinkedHashMap 使用双向链表来维护 key-value 对的次序。\n\nLinkedHashMap 需要维护元素的插入顺序，因此性能略低于 HashMap 的性能；但是因为它以链表来维护内部顺序，所以在迭代访问 \u003cstrong\u003eMap 里的全部元素时有较好的性能\u003c/strong\u003e。迭代输出 LinkedHashMap 的元素时，将会按照添加 key-value 对的顺序输出。\n\n\u003cstrong\u003e本质上来讲，LinkedHashMap = 散列表 + 双向循环链表\u003c/strong\u003e\n\n#### \u003cstrong\u003e实现原理\u003c/strong\u003e\n\nLinkedHashMap 的主要成员变量和方法实现简化后如下：\n\n```java\npublic class LinkedHashMap\u003cK,V\u003e extends HashMap\u003cK,V\u003e \n          implements Map\u003cK,V\u003e {\n    static class Entry\u003cK,V\u003e extends HashMap.Node\u003cK,V\u003e {\n        Entry\u003cK,V\u003e before, after;\n        Entry(int hash, K key, V value, Node\u003cK,V\u003e next) {\n            super(hash, key, value, next);\n        }\n    } \n    // 双向链表的头节点\n    transient LinkedHashMap.Entry\u003cK,V\u003e head;\n    // 双向链表的尾戒低钠\n    transient LinkedHashMap.Entry\u003cK,V\u003e tail;\n    // 是否按照访问顺序排序\n    final boolean accessOrder;\n    \n    public LinkedHashMap(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor);\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(int initialCapacity) {\n        super(initialCapacity);\n        accessOrder = false;\n    }\n\n    public LinkedHashMap() {\n        super();\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(Map\u003c? extends K, ? extends V\u003e m) {\n        super();\n        accessOrder = false;\n        putMapEntries(m, false);\n    }\n\n    public LinkedHashMap(int initialCapacity,\n               float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n    \n    Node\u003cK,V\u003e newNode(int hash, K key, V value, Node\u003cK,V\u003e e) {\n        LinkedHashMap.Entry\u003cK,V\u003e p =\n            new LinkedHashMap.Entry\u003cK,V\u003e(hash, key, value, e);\n        // 将 Entry 接在双向链表的尾部\n        linkNodeLast(p);\n        return p;\n    }\n \n    @Overrid\n    Node\u003cK,V\u003e replacementNode(Node\u003cK,V\u003e p, Node\u003cK,V\u003e next) {\n        LinkedHashMap.Entry\u003cK,V\u003e q = (LinkedHashMap.Entry\u003cK,V\u003e)p;\n        LinkedHashMap.Entry\u003cK,V\u003e t = new LinkedHashMap.Entry\u003cK,V\u003e\n            (q.hash, q.key, q.value, next);\n        transferLinks(q, t);\n        return t;\n    }\n \n    @Overrid\n    TreeNode\u003cK,V\u003e newTreeNode(int hash, K key, V value, \n            Node\u003cK,V\u003e next) {\n        TreeNode\u003cK,V\u003e p = new TreeNode\u003cK,V\u003e(hash, key, value, next);\n        linkNodeLast(p);\n        return p;\n    }\n    \n    @Override\n    TreeNode\u003cK,V\u003e replacementTreeNode(Node\u003cK,V\u003e p, Node\u003cK,V\u003e next) {\n        LinkedHashMap.Entry\u003cK,V\u003e q = (LinkedHashMap.Entry\u003cK,V\u003e)p;\n        TreeNode\u003cK,V\u003e t = new TreeNode\u003cK,V\u003e(q.hash, q.key, \n            q.value, next);\n        transferLinks(q, t);\n        return t;\n    }\n    \n    // link at the end of list\n    private void linkNodeLast(LinkedHashMap.Entry\u003cK,V\u003e p) {\n        LinkedHashMap.Entry\u003cK,V\u003e last = tail;\n        tail = p;\n        // last 为 null，表明链表还未建立\n        if (last == null)\n            head = p;\n        else {\n            // 将新节点 p 接在链表尾部\n            p.before = last;\n            last.after = p;\n        }\n    }\n    \n    // apply src's links to dst\n    private void transferLinks(LinkedHashMap.Entry\u003cK,V\u003e src,\n                  LinkedHashMap.Entry\u003cK,V\u003e dst) {\n        LinkedHashMap.Entry\u003cK,V\u003e b = dst.before = src.before;\n        LinkedHashMap.Entry\u003cK,V\u003e a = dst.after = src.after;\n        if (b == null)\n            head = dst;\n        else\n            b.after = dst;\n        if (a == null)\n            tail = dst;\n        else\n            a.before = dst;\n    }\n    \n    @Override\n    void afterNodeAccess(Node\u003cK,V\u003e p) { }\n    @Override\n    void afterNodeInsertion(boolean evict) { }\n    @Override\n    void afterNodeRemoval(Node\u003cK,V\u003e e) { }\n}\n```\n\nLinkedHashMap 继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。\n\nMap 类型的集合类是通过 put(K,V) 方法插入键值对，LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。\n\n在 newNode 方法中，LinkedHashMap 创建了 Entry，并通过 linkNodeLast 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立\n\n#### afterNodeAccess()\n\n当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。\n\n```java\nvoid afterNodeAccess(Node\u003cK,V\u003e e) { // move node to last\n    LinkedHashMap.Entry\u003cK,V\u003e last;\n    if (accessOrder \u0026\u0026 (last = tail) != e) {\n        LinkedHashMap.Entry\u003cK,V\u003e p =\n            (LinkedHashMap.Entry\u003cK,V\u003e)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n```\n\n#### afterNodeInsertion()\n\n```java\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n    LinkedHashMap.Entry\u003cK,V\u003e first;\n    if (evict \u0026\u0026 (first = head) != null \u0026\u0026 removeEldestEntry(first)) {\n        K key = first.key;\n        removeNode(hash(key), key, null, false, true);\n    }\n}\n\nprotected boolean removeEldestEntry(Map.Entry\u003cK,V\u003e eldest) {\n    return false;\n}\n```\n\n在元素新增之后，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。\n\nevict 只有在构建 Map 的时候才为 false，在这里为 true。\n\nremoveEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。\n\n#### afterNodeRemoval()\n\n元素被删除后，此方法会被回调，删除双向链表中对应的节点。\n\n```java\nvoid afterNodeRemoval(Node\u003cK,V\u003e e) { // unlink\n    LinkedHashMap.Entry\u003cK,V\u003e p = (LinkedHashMap.Entry\u003cK,V\u003e)e, \n          b = p.before, a = p.after;\n    // 将 p 节点的前驱后后继引用置空\n    p.before = p.after = null;\n    // b 为 null，说明 p 是头节点\n    if (b == null)\n        head = a;\n    else\n        b.after = a;\n    // a 为 null，说明 p 是尾节点\n    if (a == null)\n        tail = b;\n    else\n        a.before = b;\n}\n```\n\n#### LRU 缓存\n\n以下是使用 LinkedHashMap 实现的一个 LRU 缓存：\n\n- 设定最大缓存空间 MAX_ENTRIES 为 3；\n- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；\n- 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。\n\n```java\nclass LRUCache\u003cK, V\u003e extends LinkedHashMap\u003cK, V\u003e {\n    private static final int MAX_ENTRIES = 3;\n\n    protected boolean removeEldestEntry(Map.Entry eldest) {\n        return size() \u003e MAX_ENTRIES;\n    }\n\n    LRUCache() {\n        super(MAX_ENTRIES, 0.75f, true);\n    }\n}\n```\n\n## TreeMap\n\nTreeMap 是 SortedMap 接口的实现类。TreeMap 是一个\u003cstrong\u003e有序的 \u003c/strong\u003ekey-value 集合，它是通过红黑树实现的，每个 key-value 对即作为红黑树的一个节点。\n\n### 排序方式\n\n和 TreeSet 一样，TreeMap 有两种排序方式：\n\n- 自然排序：TreeMap 的所有 key 必须实现 Comparable 接口，而且所有的 key 应该是同一个类的对象，否则会抛出 ClassCastException 异常。\n- 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。\n\n### 判断元素相等\n\n类似于 TreeSet 中判断两个元素相等的标准，TreeMap 中判断两个 key 相等的标准是：两个 key 通过 compareTo() 方法返回 0，TreeMap 即认为这两个 key 是相等的；判断两个 value 相等的标准是：两个 value 通过 equals() 方法比较返回 true。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e如果使用自定义类作为 TreeMap 的 key，且想让 TreeMap 良好地工作，则重写该类的 equals() 方法和 compareTo() 方法时应保持一致的返回结果：两个 key 通过 equals()方 法比较返回 true 时，它们通过 compareTo() 方法比较应该返回 0。如果两个方法的返回结果不一致，TreeMap 与 Map 接口的规则就会冲突。\n\n除此之外，与 TreeSet 类似，TreeMap 根据排序特性，也添加了一部分新的方法，与 TreeSet 中的一致。可以参考本文前面的内容。\n\n### 实现原理\n\nTreeMap 基于红黑树实现，而红黑树是一种自平衡二叉查找树，所以查找操作流程和二叉查找树一致。TreeMap 可保证在 log(n) 时间复杂度内完成 containsKey、get、put 和 remove 操作，效率很高。另一方面，由于 TreeMap 基于红黑树实现，这为 TreeMap 保持键的有序性打下了基础。总的来说，TreeMap 的核心是红黑树，其很多方法也是对红黑树增删查基础操作的一个包装。\n\n# fast-fail 机制\n\n#\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":["Collection","Iterable","Java 容器类","Java"]},"/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0":{"title":"我的日记","content":"### 今日开发工作\n### 今日感想","lastmodified":"2023-03-22T16:21:32.006550035Z","tags":[]},"/%E6%9C%AA%E5%91%BD%E5%90%8D":{"title":"未命名","content":"","lastmodified":"2023-03-22T16:21:32.006550035Z","tags":[]},"/%E6%B3%9B%E5%9E%8B":{"title":"泛型","content":"# 什么是泛型？\n\n声明中具有一个或者多个类型参数(type parameter)的类或者接口，就是泛型类或者接口。泛型类和接口统称为泛型(generic type)。\n\n每种泛型定义一组类型形参(formal type parameters)，这些类型形参有时也被简称为类型参数(type parameter)，例如对于 `List\u003cE\u003e` 而言，`List\u003cString\u003e` 就是一个参数化的类型(parameterized type)，String 就是对应于类型形参(formal type parameters)的类型实参(actual type parameter)。\n\n而如果 `List\u003cE\u003e` 不使用泛型参数，List 则为原生类型(raw type)。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。\n\n每个泛型定义一个原生类型(raw type)，即不带任何类型参数的类型名称，例如，与 `List\u003cString\u003e` 对应的原生类型是 List。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。\n\nJava 泛型是自 JDK5 起引入的一种参数化类型特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型泛型的本质是参数类型，也就是说所操作的数据类型被指定为一个参数。因为类型擦除机制，泛型不存在于 JVM 虚拟机。\n\n# 为什么使用泛型？\n\n1.使代码更健壮\n\n2.使代码更简洁(不用强转)\n\n3.使代码可复用性更高，程序更灵活\n\n通俗地说，泛型是「有远⻅的创造者」创造的「方便使用者」的工具。也就是说，使用泛型能够让开发这编写出更加灵活的代码。\n\n## 泛型的使用\n\n## 作为类/接口的类型参数\n\n可以在一个类或者接口里定义一个类型参数，等着子类/实现类去写出不同的实现：\n\n```java\npublic interface Comparable\u003cT\u003e {\n  int compareTo(T o);\n  ...\n}\n\npublic String implements Comparable\u003cString\u003e {\n  int compareTo(String anotherString);\n  ...\n}\n\npublic class Stack\u003cE\u003e extends Vector\u003cE\u003e {\n  ...\n}\n\nStack\u003cString\u003e stack = new Stack\u003c\u003e();\n```\n\n## 作为方法的返回值类型\n\n```java\nT buy();\n```\n\n## 用于类型约束\n\n由于泛型语法自身特性，某些情形下也可以用于类型约束\n\n```java\n// 约束类型参数上界\npublic \u003cE extends Runnable, Serializable\u003e void someMethod(E param);\n\n// 约束方法参数之间的关系\npublic \u003cT\u003e void merge(T item, List\u003cT\u003e list) {\n  list.add(item);\n}\n```\n\n# 泛型擦除的过程\n\n1. 类型检查：在生成字节码之前提供类型检查\n2. 类型擦除：所有类型参数都用他们的限定类型替换，包括类、变量和方法（类型擦除）\n3. 如果类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决\n4. 如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转换\n\n# 泛型的限制\n\n1. 不能用基本类型作为泛型参数\n2. 不能在运行时获取泛型类型\n3. 不能静态字段或方法中引用泛型变量\n4. 不能创建参数化类型数组\n5. 不能实例化类型变量\n6. 不能捕获泛型类的实例，类不能继承自 Exception，只能派生自 Throwable\n\n```java\npublic \u003cT extends Throwable\u003e void fun1(T t) {\n  try {\n    ...\n  } catch(T x) {//不允许\n  }\n}\n\npublic \u003cT extends Throwable\u003e void fun2(T t) throws T {\n  try {\n    ...\n  } catch(Throwable t) {\n    throw t;\n  }\n}\n```\n\n# 编译时和运行时类型\n\n```java\npublic class Fruit {}\n\npublic class Apple extends Fruit {}\n\npublic class GreenApple extends Apple {}\n\nApple apple = new Apple();//普通变量声明和初始化\n\nFruit apple = new Apple();//向上转型\n```\n\nJava 允许把一个子类对象（Apple 对象）直接赋值给一个父类引用变量（Fruit 类变量），一般我们称之为「向上转型」。apple 变量所指向的对象，其在编译时的类型是 Fruit 类型，而在运行时的类型就是 Apple 类型。\n\n因为在编译的时候，JVM 只知道 Fruit 类变量指向了一个对象，并且这个对象是 Fruit 的子类对象或自身对象，其具体的类型并不确定，有可能是 Apple 类型，也有可能是 Orange 类型。而为了安全方面的考虑，JVM 此时将 apple 属性指向的对象定义为 Fruit 类型。因为无论其是 Apple 类型还是 Orange 类型，它们都可以安全转为 Fruit 类型。\n\n而在运行时阶段，JVM 通过初始化知道了它指向了一个 Apple 对象，所以其在运行时的类型就是 Apple 类型。\n\n# 泛型类型实例化的边界\n\n在前面的例子的基础上，定义一个容器类：\n\n```java\npublic class Plate\u003cT\u003e {\n  private List\u003cT\u003e list;\n\n  public Plate(){}\n\n  public void add(T item) {\n    list.add(item);\n  }\n\n  public T get() {\n    return list.get(0);\n  }\n}\n```\n\n如果想要一个装水果的盘子，则有如下定义：\n\n```java\nPlate\u003cFruit\u003e plate = new Plate\u003cFruit\u003e();\n```\n\n这里直接定义了一个 Plate 对象，并且指定其泛型类型为 Fruit 类。这样我们就可以往里面加水果了：\n\n```java\nplate.add(new Fruit());\n\nplate.add(new Apple());\n```\n\n按照 Java 向上转型的原则，Java 泛型可以向上转型，上面关于水果盘子的定义可以变为这样：\n\n```java\nPlate\u003cFruit\u003e plate = new Plate\u003cApple\u003e();  //编译错误\n```\n\n错误的原因就是：\tJava 并不支持支持泛型的向上转型，所以不能够使用上面的写法，这样的写法在 Java 中是不被支持的。\n\n解决方法就是：使用通配符。\n\n## `\u003c? extends Xxx\u003e` 限定上界通配符\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cApple\u003e();\n```\n\n上面的这行代码表示：plate 实例可以指向任何 Fruit 类对象，或者任何 Fruit 的子类对象。Apple 是 Fruit 的子类，自然就可以正常编译了。\n\n虽然通过这种方式，Java 支持了 Java 泛型的向上转型，但是这种方式是有缺陷的：\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cApple\u003e();\n\nplate.add(new Apple()); //Compile Error\n\nplate.add(new Fruit()); //Compile Error\n\nplate.get();    // Compile Success\n```\n\n这时候发现：无法向 Plate 中添加任何对象，只能从中读取对象。\n\n这是什么原因？还得从 plate 的定义说起：\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cXXX\u003e();\n```\n\n上面对盘子的定义中，plate 可以指向任何 Fruit 类对象，或者任何 Fruit 的子类对象。也就是说，plate 属性指向的对象其在运行时可以是 Apple 类型，也可以是 Orange 类型，也可以是 Banana 类型，只要它是 Fruit 类，或任何 Fruit 的子类即可。\n\n这样子的话，在我们还未具体运行时，JVM 并不知道我们要往盘子里放的是什么水果，到底是苹果，还是橙子，还是香蕉，完全不知道。既然我们不能确定要往里面放的类型，那 JVM 就干脆什么都不给放，避免出错。\n\n那为什么又可以取出数据呢？因为无论是取出苹果，还是橙子，还是香蕉，我们都可以通过向上转型用 Fruit 类型的变量指向它，这在 Java 中都是允许的：\n\n```java\nFruit apple = plate.get(); //能够保证取出来的是水果\n\nApple apple = plate.get(); //编译报错，JVM 不能保证取出来的就是苹果\n```\n\n我们通过 extends 关键字可以实现向上转型。但是我们却失去了部分的灵活性，即我们不能往其中添加任何东西，只能取出东西。\n\n## `\u003c? super Xxx\u003e` 限定下界通配符\n\n与 extends 通配符相似的另一个通配符是 super 通配符，其特性与 extends 完全相反。\tsuper 通配符可以存入对象，但是取出对象的时候受到限制。\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n```\n\n上面这行代码表示 plate 属性可以指向一个特定类型的 Plate 对象，只要这个特定类型是 Apple 或 Apple 的父类。上面的 Fruit 类就是 Apple 类的父级，所以上面的语法是对的。\n\n也就是说，如果 Food 类是 Fruit 的父级，那么则有下面的声明：\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n\nPlate\u003c? super Apple\u003e plate2 = new Plate\u003cApple\u003e();\n\nPlate\u003c? super Apple\u003e plate3 = new Plate\u003cGreenApple\u003e(); //Error\n```\n\n既然这样，也就是说 plate 指向的具体类型可以是任何 Apple 的父级，JVM 在编译的时候肯定无法判断具体是哪个父类型。但 JVM 能确定的是：任何 Apple 的子类都可以转为 Apple 类型，但任何 Apple 的父类都无法转为 Apple 类型。\n\n所以对于使用了 super 通配符的情况，我们只能存入 T 类型及 T 类型的子类对象。\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n\nplate.add(new Apple());\n\nplate.add(new GreenApple());\n\nplate.add(new Fruit()); //Error\n```\n\n当我们向 plate 存入 Apple 对象时，编译正常。但是存入 Fruit 对象，就会报编译错误。\n\n而当我们取出数据的时候，也是类似的道理。JVM 在编译的时候知道，我们具体的运行时类型可以是任何 Apple 的父级，那么为了安全起见，我们就用一个最顶层的父级来指向取出的数据，这样就可以避免发生强制类型转换异常了。\n\n```java\nObject object = plate.get();\n\nApple apple = plate.get();  //Error\n\nFruit fruit = plate.get();  //Error\n```\n\n当使用 Apple 类型或 Fruit 类型的变量指向 plate 取出的对象，会出现编译错误。而使用 Object 类型的额变量指向 plate 取出的对象，则可以正常通过。\n\n也就是说对于使用了 super 通配符的情况，我们取出的时候只能用 Object 类型的属性指向取出的对象。\n\n## `\u003c?\u003e` 无限定边界通配符\n\n也就是不限定泛型参数的边界，所以对 Plate\u003c?\u003e 实例来说可以存放任何任意类型的对象，由于所有类型都继承自 Object，因此 Plate\u003c?\u003e等价于 `Plate\u003c? extends Object\u003e`。所以只能够对该集合进行读操作，并且只能把读取到的元素当成 Object 实例来对待。\n\n## 小结\n\n- 对于 extends 通配符，我们无法向其中加入任何对象，但是我们可以进行正常的取出。\n- 对于 super 通配符，我们可以存入 T 类型对象或 T 类型的子类对象，但是我们取出的时候只能用 Object 类变量指向取出的对象。\n\n从上面的总结可以看出，extends 通配符偏向于内容的获取，而 super 通配符更偏向于内容的存入。我们有一个 PECS 原则（Producer Extends Consumer Super）很好的解释了这两个通配符的使用场景。\n\nProducer Extends 说的是当你的情景是生产者类型，需要获取资源以供生产时，我们建议使用 extends 通配符，因为使用了 extends 通配符的类型更适合获取资源。\n\nConsumer Super 说的是当你的场景是消费者类型，需要存入资源以供消费时，我们建议使用 super 通配符，因为使用 super 通配符的类型更适合存入资源。\n\n但如果既想存入，又想取出，那么最好还是不要使用 extends 或 super 通配符。\n\n# 面试题\n\n## `List\u003cT\u003e` 和数组的区别\n\n```java\nApple apple = new Fruit();\n\nApple[] appleArr = new Fruit[5];\n```\n\n在 Java 语言中，数组是协变的，即 Apple extends Fruit，那么子类 Apple[] 数组实例是可以赋值给父类 Fruit[] 数组实例的。那是由于 Java 中的数组类型本质上会由虚拟机运行时动态生成一个类型，这个类型除了记录数组的必要属性，如长度，元素类型等，会有一个指针指向内存某个位置，这个位置就是该数组元素的起始位置。\n\n所以子类数组实例赋值父类数组实例时，只是意味着父类数组实例的引用指向堆中子类数组而已，并不会有所冲突，因此是 Java 允许这种操作的。\n\n而泛型是不允许这么做的：\n\n```java\nArrayList\u003cNumber\u003e numbers = new ArrayList\u003cInteger\u003e(); \n\nnumbers = integers;//假设编译器是能通过的 \n\nnumbers.add(23.5);//将一个浮点数放入了整型容器中\n```\n\n前面已经说过，假设 Java 允许泛型协变，那么上述代码在编译器看来是没问题的，但运行时就会出现问题。这个 add 方法实际上就将一个浮点数放入了整型容器中了，虽然由于类型擦除并不会对程序运行造成问题，但显然违背了泛型的设计初衷，容易造成逻辑混乱，所以 Java 干脆禁止泛型协变。\n\n所以虽然 `ArrayList\u003cInteger\u003e` 和 `ArrayList\u003cNumber\u003e`编译器类型擦除之后都是 ArrayList 的实例，但是起码在编译器看来，这两者是两种不同的类型。\n\n但是对于数组，尽管 Apple 可以向上转型为 Fruit，但是 fruits 对象在运行时却是 Apple[] 类型的，因此只能向数组中放入 Apple 或者其子类对象。尽管在编译时不会报错，到了运行时仍然是会报错的。\n\n```java\nFruit[] fruits = new Apple[5];\n\nfruits[0] = new Apple();\n\nfruits[1] = new GreenApple();\n\nfruits[2] = new Fruit(); //RTE：ArrayStoreException\n```\n\n## Java 为什么不支持创建泛型数组\n\n首先对于 Java 数组，必须明确知道内部元素的类型，而且 JVM 会“记住”这个类型。每次往数组里插入新元素都会进行类型检查，不匹配则抛出 ArrayStoreException 错误。\n\n而由于泛型擦除机制的存在，因此 JVM 并不能确定数组中的泛型类型，因此创建泛型数组被编译器拦下来了。\n\n```java\nList\u003cInteger\u003e[] intListArray = new List\u003cInteger\u003e[10]; //Error\n```\n\n前面说过，因为泛型是协变的，而且 Object 是所有类的共同父类。如果允许创建泛型数组，则有：\n\n```java\nList\u003cInteger\u003e[] listArr= new ArrayList\u003cInteger\u003e[10];\n\nObject[] objArr= listArr;\n\nobjArr[0] = new ArrayList\u003cString\u003e(Arrays.asList(new String[]{\"abc\"}));\n\n这样做不但编译器不能发现类型错误，就连运行时的数组存储检查对它也无能为力。它能看到的是我们往里面放 List 的对象，我们定义的 `\u003cInteger\u003e` 在这个时候已经被抹掉了。于是而对它而言，只要是 List，都是合法的。\n```\n\n想想看，我们本来定义的是存放 `List\u003cInteger\u003e` 的数组，结果我们却可以往里面放任何 List，接下来如果有代码试图按原有的定义去取值，后果可想而知。\n\n实际上，泛型数组是可以定义出来的，然后通过强制转型，也是可以为其赋值的。\n\n```java\nList\u003cInteger\u003e[] listArr= (List\u003cInteger\u003e[])new ArrayList[10];\n\nObject[] objArr= listArr;\n\nobjArr[0] = new ArrayList\u003cString\u003e(Arrays.asList(new String[]{\"abc\"}));\n```\n\n这样不但编译可以通过，而且运行时也不会报任何错误。\n\n## `List`、`List\u003c?\u003e`、`List\u003cObject\u003e`的区别\n\n容器类使用泛型的好处：\n\n- 安全性：在对参数化类型的容器中放入了错误即不匹配的类型的时候，编译器将会强制性进行错误提示。\n- 便利性：当从容器中取出元素的时候不用自己手动将 Object 转换为元素的实际类型了，编译器将隐式地进行自动转换。\n- 表述性：带有类型实参的泛型即参数化类型，可以让人看到实参就知道里面的元素 E 都是什么类型。\n\n从以上三点出发，`List\u003cObject\u003e`、`List\u003c?\u003e` 和 `List` 的区别如下：\n\n| 类型    | 名称                               | 可以接受的类型                            | 能否添加元素           | 安全性 | 便利性 | 表述性 |\n| ------- | ---------------------------------- | ----------------------------------------- | ---------------------- | ------ | ------ | ------ |\n| List    | 原始类型                           | 任何对应 List 的参数化类型， 包括 List\u003c?\u003e | 可以添加任意类型的元素 | 无     | 无     | 无     |\n| List\u003c?\u003e | 通配符类型                         | 任何对应 List 的参数化类型，包括 List     | 不能添加任何元素       | 有     | 无     | 有     |\n| List    | 实际类型参数为 Object 的参数化类型 | 仅可以接受 List 和其本身类型              | 可以添加任意类型元素   | 有     | 有     | 有     |\n\n## JVM 如何解决泛型类型擦除导致多态冲突\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":["泛型","Java"]},"/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84":{"title":"注解和反射","content":"\n# \u003cstrong\u003e注解是什么？有何作用？\u003c/strong\u003e\n\nJava 注解（Annotation）又称 Java 标注，是 JDK1.5 引入的一种注释机制。是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。\n\n注解本身没有任何意义，单独的注解就是一种注释，他需要结合其他如反射、插桩等技术才有意义。\n\n# \u003cstrong\u003e元注解\u003c/strong\u003e\n\n在 JDK 中提供了 4 个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：\n\n#### \u003cstrong\u003e@Target\u003c/strong\u003e\nTarget 注解的作用是：描述注解的使用范围(即被修饰的注解可以用在什么地方).\n\nTarget 注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数），在定义注解类时使用了 @Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在 ElementType 枚举中.\n\n源码：\n```java\n@Documented \n@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) \npublic @interface Target { \n  ElementType[] value(); \n}\nElementType定义：\npublic enum ElementType { \n  TYPE, // 类、接口、枚举类 \n  FIELD, // 成员变量（包括：枚举常量） \n  METHOD, // 成员方法 \n  PARAMETER, // 方法参数 \n  CONSTRUCTOR, // 构造方法 \n  LOCAL_VARIABLE, // 局部变量 \n  ANNOTATION_TYPE, // 注解类 \n  PACKAGE, // 可用于修饰：包 \n  TYPE_PARAMETER, // 类型参数，JDK 1.8 新增 \n  TYPE_USE // 使用类型的任何地方，JDK 1.8 新增 \n}\n```\n\n#### \u003cstrong\u003e@Retention\u003c/strong\u003e\nReteniton 注解的作用是：描述注解保留的时间范围(即：被描述的注解在它所修饰的类中可以被保留到何时).\n\nReteniton 注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在 RetentionPolicy 枚举中.\n\n```java\npublic enum RetentionPolicy {\n    SOURCE,    // 只会在源文件中保留，随后会被编译器忽略\n    CLASS,     // 保留至编译期，会被 JVM 忽略，默认值\n    RUNTIME    // 保留至运行时，可通过反射去获取注解信息\n}\n```\n\n使用场景：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Annotation%26Reflection/clipboard_20230322_115319.png)\n\n#### \u003cstrong\u003e@Documented\u003c/strong\u003e\n描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。\n\n#### \u003cstrong\u003e@Inherited\u003c/strong\u003e\n使被它修饰的注解具有继承性（如果某个类使用了被 @Inherited 修饰的注解，则其子类将自动具有该注解）。\n\n# \u003cstrong\u003e反射是什么？有何作用？\u003c/strong\u003e\n\n一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的，并且能够获得此类的引用。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。\n\n如果一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。这时候，我们使用 JDK 提供的反射 API 进行反射调用。反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且都能改变它的属性。这也是 Java 被视为动态语言的关键。\n\nJava 反射机制主要提供了以下功能：\n\n- 在运行时构造任意一个类的对象\n- 在运行时获取或者修改任意一个类所具有的成员变量和方法\n- 在运行时调用任意一个对象的方法（属性）\n\n# Class 类\n\n反射始于 Class，\u003cstrong\u003eClass 是一个类，封装了当前对象所对应的类的信息。\u003c/strong\u003e一个类中有属性，方法，构造器等，比如说有一个 Person 类，一个 Order 类，一个 Book 类，这些都是不同的类，现在需要一个类，用来描述类，这就是 Class，它应该有类名，属性，方法，构造器等。Class 是用来描述类的类。\n\nClass 类是一个对象照镜子的结果，对象可以看到自己有哪些属性，方法，构造器，实现了哪些接口等等。对于每 个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 对象只能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个 Class 实例。 \n\n### 获取 Class 的方式\n\n#### 通过类名获取\n\n通过调用“类名.class”即可获取该类的 Class 对象\n\n```java\nClass\u003c?\u003e klass = int.class;\nClass\u003c?\u003e classInt = Integer.TYPE;\n```\n\n#### 通过对象获取\n\n获取到对象实例后，通过“对象名.getClass()”或者“对象名.getSuperClass”即可获取该类或者父类的 Class 对象。\n\n```java\nStringBuilder str = new StringBuilder(\"abc\");\nClass\u003c?\u003e klass = str.getClass(); \n```\n\n#### 通过全类名获取\n\n使用 Class.forName(全类名) 或者 classLoader.loadClass(全类名) 也可以得到 Class 对象。\n\n```java\nClass.forName(\"android.content.Intent\");\ngetClassLoader().loadClass(\"android.content.Intent\");\n```\n\n### 使用 Class 创建实例\n\n通过反射来生成对象主要有两种方式。\n\n#### 直接调用 newInstance()\n\n使用 Class 对象的 newInstance() 方法来创建 Class 对象对应类的实例。 \n\n```java\nClass\u003c?\u003e c = String.class;\nObject str = c.newInstance(); \n```\n\n#### 通过 Constructor 调用 newInstance()\n\n如果需要通过某个构造方法创建对象，则须通过 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建实例。\n\n```java\nClass\u003c?\u003e c = String.class;\n//获取String类带一个String参数的构造器\nConstructor constructor = c.getConstructor(String.class);\n//根据构造器创建实例\nObject obj = constructor.newInstance(\"abc\");\n```\n\n### 获取构造方法\n\n```java\n//获得使用特殊的参数类型的public构造函数(包括父类）\nConstructor getConstructor(Class[] params)\n//获得类的所有公共构造函数\nConstructor[] getConstructors()\n获得使用特定参数类型的构造函数(包括私有)\nConstructor getDeclaredConstructor(Class[] params)\n//获得类的所有构造函数(与接入级别无关) \nConstructor[] getDeclaredConstructors()\n```\n\n### 获取成员变量（字段）信息\n\n```java\n//获得命名的公共字段\nField getField(String name)\n//获得类的所有公共字段\nField[] getFields()\n//获得类声明的命名的字段\nField getDeclaredField(String name)\n//获得类声明的所有字段\nField[] getDeclaredFields()\n```\n\n### 调用方法\n\n```java\n//使用特定的参数类型，获得命名的公共方法\nMethod getMethod(String name, Class[] params)\n//获得类的所有公共方法\nMethod[] getMethods()\n//使用特写的参数类型，获得类声明的命名的方法\nMethod getDeclaredMethod(String name, Class[] params)\n//获得类声明的所有方法 \nMethod[] getDeclaredMethods()\n获取到 Method 对象后，调用 invoke 方法即可调用该方法，invoke 方法定义：\npublic Object invoke(Object obj, Object... args)\n```\n\n# 获取泛型的真实类型\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Annotation%26Reflection/clipboard_20230322_115426.png)\n\n当我们对一个泛型类进行反射时，需要的到泛型中的真实数据类型，来完成如 json 反序列化的操作。此时需要通过 Type 体系来完成。Type 接口包含了一个实现类(Class)和四个实现接口，他们分别是：\n\n#### TypeVariable\n\n泛型类型变量。可以泛型上下限等信息；\n\n```java\nclass TestType\u003cK extends Comparable \u0026 Serializable, V\u003e {\n    K key;\n    V value;\n}\n\n@Test\npublic void test() {\n    // 获取字段的类型\n    Field fk = null;\n    Field fv = null;\n    try {\n        fk = TestType.class.getDeclaredField(\"key\");\n        fv = TestType.class.getDeclaredField(\"value\");\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    }\n    TypeVariable keyType = (TypeVariable)fk.getGenericType();\n    TypeVariable valueType = (TypeVariable)fv.getGenericType();\n    \n    // getName 方法\n    System.out.println(keyType.getName()); // K\n    System.out.println(valueType.getName()); // V\n    \n    // getGenericDeclaration 方法\n    System.out.println(keyType.getGenericDeclaration()); \n    System.out.println(valueType.getGenericDeclaration());\n    \n    System.out.println(\"K 的上界:\"); // 有两个\n    for (Type type : keyType.getBounds()) {\n        System.out.println(type);\n    }\n    \n    System.out.println(\"V 的上界:\"); // 没明确声明上界的, 默认上界是 Object\n    for (Type type : valueType.getBounds()) {// class java.lang.Object\n        System.out.println(type);\n    }\n}\n\n输出为：\nK\nV\nclass com.test.ExampleUnitTest$TestType\nclass com.test.ExampleUnitTest$TestType\n```\n\nK 的上界:\n\n`interface java.lang.Comparable`\n\n`interface java.io.Serializable`\n\nV 的上界:\n\n`class java.lang.Object`\n\n#### ParameterizedType\n\n具体的泛型类型，可以获得元数据中泛型签名类型(泛型真实类型)\n\n```java\nclass TestType {\n    Map\u003cString, String\u003e map;\n}\n\n@Test\npublic void test() {\n    Field f = null;\n    try {\n        f = TestType.class.getDeclaredField(\"map\");\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    }\n    System.out.println(f.getGenericType());\n    ParameterizedType pType = (ParameterizedType) f.getGenericType();\n    System.out.println(pType.getRawType());\n    for (Type type : pType.getActualTypeArguments()) {\n        System.out.println(type);\n    }\n}\n\n输出为：\njava.util.Map\u003cjava.lang.String, java.lang.String\u003e\ninterface java.util.Map\nclass java.lang.String\nclass java.lang.String\n```\n\n#### GenericArrayType\n\n当需要描述的类型是\u003cstrong\u003e泛型类的数组\u003c/strong\u003e时，比如 List[],Map[]，此接口会作为 Type 的实现。\n\n```java\npublic class TestType\u003cT\u003e {\n    List\u003cString\u003e[] lists;\n}\n@Test\npublic void test() {\n    Field f = null;\n    try {\n        f = TestType.class.getDeclaredField(\"lists\");\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    }\n    GenericArrayType genericType = (GenericArrayType) f.getGenericType();\n    System.out.println(genericType.getGenericComponentType());\n}\n\n输出为：\njava.util.List\u003cjava.lang.String\u003e\nWildcardType \n```\n\n通配符泛型，获得上下限信息；\n\n```java\npublic class TestType {\n    private List\u003c? extends Number\u003e a;\n    private List\u003c? super String\u003e b;\n}\n\n@Test\npublic void test() throws NoSuchFieldException {\n    Field fieldA = TestType.class.getDeclaredField(\"a\");\n    Field fieldB = TestType.class.getDeclaredField(\"b\");\n    ParameterizedType pTypeA = (ParameterizedType) fieldA.getGenericType();\n    ParameterizedType pTypeB = (ParameterizedType) fieldB.getGenericType();\n    WildcardType wTypeA = (WildcardType) pTypeA.getActualTypeArguments()[0];\n    WildcardType wTypeB = (WildcardType) pTypeB.getActualTypeArguments()[0];\n    System.out.println(wTypeA.getUpperBounds()[0]);\n    System.out.println(wTypeB.getLowerBounds()[0]);\n    System.out.println(wTypeA);\n    System.out.println(wTypeB);\n}\n\n输出为：\nclass java.lang.Number\nclass java.lang.String\n? extends java.lang.Number\n? super java.lang.String\n```\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Annotation%26Reflection/clipboard_20230322_115500.png)\n\n问题：为什么 Gson 反序列化时候需要借助 TypeToken 获取 Type？\n\n//todo\n","lastmodified":"2023-03-22T16:21:32.370564722Z","tags":["注解","反射","Java"]},"/2023-03-15":{"title":"2023-03-15","content":"弄完了同步，牛逼","lastmodified":"2023-03-22T16:21:32.006550035Z","tags":[]},"/2023-03-16":{"title":"2023-03-16","content":"","lastmodified":"2023-03-22T16:21:32.006550035Z","tags":[]},"/2023-03-18":{"title":"2023-03-18","content":"# 2023-03-18\n### 今日开发工作\n### 今日感想","lastmodified":"2023-03-22T16:21:32.006550035Z","tags":["哈哈","好"]},"/2023-03-19":{"title":"2023-03-19","content":"### 今日开发工作\n### 今日感想","lastmodified":"2023-03-22T16:21:32.006550035Z","tags":[]},"/2023-03-20":{"title":"2023-03-20","content":"### 今日开发工作\n### 今日感想\nsadlfjsal \n\nfrom windows\n\n之类主页是[[AboutTheGarden]]","lastmodified":"2023-03-22T16:21:32.006550035Z","tags":[]},"/2023-03-22":{"title":"Troubleshooting and FAQ","content":"\nStill having trouble? Here are a list of common questions and problems people encounter when installing Quartz.\n\nWhile you're here, join our [Discord](https://discord.gg/cRFFHYye7t) :)\n\n### Does Quartz have Latex support?\nYes! See [CJK + Latex Support (测试)](notes/CJK%20+%20Latex%20Support%20(测试).md) for a brief demo.\n\n### Can I use \\\u003cObsidian Plugin\\\u003e in Quartz?\nUnless it produces direct Markdown output in the file, no. There currently is no way to bundle plugin code with Quartz.\n\nThe easiest way would be to add your own HTML partial that supports the functionality you are looking for.\n\n### My GitHub pages is just showing the README and not Quartz\nMake sure you set the source to deploy from `master` (and not `hugo`) using `/ (root)`! See more in the [hosting](/notes/hosting) guide\n\n### Some of my pages have 'January 1, 0001' as the last modified date\nThis is a problem caused by `git` treating files as case-insensitive by default and some of your posts probably have capitalized file names. You can turn this off in your Quartz by running this command.\n\n```shell\n# in the root of your Quartz (same folder as config.toml)\ngit config core.ignorecase true\n\n# or globally (not recommended)\ngit config --global core.ignorecase true\n```\n\n### Can I publish only a subset of my pages?\nYes! Quartz makes selective publishing really easy. Heres a guide on [excluding pages from being published](notes/ignore%20notes.md).\n\n### Can I host this myself and not on GitHub Pages?\nYes! All built files can be found under `/public` in the `master` branch. More details under [hosting](notes/hosting.md).\n\n### `command not found: hugo-obsidian`\nMake sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize `hugo-obsidian` as an executable.\n\n```shell\n# Add the following 2 lines to your ~/.bash_profile (~/.zshrc if you are on Mac)\nexport GOPATH=/Users/$USER/go\nexport PATH=$GOPATH/bin:$PATH\n\n# In your current terminal, to reload the session\nsource ~/.bash_profile # again, (~/.zshrc if you are on Mac)\n```\n\n### How come my notes aren't being rendered?\nYou probably forgot to include front matter in your Markdown files. You can either setup [Obsidian](notes/obsidian.md) to do this for you or you need to manually define it. More details in [the 'how to edit' guide](notes/editing.md).\n\n### My custom domain isn't working!\nWalk through the steps in [the hosting guide](notes/hosting.md) again. Make sure you wait 30 min to 1 hour for changes to take effect.\n\n### How do I setup analytics?\nQuartz by default uses [Plausible](https://plausible.io/) for analytics. \n\nIf you would prefer to use Google Analytics, you can follow this [guide in the Hugo documentation](https://gohugo.io/templates/internal/#google-analytics). \n\nAlternatively, you can also import your Google Analytics data into Plausible by [following this guide](https://plausible.io/docs/google-analytics-import).\n\n\n### How do I change the content on the home page?\nTo edit the main home page, open `/content/_index.md`.\n\n### How do I change the colours?\nYou can change the theme by editing `assets/custom.scss`. More details on customization and themeing can be found in the [customization guide](notes/config.md).\n\n### How do I add images?\nYou can put images anywhere in the `/content` folder.\n\n### My Interactive Graph and Backlinks aren't up to date\nBy default, the `linkIndex.json` (which Quartz needs to generate the Interactive Graph and Backlinks) are not regenerated locally. To set that up, see the guide on [local editing](notes/editing.md)\n\n### Can I use React/Vue/some other framework?\nNot out of the box. You could probably make it work by editing `/layouts/_default/single.html` but that's not what Quartz is designed to work with. 99% of things you are trying to do with those frameworks you can accomplish perfectly fine using just vanilla HTML/CSS/JS.\n\n## Still Stuck?\nQuartz isn't perfect! If you're still having troubles, file an issue in the GitHub repo with as much information as you can reasonably provide. Alternatively, you can message me on [Twitter](https://twitter.com/_jzhao) and I'll try to get back to you as soon as I can.\n\n🐛 [Submit an Issue](https://github.com/jackyzha0/quartz/issues)\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":[]},"/About-Atlas":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: tutorial\ntitle: \"About Atlas\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\nAtlas意思是地图集。\n\n单个案例或项目的MOC，考虑直接放在对应文件夹里面，相当于起到一个个文件夹的readme和导览的作用。这里专门放这些MOC的MOC。\n\n围绕本库和obsidian的使用教程、方法和细节，也放到这里，就像是地图的指南针。\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":[]},"/About-Extras":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: tutorial\ntitle: \"About Extras\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n[[图片保存：图床or本地]]\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":[]},"/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90":{"title":"HashMap 源码解析","content":"# 前言  \n  \nHashMap 是 Java 中最常用 K-V 容器，使用哈希值来确定元素存储的位置，HashMap 对 Entry 进行了扩展（Node），使其形成以链表或者树的形式存储在 HashMap 的容器里。  \n  \n在 Java 8 之前和之后，HashMap 的实现有较大的不同，因此对于 put 流程、扩容机制等主要过程分析将会采用两个版本进行对比。  \n  \n# 成员变量  \n  \nHashMap 成员变量和构造方法声明如下（Java 7 和 8 大致相同，以下为 Java 8 版本）：  \n  \n```java  \npublic class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e  \n  \n    implements Map\u003cK,V\u003e, Cloneable, Serializable {  \n\n    // 初始容量 16  \n    static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16  \n  \n    // 最大容量，该数组最大值为2^31一次方。  \n    static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30;  \n  \n    // 默认的加载因子，如果构造的时候不传则为 0.75  \n    static final float DEFAULT_LOAD_FACTOR = 0.75f;  \n  \n    // @1.8：数组某个位置下的 node 链表转化为红黑树对该链表的最小长度要求  \n    static final int TREEIFY_THRESHOLD = 8;  \n  \n    // @1.8：当一个反树化的阈值，当这个 node 长度减少到该值就会从树转化成链表  \n    static final int UNTREEIFY_THRESHOLD = 6;  \n  \n    // @1.8：数组某个位置下的 node 链表转化为红黑树对元素个数的最小要求  \n    static final int MIN_TREEIFY_CAPACITY = 64;  \n  \n    // 具体存放数据的数组  \n    transient Node\u003cK,V\u003e[] table;  \n  \n    // entrySet，一个存放 k-v 缓冲区  \n    transient Set\u003cMap.Entry\u003cK,V\u003e\u003e entrySet;  \n  \n    // 存放键值对的个数。  \n    transient int size;  \n  \n    // 记录更改 map 结构次数(添加、删除、扩容？)  \n    transient int modCount;  \n  \n    // 临界值，当实际大小(容量*填充因子)超过临界值时，会进行扩容  \n  \n    int threshold;  \n  \n    // 填充因子  \n    final float loadFactor;  \n  \n    // 指定初始容量  \n    public HashMap(int initialCapacity) {  \n        this(initialCapacity, DEFAULT_LOAD_FACTOR);  \n    }  \n\n    // 默认构造函数  \n    public HashMap() {  \n        // 默认 threshold 在首次 put 时才复制，Java 7 则是调用  \n        // this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR)  \n        this.loadFactor = DEFAULT_LOAD_FACTOR;   \n    }  \n\n    // 包含另一个 Map  \n    public HashMap(Map\u003c? extends K, ? extends V\u003e m) {  \n        this.loadFactor = DEFAULT_LOAD_FACTOR;  \n  \n        putMapEntries(m, false);  \n    }  \n\n    // 指定初始容量和填充因子  \n    public HashMap(int initialCapacity, float loadFactor) {  \n        if (initialCapacity \u003c 0) // 容量不能为负数  \n  \n            throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);  \n  \n        // 当容量大于 2^31 就取最大值 1\u003c\u003c30;   \n  \n        if (initialCapacity \u003e MAXIMUM_CAPACITY)  \n  \n            initialCapacity = MAXIMUM_CAPACITY;  \n  \n        if (loadFactor \u003c= 0 || Float.isNaN(loadFactor))  \n  \n            throw new IllegalArgumentException(\"Illegal load factor: \"                + loadFactor);  \n  \n        this.loadFactor = loadFactor;  \n  \n        // tableSizeFor 保证了数组长度一定是 2 的幂次方，是大于等于    initialCapacity 最接近的值。  \n        // 这里使用 threshold 暂时保存计算后的 initialCapacity 值  \n        this.threshold = tableSizeFor(initialCapacity);  \n  \n    }  \n    ...  \n}  \n```  \n  \n# 数据结构  \n  \nJava 7 采用数组 + 链表方式进行存储，元素类型为 Entry：  \n  \n```java  \nstatic class Entry\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {  \n  \n    final K key;  \n  \n    V value;  \n  \n    Entry\u003cK,V\u003e next;  \n  \n    int hash;  \n\n    ...  \n}  \n```  \n  \n元素的存储结构如下：  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_035018.png)\nJava 8 开始，采用数组 + 链表 + 红黑树方式进行存储，元素类型为 Node 和 TreeNode：  \n  \n```java  \nstatic class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {  \n  \n    final int hash;  \n  \n    final K key;  \n  \n    V value;  \n  \n    Node\u003cK,V\u003e next;  \n\n    ...  \n}  \n  \n  \n  \nstatic final class TreeNode\u003cK,V\u003e extends LinkedHashMap.Entry\u003cK,V\u003e {  \n  \n    TreeNode\u003cK,V\u003e parent;  // red-black tree links  \n  \n    TreeNode\u003cK,V\u003e left;  \n  \n    TreeNode\u003cK,V\u003e right;  \n  \n    TreeNode\u003cK,V\u003e prev;    // needed to unlink next upon deletion  \n  \n    boolean red;  \n    \n    ...  \n}  \n```  \n  \n元素的存储结构如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_041741.png)\n\n# put 流程分析  \n  \n## Java 7 put 流程  \n  \n### 代码分析  \n  \nJava 7 put 流程主要方法源码如下：  \n  \n```java  \npublic V put(K key, V value)  \n    if (table == EMPTY_TABLE) {  \n        // 初始化 table  \n        inflateTable(threshold);  \n    }  \n  \n    if (key == null) {  \n        // 在 table[0] 处插入 key 为 null 元素并返回  \n        return putForNullKey(value);  \n    }  \n  \n    // 先进行一次 hash 计算     \n    int hash = hash(key);  \n  \n    // 根据 hash 值计算 table 下标  \n    int i = indexFor(hash, table.length);  \n  \n    // 遍历 table[i] 处的链表  \n    for (Entry\u003cK,V\u003e e = table[i]; e != null; e = e.next) {  \n        Object k;  \n        // hash 一样且 key 相等或者 equals 方法返回 true 才进行替换  \n        if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) {  \n            V oldValue = e.value;  \n  \n            e.value = value;  \n  \n            e.recordAccess(this);  \n  \n            return oldValue;  \n        }  \n    }  \n    // 出循环意味着 table[i] 这条链表没有此元素  \n    // 更新 modCount  \n    modCount++;  \n    // 插入新元素  \n    addEntry(hash, key, value, i);  \n  \n    return null;  \n}  \n  \nprivate void inflateTable(int toSize) {  \n    // 获取大于  \n    int capacity = roundUpToPowerOf2(toSize);  \n    // 重新计算阈值  \n    threshold = (int) Math.min(capacity * loadFactor,   \n            MAXIMUM_CAPACITY + 1);  \n  \n    // 创建数组  \n    table = new Entry[capacity];  \n  \n    // 根据配置判断是否初始化 hashSeed  \n    initHashSeedAsNeeded(capacity);  \n}  \n  \nprivate V putForNullKey(V value) {  \n    // 最多循环一次，因为这个位置最多只有一个元素  \n    for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) {  \n        // key 为 null 直接替换  \n        if (e.key == null) {  \n            V oldValue = e.value;  \n            e.value = value;  \n            e.recordAccess(this);  \n  \n            return oldValue;  \n        }  \n    }  \n  \n    // 更新 modCount  \n    modCount++;  \n  \n    // 在 table[0] 处插入元素  \n    addEntry(0, null, value, 0);  \n  \n    return null;  \n}  \n  \nvoid addEntry(int hash, K key, V value, int bucketIndex) {  \n    // 元素数量达到临界值且 table[bucketIndex] 位置不为空才进行扩容  \n    if ((size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])) {  \n        // 两倍容量  \n        resize(2 * table.length);  \n  \n        // 重新计算 hash  \n        hash = (null != key) ? hash(key) : 0;  \n  \n        // 重新确定数组下标  \n        bucketIndex = indexFor(hash, table.length);  \n    }\n    // 创建并插入新元素  \n    createEntry(hash, key, value, bucketIndex);  \n}  \n  \n// 在链表头部插入新元素  \nvoid createEntry(int hash, K key, V value, int bucketIndex) {  \n    // 保存原头结点  \n    Entry\u003cK,V\u003e e = table[bucketIndex];  \n    // 创建新元素、把 next 指向头节点，并替换原来 bucketIndex 位置的链表  \n    table[bucketIndex] = new Entry\u003c\u003e(hash, key, value, e);  \n    // 元素数量++  \n    size++；  \n}  \n```  \n  \n### 流程图示  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040358.png)\n## Java 8 put 流程  \n  \n### 代码分析  \n  \nJava 8 put 流程主要方法源码如下：  \n  \n```java  \npublic V put(K key, V value) {  \n      // onlyIfAbsent 默认为 false，即元素存在时进行替换  \n    return putVal(hash(key), key, value, false, true);  \n}  \n  \nfinal V putVal(int hash, K key, V value,   \n          boolean onlyIfAbsent, boolean evict) {  \n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i;  \n  \n    // table 未初始化或者长度为 0，进行扩容  \n    if ((tab = table) == null || (n = tab.length) == 0)  \n        n = (tab = resize()).length;  \n  \n    // (n - 1) \u0026 hash 确定元素存放位置，位置为空则直接放入该位置  \n    if ((p = tab[i = (n - 1) \u0026 hash]) == null)  \n        tab[i] = newNode(hash, key, value, null);  \n  \n    // 数组对应位置已经存在元素  \n    else {  \n        Node\u003cK,V\u003e e; K k;  \n  \n        // 比较数组中第一个元素  \n        if (p.hash == hash \u0026\u0026  \n            ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n  \n                // 将第一个元素赋值给 e  \n                e = p;  \n        // 是否为红黑树结点  \n        else if (p instanceof TreeNode)  \n            // 放入树中  \n            e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab,   \n                        hash, key, value);  \n        // 链表结点  \n        else {  \n            // 遍历链表  \n            for (int binCount = 0; ; ++binCount) {  \n                // 到达链表的尾部，说明没有找到相等的 key  \n                if ((e = p.next) == null) {  \n                    // 在尾部插入新结点  \n                    p.next = newNode(hash, key, value, null);  \n  \n                    // 判断结点数量是否达到阈值(TREEIFY_THRESHOLD 默认为 8)  \n                    if (binCount \u003e= TREEIFY_THRESHOLD - 1) {  \n                        // 根据数组长度决定是否树化  \n                        treeifyBin(tab, hash);  \n                    }  \n  \n                    // 跳出循环  \n                    break;  \n                }  \n  \n                // 判断链表中结点的 key 值是否与插入的 key 相等  \n                if (e.hash == hash \u0026\u0026  \n                    ((k = e.key) == key ||   \n                          (key != null \u0026\u0026 key.equals(k))))  \n                    // key 相等，跳出循环，此时 e 就是目标结点  \n                    break;  \n  \n                // 与前面的 e = p.next 组合遍历链表  \n                p = e;  \n            }  \n        }  \n  \n        // 找到 key 值相等的目标结点  \n        if (e != null) {  \n  \n            V oldValue = e.value;  \n  \n            // onlyIfAbsent 为 false 或者目标接点值为 null  \n            if (!onlyIfAbsent || oldValue == null)  \n  \n                //用新值替换旧值  \n                e.value = value;  \n  \n            // 空实现，用于访问后回调给子类，如 LinkedHashMap  \n            afterNodeAccess(e);  \n  \n            // 返回旧值  \n            return oldValue;  \n        }  \n    }  \n  \n    // 结构修改，更新 modCount  \n    ++modCount;  \n  \n    // 实际大小大于阈值则扩容  \n    if (++size \u003e threshold)  \n        resize();  \n  \n    // 插入后回调  \n    afterNodeInsertion(evict);  \n  \n    return null;  \n}  \n```  \n  \n#### 流程图示  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040522.png)\n# hash 计算与元素位置确定  \n  \n## Java 7  \n  \n```java  \nint hash = hash(key);  \n  \nint i = indexFor(hash, table.length);  \n  \nfinal int hash(Object k) {  \n  \n    // 默认为 0，初始化方法见后文  \n    int h = hashSeed;  \n  \n    // 如果 hashSeed 不为零且 key 是 String 类型  \n    if (0 != h \u0026\u0026 k instanceof String) {  \n        // 返回特定 hash 值  \n        return sun.misc.Hashing.stringHash32((String) k);  \n    }  \n  \n    h ^= k.hashCode();  \n  \n    // 多次异或  \n    h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12);  \n  \n    return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4);  \n}  \n  \nstatic int indexFor(int h, int length) {  \n    // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";  \n    return h \u0026 (length-1);  \n}  \n```  \n  \n## Java 8  \n  \n```java  \npublic V put(K key, V value) {  \n    return putVal(hash(key), key, value, false, true);  \n}  \n\nstatic final int hash(Object key) {  \n    int h;  \n  \n    // 让高 16 位和低 16 位异或  \n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16);  \n}  \n\np = tab[index = (n - 1) \u0026 hash]；  \n```  \n  \n# 扩容流程  \n  \n扩容过程涉及到 rehash、复制数据等操作，非常消耗性能。  \n  \n和扩容相关的全局变量及其含义：  \n  \n| 全局变量   | 含义                                                                                                                                                                                                                                                                                                                                                                                                      |  \n| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |  \n| capacity   | table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。                                                                                                                                                                                                                                                                                                                               |  \n| size       | 存放键值对数量。                                                                                                                                                                                                                                                                                                                                                                                          |  \n| threshold  | size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。threshold = (int) (capacity * loadFactor)                                                                                                                                                                                                                                                                                                   |  \n| loadFactor | 填充因子，table 能够使用的比例。loadFactor 能够控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。\u003cbr/\u003eloadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。 |  \n  \n## Java 7 扩容流程  \n  \n### 代码分析  \n  \nJava 7 的 resize 方法相关代码：  \n  \n```java  \nvoid resize(int newCapacity) {  \n    Entry[] oldTable = table;  \n  \n    // 记录旧容量  \n    int oldCapacity = oldTable.length;  \n  \n    // 如果容量已达到上限，则扩容阈值设置成不可能达到的最大值，即后续不再扩容  \n    if (oldCapacity == MAXIMUM_CAPACITY) {  \n        threshold = Integer.MAX_VALUE;  \n  \n        return;  \n    }  \n  \n    // 根据新容量创建出新数组  \n    Entry[] newTable = new Entry[newCapacity];  \n  \n    // 将旧数组的节点转移到新数组  \n    transfer(newTable, initHashSeedAsNeeded(newCapacity));  \n  \n    // 新旧易主  \n    table = newTable;  \n  \n    // 根据新容量重新确定新阈值  \n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);  \n}  \n \n// 从配置中获取是否启用备用 hash，用于减少字符串 hash 冲突  \nfinal boolean initHashSeedAsNeeded(int capacity) {  \n    // 是否已经启用备用 hash  \n    boolean currentAltHashing = hashSeed != 0;  \n  \n    // 虚拟机已经启动且数组容量大于 ALTERNATIVE_HASHING_THRESHOLD  \n    boolean useAltHashing = sun.misc.VM.isBooted() \u0026\u0026  \n            (capacity \u003e= Holder.ALTERNATIVE_HASHING_THRESHOLD);  \n  \n    // 异或操作判断是否切换  \n    boolean switching = currentAltHashing ^ useAltHashing;  \n    if (switching) {  \n        // useAltHashing 为 true 则 hashSeed 初始化为也给随机 hash 值  \n        hashSeed = useAltHashing  \n            ? sun.misc.Hashing.randomHashSeed(this)  \n            : 0;  \n    }  \n    return switching;  \n}  \n\nvoid transfer(Entry[] newTable, boolean rehash) {  \n    int newCapacity = newTable.length;  \n  \n    // 遍历旧数组  \n    for (Entry\u003cK,V\u003e e : table) {  \n        // 遍历数组上的链表  \n        while(null != e) {  \n            // 记录下一个位置  \n            Entry\u003cK,V\u003e next = e.next;  \n  \n            // 判断是否重新计算 hash 值  \n            if (rehash) {  \n  \n                e.hash = null == e.key ? 0 : hash(e.key);  \n  \n            }  \n  \n            // 根据新容量重新计算位置  \n            int i = indexFor(e.hash, newCapacity);  \n  \n            // 按旧链表的正序遍历链表、在新链表的头部依次插入  \n            // 因此扩容后可能出现逆序  \n            e.next = newTable[i];  \n  \n            newTable[i] = e;  \n  \n            e = next;  \n        }  \n    }  \n}  \n```  \n  \n### 扩容流程在多线程环境下的隐患  \n  \n在 resize 扩容过程中，在将旧数组上的数据转移到新数组上时，转移数据操作是按旧链表的正序遍历链表、在新链表的头部依次插入的。在多线程的环境下，由于这些操作不具有原子性和内存可见性，转移数据、扩容后，容易出现环形链表的情况。  \n  \n## Java 8 扩容流程  \n  \n### 代码分析  \n  \nJava 8 中的 resize 和 treeifyBin 方法：  \n  \n```java  \nfinal void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) {  \n    int n, index; Node\u003cK,V\u003e e;  \n    // 如果数组为空或者数组长度小于 64，则进行扩容  \n    if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY)  \n        resize();  \n    // 根据 hash 获取数组下标，该位置有值再进行树化  \n    else if ((e = tab[index = (n - 1) \u0026 hash]) != null) {  \n        TreeNode\u003cK,V\u003e hd = null, tl = null;  \n        // 遍历链表  \n        do {  \n            // Node 节点转换成 TreeNode 节点  \n            TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null);  \n  \n            if (tl == null)  \n                hd = p;  \n            else {  \n                p.prev = tl;  \n  \n                tl.next = p;  \n            }  \n  \n            tl = p;  \n        } while ((e = e.next) != null);  \n        \n        if ((tab[index] = hd) != null)  \n            hd.treeify(tab);  \n    }  \n}  \n\nfinal Node\u003cK,V\u003e[] resize() {  \n  \n    Node\u003cK,V\u003e[] oldTab = table;  \n  \n    int oldCap = (oldTab == null) ? 0 : oldTab.length;  \n  \n    int oldThr = threshold;  \n  \n    int newCap, newThr = 0;  \n  \n    if (oldCap \u003e 0) {  \n        // 超过最大值后续不再扩容  \n        if (oldCap \u003e= MAXIMUM_CAPACITY) {  \n            threshold = Integer.MAX_VALUE;  \n            return oldTab;  \n        }  \n  \n        // 否则扩充为原来的2倍  \n        else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 oldCap \u003e= DEFAULT_INITIAL_CAPACITY)  \n            newThr = oldThr \u003c\u003c 1; // double threshold  \n    }  \n  \n    else if (oldThr \u003e 0) // initial capacity was placed in threshold  \n        newCap = oldThr;  \n    else {  \n        // signifies using defaults  \n        newCap = DEFAULT_INITIAL_CAPACITY;  \n  \n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  \n    }  \n  \n    // 计算新的 resize 上限  \n  \n    if (newThr == 0) {  \n        float ft = (float)newCap * loadFactor;  \n        newThr = (newCap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);  \n    }  \n  \n    threshold = newThr;  \n  \n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})  \n  \n    Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap];  \n  \n    table = newTab;  \n\n    if (oldTab != null) {  \n        // 旧数组迁移至新数组  \n        for (int j = 0; j \u003c oldCap; ++j) {  \n            Node\u003cK,V\u003e e;  \n            if ((e = oldTab[j]) != null) {  \n                oldTab[j] = null;  \n                if (e.next == null)  \n                    newTab[e.hash \u0026 (newCap - 1)] = e;  \n                else if (e instanceof TreeNode)  \n                    ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap);  \n                else {  \n                    Node\u003cK,V\u003e loHead = null, loTail = null;  \n                    Node\u003cK,V\u003e hiHead = null, hiTail = null;  \n                    Node\u003cK,V\u003e next;  \n                    do {  \n                        next = e.next;  \n                        // 原索引  \n                        if ((e.hash \u0026 oldCap) == 0) {  \n                            if (loTail == null)  \n                                loHead = e;  \n                            else  \n                                loTail.next = e;  \n                            loTail = e;  \n                        }  \n  \n                        // 原索引+oldCap  \n                        else {  \n                            if (hiTail == null)  \n                                hiHead = e;  \n                            else  \n                                hiTail.next = e;  \n                            hiTail = e;  \n                        }  \n                    } while ((e = next) != null);  \n  \n                    // 原索引元素放到新数组中  \n                    if (loTail != null) {  \n                        loTail.next = null;  \n                        newTab[j] = loHead;  \n                    }  \n  \n                    // 原索引 +oldCap 元素放到新数组中  \n                    if (hiTail != null) {  \n                        hiTail.next = null;  \n                        newTab[j + oldCap] = hiHead;  \n                    }  \n                }  \n            }  \n        }  \n    }  \n    return newTab;  \n}  \n```  \n  \nresize 方法中的前半段，关于 newCap 和 newThr 的计算过程，简化后如下：  \n  \n```java  \nif (oldCap \u003e 0) {  \n    // 嵌套条件分支  \n    if (oldCap \u003e= MAXIMUM_CAPACITY) {...}  \n    else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026  \n                 oldCap \u003e= DEFAULT_INITIAL_CAPACITY) {...}  \n}   \nelse if (oldThr \u003e 0) {...}  \n  \nelse {...}  \n```  \n  \n这些判断分别对应以下几种条件：  \n  \n| 条件                       | 覆盖情况                            | 备注                                                                                                                         |  \n| -------------------------- | ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |  \n| oldCap \u003e 0                 | 桶数组 table 已经被初始化           |                                                                                                                              |  \n| oldThr \u003e 0                 | threshold \u003e 0，且桶数组未被初始化   | 调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况，此种情况下 newCap = oldThr，newThr 在第二个条件分支中算出 |  \n| oldCap == 0 \u0026\u0026 oldThr == 0 | 桶数组未被初始化，且 threshold 为 0 | 调用 HashMap() 构造方法会产生这种情况。                                                                                      |  \n  \noldCap \u003e 0 时表示 table 数组已经被初始化过，这时需要再次计算容量和阈值：  \n  \n| 条件                        | 覆盖情况                                      | 备注                                                      |  \n| --------------------------- | --------------------------------------------- | --------------------------------------------------------- |  \n| oldCap \u003e= 230               | 桶数组容量大于或等于最大桶容量 230            | 后续不再扩容                                              |  \n| newCap \u003c 230 \u0026\u0026 oldCap \u003e 16 | 新桶数组容量小于最大值，且旧桶数组容量大于 16 | 该种情况下新阈值 newThr = oldThr \u003c\u003c 1，移位可能会导致溢出 |  \n  \nresize 方法后续过程中可以看出，Java 8 转移数据操作是按旧链表的正序遍历链表、在新链表的尾部依次插入的，所以不会出现链表 逆序、倒置的情况，故不容易出现环形链表的情况。但仍然还是线程不安全，因为没有加同步锁保护。  \n  \n## 扩容流程对比  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040805.png)\n# get 流程分析  \n  \n## Java 7\n  \n```java  \npublic V get(Object key) {  \n    if (key == null)  \n        return getForNullKey();  \n    Entry\u003cK,V\u003e entry = getEntry(key);  \n    return null == entry ? null : entry.getValue();  \n}  \n  \nprivate V getForNullKey() {  \n    if (size == 0) {  \n        return null;  \n    }  \n  \n    // 下标为 0 处获取 key 为 null 的元素  \n    for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) {  \n        if (e.key == null)  \n            return e.value;  \n    }  \n    return null;  \n}  \n\nfinal Entry\u003cK,V\u003e getEntry(Object key) {  \n    if (size == 0) {  \n        return null;  \n    }  \n  \n    int hash = (key == null) ? 0 : hash(key);  \n    for (Entry\u003cK,V\u003e e = table[indexFor(hash, table.length)];  \n             e != null; e = e.next) {  \n        Object k;  \n        if (e.hash == hash \u0026\u0026  \n            ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n            return e;  \n    }  \n    return null;  \n}  \n```  \n  \n## Java 8\n  \n```java  \npublic V get(Object key) {  \n    Node\u003cK,V\u003e e;  \n    return (e = getNode(hash(key), key)) == null ? null : e.value;  \n}  \n\nfinal Node\u003cK,V\u003e getNode(int hash, Object key) {  \n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n; K k;  \n    if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026  \n        (first = tab[(n - 1) \u0026 hash]) != null) {  \n        // 先判断 tab[index] 中的第一个元素  \n        if (first.hash == hash \u0026\u0026 // always check first node  \n            ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n            return first;  \n        if ((e = first.next) != null) {  \n            // 结点为红黑树则使用 TreeNode 的方法获取  \n            if (first instanceof TreeNode)  \n                return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key);  \n            do { //否则遍历链表  \n                if (e.hash == hash \u0026\u0026  \n                    ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n                    return e;  \n            } while ((e = e.next) != null);  \n        }  \n    }  \n    return null;  \n}  \n```  \n  \n遍历方式  \n  \n```java  \nMap\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e() {{  \n    put(\"a\", 10);  \n    put(\"b\", 20);  \n}};  \n  \n// 方式一：迭代 entrySet  \n  \nfor (Map.Entry\u003cString, Integer\u003e entry : map.entrySet()) {  \n    String key = entry.getKey();  \n    int value = entry.getValue();  \n}  \n\n// 方式二：单独迭代 keySet 或 values  \n// 迭代键  \nfor (String key : map.keySet()) {  \n    System.out.println(\"Key = \" + key);  \n}  \n  \n// 迭代值  \nfor (Integer value : map.values()) {  \n    System.out.println(\"Value = \" + value);  \n}  \n\n// 方式三：使用 iterator  \n  \nIterator\u003cMap.Entry\u003cString, Integer\u003e\u003e entries =         \n          map.entrySet().iterator();  \n  \nwhile (entries.hasNext()) {  \n    Map.Entry\u003cString, Integer\u003e entry = entries.next();  \n    String key = entry.getKey();  \n    int value = entry.getValue();  \n}  \n\n// 方式四：Lambda 表达式  \nmap.forEach((k, v) -\u003e System.out.println(\"key: \" + k + \" value:\" + v));  \n```  \n  \n# 面试题  \n  \n## 为什么 HashMap 数组长度为 2 的幂次方？  \n  \n如果数组中 hash 冲突太过频繁，某些位置的元素形成过长的链表，就会导致数据存取效率过低，因此要使元素均匀地分布在数组中，hash 碰撞就不能太频繁。而 hash 值范围为 -2147483648 到 2147483647，如果用如此长的数组来进行存放加上合理 hash 映射确实可以使 hash 碰撞降到很低的水平，但这明显是不现实的。  \n  \n因此这个 hash 值是不能直接使用的，首先需要进行二次 hash 使得结果更加随机，这时理论上可以使用 hash % length 得到一个不小于数组长度 length 的 index 值，这样不但能避免产生数组越界，并且可以使元素均匀分布，事实上很多 hash 算法都是采用该方法。但是在计算机中，% 取模运算比位 \u0026 运算的效率要低得多，而当 length 为 2 的幂次方时，hash % length 刚好等于 hash \u0026 (length - 1) ，从而能够将 % 运算转换成 \u0026 运算，更加快速地得到 index 值。  \n  \n因此采用 2 的幂次方作为数组的长度的好处是：使元素均匀分部以降低 hash 冲突的基础上，大大加快了计算元素所在数组位置的速度。  \n  \n## hash 冲突有哪些解决方法？HashMap 是怎样解决的？  \n  \n1. 二次 hash，通过高 16 位与低 16 位异或运算，使得结果更加随机；  \n2. 拉链地址法，将 hash 值相同的元素串成一个链表或者转为红黑树。  \n  \n## HashMap 会造成哪些安全问题？怎么解决？  \n  \n如前面文章所述，在 Java 7 中，HashMap 在扩容的时候是通过遍历旧数组，然后在新数组中使用头插法进行转移元素的。这在单线程环境中是没有问题的，但是到了多线程环境下，由于 JMM 的特性，会以一定的概率形成环形链表的情况。在 Java 8 中这个问题通过使用尾插法得到解决，但是多线程下很多操作仍然会导致线程安全问题，比如多个线程 put 后某些元素丢失等。因此多线程环境下要保证线程安全，可以使用 ConcurentHashMap 代替 HashMap。  \n  \n## 使用对象作为 HashMap 的 key 应该注意什么？  \n  \n应当重写对象的 hashCode() 和 equals() 方法。如前面代码所示，HashMap 在 put 一个元素的时候，会调用此元素的 key 值的 hashCode 方法确定元素存放位置，并且会调用 hashCode 和 equals 方法判断元素是否相等。因此如果没有重写这两个方法，或者方法重写的时候没有遵守规则，HashMap 通过 put 存入一组元素后，再通过此元素的 key 值去 get 对象的时候就有可能出现跟预期结果不一致的情况。  \n  \n在重写 equals 方法的时候，需要遵守下面的通用约定：  \n  \n- \u003cstrong\u003e自反性\u003c/strong\u003e：对于任何非空引用 x，x.equals(x) 必须返回 true；  \n- \u003cstrong\u003e对称性\u003c/strong\u003e：对于任何非空引用 x 和 y，如果且仅当 y.equals(x) 返回 true 时 x.equals(y) 必须返回 true；  \n- \u003cstrong\u003e传递性\u003c/strong\u003e：对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 必须返回 true；  \n- \u003cstrong\u003e一致性\u003c/strong\u003e：对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 x.equals(y) 的多次调用必须始终返回 true 或始终返回 false；  \n- \u003cstrong\u003e非空性\u003c/strong\u003e：对于任何非空引用 x，x.equals(null) 必须返回 false。  \n  \n\u003cstrong\u003e重写 hashCode 方法的大致方式（非强制）：\u003c/strong\u003e  \n  \n1. 把某个非零常数值，比如说 31（最好是素数，考虑到 HashMap 源码中的异或操作），保存在一个叫 result 的 int 类型的变量中。  \n2. 对于对象中每一个关键域 f（值 equals 方法中考虑的每一个域），完成以下步骤：  \n3. 为该域计算 int 类型的散列码 c:  \n  \n```  \n1. 如果该域是 boolean 类型，则计算 (f?0:1)  \n  \n2. 如果该域是 byte、char、short 或者 int 类型，则计算 (int)f  \n  \n3. 如果该域是 float 类型，则计算 Float.floatToIntBits(f)  \n  \n4. 如果该域是 long 类型，则计算 (int)(f ^ (f\u003e\u003e\u003e32))  \n  \n5. 如果该域是double类型，则计算 Double.doubleToLongBits(f) 得到一个 long 类型的值，然后按照步骤 4，对该 long 型值计算散列值  \n  \n6. 如果该域是一个对象引用，并且该类的 equals 方法通过递归调用 equals 的方式来比较这个域，则同样对这个对象递归调用 hashCode 方法。  \n  \n7. 如果该域是一个数组，则把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤下面的做法把这些散列值组合起来。  \n```  \n  \n2. 按照下面的公式，把步骤 1 中计算得到的散列码 c 组合到 result 中：result = 31 x result+c。  \n3. 返回 result。  \n4. 写完 hashCode 方法之后，确认是否相等的实例具有相等的散列码。如果不是的话，找出原因，并修改。  \n  \n样例：  \n```java  \npublic class Student {  \n  \n    private String name;  \n  \n    private int age;  \n  \n    private Grades grades;  \n  \n    public Student(String name, int age, Grades grades) {  \n        this.name = name;  \n        this.age = age;  \n        this.grades = grades;  \n    }  \n\n    @Override  \n    public int hashCode() {  \n        final int prime = 31;  \n        int result = 1;  \n        \n        result = prime * result + age;  \n        result = prime * result +  \n                ((name == null) ? 0 : name.hashCode());  \n        result = prime * result +  \n                (grades == null ? 0 : grades.hashCode());  \n  \n        return result;  \n    }  \n  \n    @Override  \n    public boolean equals(Object obj) {  \n        if (this == obj) return true;  \n  \n        if (obj == null || getClass() != obj.getClass()) return false;  \n  \n        Student other = (Student) obj;  \n  \n        if (age != other.age) return false;  \n  \n        if (name != null ? !name.equals(other.name) :   \n              other.name != null) return false;  \n  \n        if (grades != null ? !grades.equals(other.grades) :           \n              other.grades != null) return false;  \n  \n        return true;  \n    }  \n}  \n```","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":["HashMap","源码解析","Java"]},"/IO":{"title":"IO","content":"","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":["Java","IO"]},"/Index-for-Atlases":{"title":"Untitled Page","content":"---\ndate created: 2022-06-22\ndate modified: 2022-08-20\ntags: dataview\ntitle: \"Index for Atlases\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n```dataviewjs\n// 获取当前文件所在的文件夹\nconst currentFolder = dv.current().file.folder\n// 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息\nconst groups =  dv.pages(`\"${currentFolder}\"`).groupBy(p =\u003e p.file.folder)\nfor (let group of groups) {\n\tdv.header(4, group.key);\n\tdv.table([\"Name\",\"标签\",\"入链\", \"创建日期\", \"修改日期\"],\n\t\tgroup.rows\n\t\t\t.sort(k =\u003e k.file.name, 'asc')\n\t\t\t.map(k =\u003e [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday]))\n}\n```\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":[]},"/Index-for-Extras":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: dataview\ntitle: \"Index for Extras\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n```dataviewjs\n// 获取当前文件所在的文件夹\nconst currentFolder = dv.current().file.folder\n// 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息\nconst groups =  dv.pages(`\"${currentFolder}\"`).groupBy(p =\u003e p.file.folder)\nfor (let group of groups) {\n\tdv.header(4, group.key);\n\tdv.table([\"Name\",\"标签\",\"入链\", \"创建日期\", \"修改日期\"],\n\t\tgroup.rows\n\t\t\t.sort(k =\u003e k.file.name, 'asc')\n\t\t\t.map(k =\u003e [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday]))\n}\n```\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":[]},"/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6":{"title":"JVM 中的对象和垃圾回收","content":"\n# 虚拟机中的对象\n\n了解了 JVM 运行时数据区域之后，大致明白了 JVM 内存模型的概况，对内存中的存放内容也有了初步了解。更进一步地，如果要了解内存中的数据的创建过程、在内存中如何布局、以及访问方式等，就必须要把范围限定到具体的虚拟机类型和集中在某一个内存区域上才有意义。下面以最常用的 HotSpot 虚拟机和最常用的内存区域 Java 堆为例，深入探索对象分配、布局和访问过程。\n\n## 对象的创建\n\n![](static/boxcn10RBYpfMovRQajq1qAO2ie.png)\n\n虚拟机遇到一条 new 指令时，首先检查是否被类加载器加载，如果没有，则必须先执行相应的类加载过程。类加载就是把 class 加载到 JVM 的运行时数据区的过程。\n\n### \u003cstrong\u003e1、检查加载\u003c/strong\u003e\n\n首先检查这个指令的参数是否能在常量池中定位到一个类的\u003cstrong\u003e符号引用\u003c/strong\u003e（以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。\n\n### \u003cstrong\u003e2、分配内存\u003c/strong\u003e\n\n如果上一步检查加载成功，接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。\n\n分配内存主要有两种方式\n\n#### \u003cstrong\u003e指针碰撞\u003c/strong\u003e\n\n如果 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“\u003cstrong\u003e指针碰撞\u003c/strong\u003e”。\n\n![](static/boxcnxTmz10LAE2kbvfBvsfLfZe.png)\n\n#### \u003cstrong\u003e空闲列表\u003c/strong\u003e\n\n如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“\u003cstrong\u003e空闲列表\u003c/strong\u003e”。\n\n![](static/boxcnV8m2nZdx5BaYthg1V4DWKh.png)\n\n选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n\n如果是 Serial、ParNew 等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞的方式，既简单又高效。\n\n如果是使用 CMS 这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。\n\n#### \u003cstrong\u003e内存分配的并发安全问题\u003c/strong\u003e\n\n除如何划分可用空间之外，还有另外一个需要考虑的问题是：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的。\n\n解决方案有以下两种：\n\n\u003cstrong\u003eCAS 机制\u003c/strong\u003e\n\n![](static/boxcnjBn0Nebp0DsEqLWhykMAGb.png)\n\n对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。虽然这种方式解决了并发问题，但是我们不难发现，这种方式增加了复杂度，降低了内存的分配的功效性。\n\n\u003cstrong\u003e分配缓冲\u003c/strong\u003e\n\n另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer, 简称 TLAB）。JVM 在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个 Buffer，如果需要分配内存，就在自己的 Buffer 上分配，这样就不存在竞争的情况，可以大大提升分配效率，当 Buffer 容量不够的时候，再重新从 Eden 区域申请一块继续使用。\n\nTLAB 的目的是在为新对象分配内存空间时，让每个 Java 应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。\n\nTLAB 只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个 TLAB 用满（分配指针 top 撞上分配极限 end 时），就新申请一个 TLAB。\n\n分配缓冲较 CAS 机制少了比较、预处理，失败重试步骤，极其高效，所以我们一般使用 TLAB 方式，JVM 默认也是此方式。要禁用 TLAB，需指定 -XX:-UseTLAB。\n\n![](static/boxcn9JqE8jgA1pov2UBLyuei1c.png)\n\n### \u003cstrong\u003e3、内存空间初始化\u003c/strong\u003e\n\n内存分配完成后，虚拟机需要将分配到的内存空间（不包括对相投）都初始化为零值（如 int 值为 0，boolean 值为 false 等等）。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n\n\u003cstrong\u003e注意：此过程没有调用构造方法！\u003c/strong\u003e\n\n### \u003cstrong\u003e4、设置\u003c/strong\u003e\n\n接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes 在 Java hotspot VM 内部表示为类元数据）、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头之中。\n\n### \u003cstrong\u003e5、对象初始化\u003c/strong\u003e\n\n在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但从 Java 程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行 new 指令之后会接着把对象按照程序员的意愿进行初始化(构造方法)，这样一个真正可用的对象才算完全产生出来。\n\n## 对象内存布局\n\n在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。\n\n对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。\n\n对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n\n如果对象是一个 Java 数组，那么在对象头中还有一块用于记录数组长度的数据。\n\n第三部分对齐填充并不是必须的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot 的自动内存管理系统要求对对象的大小必须是 8 字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。数据对齐的作用就是\u003cstrong\u003e方便进行垃圾回收\u003c/strong\u003e。\n\n![](static/boxcntID07QTc6KE013xEOld2dc.png)\n\n## 对象访问定位\n\n建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。\n\n### \u003cstrong\u003e句柄\u003c/strong\u003e\n\nJava 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。\n\n![](static/boxcnpmzpNp2fKTT31oFo73g96c.png)\n\n- \u003cstrong\u003e优点：\u003c/strong\u003ereference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改.\n- \u003cstrong\u003e缺点：\u003c/strong\u003e需要在堆中维护一个句柄池，而且由于中间多了个句柄池引用过程也多了一个步骤，执行效率受到影响。\n\n### \u003cstrong\u003e直接指针\u003c/strong\u003e\n\n如果使用直接指针访问， reference 中存储的直接就是对象地址。\n\n这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。\n\n使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。\n\n![](static/boxcnsgSNPLFvKHRKU6lS0FNUcf.png)\n\n对 HotSpot 而言，它是使用直接指针访问方式进行对象访问的。\n\n# 垃圾收集\n\n## 判断对象存活\n\n在堆里面存放着几乎所有的对象实例，垃圾回收器在对进行回收前，要做的事情就是确定这些对象中哪些还是“存活”着，哪些已经“死去”（死去代表着不可能再被任何途径使用得对象了）。JVM 中有两种算法判断对象的存活。\n\n### 引用计数法\n\n在对象中添加一个引用计数器，每当有一个地方引用他时，计数器的值就加一；当引用失效时，计数器的值就减一，任何时刻计数器为零的对象就是不可能再被使用的。\n\n优点：原理简单、判断效率高\n\n缺点：必须要配合大量的额外处理才能保证正确的工作，如单纯的引用计数法很难解决对象之间相互循环引用的问题。\n\n主流的 Java 虚拟机没有采用引用计数法管理内存。\n\n### 引用链法（可达性分析法）\n\n#### 可达性分析\n\n通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的说法就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。\n\n主流的商用程序（Java、C#）的内存管理子系统都是通过可达性（Reachability Analysis）分析算法来判断对象是否存活。\n\n![](static/boxcnOlPw8Y5iQqLgMY6I87uPeg.png)\n\n#### GC Roots 分类\n\n作为 GC Roots 的对象包括下面几种（重点是前面 4 种）：\n\n\u003cstrong\u003e1、虚拟机栈（栈帧中的本地变量表）中引用的对象。比如各个现场被调用方法堆栈中使用到的参数、局部变量、临时变量等。\u003c/strong\u003e\n\n\u003cstrong\u003e2、方法区中类静态属性引用的对象。比如 Java 类的引用类型静态变量。\u003c/strong\u003e\n\n\u003cstrong\u003e3、方法区中常量引用的对象。比如字符串常量池里的引用。\u003c/strong\u003e\n\n\u003cstrong\u003e4、本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。\u003c/strong\u003e\n\n5、JVM 的内部引用（class 对象、异常对象 NullPointException、OutofMemoryError，系统类加载器）。\n\n6、所有被同步锁（synchronized）持有的对象。\n\n7、JVM 内部的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。\n\n8、JVM 实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收只回收部分代的对象，这个后续会细讲，先大致了解概念）。\n\n#### 决定对象是否死亡\n\n- 可达性分析仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡\n- 当在可达性分析 中判断不可达的对象，只是“被判刑”= 还没真正死亡\n- 不可达对象会被放在”即将回收“的集合里\n- 要判断一个对象真正死亡，还需要经历两个阶段：\n\n##### \u003cstrong\u003e第一次标记 \u0026 筛选\u003c/strong\u003e\n\n如果一个对象在可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。如果对象没有覆盖 finalize() 方法或者 finalize() 方法已被虚拟机调用过，那么虚拟机都将视为“没有必要执行”，这时对象将被继续留在“即将回收”集合。\n\n##### \u003cstrong\u003e第二次标记 \u0026 筛选\u003c/strong\u003e\n\n如果这个对象被判断为有必要执行 finalize() 方法，那么该对象就会被放到 F-Queue 中，稍后收集器将对 F-Queue 中的对象进行小规模标记。在执行 finalize() 过程中，如果对象重新与引用链上的任意一个对象建立关系，那么第二次标记的时候就会被移除“即将回收”的集合。\n\n经过上面两次标记 \u0026 筛选，仍然留在“即将回收”集合里的对象将会在 GC 到来的时候被回收。\n\n![](static/boxcn8X5YVxnXz76VvveR8VXRO6.png)\n\n\u003cstrong\u003e尽量不要依赖 finalize，因为这个方法太不可靠，在生产中很难控制方法的执行或者对象的调用顺序。可以忽略 finalize 方法，因为在 finalize 方法能做的工作，Java 中有更好的方式，比如 try-finally。\u003c/strong\u003e\n\n## 引用类型\n\nJava 中一共有四种引用，分别为强引用、弱引用、软引用和虚引用。\n\n### \u003cstrong\u003e强引用\u003c/strong\u003e\n\n一般的 Object obj = new Object() 就属于强引用。在任何情况下，只要有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n### \u003cstrong\u003e软引用 SoftReference\u003c/strong\u003e\n\n如果内存空间足够，垃圾回收器就不会回收它，\u003cstrong\u003e如果内存空间不足了，就会回收这些对象的内存\u003c/strong\u003e。只要垃圾回收器没有回收它，该对象就可以被程序使用。\n\n软引用可用来实现内存敏感的高速缓存。例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。\n\n### \u003cstrong\u003e弱引用 WeakReference\u003c/strong\u003e\n\n弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，\u003cstrong\u003e不管当前内存空间足够与否，都会回收它的内存\u003c/strong\u003e。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e软引用和弱引用可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。\n\n实际运用（WeakHashMap、ThreadLocal）\n\n### \u003cstrong\u003e虚引用 PhantomReference\u003c/strong\u003e\n\n幽灵引用，最弱（随时会被回收掉）。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。唯一的作用就是垃圾回收的时候收到一个通知，可以用来监控垃圾回收器是否正常工作。\n\n## 垃圾收集算法\n\n#### 分代收集理论\n\n当前虚拟机的垃圾收集器大多数都采用分代收集的理论进行设计，分代收集名为理论，实质事一套符合大多数程序运行实际情况的经验法则，，它建立在两个分代假说之上：\n\n1. 弱分代假说：绝大多数对象都是朝生夕灭的。\n2. 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。\n\n这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（即熬过垃圾收集过程的次数）分配到不同区域中存储。\n\n在 Java 堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型划分；也才能够针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出“标记 - 复制算法”“标记 - 清除算法”和“标记 - 整理算法”等针对性的垃圾收集算法。\n\n一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n![](static/boxcnZP6jEoswUJsiLl90ijJ0Hh.png)\n\n- 新生代：复制算法。每次收集都会有大量对象死去，复制算法只需要付出少量对象的复制成本就可以完成每次垃圾收集。当年轻代中的 Eden 区分配满的时候，就会触发年轻代的 GC（Minor GC）。具体过程如下：\n\n  - 在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区（From 区）；\n  - Eden 区再次 GC，这时会采用复制算法，将 Eden 和 From 区一起清理。存活的对象会被复制到 To 区；接下来，只需要清空 From 区就可以了。\n  - 所以在这个过程中，总会有一个 Survivor 分区是空置的。Eden、From、To 的默认比例是 8:1:1，所以只会造成 10% 的空间浪费。\n- 老年代：标记 - 清除或者标记 - 整理算法。老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保。对象进入老年代有多个途径：\n\n（1）提升（Promotion）\n\n每当发生一次 Minor GC，存活下来的对象年龄（对象头中纪录）都会加 1。直到达到一定的阈值，就会把这些“老年”对象给提升到老年代。\n\n这些对象如果变的不可达，直到老年代发生 GC 的时候，才会被清理掉。\n\n这个阈值，可以通过参数 ‐XX:+MaxTenuringThreshold 进行配置，最大值是 15，因为它是用 4bit 存储的。\n\n（2）空间分配担保\n\nGC 过程每次存活的对象，都会放入其中一个 Survivor 区，这个区域默认的比例是 10%。但是无法保证每次存活的对象都小于 10%，当 Survivor 空间不够，就需要依赖其他内存（指老年代）进行分配担保。这个时候，对象也会直接在老年代上分配。\n\n（3）大对象直接在老年代分配\n\n超出某个大小的对象将直接在老年代分配。这个值是通过参数 -XX:PretenureSizeThreshold 进行配置的。默认为 0，意思是全部首选 Eden 区进行分配。\n\n（4）动态对象年龄判定\n\n有的垃圾回收算法，并不要求 age 必须达到 15 才能晋升到老年代，它会使用一些动态的计算方法。比如，从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 将作为新的阈值，年龄大于此阈值的对象直接进入老年代。\n\n#### 垃圾回收类型介绍\n\n- 部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：\n\n  - 新生代收集（Minor GC/Young GC）：目标只是新生代的垃圾收集。\n  - 老年代收集（Major GC/Old GC）：目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独回收老年代的行为。\n  - 混合收集（Mixed GC）：指目标是收集整个新生代及老年代的垃圾收集。目前只有 G1 收集器有这种行为。\n- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。\n\n#### 标记 - 清除\n\n在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。\n\n在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。\n\n在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。\n\n![](static/boxcnK1bg9OET8qeznmbUKMfAeg.png)\n\n不足：\n\n- 标记和清除过程效率都不高；\n- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。\n\n#### 标记 - 复制\n\n![](static/boxcnFXxzFSeKIN83QcPgEVPCOd.png)\n\n将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。\n\n主要不足是只使用了内存的一半空间。\n\n现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间（分别叫做 From 和 To，也可以叫做 Survivor0 和 Survivor1 ），每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。\n\nHotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。\n\n#### 标记 - 整理\n\n![](static/boxcn14FEWiXqf4jyUx6Wap5ITc.png)\n\n标记的过程与“标记 - 清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n优点:\n\n- 不会产生内存碎片\n\n不足:\n\n- 需要移动大量对象，处理效率比较低。\n\n## 经典垃圾收集器\n\n如果说垃圾收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。《Java 虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器都有可能会有很大的差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。\n\n![](static/boxcny2nVtOWtdnB2WLNTvVSfeg.png)\n\n以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。它们之间涉及到的某些概念，在谈论垃圾收集器的上下文语境中，可以有如下理解：\n\n- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；\n- 串行（Serial）：串行指的是垃圾收集器与用户程序交替执行，意味着在执行垃圾收集的时候需要停顿用户程序；\n- 并行（Parallel） ：指的是多条垃圾收集线程并行工作，默认用户线程仍然处于等待状态。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。\n- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（不一定是并行，可能会交替执行）。用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。\n\n#### Serial 收集器\n\nSerial 翻译为串行，也就是说它以串行的方式执行。\n\n它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内。\n\n![](static/boxcnHNvUoxJnbxUPvalXqwHmQc.png)\n\n\u003cstrong\u003e优点\u003c/strong\u003e\n\n简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。\n\n\u003cstrong\u003e缺点\u003c/strong\u003e\n\n进行垃圾收集工作的时候必须暂停其他所有的工作线程（Stop The World），直到收集结束。\n\n#### ParNew 收集器\n\n它是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。\n\n![](static/boxcn3olNYUQuNAsiR9oYGLtntb.png)\n\n#### Parallel Scavenge 收集器\n\n与 ParNew 一样是多线程收集器。其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。\n\n停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。\n\n缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。\n\n#### Serial Old 收集器\n\n是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用，同样也是一个单线程收集器，使用“标记-整理”算法。如果用在 Server 场景下，它有两大用途：\n\n- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。\n- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。\n\n#### Parallel Old 收集器\n\nParallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。\n\n#### CMS 收集器\n\nCMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。它是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\n\n从名字中的 Mark Sweep 这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n\n- 初始标记： \u003cstrong\u003e暂停所有的其他线程\u003c/strong\u003e，并记录下\u003cstrong\u003e与 GC root 直接相连\u003c/strong\u003e的对象，速度很快。\n- 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n- 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段也需要\u003cstrong\u003e暂停所有的其他线程\u003c/strong\u003e。但停顿时间一般会比初始标记阶段的时间稍长，而又远远比并发标记阶段时间短。\n- 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\n\n![](static/boxcnzuuMqEX3XTJcpYwt8BAfOg.png)\n\n在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。\n\n从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：\n\n- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。\n- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将\u003cstrong\u003e临时启用 Serial Old 来替代 CMS\u003c/strong\u003e。\n- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。\n\n#### G1 收集器\n\nG1 (Garbage-First) 是一款\u003cstrong\u003e面向服务器\u003c/strong\u003e的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。\n\n堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。它把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。\n\n每一个 Region 都可以根据需要，扮演新生代的 Eden、Survivor 和老年代空间，G1 能够对扮演不同觉得的 Region 采用不同的策略区处理。Region 中还有一类特殊的 Humongous（巨大的） 区域，专门用来储存大对象。\n\n![](static/boxcnSEOmm6HPqtl6LO5SZyEIoh.png)\n\nG1 收集器的运作大致分为以下几个步骤：\n\n- 初始标记\n- 并发标记\n- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。\n- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。\n\n![](static/boxcnAsMbObq77oxwiiYgMSXh2d.png)\n\nG1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\n\nG1 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：\n\n- 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。\n- 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\n- 空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。\n- 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。\n\n| 收集器            | 收集对象/算法                      | 收集器类型      | 说明                                                                                                                           | 适用场景                                                                                                     |\n| ----------------- | ---------------------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ |\n| Serial            | 新生代/复制                        | 单线程          |                                                                                                                                | 简单高效；\u003cbr/\u003e适合内存不大的情况；\u003cbr/\u003eClient 场景下的默认新生代收集器。                                    |\n| ParNew            | 新生代/复制                        | 并行\u003cbr/\u003e多线程 | 是 Serial 收集器的多线程版本                                                                                                   | Server 场景下默认的新生代收集器；\u003cbr/\u003e搭配 CMS 垃圾回收器的首选。                                            |\n| Parallel Scavenge | 新生代/复制                        | 并行\u003cbr/\u003e多线程 | 类似 ParNew，更加关注吞吐量，达到一个可控制的吞吐量；                                                                          | Server 场景多 CPU 机器上的默认收集器，主要适合后台运算不需要太多交互的任务；                                 |\n| Serial Old        | 老年代/标记整理                    | 单线程          |                                                                                                                                | Client 模式下虚拟机使用                                                                                      |\n| Parallel Old      | 老年代/标记整理                    | 并行\u003cbr/\u003e多线程 | Parallel Scavenge 收集器的老年代版本，为了配合 Parallel Scavenge 的面向吞吐量的特性而开发的对应组合；                          | 在注重吞吐量以及 CPU 资源敏感的场合采用                                                                      |\n| CMS               | 老年代/标记清除                    | 并行\u003cbr/\u003e并发   | 尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：\u003cbr/\u003e1.内存碎片\u003cbr/\u003e2.需要更多 cpu 资源\u003cbr/\u003e3.浮动垃圾问题，需要更大的堆空间 | 重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者 B/S 系统。互联网后端目前 CMS 是主流的垃圾回收器。 |\n| G1                | 新生代和老年代/标记整理 + 化整为零 | 并行\u003cbr/\u003e并发   | JDK 1.7 才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势；             | 面向服务端应用的垃圾回收器，目标为取代 CMS。                                                                 |\n\n# 内存分配与 GC 策略\n\n## 1. 对象优先在 Eden 分配\n\n大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。\n\n## 2. 大对象直接进入老年代\n\n大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。\n\n经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。\n\n-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。\n\n## 3. 长期存活的对象进入老年代\n\n为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。\n\n-XX:MaxTenuringThreshold 用来定义年龄的阈值。\n\n## 4. 动态对象年龄判定\n\n虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。\n\n## 5. 空间分配担保\n\n在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。\n\n如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。\n\n![](static/boxcnP0d4GwIwOBAkcW5gvjKUoe.png)\n\n## Full GC 的触发条件\n\n对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：\n\n### 1. 调用 System.gc()\n\n只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。\n\n### 2. 老年代空间不足\n\n老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。\n\n为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。\n\n### 3. 空间分配担保失败\n\n使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。\n\n### 4. 永久代空间不足（JDK 1.8 之前）\n\n在 JDK 1.8 之前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。\n\n当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。\n\n为避免以上原因引起的 Full GC，可采用的方法为\u003cstrong\u003e增大永久代空间\u003c/strong\u003e或\u003cstrong\u003e转为使用 CMS 收集器\u003c/strong\u003e。\n\n### 5. Concurrent Mode Failure\n\n执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。\n\n![](static/boxcnT8mtfEs1eSASJ0ca6GARYe.png)\n\n![](static/boxcnxlE7t7AXPhhD2W2inaW5bg.png)\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":["JVM","垃圾回收","GC","Java"]},"/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F":{"title":"JVM 内存区域","content":"\n# 简介\n\n## 什么是 JVM？\n\nJava 虚拟机（Java Virtual Machine，简称 JVM），它能识别 .class 后缀的字节码文件（Java bytecode），并且能够解析它的指令，最终调用操作系统上的函数以完成指定操作。\n\n## 为什么需要 JVM？\n\nJava 程序使用 javac 编译成 .class 文件之后，还需要使用 Java 命令去主动执行它，操作系统并不认识这些 .class 文件，JVM 则充当了翻译官的角色。JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120503.png)\n\n从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现跨平台了。JVM 只需要保证能够正确执行 .class 文件，就可以运行在诸如 Linux、Windows、MacOS 等平台上了。\n\nJVM 解释的是类似于汇编语言的字节码，需要一个抽象的运行时环境。同时，这个虚拟环境也需要解决字节码加载、自动垃圾回收、并发等一系列问题。JVM 其实是一个规范，定义了 .class 文件的结构、加载机制、数据存储、运行时栈等诸多内容，最常用的 JVM 实现就是 Hotspot。\n\n一个 Java 程序，首先经过 javac 编译成 .class 文件，然后 JVM 将其加载到 `元数据` 区，执行引擎将会通过 `混合模式` 执行这些字节码。执行时，会翻译成操作系统相关的函数。JVM 作为 .class 文件的黑盒存在，输入字节码，调用操作系统函数。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120537.png)\n## JVM、JRE 和 JDK 三者关系\n\nJVM 只是一个翻译官，它负责把字节码翻译成机器码，但是需要注意，JVM 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到 JRE。\n\nJRE 除了包含 JVM 之外，提供了很多的类库（就是我们说的 jar 包，它可以提供一些即插即用的功能，比如读取或者操作文件，连接网络，使用 I/O 等等之类的）这些东西就是 JRE 提供的基础类库。JVM 标准加上实现的一大堆基础类库，就组成了 Java 的运行时环境，也就是我们常说的 JRE（Java Runtime Environment）。有了 JRE 之后，Java 程序便可以运行来了。\n\n但对于程序员来说，JRE 还不够。还需要编译代码、调试代码、打包代码，有时候还需要反编译代码等等。因此需要使用 JDK，除了 JRE 之外，JDK 还提供了一些非常好用的小工具，比如 javac（编译代码）、java、jar （打包代码）、javap（反编译 \u003c 反汇编 \u003e）等。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120708.png)\n\n# JVM 运行时数据区\n\n相对于 C 和 C++ 的手动内存管理和复杂难以理解的指针等特性，Java 引以为豪的就是它的自动内存管理机制，这使得 Java 程序写起来方便得多。然而这种呼之即来挥之即去的内存申请和释放方式，自然也有它的代价。为了管理这些快速的内存申请释放操作，就必须引入一个池子来延迟这些内存区域的回收操作。另外，Java 程序的数据结构是非常丰富的，比如有静态成员变量、动态成员变量、区域变量、短小紧凑的对象声明和庞大复杂的内存申请等等。这么多不同的数据结构，到底是在什么地方存储的，它们之间又是怎么进行交互的呢？这就有了内存区域划分的概念，如图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120716.png)\n\nJVM 内存区域划分如图所示，从图中我们可以看出：\n\n- JVM 堆中的数据是共享的，是占用内存最大的一块区域。\n- 可以执行字节码的模块叫作执行引擎。\n- 执行引擎在线程切换时依靠的就是程序计数器来进行恢复。\n- JVM 的内存划分与多线程是息息相关的。程序中运行时用到的栈，以及本地方法栈，它们的维度都是线程。\n- 本地内存包含元数据区和一些直接内存。\n\n![](static/boxcnFXQjU3d0urFc9C5qGM6ISd.png)\n\n## 程序计数器\n\n程序计数器（Program Counter Register）是一块较小的内存空间，由于 JVM 可以并发执行线程，因此会存在线程之间的切换，而这个时候就程序计数器会记录下当前程序执行到的位置，以便在其他线程执行完毕后，恢复现场继续执行。\n\nJVM 会为每个线程分配一个程序计数器，与线程的生命周期相同。\n\n如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行虚拟机字节码指令的地址。如果正在执行的是 Native 本地方法，计数器的值则为空。\n\n\u003cstrong\u003e程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。\u003c/strong\u003e\n\n## 虚拟机栈\n\n虚拟机栈描述的是 Java 方法执行的内存模型：\n\n每个方法在执行的同时都会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n\n虚拟机栈是每个线程独有的，随着线程的创建而存在，线程结束而死亡。\n\n在虚拟机栈内存不够的时候会 OutOfMemoryError，在线程运行中需要更大的虚拟机栈时会出现 StackOverFlowError。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120721.png)\n\n从上图可以看出，虚拟机栈包含很多\u003cstrong\u003e栈帧\u003c/strong\u003e，每个方法执行的同时会创建一个栈帧，栈帧又存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。\n\n### 虚拟机栈运行的原理\n\n- JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循\"先进后出\"的原则。\n- 每一次函数调用都会有一个对应的栈帧被压入虚拟机栈中，每一个函数调用结束后，都会有一个栈帧被弹出。\n- 在一条活动的线程中，一个时间点上，只会有一个数据的栈帧。即只有当前正在执行的方法的栈帧是有效的。这个栈帧称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。\n- 执行引擎运行的所有字节码指令只针对当前的栈帧进行操作。\n- 如果该方法调用了其他方法，对应新的栈帧会创建处理，放在栈的顶部，成为新的当前栈。\n- 不同线程中所包含的栈帧是不允许相互作用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。\n- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的返回结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，是的前一个栈帧重新成为当前栈帧。\n- Java 方法有两种返回方式：return 语句和抛出异常，不管哪种返回方式都会导致栈帧被弹出。\n\n### 局部变量表\n\n局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAdress 类型（指向了一条字节码指令的地址）。\n\n### 操作数栈\n\n主要用于\u003cstrong\u003e保存计算过程的中间结果\u003c/strong\u003e，同时作为计算过程中\u003cstrong\u003e临时的存储空间\u003c/strong\u003e。\n\n当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。\n\n操作数栈、局部变量表和程序计数器的工作过程：\n\n![](static/boxcnIP1LPtHC6Df6FWYsQDun3z.png)\n\n### 动态连接\n\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。\n\n方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)，这也是 Java 强大的扩展能力，在运行期间才能确定目标方法的\u003cstrong\u003e直接引用\u003c/strong\u003e。\n\n所有\u003cstrong\u003e方法调用中的目标方法\u003c/strong\u003e在 Class 文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。\n\n在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池中。比如：描述一个方法调用另外的其他方法时，就是通过常量池中指向方法的引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120904.png)\n\n下面从字节码的角度分析动态连接的过程：\n\n```java\npublic class DynamicLinkingTest {\n    int num = 10;\n    public void methodA() {\n        System.out.println(\"methodA...\");\n    }\n    public void method() {\n        System.out.println(\"methodB...\");\n        methodA();\n        num++;\n    }\n}\n```\n\n上面代码反编译以后可以看到如下指令：\n\n```java\n Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokevirtual #2                  // Method a:()V\n         4: return\n```\n\ninvokevirtual 后面的 #2 符号引用对应的就是运行时常量池中的直接引用。\n\n#2 对应了方法引用，#3，#17……最终对应到 methodA：\n\n```java\nConstant pool:\n   #1 = Methodref          #4.#16         // java/lang/Object.\"\u003cinit\u003e\":()V\n   #2 = Methodref          #3.#17         // com/suanfa/jvm/OperandStackTest.a:()V\n   #3 = Class              #18            // com/suanfa/jvm/OperandStackTest\n   #4 = Class              #19            // java/lang/Object\n   #5 = Utf8               \u003cinit\u003e\n   #6 = Utf8               ()V\n   #7 = Utf8               Code\n   #8 = Utf8               LineNumberTable\n   #9 = Utf8               LocalVariableTable\n  #10 = Utf8               this\n  #11 = Utf8               Lcom/suanfa/jvm/OperandStackTest;\n  #12 = Utf8               a\n  #13 = Utf8               b\n  #14 = Utf8               SourceFile\n  #15 = Utf8               OperandStackTest.java\n  #16 = NameAndType        #5:#6          // \"\u003cinit\u003e\":()V\n  #17 = NameAndType        #12:#6         // a:()V\n  #18 = Utf8               com/suanfa/jvm/OperandStackTest\n  #19 = Utf8               java/lang/Object\n```\n\n#### \u003cstrong\u003e方法调用\u003c/strong\u003e\n\n在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。\n\n1. 静态链接、早期绑定：当一个字节码文件别装入 JVM 内部，如果被调用的目标方法在编译器可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。对应的方法绑定机制为\u003cstrong\u003e早期绑定\u003c/strong\u003e。\n2. 动态链接、晚期绑定：如果方法被调用的时候在编译期无法确定下来，就是说，只能在运行时将调用方法的符号引用转换为直接引用，引用这种引用转换过程具备动态性，因此称之为动态链接。对应的方法绑定机制为\u003cstrong\u003e晚期绑定\u003c/strong\u003e。\n\n#### \u003cstrong\u003e虚方法与非虚方法\u003c/strong\u003e\n\n- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称之为非虚方法。\n- 静态变量、私有方法、final 方法、实例构造器、父类方法都是非虚方法。\n- 其它方法称之为虚方法。\n\n##### 普通调用指令\n\n- invokestatic ：静态方法，解析阶段确定唯一方法版本\n- invokespecial ：调用`\u003cinit\u003e`方法、私有方法以及父类方法，解析阶段确定唯一方法版本\n- invokevirtual ：调用所有虚方法\n- invokeinterface ：调用接口方法\n\n##### 动态调用指令\n\n- invokedynamic ： 动态解析所需要调用的方法，然后执行。invokedynamic 指令是在 Java 7 中增加的，为了实现动态类型语言支持而做的一种改进，但在 Java 7 中并没有提供直接生成的 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具才能够生成 invokedynamic 指令。直到 JDK 8 的 Lambda 表达式的出现，invokedynamic 指令在 Java 中才有了直接生成的方式。\n\n前四条指令固化在虚拟机的内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定版本。其中 invokevirtual 和 invokestatic 指令调用的方法称为非虚方法，其余的（final 修饰除外）称为虚方法。\n\n下面以具体实例展示以上介绍的各种调用指令：\n\n```java\n/**\n * 解析调用中非虚方法、虚方法的测试\n */\nclass Father {\n    public Father(){\n        System.out.println(\"Father 默认构造器\");\n    }\n\n    public static void showStatic(String s){\n        System.out.println(\"Father show static \" + s);\n    }\n\n    public final void showFinal(){\n        System.out.println(\"Father show final\");\n    }\n\n    public void showCommon(){\n        System.out.println(\"Father show common\");\n    }\n\n}\n\npublic class Son extends Father{\n    public Son(){\n        super();\n    }\n\n    public Son(int age){\n        this();\n    }\n\n    public static void main(String[] args) {\n        Son son = new Son();\n        son.show();\n    }\n\n    //不是重写的父类方法，因为静态方法不能被重写\n    public static void showStatic(String s) {\n        System.out.println(\"Son show static \" + s);\n    }\n\n    private void showPrivate(String s) {\n        System.out.println(\"Son show private \" + s);\n    }\n\n    public void show() {\n        //invokestatic\n        showStatic(\"大头儿子\");\n        //invokestatic\n        super.showStatic(\"大头儿子\");\n        //invokespecial\n        showPrivate(\"hello!\");\n        //invokespecial\n        super.showCommon();\n        //invokevirtual 因为此方法声明有final，不能被子类重写\n        //所以也认为该方法是非虚方法\n        showFinal();\n        //虚方法如下\n        //invokevirtual\n        //没有显式加super，被认为是虚方法，因为子类可能重写showCommon\n        showCommon();\n        info();\n\n        MethodInterface in = null;\n        //invokeinterface  \n        //不确定接口实现类是哪一个 需要重写\n        in.methodA();\n        //invokedynamic\n        lambda(()-\u003e {\n          \n        });\n    }\n\n    public void info(){\n\n    }\n    \n    public void lambda(MethodInterface interface) {\n        methodInterface.methodA();\n    }\n\n}\n\ninterface MethodInterface {\n    void methodA();\n}\n```\n\n### 方法出口\n\n指方法返回地址，是存放调用该方法的程序计数器的值。\n\n方法返回分为正常返回和异常退出。无论何种退出情况，都将返回至方法当前被调用的位置，这样程序才能继续执行。\n\n本质上，方法的退出就是当前栈帧出栈的过程。此时需要回复上层方法的局部变量表、操作数栈、将返回值压入调用者的栈帧的操作数栈、设置程序计数器的值等，让调用者方法继续执行下去。正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值。\n\n### 本地方法栈\n\nJava 虚拟机栈是用来为 Java 方法服务，相应地，本地方法栈则是用来为 native 方法服务的，可以认为是通过 JNI (Java Native Interface) 直接调用本地 C/C++ 库，不受 JVM 控制。需要注意的是，HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一了。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120910.png)\n\n本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 异常。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120920.png)\n\n## 堆\n\n堆是 JVM 上最大的内存区域，我们申请的\u003cstrong\u003e几乎所有的对象\u003c/strong\u003e，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。\n\n一个对象创建的时候，决定是堆上分配还是在栈上分配，和两个方面有关：对象的类型和在 Java 类中存在的位置。\n\n- 对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。\n- 对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况。由于每个线程拥有一个虚拟机栈，当在方法体内声明了基本数据类型的对象，就会在栈上直接分配。其他情况，则都是在堆上分配。\n\n堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。\n\n随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。由于对象的大小不一，在长时间运行后，堆空间会被许多细小的碎片占满，造成空间浪费。所以，仅仅销毁对象是不够的，还需要堆空间整理。\n\n现在的虚拟机（包括 HotSpot）都是采用分代回收算法。在分代回收的思想中， 把堆分为：新生代 + 老年代 + 永久代（Java 1.8 之前的方法区的实现方式）； 新生代又分为 Eden + From Survivor + To Survivor 区。几乎所有的 Java 对象都在 Eden 区被 new 出来的。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121108.png)\n\n在 Hotspot 中，Eden、 From 和 To 区空间大小默认比例是 8：1：1。\n\n也可以使用 -XX:SurvivorRatio 调整这个空间比例，比如 -XX:SruvivorRatio=8。\n\n## 方法区\n\n方法区（Method Area）与 Java 堆一样，是所有\u003cstrong\u003e线程共享\u003c/strong\u003e的内存区域。\n\n方法区用于存储已经被虚拟机加载的类信息（即加载类、接口、枚举、注解时需要的信息，包括版本、field、方法、接口等信息）、final 常量、静态变量、编译器即时编译的代码等。\n\n方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。\n\n### 版本演进\n\nJava 8 之前，许多 Java 程序员都习惯在 HotSpot 虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或者将两者混为一谈。本质上这两者是不等价的，因为仅仅是当时的 HotSpot 虚拟机设计团队把垃圾收集器的分代设计思想扩展到方法区，或者说使用永久代来实现方法区而已，这样使得 Hotspot 的垃圾收集器能够像管理 Java 堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机（如 JRockit 和 J9）来说是不存在永久代的概念的，因为《Java 虚拟机规范》对方法区的实现要求比较宽松。\n\n在 Java 6 的时候 Hotspot 开发团队就有放弃永久代，逐步改为采用本地内存来实现方法区的计划了。到了 Java 7，Hotspot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆里；而从 Java 8 开始，则放弃了永久代的概念，改用与 JRockit 和 J9 一样在本地内存中实现的元空间（MetaSpace）来代替，并把之前永久代剩余的内容（运行时常量池和其他类信息等）全部移动到元空间中\n\nJava 7 之前：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121115.png)\n\nJava 7:\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121121.png)\n\nJava 8 开始：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121132.png)\n\n### 采用元空间替代永久代实现方法区的优点\n\n1. 字符串存在永久代中，容易出现性能问题和内存溢出。\n2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。而元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制。\n3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。\n4. 将 HotSpot 与 JRockit 合二为一。\n\n### 方法区中的内容\n\n#### \u003cstrong\u003e类型信息\u003c/strong\u003e\n\n对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：\n\n1. 这个类型的完整有效名称（即包名.类名）\n2. 这个类型直接父类的完整有效名（对于 interface 或是 java. lang.Object，都没有父类）\n3. 这个类型的修饰符（public、 abstract、 final 的某个子集）\n4. 这个类型直接接口的一个延续列表\n\n#### \u003cstrong\u003e域（Field）信息\u003c/strong\u003e\n\nJVM 必须在方法区中保存类型的所有域的相关信息以及域的生命顺序。\n\n域的相关信息包括：域名称、域类型、域修饰符（pubic、private、protected、static、final、volatile、transient 的某个子集）。\n\n#### \u003cstrong\u003e方法（method）信息\u003c/strong\u003e\n\nJVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：\n\n1. 方法名称。\n2. 方法的返回类型（或 void）\n3. 方法参数的数量和类型（按顺序）\n4. 方法的修饰符（public、private、protected、static、final、synchronized、native、abstract 的一个子集）\n5. 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）\n6. 异常表（abstract 和 native 方法除外），每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。\n\n#### \u003cstrong\u003e静态变量（static 变量）\u003c/strong\u003e\n\n1. 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。\n2. 类变量被类的所有实例所共享，即使没有类实例你也可以访问它。\n\n#### \u003cstrong\u003e全局常量（static final 变量）\u003c/strong\u003e\n\n与 non-final 的类变量的处理方法则不同，每个全局常量在编译的时候就被分配了。\n\n```java\npublic static int count = 1;\npublic static final int number = 2;\n```\n\n反编译后就可以看到如下代码：\n\n```java\npublic static int count;\n    descriptor: I\n    flags: ACC_PUBLIC, ACC_STATIC\n\npublic static final int number;\n    descriptor: I\n    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL\n    ConstantValue: int 2\n```\n\n## 直接内存\n\n直接内存并不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。它是处于 Java 堆外的、直接向内存申请的系统内存区间。\n\n直接内存源自 NIO，通过存在堆外内存的 DirectByteBuffer 操作 Native 本地内存。通常，访问直接内存的速度会优于 Java 堆内存，即读写性能高。因此出于性能考虑，读写频繁的场合可能考虑使用直接内存。因此 Java 的 NIO 库使用直接内存进行数据缓冲器。\n\n直接内存也可能导致 OOM，由于它处于 Java 堆外，因此它的大小不会直接受限于 -Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统给出的最大内存。可以通过 -XX:MaxDirectMemorySize 设置它的大小，默认与堆的最大值 -Xmx 参数值一致。\n\n直接内存的缺点是分配回收成本较高、不受 JVM 内存回收管理。\n\n# 常量池和 String\n\n## 常量池概念\n\n### 静态常量池\n\n一个有效的 Class 文件中除了包含了类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息就是\u003cstrong\u003e常量池（Constant Pool）\u003c/strong\u003e，用于存放编译期生成的各种\u003cstrong\u003e字面量（Literal）\u003c/strong\u003e和\u003cstrong\u003e对类型、域和方法的符号引用（Symbolic References）\u003c/strong\u003e。\n\n### 运行时常量池\n\n运行时常量池是方法区中的一部分。Class 文件中静态常量池的内容将在类加载后存放到方法区的运行时常量池中。也就是说，每个 Class 都有一个静态常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。\n\n运行时常量池相对于 Class 文件常量池的一个重要特征就是它具备动态性。运行期间也可以将新产生的常量放入常量池中，典型的实现方式就是 String 类的 intern() 方法。\n\n### 字符串常量池\n\n字符串的分配和其他的对象分配一样，需要耗费高昂的时间和空间为代价，如果需要大量频繁的创建字符串，会极大程度地影响程序的性能，因此 JVM 为了提高性能和减少内存开销引入了字符串常量池的概念。\n\n#### 特点\n\n字符串常量池中是不会存储相同的字符串的。\n\n字符串常量池（String Pool）由 StringTable 类实现，它是一个固定大小的 Hashtable。因此，如果 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长会直接造成调用 String.intern 时性能大幅度下降。\n\n```java\npublic class StringTable extends sun.jvm.hotspot.utilities.Hashtable {\n    ...\n}\n```\n\nJDK6、7 中，StringTable 默认是 1009，所以如果常量池中的字符串过多就会导致效率下降很快，此时可以通过参数进行调整。\n\nJDK8 开始，StringTable 默认是 60013，也可以通过参数进行调整，但限制最小长度不低于 1009。\n\nStringTable 存储的不是 String 对象的内容，而是一个个 HashtableEntry，HashtableEntry 里面的 value 指向的才是 String 对象一般我们说一个字符串进入了字符串常量池其实是说在这个 StringTable 中保存了对它的引用；反之，如果说没有在其中就是说 StringTable 中没有对它的引用。\n\n#### 字符串常量池位置变化\n\n字符串常量池自 Java 7 开始从永久代移动到堆中。因为永久代的回收频率很低，在 Full GC 的时候才会触发，而 Full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了 StringTable 回收效率不高。而开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。因此，只有放到堆里才能及时回收这部分内存。\n\n## String\n\n无论是服务端还是 Android 客户端开发，String 对象无疑是用得最多的数据类型之一，String 类的代码简化后有如下内容：\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    \n    ...\n}\n```\n\n实际上，value[] 数组才是真正存放字符串的容器。\n\n### String 对象的内存分配\n\n以下使用 String 对象最常用的两种方式，下面进行深入分析。\n\n#### 通过字面量赋值创建\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"xyz\";\n        ...\n    }\n}\n```\n\n这段代码执行后（假如 main 线程还存活），内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121313png)\n\n执行 String s = \"xyz\" 时，首先会在字符串常量池中查找（遍历 StringTable 逐个获取 HashtableEntry 对象，判断 HashtableEntry 的 value 是否 equals(\"xyz\")），看能不能找到“xyz”\u003cstrong\u003e字符串的引用\u003c/strong\u003e，如果字符串常量池中找不到这个引用，则：\n\n1. 创建一个 String 对象和 char 数组对象；\n2. 将创建的 String 对象封装成 HashtableEntry，作为 StringTable 的 value 进行存储；\n3. 返回创建的 String 对象。\n\n如果能找到这个引用：\n\n- 直接返回找到引用对应的 String 对象。\n\n#### 通过 new 关键字创建\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = new String(\"xyz\");\n        ...\n    }\n}\n```\n\n这段代码执行后（假如 main 线程还存活），内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121321.png)\n\n执行 String s = new String(\"xyz\") 时，首先会在字符串常量池中查找，看能不能找到“xyz”\u003cstrong\u003e字符串对应对象的引用\u003c/strong\u003e，如果字符串常量池中找不到这个引用，则：\n\n1. 创建一个 String 对象和 char 数组对象；\n2. 将创建的 String 对象封装成 HashtableEntry，作为 StringTable 的 value 进行存储；\n3. new String(\"xyz\") 会在堆区又创建一个 String 对象，char 数组直接指向创建好的 char 数组对象。\n\n如果能找到这个引用：\n\n- new String(\"xyz\") 会在堆区创建一个对象，char 数组直接指向已经存在的 char 数组对象。\n\n#### 对比\n\n对于 String s = \"xyz\" 这种形式创建字符串对象，如果字符串常量池中能找到，不会创建 String 对象；如果如果字符串常量池中找不到，创建一个 String 对象。\n\n对于 String s = new String(\"xyz\") 这种形式创建字符串对象，如果字符串常量池中能找到，创建一个 String 对象；如果如果字符串常量池中找不到，创建两个 String 对象。\n\n所以，在日常开发中，能用 String s = \"xyz\" 尽量不用 String s = new String(\"xyz\")，因为可以少创建一个对象，节省一部分空间。\n\n事实上，运行程序用到 Test 类的时候，Test.class 文件的信息会被解析到内存的方法区里，例子中的“xyz”作为字面量，它的一个引用会被存到在堆中的字符串常量池里。而“xyz”本体还是和所有对象一样，创建在堆中的 Eden 区，但因为一直有一个引用驻留在字符串常量池，所以不会被 GC 清理掉。这个对象“xyz”会生存到整个线程结束。主线程中的 s 变量这时候都还没有被创建，但“xyz”的实例已经在堆里了，对它的引用也已经在字符串常量池里了。\n\n有了前面的基础，再来分析下面代码：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s1 = new String(\"xyz\");\n        String s2 = \"xyz\";\n        System.out.println(s1 == s2);\n        System.out.println(s1.equals(s2));\n        ...\n    }\n}\n输出结果：\nfalse\ntrue\n```\n\n这段代码执行后（假如 main 线程还存活），内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121328.png)\n\n很明显，s1 和 s2 指向的是不同的对象。而 equals 方法比较的真正的 char 数据，并且从图中可以看出 s1 和 s2 最终指向的都是同一个 char 数组对象，所以 s1.equals(s2) 等于 true。关于它们是否指向同一个数组，下图也可以证实：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121334.png)\n\n#### 通过字符串拼接创建\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s1 = \"aa\";\n        String s2 = \"bb\";\n        String str0 = new String(\"aa\") + new String(\"bb\");\n        String str1 = s1 + s2;\n        String str2 = \"aabb\";\n        String str3 = \"aa\" + \"bb\";\n        System.out.println(str0 == str1);\n        System.out.println(str1 == str2);\n        System.out.println(str2 == str3);\n        ...\n    }\n}\n输出结果：\nfalse\nfalse\ntrue\n```\n\n首先，对于 str3 来说，编译期会优化成 “aabb”，因此只有它与 str2 是同一个对象。\n\n对于 str0 和 str1 来说，会被编译器会优化成 new StringBuilder().append(\"aa\").append(\"bb\").toString();\n\nStringBuilder 里面的 append 方法就是对 char 数组进行操作，查看 StringBuilder 的 toString 方法：\n\n```java\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    /**\n     * The value is used for character storage.\n     */\n    char[] value;\n    \n    ...\n\n    @Override\n    public String toString() {\n        // Create a copy, don't share the array\n        return new String(value, 0, count);\n    }\n    \n    ...\n}\n```\n\n再看 String 的这个构造方法：\n\n```java\npublic String(char value[], int offset, int count) {\n    if (offset \u003c 0) {\n        throw new StringIndexOutOfBoundsException(offset);\n    }\n    if (count \u003c= 0) {\n        if (count \u003c 0) {\n            throw new StringIndexOutOfBoundsException(count);\n        }\n        if (offset \u003c= value.length) {\n            this.value = \"\".value;\n            return;\n        }\n    }\n    // Note: offset or count might be near -1\u003e\u003e\u003e1.\n    if (offset \u003e value.length - count) {\n        throw new StringIndexOutOfBoundsException(offset + count);\n    }\n    this.value = Arrays.copyOfRange(value, offset, offset+count);\n}\n```\n\n它关键做了如下操作：\n\n- 根据参数\u003cstrong\u003e复制一份\u003c/strong\u003e char 数组对象。\n- 创建一个 String 对象，String 对象的 value 指向复制的 char 数组对象。\n\n也就是说 str1 指向的 String 对象的 value 值直接指向了一个已经存在的数组，而且没有驻留到字符串常量池，而 str2 指向的对象驻留到字符串常量池里面去了。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121345.png)\n\n因此 str0、str1 和 str2 都是指向不同的对象，并且分别指向不同的 char 数组对象。下图再次验证：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121351.png)\n\n### String.intern() 方法\n\n上面说到，调用 StringBuilder 的 toString 方法创建的 String 对象是不会驻留到字符串常量池的，那还有没有办法将这个对象驻留到字符串常量池呢？有的，这就是 String.intern 方法的作用。\n\n以这段代码为例：\n\n```java\nString s1 = \"aa\";\nString s2 = \"bb\";\nString str = s1 + s2;\nstr.intern();\n```\n\n在执行 str.intern() 之前，内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121400.png)\n\n在执行 str.intern();之后，内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121406.png)\n\nintern 方法就是创建了一个 HashtableEntry 对象，并把 value 指向 String 对象，然后把 HashtableEntry 通过 hash 定位存到对应的字符串成常量池中。当然，前提是字符串常量池中原来没有对应的 HashtableEntry。如果字符串常量池中已经有对应的 HashtableEntry，则返回 HashtableEntry 的 value，即它所对应 String 对象的地址。\n\n#### 版本区别\n\nJDK6 中，将字符串对象尝试放入字符串常量池中：\n\n如果字符串常量池中有，则不会放入，并返回已有的字符串常量池中的对象。\n\n如果没有，会把此对象复制一份，返回字符串池常量池，并返回字符串常量池的地址。\n\nJDK7 开始，将字符串对象尝试放入字符串池常量池中：\n\n如果字符串常量池中有，则不会放入，并返回已有的字符串常量池中的对象。\n\n如果没有，会把对象的引用地址复制一份，放入字符串常量池中，并返回字符串常量池中的引用地址。\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":["JVM","内存区域","内存布局","Java"]},"/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B":{"title":"JVM 字节码指令简介","content":"\nJava 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需的参数（操作数）构成。\n\n在 Java 虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。比如， iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在 Class 文件中它们必须拥有各自独立的操作码。\n\n编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的对 int 类型作为运算类型来进行的。\n\n### 加载和存储指令\n\n加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。这些指令如下：\n\n- 将一个局部变量加载到操作栈:iload、iload_、lload、lload_、fload、fload_、dload、dload_、aload、aload_\n- 将一个数值从操作数栈存储到局部变量表:istore、istore_、lstore、lstore_、fstore、fstore_、dstore、dstore_、astore、astore_\n- 将一个常量加载到操作数栈:bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_、lconst_、fconst_、dconst_\n- 扩充局部变量表的访问索引的指令:wide\n\n### 运算指令\n\n算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。\n\n- 加法指令:iadd、ladd、fadd、dadd\n- 减法指令:isub、lsub、fsub、dsub\n- 乘法指令:imul、lmul、fmul、dmul\n- 除法指令:idiv、ldiv、fdiv、ddiv\n- 求余指令:irem、lrem、frem、drem\n- 取反指令:ineg、lneg、fneg、dneg\n- 位移指令:ishl、ishr、iushr、lshl、lshr、lushr\n- 按位或指令:ior、lor ·按位与指令:iand、land\n- 按位异或指令:ixor、lxor ·局部变量自增指令:iinc\n- 比较指令:dcmp g、dcmp l、fcmp g、fcmp l、lcmp\n\n### 类型转换指令\n\n类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码的显示类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。\n\nJava 虚拟机直接支持以下数值类型的宽化类型转换：\n\n- int 类型到 long、float 或者 double 类型\n- long 类型到 float、double 类型\n- float 类型到 double 类型\n\n相对的，处理窄化类型转换时，就必须显示地使用转换指令来完成：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l 和 d2f\n\n在将 int 或 long 类型窄化转换为整数类型 T 的时候，转换过程仅仅是简单丢弃除最低位 N 字节以外的内容，N 是类型 T 的数据类型长度，这将可能导致转换结果与输入值有不同的正负号（把前面的符号位给舍去了）。\n\n### 对象创建与访问指令\n\n虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素。\n\n- 创建类实例的指令:new\n- 创建数组的指令:new array 、anew array 、mult ianew array\n- 访问类字段(static 字段，或者称为类变量)和实例字段(非 static 字段，或者称为实例变量)的 指令:getfield、putfield、getstatic、putstatic\n- 把一个数组元素加载到操作数栈的指令:baload、caload、saload、iaload、laload、faload、 daload、aaload\n- 将一个操作数栈的值储存到数组元素中的指令:bastore、castore、sastore、iastore、fastore、 dastore、aastore\n- 取数组长度的指令:array lengt h - 检查类实例类型的指令:inst anceof、checkcast\n\n### 操作数栈管理指令\n\n如同操作一个普通数据结构中的堆栈那样，Java 虚拟机提供了一些用于直接操作操作数栈的指令：\n\n- 将操作数栈的栈顶一个或两个元素出栈:p op 、p op 2\n- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶:dup 、dup 2、dup _x1、 dup 2_x1、dup _x2、dup 2_x2\n- 将栈最顶端的两个数值互换:swap\n\n### 控制转移指令\n\n控制转移指令可以让 Java 虚拟机有条件或无条件地从指定位置指令(而不是控制转移指令)的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改 PC 寄存器的值。\n\n- 条件分支:ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq 和 if_acmpne\n- 复合条件分支:tableswitch、lookupswitch\n- 无条件分支:goto、goto_w、jsr、jsr_w、ret\n\n与前面的算术运算的规则一致，对于 boolean、byte、char 和 short 类型的条件分支比较操作，都使用 int 类型的比较指令完成，而对于 long、float 和 double 类型的条件分支比较操作，则会先执行相应类型的比较运算指令，预算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。因此，各种类型的比较最终都会转换为 int 类型的比较操作。\n\n### 方法调用和返回指令\n\n方法调用：分派、执行过程。\n\n- invokevirt ual 指令:用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)， 这也是 Java 语言中最常见的方法分派方式。\n- invokeinterface 指令:用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找 出适合的方法进行调用。\n- invokespecial 指令:用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和 父类方法。\n- invokestatic 指令:用于调用类静态方法(static 方法)。\n- invokedynamic 指令:用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面 四条调用指令的分派逻辑都固化在 Java 虚拟机内部，用户无法改变，而 invokedy namic 指令的分派逻辑 是由用户所设定的引导方法决定的。\n\n方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、dreturn 和 areturn，另外还有一条 return 指令供声明为 void 的方法、实例初始化方法、类和接口的类初始化方法使用。\n\n### 异常处理指令\n\n在 Java 程序中显式抛出异常的操作(throw 语句)都由 athrow 指令来实现，除了用 throw 语句显式抛出异常的情况之外，《Java 虚拟机规范》还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状态时自动抛出。例如整数运算中，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出 ArithmeticException 异常。\n\n而在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（很久之前曾经使用 jsr 和 ret 指令来实现，现在已经不用了），而是采用异常表来完成。\n\n### 10. 同步指令\n\nJava 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来实现的。\n\n方法级的同步是隐式的，无法通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。\n\n同步一段指令集序列通常是由 Java 语言中的 synchronized 语句块来表示，Java 虚拟机的指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义，正确实现 synchronized 关键字需要 javac 编译器与 Java 虚拟机两者共同协作支持。\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":["JVM","字节码","Java"]},"/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90":{"title":"JVM 字节码结构分析","content":"\n# 概述\n\n提到字节码，首先想到的就是 Java，Java 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。\n\n​其实不止是 Java，其他很多编程语言如 Scala、Kotlin 和 Groovy 等都是运行在 JVM 的语言，因此它们对应的编译器也能够生成 .class 字节码。\n\n源代码中的各种变量，关键字和运算符号的语义最终都会编译成多条字节码命令。而字节码命令所能提供的语义描述能力是要明显强于 Java 本身的，所以有其他一些同样基于 JVM 的语言能提供许多 Java 所不支持的语言特性。\n\n![](static/boxcnkcdgXBNKvNVzhrXq8VUnRK.png)\n\n在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个 .java 文件从编译到运行的示例如下。\n\n![](static/boxcnvjHB3lK8C1993rcvvhsAFg.png)\n\nJVM 的指令由一个字节长度的操作码（opcode）和紧随其后的可选的操作数（operand）构成。“字节码”这个名字的由来也是因为操作码的长度用一个字节表示。\n\n`\u003copcode\u003e [\u003coperand1\u003e, \u003coperand2\u003e]`\n\n比如将整型常量 100 压栈到栈顶的指令是 “bipush 100”，其中 bipush 就是操作码，100 就是操作数。\n\n因为操作码长度只有 1 个字节长度，这使得编译后的字节码文件非常小巧紧凑，但同时也直接限制了整个 JVM 操作码指令集的数量最多只能有 256 个，目前已经使用了 200+。\n\n大部分字节码指令都包含了所要操作的类型信息。比如 “ireturn” 用于返回一个 int 类型的数据，“dreturn” 用于返回一个 double 类型的的数据，“freturn” 指令用于返回一个 float 类型的数据，这种方式也使得字节码实际的指令类型远小于 200 个。\n\n字节码使用大端序（Big-Endian）表示，即高位在前，低位在后的方式，比如字节码 “getfield 00 02”，表示的是 “getfiled 0x00\u003c\u003c8 | 0x02（getfield #2)”。\n\n字节码并不是某种虚拟 CPU 的机器码，而是一种介于源码和机器码中间的一种抽象表示方法，不过字节码通过 JIT（Just in time）技术可以被进一步编译成机器码。\n\n# 字节码结构\n\n根据 Java 虚拟机规范，Class 文件通过 \u003cstrong\u003eClassFile\u003c/strong\u003e 定义，有点类似 C 语言的结构体。\n\nClassFile 的结构如下：\n\n```plain text\nClassFile {\n    u4             magic; //魔数\n    u2             minor_version;//小版本号\n    u2             major_version;//大版本号\n    u2             constant_pool_count;//常量数量\n    cp_info        constant_pool[constant_pool_count-1];//常量池\n    u2             access_flags;//类访问标记\n    u2             this_class;//当前类\n    u2             super_class;//父类\n    u2             interfaces_count;//接口数量\n    u2             interfaces[interfaces_count];//接口表\n    u2             fields_count;//字段数量\n    field_info     fields[fields_count];//字段表\n    u2             methods_count;//方法数量\n    method_info    methods[methods_count];//方法表\n    u2             attributes_count;//属性数量\n    attribute_info attributes[attributes_count];//属性表\n}\n```\n\n可以看出，class 文件由下面十个部分组成：\n\n- 魔数（Magic Number）\n- 版本号（Minor\u0026Major Version）\n- 常量池（Constant Pool）\n- 类访问标记(Access Flags)\n- 类索引（This Class）\n- 超类索引（Super Class）\n- 接口表索引（Interfaces）\n- 字段表（Fields）\n- 方法表（Methods）\n- 属性表（Attributes）\n\n它们的按照以下顺序进行排放：\n\n![](static/boxcnjjpJAE7qORzHAVoIdq9yve.png)\n\n《Optimizing Java》的作者编了一句顺口溜帮忙记住上面这十部分：\"My Very Cute Animal Turns Savage In Full Moon Areas.\"\n\n![](static/boxcnuIbBA41MB7NR382pr0gYQ1.png)\n\n以下面这个类为例：\n\n```java\npublic class ByteCodeDemo {\n   private int a = 1;\n\n   public int add() {\n      int b = 2;\n      int c = a + b;\n      System.out.println(c);\n      return c;\n   }\n}\n```\n\n编译生成的字节码如下：\n\n```plain text\n➜  Test hexdump ByteCodeDemo.class\n0000000 ca fe ba be 00 00 00 34 00 24 0a 00 06 00 16 09\n0000010 00 05 00 17 09 00 18 00 19 0a 00 1a 00 1b 07 00\n0000020 1c 07 00 1d 01 00 01 61 01 00 01 49 01 00 06 3c\n0000030 69 6e 69 74 3e 01 00 03 28 29 56 01 00 04 43 6f\n0000040 64 65 01 00 0f 4c 69 6e 65 4e 75 6d 62 65 72 54\n0000050 61 62 6c 65 01 00 12 4c 6f 63 61 6c 56 61 72 69\n0000060 61 62 6c 65 54 61 62 6c 65 01 00 04 74 68 69 73\n0000070 01 00 0e 4c 42 79 74 65 43 6f 64 65 44 65 6d 6f\n0000080 3b 01 00 03 61 64 64 01 00 03 28 29 49 01 00 01\n0000090 62 01 00 01 63 01 00 0a 53 6f 75 72 63 65 46 69\n00000a0 6c 65 01 00 11 42 79 74 65 43 6f 64 65 44 65 6d\n00000b0 6f 2e 6a 61 76 61 0c 00 09 00 0a 0c 00 07 00 08\n00000c0 07 00 1e 0c 00 1f 00 20 07 00 21 0c 00 22 00 23\n00000d0 01 00 0c 42 79 74 65 43 6f 64 65 44 65 6d 6f 01\n00000e0 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65\n00000f0 63 74 01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 53\n0000100 79 73 74 65 6d 01 00 03 6f 75 74 01 00 15 4c 6a\n0000110 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65\n0000120 61 6d 3b 01 00 13 6a 61 76 61 2f 69 6f 2f 50 72\n0000130 69 6e 74 53 74 72 65 61 6d 01 00 07 70 72 69 6e\n0000140 74 6c 6e 01 00 04 28 49 29 56 00 21 00 05 00 06\n0000150 00 00 00 01 00 02 00 07 00 08 00 00 00 02 00 01\n0000160 00 09 00 0a 00 01 00 0b 00 00 00 38 00 02 00 01\n0000170 00 00 00 0a 2a b7 00 01 2a 04 b5 00 02 b1 00 00\n0000180 00 02 00 0c 00 00 00 0a 00 02 00 00 00 01 00 04\n0000190 00 02 00 0d 00 00 00 0c 00 01 00 00 00 0a 00 0e\n00001a0 00 0f 00 00 00 01 00 10 00 11 00 01 00 0b 00 00\n00001b0 00 5c 00 02 00 03 00 00 00 12 05 3c 2a b4 00 02\n00001c0 1b 60 3d b2 00 03 1c b6 00 04 1c ac 00 00 00 02\n00001d0 00 0c 00 00 00 12 00 04 00 00 00 05 00 02 00 06\n00001e0 00 09 00 07 00 10 00 08 00 0d 00 00 00 20 00 03\n00001f0 00 00 00 12 00 0e 00 0f 00 00 00 02 00 10 00 12\n0000200 00 08 00 01 00 09 00 09 00 13 00 08 00 02 00 01\n0000210 00 14 00 00 00 02 00 15\n0000218\n```\n\n通过反编译后可得到如下信息：\n\n```plain text\n➜  Test javap -v ByteCodeDemo\nClassfile /Users/Jie/IdeaProjects/Test/out/production/Test/ByteCodeDemo.class\n  Last modified 2021年8月30日; size 536 bytes\n  MD5 checksum aa05281ffe821ab9f1e1c192a69a5688\n  Compiled from \"ByteCodeDemo.java\"\npublic class ByteCodeDemo\n  minor version: 0\n  major version: 52\n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER\n  this_class: #5                          // ByteCodeDemo\n  super_class: #6                         // java/lang/Object\n  interfaces: 0, fields: 1, methods: 2, attributes: 1\nConstant pool:\n   #1 = Methodref          #6.#22    // java/lang/Object.\"\u003cinit\u003e\":()V\n   #2 = Fieldref           #5.#23    // ByteCodeDemo.a:I\n   #3 = Fieldref           #24.#25   // java/lang/System.out:Ljava/io/PrintStream;\n   #4 = Methodref          #26.#27   // java/io/PrintStream.println:(I)V\n   #5 = Class              #28       // ByteCodeDemo\n   #6 = Class              #29       // java/lang/Object\n   #7 = Utf8               a\n   #8 = Utf8               I\n   #9 = Utf8               \u003cinit\u003e\n  #10 = Utf8               ()V\n  #11 = Utf8               Code\n  #12 = Utf8               LineNumberTable\n  #13 = Utf8               LocalVariableTable\n  #14 = Utf8               this\n  #15 = Utf8               LByteCodeDemo;\n  #16 = Utf8               add\n  #17 = Utf8               ()I\n  #18 = Utf8               b\n  #19 = Utf8               c\n  #20 = Utf8               SourceFile\n  #21 = Utf8               ByteCodeDemo.java\n  #22 = NameAndType        #9:#10         // \"\u003cinit\u003e\":()V\n  #23 = NameAndType        #7:#8          // a:I\n  #24 = Class              #30            // java/lang/System\n  #25 = NameAndType        #31:#32        // out:Ljava/io/PrintStream;\n  #26 = Class              #33            // java/io/PrintStream\n  #27 = NameAndType        #34:#35        // println:(I)V\n  #28 = Utf8               ByteCodeDemo\n  #29 = Utf8               java/lang/Object\n  #30 = Utf8               java/lang/System\n  #31 = Utf8               out\n  #32 = Utf8               Ljava/io/PrintStream;\n  #33 = Utf8               java/io/PrintStream\n  #34 = Utf8               println\n  #35 = Utf8               (I)V\n{\n  public ByteCodeDemo();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1  // Method java/lang/Object.\"\u003cinit\u003e\":()V\n         4: aload_0\n         5: iconst_1\n         6: putfield      #2  // Field a:I\n         9: return\n      LineNumberTable:\n        line 1: 0\n        line 2: 4\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      10     0  this   LByteCodeDemo;\n\n  public int add();\n    descriptor: ()I\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: iconst_2\n         1: istore_1\n         2: aload_0\n         3: getfield      #2 // Field a:I\n         6: iload_1\n         7: iadd\n         8: istore_2\n         9: getstatic     #3 // Field java/lang/System.out:Ljava/io/PrintStream;\n        12: iload_2\n        13: invokevirtual #4 // Method java/io/PrintStream.println:(I)V\n        16: iload_2\n        17: ireturn\n      LineNumberTable:\n        line 5: 0\n        line 6: 2\n        line 7: 9\n        line 8: 16\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      18     0  this   LByteCodeDemo;\n            2      16     1     b   I\n            9       9     2     c   I\n}\nSourceFile: \"ByteCodeDemo.java\"\n```\n\n反编译的过程将看似毫无规律的十六进制数字还原出了更直观易懂的信息，可见字节码的生成必然遵循着某个固定而特殊的规律，下面将一一对它们进行解析。\n\n## 魔数（Magic Number）\n\n.class 文件的头四个字节称为魔数（Magic Number），可以看到 .class 的魔数为 0xCAFEBABE。很多文件都以魔数来进行文件类型的区分，比如 PDF 文件的魔数是 %PDF-(16 进制 0x255044462D)，png 文件的魔数是\\x89PNG（0x89504E47）。文件格式的制定者可以自由的选择魔数值，只要魔数值还没有被广泛的采用过且不会引起混淆即可。\n\n魔数放在文件开头，JVM 可以根据文件的开头来判断这个文件是否可能是一个 .class 文件，如果是，才会继续进行之后的操作。\n\n## 版本号（Minor \u0026 Major Version）\n\n版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。上面示例中版本号对应的字节码为“00 00 00 34”，次版本号转化为十进制为 0，主版本号转化为十进制为 52，对应的主版本号为 1.8，所以编译该文件的 Java 版本号为 1.8.0（每次 Java 发布大版本时，主版本号加 1）。\n\n## 常量池（Constant Pool）\n\n紧接着主版本号之后的字节为常量池入口。常量池整体上分为两部分：常量池计数器（存储常量池大小计数）以及常量池数据区（存储常量池项），如下图所示。\n\n![](static/boxcnRAcBVKioatXxFhpOOr3F9e.png)\n\n### 常量池计数器（constant_pool_count）\n\n由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。本文示例中的代码常量池计数对应的字节码为“00 24”，将十六进制的 24 转化为十进制值为 36，排除掉下标“0”，也就是说，这个类文件中共有 35 个常量。\n\n### 常量池数据区（constant_pool[constant_pool_count-1]）\n\n常量池项中存储两类常量：字面量与符号引用。字面量如声明为 Final 的常量值和文本字符串等，符号引用分为类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。\n\n数据区是由（constant_pool_count-1）个 cp_info 结构组成，一个 cp_info 结构对应一个常量。\n\n目前在字节码中共有 14 种类型的 cp_info（如下图所示），每种类型的结构都是固定的。\n\n| 类型                             | 标志（tag） | 描述                 |\n| -------------------------------- | ----------- | -------------------- |\n| CONSTANT_utf8_info               | 1           | UTF-8 编码的字符串   |\n| CONSTANT_Integer_info            | 3           | 整形字面量           |\n| CONSTANT_Float_info              | 4           | 浮点型字面量         |\n| CONSTANT_Long_info               | ５          | 长整型字面量         |\n| CONSTANT_Double_info             | ６          | 双精度浮点型字面量   |\n| CONSTANT_Class_info              | ７          | 类或接口的符号引用   |\n| CONSTANT_String_info             | ８          | 字符串类型字面量     |\n| CONSTANT_Fieldref_info           | ９          | 字段的符号引用       |\n| CONSTANT_Methodref_info          | 10          | 类中方法的符号引用   |\n| CONSTANT_InterfaceMethodref_info | 11          | 接口中方法的符号引用 |\n| CONSTANT_NameAndType_info        | 12          | 字段或方法的符号引用 |\n| CONSTANT_MothodType_info         | 16          | 方法类型             |\n| CONSTANT_MethodHandle_info       | 15          | 方法句柄             |\n| CONSTANT_InvokeDynamic_info      | 18          | 动态方法调用点       |\n\n具体以 CONSTANT_utf8_info 为例，它的结构如下图所示。首先一个字节“tag”，它的值取自上图中对应项的 Tag，由于它的类型是 utf8_info，所以值为“01”。接下来两个字节标识该字符串的长度 Length，然后 Length 个字节为这个字符串具体的值。\n\n从前文示例中的字节码摘取一个 cp_info 结构，如下图所示。\n\n![](static/boxcnlJJ3NIsuvEuTTWfzB3gJWb.png)\n\n将它翻译过来后，其含义为：该常量类型为 utf8 字符串，长度为一字节，数据为“a”。\n\n![](static/boxcnoYCKARu6A7fWgD6J8y5OOJ.png)\n\n下面来逐一详细介绍这些常量池项。\n\n#### CONSTANT_Utf8_info\n\nCONSTANT_Utf8_info 存储的是经过 MUTF-8(modified UTF-8) 编码的字符串，结构如下:\n\n```plain text\nCONSTANT_Utf8_info {\n    u1 tag;\n    u2 length;\n    u1 bytes[length];\n}\n```\n\n它由三部分构成：\n\n1. 第一部分 tag 值为固定为 1\n2. 第二部分 length 表示字符串的长度\n3. 第三部分是采用 MUTF-8 编码的长度为 length 的字节数组\n\n如果要存储的字符串是\"hello\"，存储结构如下图所示\n\n![](static/boxcnglozJXM2xsd4b9XtXKtMXd.png)\n\nMUTF-8 编码与标准的 UTF-8 编码大部分情况下是相同的，但也有一些细微的区别，比如在 MUTF-8 里空字符(\"\\u0000\")用两个字节 0xC080 表示，而在标准的 UTF-8 编码里的表述方式为 0x00，还有一些其它的差异这里不做深入的展开。\n\n#### CONSTANT_Integer_info 和 CONSTANT_Float_info\n\n这两种结构分别用来表示 int 和 float 类型的常量，这两种类型的结构很类似，都用四个字节来表示具体的数值常量，它们的结构定义如下：\n\n```plain text\nCONSTANT_Integer_info {\n    u1 tag;\n    u4 bytes;\n}\nCONSTANT_Float_info {\n    u1 tag;\n    u4 bytes;\n}\n```\n\n以整型常量 18(0x12) 为例，它在常量池中的布局结构如下图所示：\n\n![](static/boxcnQxx1hRx7YZ5WTY33jM9Jkd.png)\n\nJava 语言规范还定义了 boolean、byte、short 和 char 类型的变量，在常量池中都会被当做 int 来处理，比如用代码定义了下面的常量：\n\n```plain text\npublic class MyConstantTest {\n    public final boolean bool = true; //  1(0x01)\n    public final char c = 'A';        // 65(0x41)\n    public final byte b = 66;         // 66(0x42)\n    public final short s = 67;        // 67(0x43)\n    public final int i = 68;          // 68(0x44)\n}\n```\n\n编译生成的 class 文件如下图所示：\n\n![](static/boxcnxghxz55lxR24BEeO7J4IFd.png)\n\n#### CONSTANT_Long_info 和 CONSTANT_Double_info\n\n这两种结构分别用来表示 long 和 double 类型的常量，这两个结构类似，都用 8 个字节表示具体的常量数值。它们的结构如下：\n\n```plain text\nCONSTANT_Long_info {\n    u1 tag;\n    u4 high_bytes;\n    u4 low_bytes;\n}\n\nCONSTANT_Double_info {\n    u1 tag;\n    u4 high_bytes;\n    u4 low_bytes;\n}\n```\n\n对应的结构如下图所示：\n\n![](static/boxcnw4fKxeJeUtoutX0LlsH9xd.png)\n\n以下面的代码为例\n\n```plain text\npublic class HelloWorldMain {\n    public final long a = Long.MAX_VALUE; \n}\n```\n\njavap 输出的常量池信息如下：\n\n```plain text\nConstant pool:\n   #1 = Methodref          #7.#17         // java/lang/Object.\"\u003cinit\u003e\":()V\n   #2 = Class              #18            // java/lang/Long\n   #3 = Long               9223372036854775807l\n   #5 = Fieldref           #6.#19         // HelloWorldMain.a:J\n```\n\n前面提到过，CONSTANT_Long_info 和 CONSTANT_Double_info 占用两个常量池位置，可以看到常量 a 占用了 #3 和 #4 两个位置，下一个常量从索引值 5 开始。\n\n![](static/boxcnYdwhTSIEh2LOVH65Q9Roed.png)\n\n#### CONSTANT_Class_info\n\nCONSTANT_Class_info 结构用来表示类或接口，它的结构如下：\n\n```plain text\nCONSTANT_Class_info {\n    u1 tag;\n    u2 name_index;\n}\n```\n\n它由两部分组成，第一个字节是 tag，值为 7，tag 后面的两个字节 name_index 是一个常量池索引，指向类型为 CONSTANT_Utf8_info 常量，这个字符串存储的是类或接口的全限定名。如下图所示：\n\n![](static/boxcnsbv5Pcz2WFCdEy1irInLdc.png)\n\n#### CONSTANT_String_info\n\nCONSTANT_String_info 用来表示 java.lang.String 类型的常量对象，同样由两部分构成：\n\n```plain text\nCONSTANT_String_info {\n    u1 tag;\n    u2 string_index;\n}\n```\n\n第一个字节是 tag，值为 8，tag 后面的两个字节是一个叫 string_index 的索引值，指向常量池中的 CONSTANT_Utf8_info，这个 CONSTANT_Utf8_info 中存储的才是真正的字符串常量。\n\n以下面的代码为例：\n\n```java\npublic class HelloWorldMain {\n    private String a = \"hello\";\n}\n```\n\nCONSTANT_String_info 的存储布局方式为：\n\n![](static/boxcnkuaAMiOGNfEanZiRNtV1dh.png)\n\n#### CONSTANT_Fieldref_info、CONSTANT_Methodref_info 和 CONSTANT_InterfaceMethodref_info\n\n这三种常量类型结构比较类似\n\n```plain text\nCONSTANT_Fieldref_info {\n    u1 tag;\n    u2 class_index;\n    u2 name_and_type_index;\n}\n\nCONSTANT_Methodref_info {\n    u1 tag;\n    u2 class_index;\n    u2 name_and_type_index;\n}\n\nCONSTANT_InterfaceMethodref_info {\n    u1 tag;\n    u2 class_index;\n    u2 name_and_type_index;\n}\n```\n\n下面以 CONSTANT_Methodref_info 为例来介绍如何描述一个方法。\n\n方法 = 方法所属的类 + 方法名 + 方法参数和返回值描述符\n\n这就是 CONSTANT_Methodref_info 的作用，它表示类中方法的符号引用\n\n它由三部分构成\n\n- 第一部分也是 tag，值为 10\n- 第二个部分是 class_index，是一个指向 CONSTANT_Class_info 的常量池索引值\n- 第三部分是 name_and_type_index，是一个指向 CONSTANT_NameAndType_info 的常量池索引值，表示方法的参数类型和返回值的签名\n\n```java\npublic class HelloWorldMain {\n    public static void main(String[] args) {\n        new HelloWorldMain().testMethod(1, \"hi\");\n    }\n    public void testMethod(int id, String name) {\n    }\n}\n```\n\nConstant pool:\n\n```plain text\n   #2 = Class              #18            // HelloWorldMain\n   #5 = Methodref          #2.#20         // HelloWorldMain.testMethod:(ILjava/lang/String;)V\n  #20 = NameAndType        #13:#14        // testMethod:(ILjava/lang/String;)V\n```\n\n结构布局示意图如下：\n\n![](static/boxcnX4C4I8q1iJ5YNvckikrLXg.png)\n\n#### CONSTANT_NameAndType_info\n\nCONSTANT_NameAndType_info 结构用来表示字段或者方法，格式如下：\n\n```plain text\nCONSTANT_NameAndType_info {\n    u1 tag;\n    u2 name_index;\n    u2 descriptor_index;\n}\n```\n\n它由三部分组成：\n\n- tag : 值为 12\n- name_index : 指向常量池中的 CONSTANT_Utf8_info，存储的是字段名或者方法名\n- descriptor_index : 也是指向常量池中的 CONSTANT_Utf8_info，存储的是字段描述符或者方法描述符\n\n以下面的方法为例：\n\n```java\npublic void testMethod(int id, String name) {\n}\n```\n\nCONSTANT_NameAndType_info 的结构布局示意图如下：\n\n![](static/boxcnTMVJQxDbRQr2Yj56r48Ywd.png)\n\n#### CONSTANT_MethodType_info、CONSTANT_MethodHandle_info 和 CONSTANT_InvokeDynamic_info\n\n从 JDK1.7 开始，为了更好的支持动态语言调用，新增了以上 3 种常量池类型。\n\n以 CONSTANT_InvokeDynamic_info 为例，它主要为 invokedynamic 指令提供启动引导方法，它由三部分构成：\n\n```plain text\nCONSTANT_InvokeDynamic_info {\n    u1 tag;\n    u2 bootstrap_method_attr_index;\n    u2 name_and_type_index;\n}\n```\n\n- tag：值为 18\n- bootstrap_method_attr_index：指向引导方法表 bootstrap_methods[] 数组的索引\n- name_and_type_index：指向索引类常量池里 CONSTANT_NameAndType_info，表示方法描述符\n\n比如下面的的代码：\n\n```java\npublic void foo() {\n    new Thread (()-\u003e {\n        System.out.println(\"hello\");\n    }).start();\n}\n```\n\njavap 输出的常量池的部分如下：\n\n```plain text\nConstant pool:\n   #3 = InvokeDynamic      #0:#25         // #0:run:()Ljava/lang/Runnable;\n   ...\n  #25 = NameAndType        #37:#38        // run:()Ljava/lang/Runnable;\n\nBootstrapMethods:\n  0: #22 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #23 ()V\n      #24 invokestatic HelloWorldMain.lambda$foo$0:()V\n      #23 ()V\n```\n\n整体的结构如下图所示：\n\n![](static/boxcnRDdo2x0Kya4uGFXaka6gNe.png)\n\n## 类访问标记(Access Flags)\n\n常量池之后存储的是访问标记（Access flags），用来标识一个类是是不是 final、abstract 等，由两个字节表示总共可以有 16 个标记位可供使用，目前只使用了其中的 8 个。\n\n![](static/boxcnIlKqPR8zZnaVqJsjZMEYNg.png)\n\n具体的标记位含义如下\n\n| Flag Name      | Value | Interpretation                         |\n| -------------- | ----- | -------------------------------------- |\n| ACC_PUBLIC     | 1     | 标识是否是 public                      |\n| ACC_FINAL      | 10    | 标识是否是 final                       |\n| ACC_SUPER      | 20    | 已经不用了                             |\n| ACC_INTERFACE  | 200   | 标识是类还是接口                       |\n| ACC_ABSTRACT   | 400   | 标识是否是 abstract                    |\n| ACC_SYNTHETIC  | 1000  | 编译器自动生成，不是用户源代码编译生成 |\n| ACC_ANNOTATION | 2000  | 标识是否是注解类                       |\n| ACC_ENUM       | 4000  | 标识是否是枚举类                       |\n\nJVM 并没有穷举所有的访问标志，而是使用按位或操作来进行描述的，比如某个类的修饰符为 Public Final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010=0x0011。\n\n## 类索引（This Class）、超类索引（Super Class）和接口表索引（Interfaces）\n\n这三个部分用来确定类的继承关系，this_class 表示类索引，super_name 表示父类索引，interfaces 表示类或者接口的直接父接口。以 this_class 为例，它是一个两字节组成，执行常量池。\n\n以下面代码为例：\n\n```java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World\");\n    }\n}\n```\n\nthis_class 为 0x0005，指向常量池中下标为 5 的元素，这个元素是由两部分组成，第一部分是类型，这里是 Class 表示是一个类，第二部分是指向常量池下标 21 的元素，这个元素是字符串 \"HelloWorldMain\"。\n\n![](static/boxcnYfH6pokcjiBINJXkypd1Wh.png)\n\nsuper_class 和 interfaces 的原理与之类似。\n\n## 字段表（Fields）\n\n### 字段表概述\n\n紧随接口索引表之后的是字段表（Fields），类中定义的字段会被存储到这个集合中，包括类中定义的静态和非静态的字段，不包括方法内部定义的变量。\n\n结构如下:\n\n```java\n{\n    u2             fields_count;\n    field_info     fields[fields_count];\n}\n```\n\n由两部分组成\n\n- 字段数量（fields_count）：字段表也是一个变长的结构，类中定义的若干个字段的个数会被存储到字段数量里。\n- 字段集合（fields）：字段集合是一个类数组的结构，共有 fields_count 个，对应类中定义的若干个字段，每一个字段 field_info 的结构会在下面介绍。\n\n如下图所示:\n\n![](static/boxcneFvQOLATDfINYhTn60HaNp.png)\n\n### 字段结构\n\n每个字段（field_info）的格式如下：\n\n```plain text\nfield_info {\n    u2             access_flags; \n    u2             name_index;\n    u2             descriptor_index;\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n字段结构分为四部分：\n\n- access_flags：字段的访问标记。是 public、private 还是 protected，是否是 static，是否是 final 等。\n- name_index：字段名的索引值，指向常量池的的字符串常量。\n- descriptor_index：字段描述符的索引，指向常量池的字符串常量。\n- attributes_count、attribute_info：属性的个数和属性集合。\n\n这些组成部分接下来的会有详细介绍。\n\n### 字段访问标记\n\n与类一样，字段也拥有自己的字段访问标记，不过要比类的访问标记要更丰富一些，共有 9 种，详细的列表如下：\n\n| 访问标记名    | 十六进制值 | 描述                                                      |\n| ------------- | ---------- | --------------------------------------------------------- |\n| ACC_PUBLIC    | 0x0001     | 声明为 public                                             |\n| ACC_PRIVATE   | 0x0002     | 声明为 private                                            |\n| ACC_PROTECTED | 0x0004     | 声明为 protected                                          |\n| ACC_STATIC    | 0x0008     | 声明为 static                                             |\n| ACC_FINAL     | 0x0010     | 声明为 final                                              |\n| ACC_VOLATILE  | 0x0040     | 声明为 volatile，解决内存可见性的问题                     |\n| ACC_TRANSIENT | 0x0080     | 声明为 transient，被 transient 修饰的字段默认不会被序列化 |\n| ACC_SYNTHETIC | 0x1000     | 表示这个字段是由编译器自动生成，而不是用户代码编译产生    |\n| ACC_ENUM      | 0x4000     | 表示这是一个枚举类型的变量                                |\n\n如果在类中定义了如下的字段：\n\n```java\npublic static final int DEFAULT_SIZE = 128;\n```\n\n编译后 DEFAULT_SIZE 字段在类文件中存储的访问标记值为 0x0019，则它的访问标记为 ACC_PUBLIC | ACC_STATIC | ACC_FINAL，表示它是一个 public static final 类型的变量。如下图所示：\n\n![](static/boxcnfiGV3FwMsuDmrPfKGeyFsh.png)\n\n### 字段描述符\n\n当定义一个 int 类型的变量时，类文件中存储的类型并不是字符串的 “int”，而是使用了更精简的 I 来表示。\n\n\u003cstrong\u003e引用类型\u003c/strong\u003e使用 “L;” 的方式来表示为了防止多个连续的引用类型描述符出现混淆，引用类型描述符最后都加上了一个 “;” 作为分隔。比如字符串类型 String 的描述符为  “Ljava/lang/String;\"，\n\nJVM 使用一个前置的 “[” 来表示数组类型，如 int[] 类型描述符为 “[I”，字符串数组 String[] 的描述符为 “[Ljava/lang/String;”。多维数组描述符只是多加了几个 “[” 而已，比如 Object[][][] 类型描述符为 “[[[Ljava/lang/Object;”。\n\n完整的字段类型描述符映射表如下所示：\n\n| 描述符        | 类型                                     |\n| ------------- | ---------------------------------------- |\n| B             | byte 类型                                |\n| C             | char 类型                                |\n| D             | double 类型                              |\n| F             | float 类型                               |\n| I             | int 类型                                 |\n| J             | long 类型                                |\n| S             | short 类型                               |\n| Z             | bool 类型                                |\n| L ClassName ; | 引用类型，\"L\" + 对象类型的全限定名 + \";\" |\n| [             | 一维数组                                 |\n\n### 字段属性表\n\n与字段相关的属性有下面这几个：ConstantValue、Synthetic 、Signature、Deprecated、RuntimeVisibleAnnotations 和 RuntimeInvisibleAnnotations 这六个，比较常见的是 ConstantValue 这属性，用来表示一个常量字段的值。\n\n### 案例分析\n\n以文章开头 ByteCodeDemo 类的字节码中的字段表为例，如下图所示。\n\n![](static/boxcnhkYCPUuhnfj6seMHJCkV5L.png)\n\n0001：字段表计数。实例代码中只有一个字段，故值为 1\n\n剩下为字段属性，一共由四个部分组成：\n\n1. 0002：表示字段的访问标志。对应为 Private\n2. 0007：字段名称。指向常量池中第 7 项：字符 “a”\n3. 0008：字段描述符。指向常量池中第 8 项：字符 “I”（代表 int）\n4. 0000：字段属性个数。没有属性，值为 0\n\n综上，就可以唯一确定出一个类中声明的变量：private int a。\n\n## 方法表（Methods）\n\n### 方法表概述\n\n在字段表后面的是方法表，类中定义的方法会被存储在这里，与前面介绍的字段表很类似，方法表也是一个变长结构：\n\n```java\n{\n    u2             methods_count;\n    method_info    methods[methods_count];\n}\n```\n\n由表示方法个数的 methods_count 和对应个数的方法项集合组成，如下图所示：\n\n![](static/boxcnYRn6VyBjUALNLwpaaXmCGh.png)\n\n### 方法结构\n\n每个字段（method_info）的格式如下：\n\n```plain text\nmethod_info {\n    u2             access_flags;\n    u2             name_index;\n    u2             descriptor_index;\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n字段结构分为四部分：\n\n- access_flags：方法的访问标记。是 public、private 还是 protected，是否是 static，是否是 final 等。\n- name_index：方法名的索引值，指向常量池的的字符串常量。\n- descriptor_index：方法描述符的索引，指向常量池的字符串常量。\n- attributes_count、attribute_info：属性的个数和属性集合。\n\n### 方法访问标记\n\n方法的访问标记比类和字段的访问标记类型更丰富，有 12 种之多，如下表所示：\n\n| 方法访问标记     | 值     | 描述                                                          |\n| ---------------- | ------ | ------------------------------------------------------------- |\n| ACC_PUBLIC       | 0x0001 | 声明为 public                                                 |\n| ACC_PRIVATE      | 0x0002 | 声明为 private                                                |\n| ACC_PROTECTED    | 0x0004 | 声明为 protected                                              |\n| ACC_STATIC       | 0x0008 | 声明为 static                                                 |\n| ACC_FINAL        | 0x0010 | 声明为 final                                                  |\n| ACC_SYNCHRONIZED | 0x0020 | 声明为 synchronized                                           |\n| ACC_BRIDGE       | 0x0040 | bridge 方法, 由编译器生成                                     |\n| ACC_VARARGS      | 0x0080 | 方法包含可变长度参数，比如 String... args                     |\n| ACC_NATIVE       | 0x0100 | 声明为 native                                                 |\n| ACC_ABSTRACT     | 0x0400 | 声明为 abstract                                               |\n| ACC_STRICT       | 0x0800 | 声明为 strictfp，表示使用 IEEE-754 规范的精确浮点数，极少使用 |\n| ACC_SYNTHETIC    | 0x1000 | 表示这个方法是由编译器自动生成，而不是用户代码编译产生        |\n\n以下面的代码为例：\n\n```java\nprivate static synchronized void foo() {\n}\n```\n\n生成的类文件中 foo 方法的访问标记等于 0x002a（ACC_PRIVATE | ACC_STATIC | ACC_SYNCHRONIZED），，表示这是一个 private static synchronized 的方法，如下图所示：\n\n![](static/boxcn5MLe8x4tSSIltG15Zix6Bb.png)\n\n### 方法名与描述符\n\n紧随方法访问标记是方法名索引 name_index，指向常量池中 CONSTANT_Utf8_info 类型的字符串常量，比如有这样一个方法定义 “private void foo()”，编译器会生成一个类型为 CONSTANT_Utf8_info 的字符串常量项，里面存储了 “foo”，方法名索引 name_index 指向了这个常量项。\n\n方法描述符索引 descriptor_index，它也是方法名指向常量池中类型为 CONSTANT_Utf8_info 的字符串常量项。方法描述符用来表示一个方法所需参数和返回值，格式为：\n\n(参数 1 类型 参数 2 类型 参数 3 类型 ...)返回值类型\n\n比如方法 “Object foo(int i, double d, Thread t)” 的描述符为“(IDLjava/lang/Thread;)Ljava/lang/Object;”，其中 “I” 表示第一个参数 i 的参数类型 int，“D” 表示第二个参数 d 的类型 double，“Ljava/lang/Thread;” 表示第三个参数 t 的类型 Thread，“Ljava/lang/Object;” 表示返回值类型 Object。\n\n如下图所示:\n\n![](static/boxcnohqABY9UKJFDi2ic5S6pyb.png)\n\n### 方法属性表\n\n前面介绍了方法的访问标记、方法签名，还有一些重要的信息没有出现，如方法声明抛出的异常，方法的字节码，方法是否被标记为 deprecated，这些信息存在哪里呢？这就是方法属性表的作用。跟方法相关的属性有很多，其中重要的是 Code 和 Exceptions 属性，其中 Code 属性存放方法体的字节码指令，Exceptions 属性用于存储方法声明抛出的异常。\n\n### 案例分析\n\n还是以文章中 ByteCodeDemo 类的字节码中的字段表为例，如下图所示。\n\n![](static/boxcn2QIufOsSvDNcqrr73NMJYe.png)\n\n共分为四个部分：\n\n1. 0001：方法访问标记。表示 public\n2. 0010：方法名的索引值。指向第 16 个常量，即 “add”\n3. 0011：方法描述符的索引。指向第 17 个常量，即 ()I（返回值类型为 int）\n4. 0001000b...：属性表。0001 表示只有一个属性，000b 表示属性名称为 “Code”，具体分析见下文\n\n## 属性表（Attributes）\n\n### 属性表概述\n\n在方法表之后的结构是 class 文件的最后一步部分属性表。\u003cstrong\u003e属性出现的地方比较广泛，不止出现在字段和方法中，在 class 文件中也会出现。\u003c/strong\u003e\n\n相比于常量池只有 14 种固定的类型，属性表是的类型是更加灵活的，不同的虚拟机实现厂商可以自定义自己的属性，JVM 运行时会忽略掉它不认识的属性。\n\n属性表的结构如下所示：\n\n```java\n{\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n与其它结构类似，属性表使用两个字节表示属性的个数 attributes_count，接下来是若干个属性项的集合，可以看做是一个数组，数组的每一项都是一个属性项 attribute_info，数组的大小为 attributes_count。\n\n### 属性结构\n\n每个属性（attribute_info）的格式如下：\n\n```plain text\nattribute_info {\n    u2 attribute_name_index;\n    u4 attribute_length;\n    u1 info[attribute_length];\n}\n```\n\n属性结构分为三部分：\n\n- attribute_name_index：属性名索引\n- attribute_length：属性长度\n- info[attribute_length]：属性数组\n\n属性表其实只是定义了属性的长度，里面还有一个不定长的数组，具体的结构需要自己定义。\n\n### 属性类型\n\n| 属性名称                            | 使用位置           | 含义                                                                                              |\n| ----------------------------------- | ------------------ | ------------------------------------------------------------------------------------------------- |\n| Code                                | 方法表             | Java 代码编译成的字节码指令                                                                       |\n| ConstantValue                       | 字段表             | final 关键字定义的常量池                                                                          |\n| Deprecated                          | 类，方法表，字段表 | 被声明为 deprecated 的方法和字段                                                                  |\n| Exceptions                          | 方法表             | 方法抛出的异常                                                                                    |\n| EnclosingMethod                     | 类文件             | 仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法              |\n| InnerClass                          | 类文件             | 内部类列表                                                                                        |\n| LineNumberTable                     | Code 属性          | Java 源码的行号与字节码指令的对应关系                                                             |\n| LocalVariableTable                  | Code 属性          | 方法的局部变量描述                                                                                |\n| StackMapTable                       | Code 属性          | JDK1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配 |\n| Signature                           | 类，方法表，字段表 | 用于支持泛型情况下的方法签名                                                                      |\n| SourceFile                          | 类文件             | 记录源文件名称                                                                                    |\n| SourceDebugExtension                | 类文件             | 用于存储额外的调试信息                                                                            |\n| Synthetic                           | 类，方法表，字段表 | 标志方法或字段为编译器自动生成的                                                                  |\n| LocalVariableTypeTable              | 类                 | 使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加                          |\n| RuntimeVisibleAnnotations           | 类，方法表，字段表 | 为动态注解提供支持                                                                                |\n| RuntimeInvisibleAnnotations         | 表，方法表，字段表 | 用于指明哪些注解是运行时不可见的                                                                  |\n| RuntimeVisibleParameterAnnotation   | 方法表             | 作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法                                   |\n| RuntimeInvisibleParameterAnnotation | 方法表             | 作用与 RuntimeInvisibleAnnotations 属性类似，作用对象哪个为方法参数                               |\n| AnnotationDefault                   | 方法表             | 用于记录注解类元素的默认值                                                                        |\n| BootstrapMethods                    | 类文件             | 用于保存 invokeddynamic 指令引用的引导方式限定符                                                  |\n\n### ConstantValue 属性\n\nConstantValue 属性只会出现字段 field_info 中，表示静态变量的初始值，它的结构如下：\n\n```plain text\nConstantValue_attribute {\n    u2 attribute_name_index;\n    u4 attribute_length;\n    u2 constantvalue_index;\n}\n```\n\n其中 attribute_name_index 是指向常量池中值为 \"ConstantValue\" 的常量项，ConstantValue 属性的 attribute_length 值恒定为 2，constantvalue_index 指向常量池中具体的常量值索引，根据变量的类型不同 constantvalue_index 指向不同的常量项。\n\n以 “public static final int DEFAULT_SIZE = 128;” 为例，字段对应的 class 文件如下图高亮部分：\n\n![](static/boxcnrzZizdz4XgrKQI7exQWeSf.png)\n\n它对应的字段结构如下：\n\n![](static/boxcnI5pQuvpSf8UwTkp6TOq8xf.png)\n\n### Code 属性\n\nCode 属性可以说是类文件中最重要的组成部分了，它包含了所有方法的字节码，结构如下：\n\n```plain text\nCode_attribute {\n    u2 attribute_name_index;\n    u4 attribute_length;\n    u2 max_stack;\n    u2 max_locals;\n    u4 code_length;\n    u1 code[code_length];\n    u2 exception_table_length;\n    {   u2 start_pc;\n        u2 end_pc;\n        u2 handler_pc;\n        u2 catch_type;\n    } exception_table[exception_table_length];\n    u2 attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\nCode 属性表的字段含义如下：\n\n- 属性名索引（attribute_name_index）占两个字节，指向常量池中 CONSTANT_Utf8_info 常量，表示属性的名字，比如这里对应的常量池的字符串常量\"Code\"。\n- 属性长度（attribute_length）占用两个字节，表示属性值大小。\n- max_stack 表示操作数栈的最大深度，方法执行的任意期间操作数栈的深度都不会超过这个值。它的计算规则是有入栈的指令 stack 增加，有出栈的指令 stack 减少，在整个过程中 stack 的最大值就是 max_stack 的值，增加和减少的值一般都是 1，但也有例外：LONG 和 DOUBLE 相关的指令入栈 stack 会增加 2，VOID 相关的指令则为 0。\n- max_locals 表示局部变量表的大小，它的值并不是等于方法中所有局部变量的数量之和。当一个局部作用域结束，它内部的局部变量占用的位置就可以被接下来的局部变量复用了。\n- code_length 和 code 用来表示字节码相关的信息，其中 code_length 表示字节码指令的长度，占用 4 个字节。code 是一个长度为 code_length 的字节数组，存储真正的字节码指令。\n- exception_table_length 和 exception_table 用来表示代码内部的异常表信息，如我们熟知的 try-catch 语法就会生成对应的异常表。\n- attributes_count 和 attributes[] 用来表示 Code 属性相关的附属属性，Java 虚拟机规定 Code 属性只能包含这四种可选属性：LineNumberTable、LocalVariableTable、LocalVariableTypeTable、StackMapTable。以 LineNumberTable 为例，LineNumberTable 用来存放源码行号和字节码偏移量之间的对应关系，这 LineNumberTable 属于调试信息，不是类文件运行的必需的属性，默认情况下都会生成。如果没有这两个属性，那么在调试时没有办法在源码中设置断点，也没有办法在代码抛出异常的时候在错误堆栈中显示出错的行号信息。\n\n以下面的代码为例：\n\n```java\npublic static void main(String[] args) {\n    try {\n        foo();\n    } catch (NullPointerException e) {\n        System.out.println();\n    } catch (IOException e) {\n        System.out.println();\n    }\n\n    try {\n        foo();\n    } catch (Exception e) {\n        System.out.println();\n    }\n}\n```\n\n如下图所示：\n\n![](static/boxcn8Vve3ec7bNJlvplJIhPbSg.png)\n\n### 案例分析\n\n同样以 ByteCodeDemo 类的字节码为例，如下图所示。\n\n![](static/boxcnTyhgjV3Q99Kdh9Zn59r0Dc.png)\n\n0001 表示为属性表计数，这里只有一个附加属性。属性表\n\n```plain text\nSourceFile_attribute {\n     u2 attribute_name_index;\n     u4 attribute_length;\n     u2 sourcefile_index;\n}\n```\n\nSourceFile_attribute 一共分为三个部分。\n\n0014：指向第 20 个常量，为 “SourceFile”，说明这个属性是 Source\n\n00000002：表示长度为 2\n\n0015：指向第 21 个常量，即 “ByteCodeDemo.java”\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":["JVM","字节码","Java"]},"/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6":{"title":"JVM 类加载机制","content":"\n# 概述\n\nJVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 Java 类型，这个过程被称作 JVM 的类加载机制。\n\n与那些在编译时需要进行连接的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。\n\n# 类加载的时机\n\n一个类型从被加载到虚拟机内存中开始到卸载位置，整个生命周期会经历如下七个阶段，其中验证、准备、解析三个部分统称为连接。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/ClassLoader/clipboard_20230323_120031.png)\n上图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段后再开始，这是为了支持 Java 语言的运行时半丁特性（也被称为动态绑定或者晚期绑定）。\n\n## 主动引用\n\n关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java 虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java 虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证和准备阶段自然需要在此之前开始）：\n\n- 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这四条指令的场景是：\n\n  - 使用 new 关键字实例化对象的时候。\n  - 读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。\n  - 调用一个类的静态方法的时候。\n- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。\n- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；\n- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n- 当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\n\n## 被动引用\n\n以上六种场景中的行为称为对一个类型进行主动引用，除此之外所有引用类型的方式都不会触发初始化，被称为被动引用。\n\n```java\npublic class SuperClass {\n    static {\n        System.out.println(\"SuperClass init!\");\n    }\n\n    public static int value = 123;\n}\n\npublic class SubClass extends SuperClass {\n    static {\n        System.out.println(\"SubClass init!\");\n    }\n    \n    public static final String CONS = \"hello\";\n}\n```\n\n- 通过子类引用父类的静态字段，不会导致子类初始化\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(SubClass.value);\n    }\n}\n输出结果：\nSuperClass init!\n123\n```\n\n- 通过数组定义来引用类，不会触发此类的初始化\n\n该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        SuperClass[] sca = new SuperClass[10];\n    }\n}\n没有任何输出\n```\n\n- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(SubClass.CONS);\n    }\n}\n输出结果：\nhello\n```\n\n# 类加载的过程\n\n类加载的过程包含了加载、验证、准备、解析和初始化这 5 个阶段。\n\n## 加载\n\n这里的加载指的是类加载的一个阶段，注意不要混淆。\n\n加载过程完成以下三件事：\n\n- 通过类的\u003cstrong\u003e完全限定名称\u003c/strong\u003e获取定义该类的二进制字节流。\n- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。\n- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。\n\n其中二进制字节流可以从以下方式中获取：\n\n- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。\n- 从网络中获取，最典型的应用是 Applet。\n- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。\n- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。\n- 从数据库中读取，这种场景相对比较少见。\n- 从加密文件中获取，这是典型的防 Class 文件被反编译的保护措施，通过加载时解密 Class 文件来保障程序运行逻辑不被窥探。\n\n## 验证\n\n验证流程确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成下面四个阶段的动作。\n\n### 文件格式验证\n\n主要验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。\n\n### 元数据验证\n\n对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语言规范》的要求。\n\n### 字节码验证\n\n通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这个阶段就要对类的方法体（Class 文件中的 Code 属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。这个阶段是整个验证过程中最复杂的一个阶段。\n\n### 符号引用验证\n\n这个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配行校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。\n\n符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，JVM 将会抛出异常。\n\n## 准备\n\n准备阶段时正式为类中定义的变量（即被 static 修饰的静态变量）\u003cstrong\u003e分配内存并设置类变量初始值\u003c/strong\u003e的阶段。\n\n实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。\n\n类变量初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。\n\npublic static int value = 123;\n\n把 value 赋值为 123 的 putstatic 指令要到类的初始化阶段中执行类构造器 `\u003cclinit\u003e() `方法时才会被执行。\n\n如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。\n\npublic static final int value = 123;\n\n## 解析\n\n解析阶段是 JVM 将常量池的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行。\n\n解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。\n\n## 初始化\n\n初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 `\u003cclinit\u003e()` 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序制定的主观计划去初始化类变量和其它资源。\n\n- `\u003cclinit\u003e()` 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：\n\n```java\npublic class Test {\n    static {\n        i = 0;                // 给变量赋值可以正常编译通过\n        System.out.print(i);  // 这句编译器会提示“非法向前引用”\n    }\n    static int i = 1;\n}\n```\n\n- 由于父类的 `\u003cclinit\u003e()` 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：\n\n```java\nstatic class Parent {\n    public static int A = 1;\n    static {\n        A = 2;\n    }\n}\n\nstatic class Sub extends Parent {\n    public static int B = A;\n}\n\npublic static void main(String[] args) {\n     System.out.println(Sub.B);  // B 的值为 2\n}\n```\n\n- `\u003cclinit\u003e() `方法对于类或接口来说不是必需的。\n- 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 `\u003cclinit\u003e()` 方法。但接口与类不同的是，执行接口的 `\u003cclinit\u003e()` 方法不需要先执行父接口的 `\u003cclinit\u003e()` 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 `\u003cclinit\u003e()` 方法。\n- 虚拟机会保证一个类的 `\u003cclinit\u003e()` 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 `\u003cclinit\u003e()` 方法，其它线程都会阻塞等待，直到活动线程执行 `\u003cclinit\u003e()` 方法完毕。如果在一个类的 `\u003cclinit\u003e()` 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞往往是很隐蔽的。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/ClassLoader/clipboard_20230323_120337.png)\n\n# 类加载器\n\nJava 虚拟机设计团队有意把了加载阶段中的“通过一个类的全限定名称来获取描述该类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器（Class Loader）”。\n\n## 类与类加载器\n\n对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。\n\n换句话说，虚拟句认定两个类是否相等，除了需要比较类本身相等之外，并且还要判断它们是否使用同一个类加载器进行加载，因为每一个类加载器都拥有一个独立的类名称空间。\n\n这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。\n\n## 类加载器的分类\n\n从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：\n\n- 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；\n- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。\n\n从 Java 开发人员的角度看，类加载器可以划分得更细致一些：\n\n##### \u003cstrong\u003e启动类加载器（Bootstrap ClassLoader）\u003c/strong\u003e\n\n此类加载器负责将存放在 \u003cJRE_HOME\u003e\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（\u003cstrong\u003e仅按照文件名识别\u003c/strong\u003e，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。\n\n##### \u003cstrong\u003e扩展类加载器（Extension ClassLoader）\u003c/strong\u003e\n\n这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 \u003cJAVA_HOME\u003e/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。\n\n##### \u003cstrong\u003e应用程序类加载器（Application ClassLoader）\u003c/strong\u003e\n\n这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为\u003cstrong\u003e系统类加载器\u003c/strong\u003e。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n## 双亲委派模型\n\n应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。\n\n下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/ClassLoader/clipboard_20230323_120403.png)\n\n### 工作过程\n\n一个类加载器收到加载请求，首先将类加载请求转发到\u003cstrong\u003e父类加载器\u003c/strong\u003e，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类加载器无法完成时，子加载器才尝试自己去加载。\n\n### 优点\n\n1. 避免重复加载。\n2. 防止 Java 核心 api 被篡改\n\n### 实现过程\n\n以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。\n\n```java\npublic abstract class ClassLoader {\n    // The parent class loader for delegation\n    private final ClassLoader parent;\n\n    public Class\u003c?\u003e loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n\n    protected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class\u003c?\u003e c = findLoadedClass(name);\n            if (c == null) {\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    c = findClass(name);\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n\n    protected Class\u003c?\u003e findClass(String name) throws ClassNotFoundException {\n        throw new ClassNotFoundException(name);\n    }\n}\n\n```\n","lastmodified":"2023-03-22T16:21:32.36656456Z","tags":["JVM","类加载机制","Java"]}}