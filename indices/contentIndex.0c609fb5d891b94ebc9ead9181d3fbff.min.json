{"/":{"title":"AboutTheGardens","content":"## 111111\n\n### hello everyone!\n\n#### 哈哈哈哈哈\n\nsldfjlsajdfl sldfjlasjdlfjsld\nalsjfsd\nldjfsdf sld\n\n## 了散打减肥了\n\nsldfjlsdfj\nThis is my note:[[2023-03-20]]\n\n### 啊啊啊啊啊\n\n#### 手里的积分啦\n\n了散打发**教练**\n我这里讲了泛型：[[泛型]]\n我这里讲了IO：[[IO]]\n\ntoday's note:[[2023-03-22]]\n\nhashmap:[[HashMap 源码解析]]\n\nmore:[[容器类]]\n\n\n","lastmodified":"2023-03-22T14:03:38.286645979Z","tags":["本库教程"]},"/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88":{"title":"其他模版","content":"### 史蒂夫\n\nline1: \u003c% tp.file.cursor(1) %\u003e\nline2: \u003c% tp.file.cursor(2) %\u003e","lastmodified":"2023-03-22T14:03:37.998643195Z","tags":[]},"/%E5%AE%B9%E5%99%A8%E7%B1%BB":{"title":"容器类","content":"全家福：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095328.png)\n# Iterable 接口\n\n可迭代的意思，实现此接口允许对象成为“for-each”循环语句的目标，提供 iterator 方法用于遍历元素。\n\n```java\npublic interface Iterable\u003cT\u003e {\n    Iterator\u003cT\u003e iterator();\n\n    default void forEach(Consumer\u003c? super T\u003e action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }\n\n    default Spliterator\u003cT\u003e spliterator() {\n        return Spliterators.spliteratorUnknownSize(iterator(), 0);\n    }\n}\n```\n\nIterator 意思为迭代器，它的定义如下：\n\n```java\npublic interface Iterator\u003cE\u003e {\n    boolean hasNext();\n\n    E next();\n\n    default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n\n    default void forEachRemaining(Consumer\u003c? super E\u003e action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n```\n\n迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的接口。它是一个经典的设计模式——迭代器模式（Iterator）。 迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e当使用 Iterator 对集合元素进行迭代时，Iterator 并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量），所以修改迭代变量的值对集合元素本身没有任何影响。\n\n# Collection 接口\n\nCollection 接口为集合层次的根接口，Collection 框架概览如图：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095429.png)\nCollection 接口中的关键方法定义如下：\n\n```java\npublic interface Collection\u003cE\u003e extends Iterable\u003cE\u003e {\n    // 集合大小\n    int size();\n    // 是否为空\n    boolean isEmpty();\n    // 是否包含此元素 o\n    boolean contains(Object o);\n    // 迭代器\n    Iterator\u003cE\u003e iterator();\n    // 转换成数组\n    Object[] toArray();\n    // 转换成指定类型数组\n    \u003cT\u003e T[] toArray(T[] a);\n    // 添加元素 e\n    boolean add(E e);\n    // 移除元素 o\n    boolean remove(Object o);\n    // 是否包含另一集合 c\n    boolean containsAll(Collection\u003c?\u003e c);\n    // 移除所有集合 c 中的元素\n    boolean removeAll(Collection\u003c?\u003e c);\n    /**\n     * 移除符合条件的元素\n     * @since 1.8\n     */\n    default boolean removeIf(Predicate\u003c? super E\u003e filter) {\n        Objects.requireNonNull(filter);\n        boolean removed = false;\n        final Iterator\u003cE\u003e each = iterator();\n        while (each.hasNext()) {\n            if (filter.test(each.next())) {\n                each.remove();\n                removed = true;\n            }\n        }\n        return removed;\n    }\n    // 判断集合中是否有不存在集合 c 中的元素\n    boolean retainAll(Collection\u003c?\u003e c);\n    // 清空所有元素\n    void clear();\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, 0);\n    }\n    /**\n     * @since 1.8\n     */\n    default Stream\u003cE\u003e stream() {\n        return StreamSupport.stream(spliterator(), false);\n    }\n    /**\n     * @since 1.8\n     */\n    default Stream\u003cE\u003e parallelStream() {\n        return StreamSupport.stream(spliterator(), true);\n    }\n}\n可以看出 Collection 有添加、删除和清除元素等方法。\n```\n\nCollection 接口下属有三个关键子借口，分别为 Set、Queue 和 List。\n\n## Set 接口\n\nSet 集合与 Collection 集合基本相同，没有提供任何额外的方法。实际上 Set 就是 Collection，只是行为略有不同（Set 不允许包含重复元素）。\n\nSet 集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个 Set 集合中，则 add() 方法会返回 false，且新元素不会被加入。\n\n```java\npublic interface Set\u003cE\u003e extends Collection\u003cE\u003e {\n    int size();\n\n    boolean isEmpty();\n\n    boolean contains(Object o);\n\n    Iterator\u003cE\u003e iterator();\n    \n    Object[] toArray();\n\n    \u003cT\u003e T[] toArray(T[] a);\n\n    boolean add(E e);\n\n    boolean remove(Object o);\n\n    boolean containsAll(Collection\u003c?\u003e c);\n\n    boolean addAll(Collection\u003c? extends E\u003e c);\n    \n    boolean removeAll(Collection\u003c?\u003e c);\n\n    void clear();\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT);\n    }\n}\n```\n\n### HashSet 类\n\nHashSet 是 Set 接口的典型实现，实现了 Set 接口中的所有方法，并没有添加额外的方法，大多数时候使用 Set 集合时就是使用这个实现类。使用的底层结构是 HashMap，按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。它的实现如下：\n\n```java\npublic class HashSet\u003cE\u003e extends AbstractSet\u003cE\u003e implements Set\u003cE\u003e {\n    static final long serialVersionUID = -5024744406713321676L;\n\n    private transient HashMap\u003cE,Object\u003e map;\n\n    private static final Object PRESENT = new Object();\n\n    public HashSet() {\n        map = new HashMap\u003c\u003e();\n    }\n\n    public HashSet(Collection\u003c? extends E\u003e c) {\n        map = new HashMap\u003c\u003e(Math.max((int) (c.size()/.75f) + 1, 16));\n        addAll(c);\n    }\n\n    public HashSet(int initialCapacity, float loadFactor) {\n        map = new HashMap\u003c\u003e(initialCapacity, loadFactor);\n    }\n\n    public HashSet(int initialCapacity) {\n        map = new HashMap\u003c\u003e(initialCapacity);\n    }\n\n    // dummy 并没有作用，只是用来区分重载构造方法\n    HashSet(int initialCapacity, float loadFactor, boolean dummy) {\n        map = new LinkedHashMap\u003c\u003e(initialCapacity, loadFactor);\n    }\n\n    public Iterator\u003cE\u003e iterator() {\n        return map.keySet().iterator();\n    }\n\n    public int size() {\n        return map.size();\n    }\n\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    public boolean contains(Object o) {\n        return map.containsKey(o);\n    }\n\n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n\n    public boolean remove(Object o) {\n        return map.remove(o)==PRESENT;\n    }\n\n    public void clear() {\n        map.clear();\n    }\n}\n```\n\n可以看出 HashSet 内部其实是一个 HashMap。它的 add(E e) 方法会调用 HashMap 的 put 方法，插入的值会作为 put 的 key 并且把 PRESENT 作为 put 方法的 value 值进行插入，put 方法新增一个原来不存在的值会返回 null，如果原来存在的话会返回原来存在的值，所以是 HashMap 保证了元素不重复。\n\n#### 特点\n\n- 不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。\n- HashSet 不是线程安全的，如果多个线程同时访问一个 HashSet，则必须通过代码来保证其同步。\n- 集合元素值可以是 null。\n\n#### 添加元素规则\n\n两个对象比较，具体分为如下四个情况：\n\n1. equals() 方法返回 false，hashCode() 方法返回不相等，HashSet 将会把它们存储在不同的位置。\n2. equals() 方法返回 true，hashCode() 方法返回不相等，HashSet 将会把它们存储在不同的位置。\n3. equals() 方法返回 true，hashCode() 方法比较相等，HashSet 将会把它们存储在相同的位置，在这个位置以链表式结构来保存多个对象。这是因为当向 HashSet 集合中存入一个元素时，HashSet 会调用对象的 hashCode() 方法来得到对象的 hashCode 值，然后根据该 hashCode 值来决定该对象存储在 HashSet 中存储位置。\n4. equals() 方法返回 true，hashCode() 方法返回 true，HashSet 将不予添加。\n\n如果 HashSet 中两个以上的元素具有相同的 hashCode 值，将会导致性能下降。所以如果重写类的 equals() 方法和 hashCode() 方法时，应尽量保证两个对象通过 hashCode() 方法返回值相等时，通过 equals() 方法比较返回 true。\n\n### LinkedHashSet 类\n\nLinkedHashSet 是 HashSet 的子类，也是根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素是以插入的顺序来保存的。当遍历 LinkedHashSet 集合里的元素时，LinkedHashSet 将会按元素的添加顺序来访问集合里的元素。但是由于要维护元素的插入顺序，在性能上略低与 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。\n\n它的实现如下：\n\n```java\npublic class LinkedHashSet\u003cE\u003e extends HashSet\u003cE\u003e implements Set\u003cE\u003e {\n\n    private static final long serialVersionUID = -2851667679971038690L;\n\n    public LinkedHashSet(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor, true);\n    }\n\n    public LinkedHashSet(int initialCapacity) {\n        super(initialCapacity, .75f, true);\n    }\n\n    public LinkedHashSet() {\n        super(16, .75f, true);\n    }\n\n    public LinkedHashSet(Collection\u003c? extends E\u003e c) {\n        super(Math.max(2*c.size(), 11), .75f, true);\n        addAll(c);\n    }\n\n    @Override\n    public Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT | \nSpliterator.ORDERED);\n    }\n}\n\n```\n\n可以看到，它的构造方法都是通过调用父类 HashSet 的三个参数的构造方法。\n\nHashSet 的构造分方法如下：\n\n```java\nHashSet(int initialCapacity, float loadFactor, boolean dummy) {\n    map = new LinkedHashMap\u003c\u003e(initialCapacity, loadFactor)\n}\n```\n\nLinkedHashMap 的实现见后文。\n\n### TreeSet 类\n\nTreeSet 是 SortedSet 接口的实现类，正如 SortedSet 名字所暗示的，TreeSet 可以确保集合元素处于排序状态。此外，TreeSet 还提供了几个额外的方法。\n\n#### 主要方法\n\ncomparator()：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。\n\nfirst()：返回此 set 中当前第一个（最低）元素。\n\nlast()：返回此 set 中当前最后一个（最高）元素。\n\nlower(E e)：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。\n\nhigher(E e)：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。\n\nfloor(E e)：返回此 set 中小于等于给定元素的最小值；如果不存在这样的元素，则返回 null。\n\nceiling(E e)：返回此 set 中大于给定元素的最大值；如果不存在这样的元素，则返回 null。\n\nsubSet(E fromElement, E toElement)：返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。\n\nheadSet(E toElement)：返回此 set 的部分视图，其元素小于 toElement。\n\ntailSet(E fromElement)：返回此 set 的部分视图，其元素大于等于 fromElement。\n\n#### 排序方式\n\nTreeSet 中所谓的有序，不同于之前所讲的插入顺序，而是通过集合中元素属性进行排序方式来实现的。TreeSet 支持两种排序方法：自然排序和定制排序。在默认情况下，TreeSet 采用自然排序。\n\n##### \u003cstrong\u003e自然排序\u003c/strong\u003e\n\nTreeSet 会调用集合中元素所属类的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列，即把通过 compareTo(Object obj) 方法比较后比较大的的往后排。这种方式就是自然排序。\n\n除了已经实现 Comparable 接口类（String 和 Integer 等）之外，如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口，否则就会出现异常。\n\n\u003cstrong\u003e注意：\u003c/strong\u003eTreeSet 中只能添加同一种类型的对象，否则无法比较，会出现异常。\n\n当一个对象调用该方法与另一个对象比较时，例如 obj1.compareTo(obj2)，如果该方法返回 0，则表明两个对象相等；如果该方法返回一个正整数，则表明 obj1 大于 obj2；如果该方法返回一个负整数，则表明 obj1 小于 obj2。\n\n##### \u003cstrong\u003e定制排序\u003c/strong\u003e\n\n定制排序是通过 Comparator 接口实现的。该接口包含一个 int compare(T o1,T o2) 方法，该方法用于比较 o1, o2 的大小：如果该方法返回正整数，则表明 o1 大于 o2；如果该方法返回 0，则表明 o1 等于 o2；如果该方法返回负整数，则表明 o1 小于 o2。\n\n如果要实现定制排序，则需要在创建 TreeSet 时，调用一个带参构造器，传入 Comparator 对 象。并有该 Comparator 对象负责集合元素的排序逻辑，此时集合元素可以不必实现 Comparable 接口。\n\n#### 判断元素相等\n\n对于 TreeSet 集合而言，判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较是否返回 0——如果通过 compareTo(Object obj) 方法比较返回 0，TreeSet 则会认为它们相等，不予添加入集合内；否则就认为它们不相等，添加到集合内。\n\n\u003cstrong\u003eTreeSet 是根据红黑树结构找到集合元素的存储位置。\u003c/strong\u003e\n\n注意：\n\n1. 无论使用自然排序还是定制排序，都可以通过自定义比较逻辑实现各种各样的排序方式。\n2. 如果向 TreeSet 中添加了一个可变对象后，并且后面程序修改了该可变对象的实例变量，这将导致它与其他对象的大小顺序发生了改变，但 TreeSet 不会再次调整它们。\n3. TreeSet 也是非线程安全的。\n\n### HashSet 和 TreeSet 对比\n\n\u003cstrong\u003e性能：HashSet \u003e LinkedHashSet \u003eTreeSet\u003c/strong\u003e\n\n- HashSet 以 hash 算法进行位置存储，特别适合用于添加、查询操作。\n- LinkedHashSet 由于要维护链表，性能比 HashSet 差点，但是有了链表，LinkedHashSet 更适合于插入、删除以及遍历操作。\n- TreeSet 需要额外的红黑树算法来维护集合的次序，性能最次。\n\n但是具体使用要考虑具体的使用场景。\n\n当需要一个特定排序的集合时，使用 TreeSet 集合。\n\n当经常使用添加、查询操作时，使用 HashSet。\n\n当经常插入排序或使用删除、插入及遍历操作时，使用 LinkedHashSet。\n\n## Queue 接口\n\nQueue 用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常队列不允许随机访问其中的元素。\n\n```java\npublic interface Queue\u003cE\u003e extends Collection\u003cE\u003e {\n    // 插入元素，容量已满时抛出 IllegalStateException 异常\n    boolean add(E e);\n    // 插入元素，容量已满时返回 false\n    boolean offer(E e);\n    // 移除队列头部元素并返回，当集合为空时抛出异常\n    E remove();\n    // 移除队列头部元素并返回，当集合为空时返回 null\n    E poll();\n    // 获取队列中第一个元素，当集合为空时抛出异常\n    E element();\n    // 获取队列中第一个元素，当集合为空时返回 null\n    E peek();\n}\n```\n\n### Deque 接口\n\nDeque 接口是 Queue 接口的子接口，它代表一个双端队列。\n\n就是说对于这个队列容器，既可以从头部插入也可以从尾部插入，既可以从头部获取，也可以从尾部获取，其机制如下图所示：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095517.png)\nLinkedList 也实现了 Deque 接口，所以也可以被当作双端队列使用。\n\n#### 主要方法\n\nvoid addFirst(E e):将指定元素插入此列表的开头。\n\nvoid addLast(E e): 将指定元素添加到此列表的结尾。\n\nE getFirst(E e): 返回此列表的第一个元素。\n\nE getLast(E e): 返回此列表的最后一个元素。\n\nboolean offerFirst(E e): 在此列表的开头插入指定的元素。\n\nboolean offerLast(E e): 在此列表末尾插入指定的元素。\n\nE peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。\n\nE peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。\n\nE pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。\n\nE pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。\n\nE removeFirst(E e): 移除并返回此列表的第一个元素。\n\nboolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\n\nE removeLast(E e): 移除并返回此列表的最后一个元素。\n\nboolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n\n从上面方法中可以看出，Deque 不仅可以当成双端队列使用，而且可以被当成栈来使用，因为该类里还包含了 pop(出栈)、push(入栈)两个方法。\n\n#### 与 Queue、Stack 的关系\n\n当 Deque 当做 Queue 队列使用时（FIFO），添加元素是添加到队尾，删除时删除的是头部元素。从 Queue 接口继承的方法对应 Deque 的方法如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095628.png)\nDeque 也能当 Stack 栈用（LIFO）。这时入栈、出栈元素都是在双端队列的头部进行。Deque  中和 Stack 对应的方法如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095654.png)\n\u003cstrong\u003e注意：\u003c/strong\u003eStack 过于古老，并且实现地非常不好，因此现在基本已经不用了，可以直接用 Deque 来代替 Stack 进行栈操作。\n\n#### ArrayDeque 类\n\n顾名思义，就是用数组实现的 Deque。既然底层是数组那肯定也可以指定其 capacity，也可以不指定，\u003cstrong\u003e默认长度是 16\u003c/strong\u003e，然后根据添加的元素的个数，动态扩展。ArrayDeque 由于是两端队列，所以其顺序是按照元素插入数组中对应位置产生的（下面会具体说明）。\n\n由于本身数据结构的限制，ArrayDeque 没有像 ArrayList 中的 trimToSize 方法可以为自己瘦身。ArrayDeque 的使用方法就是上面的 Deque 的使用方法，基本没有对 Deque 拓展什么方法。\n\n##### \u003cstrong\u003e实现原理\u003c/strong\u003e\n\nArrayDeque 为了满足可以同时在数组两端插入或删除元素的需求，其内部的动态数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。\n\nArrayDeque 维护了两个变量，表示 ArrayDeque 的头和尾：\n\n```java\n//具体存放元素的数组，数组大小一定是2的幂次方\ntransient Object[] elements; // non-private to \n//队列头索引\ntransient int head;\n//队列尾索引\ntransient int tail;\n//默认的最小初始化容量，即传入的容量小于8容量为8，而默认容量是16\nprivate static final int MIN_INITIAL_CAPACITY = 8;\n```\n\n当向头部插入元素时，head 下标减一然后插入元素。而 tail 表示的索引为当前末尾元素表示的索引值加一。若当向尾部插入元素时，直接向 tail 表示的位置插入，然后 tail 再减一。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095736.png)\n\n最初头部和尾部索引都是 0，addLast 方向往右，addFirst 方向往左，所以数组中间可能是空的，当头指针和尾指针相遇的时候对数组进行扩容，并对元素位置进行调整。\n\n注意：ArrayDeque 不是线程安全的。 当作为栈使用时，性能比 Stack 好；当作为队列使用时，性能比 LinkedList 好。\n\n### PriorityQueue 类\n\nPriorityQueue 是 Java 中唯一一个 Queue 接口的直接实现。PriorityQueue 保存队列元素的顺序不是按加入队列的顺序，而是按特定规则进行排序的。因此当调用 peek() 或 poll() 方法取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列中按规则排序最小的元素。\n\n#### 方法概览\n\nPriorityQueue 实现了 Queue 接口，下面列举出 PriorityQueue 的方法。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095901.png)\n\n#### 排序方式\n\n与 TreeSet 相同，PriorityQueue 中的元素可以默认自然排序（也就是数字默认是小的在队列头，字符串则按字典序排列）或者通过提供的 Comparator（比较器）在队列实例化时指定的排序方式。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e\n\n1. 队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素——选择方法是任意的。\n2. 当 PriorityQueue 中没有指定 Comparator 时，加入 PriorityQueue 的元素必须实现 Comparable 接口（即元素是可比较的），否则会导致 ClassCastException。\n\n#### 实现原理\n\nPriorityQueue 本质也是一个动态数组，在这一方面与 ArrayList 是一致的。它的成员变量和构造方法如下：\n\n```java\npublic class PriorityQueue\u003cE\u003e extends AbstractQueue\u003cE\u003e\n    implements java.io.Serializable {\n    private static final int DEFAULT_INITIAL_CAPACITY = 11;\n\n    transient Object[] queue; // non-private to simplify nested class access\n\n\n    private int size = 0;\n\n    private final Comparator\u003c? super E\u003e comparator;\n\n    transient int modCount = 0; // non-private to simplify nested class access\n\n    public PriorityQueue() {\n      this(DEFAULT_INITIAL_CAPACITY, null);\n    }\n\n    public PriorityQueue(int initialCapacity) {\n      this(initialCapacity, null);\n    }\n\n    public PriorityQueue(int initialCapacity,\n                         Comparator\u003c? super E\u003e comparator) {\n      // Note: This restriction of at least one is not actually \n      needed,but continues for 1.5 compatibility\n      if (initialCapacity \u003c 1)\n        throw new IllegalArgumentException();\n      this.queue = new Object[initialCapacity];\n      this.comparator = comparator;\n    }\n    ...\n}\n```\n\nPriorityQueue 可由以下三种构造方法创建：\n\n- 调用默认的构造方法时，使用默认的初始容量（DEFAULT_INITIAL_CAPACITY=11），并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable）。\n- 使用指定的初始容量，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable）。\n- 使用指定的初始容量，并根据指定的比较器 comparator 来排序其元素。\n\n从第三个构造方法可以看出，内部维护了一个动态数组。当添加元素到集合时，会先检查数组是否还有余量，有余量则把新元素加入集合，没余量则调用  grow() 方法增加容量，然后调用 siftUp 将新加入的元素排序插入对应位置。\n\n```java\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i \u003e= queue.length)\n        grow(i + 1);\n    size = i + 1;\n    if (i == 0)\n        queue[0] = e;\n    else\n        siftUp(i, e);\n    return true;\n}\n```\n\n除此之外，还要注意：\n\n1. PriorityQueue 不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的 PriorityBlockingQueue 类。\n2. 不允许插入 null 元素。\n3. PriorityQueue 实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是 O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是 O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是 O(1)。所以在遍历时，若不需要删除元素，则以 peek 的方式遍历每个元素。\n4. 方法 iterator() 中提供的迭代器并不保证以有序的方式遍历优 PriorityQueue 中的元素。\n\n## List 接口\n\nList 集合代表一个\u003cstrong\u003e元素有序、可重复\u003c/strong\u003e的集合，集合中每个元素都有其对应的顺序索引。List 集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List 集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为 0，第二个添加的元素索引为 1......\n\nList 作为 Collection 接口的子接口，可以使用 Collection 接口里的全部方法。而且由于 List 是有序集合，因此 List 集合里增加了一些根据索引来操作集合元素的方法。\n\n```java\npublic interface List\u003cE\u003e extends Collection\u003cE\u003e {\n    int size();\n\n    boolean isEmpty();\n\n    boolean contains(Object o);\n\n    Iterator\u003cE\u003e iterator();\n\n    Object[] toArray();\n\n    \u003cT\u003e T[] toArray(T[] a);\n\n    boolean add(E e);\n\n    boolean remove(Object o);\n\n    boolean containsAll(Collection\u003c?\u003e c);\n    \n    boolean addAll(Collection\u003c? extends E\u003e c);\n    \n    boolean addAll(int index, Collection\u003c? extends E\u003e c);\n    \n    boolean removeAll(Collection\u003c?\u003e c);\n    \n    boolean retainAll(Collection\u003c?\u003e c);\n    /**\n     * 根据 operator 指定的计算规则重新设置 List 集合的所有元素\n     * @since 1.8\n     */\n    default void replaceAll(UnaryOperator\u003cE\u003e operator) {\n        Objects.requireNonNull(operator);\n        final ListIterator\u003cE\u003e li = this.listIterator();\n        while (li.hasNext()) {\n            li.set(operator.apply(li.next()));\n        }\n    }\n    /**\n     * 根据Comparator参数对List集合的元素排序\n     * @since 1.8\n     */\n    default void sort(Comparator\u003c? super E\u003e c) {\n        Object[] a = this.toArray();\n        Arrays.sort(a, (Comparator) c);\n        ListIterator\u003cE\u003e i = this.listIterator();\n        for (Object e : a) {\n            i.next();\n            i.set((E) e);\n        }\n    }\n\n    void clear();\n    // 根据下标获取元素\n    E get(int index);\n    // 替换指定下标位置的元素\n    E set(int index, E element);\n    // 在指定下标位置插入元素\n    void add(int index, E element);\n    // 根据下标删除元素\n    E remove(int index);\n    // 获取元素下标，不存在则返回 -1\n    int indexOf(Object o);\n    // 获取与元素最后一个下标，，不存在则返回 -1\n    int lastIndexOf(Object o);\n\n    ListIterator\u003cE\u003e listIterator();\n    \n    ListIterator\u003cE\u003e listIterator(int index);\n    \n    List\u003cE\u003e subList(int fromIndex, int toIndex);\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.ORDERED);\n    }\n}\n```\n\n可以看出，经过扩展之后，List 相比于 Collection 多了“顺序”的概念，并且支持根据下表对集合进行操作。\n\nisEmpty()、contains() 等方法重新声明是为了为了方便查看文档。比如在 java doc 文档里，在 List 接口里也能看到 Collecion 声明的相关接口。\n\n此外，Java 8 为 List 接口添加了如下两个默认方法：\n\n- \u003cstrong\u003evoid replaceAll(UnaryOperator operator)：\u003c/strong\u003e根据 operator 指定的计算规则重新设置 List 集合的所有元素。\n- \u003cstrong\u003evoid sort(Comparator c)：\u003c/strong\u003e根据 Comparator 参数对 List 集合的元素排序。\n\nListIterator 接口在 Iterator 接口基础上增加了如下方法：\n\n- \u003cstrong\u003eboolean hasPrevious()：\u003c/strong\u003e 如果以逆向遍历列表。如果迭代器有上一个元素，则返回 true。\n- \u003cstrong\u003eObject previous()：\u003c/strong\u003e返回迭代器的前一个元素。\n- \u003cstrong\u003evoid add(Object o)：\u003c/strong\u003e将指定的元素插入列表（可选操作）。\n\n与 Iterator 相比，ListIterator 增加了前向迭代的功能，还可以通过 add() 方法向 List 集合中添加元素。\n\n### ArrayList 类\n\nArrayList 作为 List 类的典型实现，完全支持之前介绍的 List 接口的全部功能。它的成员变量和构造方法声明如下：\n\n```java\npublic class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e\n        implements List\u003cE\u003e, RandomAccess {\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    transient Object[] elementData;\n    \n    private int size;\n    \n    /**\n     * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity \u003e 0) {//初始容量大于0\n            //创建 initialCapacity 大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            // 创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {// 初始容量小于 0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n   /**\n    * 构造包含指定 collection 元素的列表，这些元素利用该集合的迭代器按顺序返回\n    * 如果指定的集合为 null，throws NullPointerException。\n    */\n     public ArrayList(Collection\u003c? extends E\u003e c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n    ...\n}\n```\n\nArrayList 是基于数组实现的 List 类，所以 ArrayList 类封装了一个动态的、允许再分配的 Object[] 数组。ArrayList 对象使用 initalCapacity 参数来设置该数组的长度，当向 ArrayList 中添加元素超过了该数组的长度时，它们的 initalCapacity 会自动增加。下面我们通过阅读 JDK 8 ArrayList 源码来了解这些内容。\n\n#### 扩容机制\n\n以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 \n\nJDK 7 new 无参构造的 ArrayList 对象时，直接创建了长度是 10 的 Object[] 数组 elementData 。并且 JDK 7 中的 ArrayList 的对象的创建类似于单例的饿汉式，而 JDK 8 中的 ArrayList 的对象的创建类似于单例的懒汉式。\n\n添加元素时，首先调用 add 方法：\n\n```java\n/**\n * 将指定的元素追加到此列表的末尾。\n */\npublic boolean add(E e) {\n    //添加元素之前，先调用ensureCapacityInternal方法\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    //这里看到ArrayList添加元素的实质就相当于为数组赋值\n    elementData[size++] = e;\n    return true;\n}\n```\n\n先调用了一个 ensureCapacityInternal() 方法，该方法用来确保数组中是否还有足够容量。\n\n\u003cstrong\u003e注意 ：JDK 11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法 \u003c/strong\u003e\n\n经过一系列方法，最后有个判断：如果剩余容量足够存放这个数据，则进行下一步，如果不够，则需要执行一个重要的方法：\n\n```java\n/**\n * 要分配的最大数组大小\n */\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n/**\n * ArrayList 扩容的核心方法。\n */\nprivate void grow(int minCapacity) {\n   // oldCapacity 为旧容量，newCapacity 为新容量\n   int oldCapacity = elementData.length;\n   //将 oldCapacity 右移一位，其效果相当于 oldCapacity / 2，\n   int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1);\n   //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n   if (newCapacity - minCapacity \u003c 0)\n      newCapacity = minCapacity;\n   // 如果新容量大于 MAX_ARRAY_SIZE，进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n   //如果 minCapacity大 于最大容量，则新容量则为 Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即 Integer.MAX_VALUE - 8。\n   if (newCapacity - MAX_ARRAY_SIZE \u003e 0)\n      newCapacity = hugeCapacity(minCapacity);\n   // minCapacity is usually close to size, so this is a win:\n   elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n`int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1)`，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）。\n\n由此可见，ArrayList 是一个能够进行动态扩展的数组。\n\n#### System.arraycopy() 和 Arrays.copyOf() 方法\n\nArrays.copyOf() 内部调用了 System.arraycopy() 方法，arraycopy() 方法由 native 层实现：\n\n```java\npublic static int[] copyOf(int[] original, int newLength) {\n   // 申请一个新的数组\n   int[] copy = new int[newLength];\n   // 调用System.arraycopy，将源数组中的数据进行拷贝，并返回新的数组\n   System.arraycopy(original, 0, copy, 0,\n           Math.min(original.length, newLength));\n   return copy;\n}\n\n/**\n * @param src 源数组\n * @param srcPos 源数组中的起始位置\n * @param dest 目标数组\n * @param destPos 目标数组中的起始位置\n * @param length 要复制的数组元素的数量\n */\npublic static native void arraycopy(Object src,  int  srcPos,\n                                    Object dest, int destPos,\n                                    int length);\n```\n\nensureCapacity() 和 trimToSize() 方法\n\n- \u003cstrong\u003evoid ensureCapacity(int minCapacity): \u003c/strong\u003e如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。\u003cstrong\u003e在增加大量数据之前，调用此方法，可以减少扩容次数。\u003c/strong\u003e\n- \u003cstrong\u003evoid trimToSize(): \u003c/strong\u003e将此 ArrayList 实例的容量调整为列表的当前大小。\n\n#### transient 的作用\n\n从构造方法中可以看到，实际存放集合元素的数组声明时时被 transient 所修饰的：\n\n`transient Object[] elementData;`\n\n当一个对象被序行化的时候，transient 修饰的变量的值是不包括在序行化的表示中的。但是 ArrayList 又是可序行化的类，elementData 是 ArrayList 具体存放元素的成员，用 transient 来修饰 elementData，岂不是反序列化后的 ArrayList 丢失了原先的元素？\n\n来看下面两个方法：\n\n```java\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException{\n    // Write out element count, and any hidden stuff\n    int expectedModCount = modCount;\n    s.defaultWriteObject();\n\n    // Write out size as capacity for behavioural compatibility with clone()\n    s.writeInt(size);\n\n    // Write out all elements in the proper order.\n    for (int i=0; i\u003csize; i++) {\n        s.writeObject(elementData[i]);\n    }\n\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n\n/**\n * Reconstitute the \u003ctt\u003eArrayList\u003c/tt\u003e instance from a stream (that is,\n * deserialize it).\n */\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n    elementData = EMPTY_ELEMENTDATA;\n\n    // Read in size, and any hidden stuff\n    s.defaultReadObject();\n\n    // Read in capacity\n    s.readInt(); // ignored\n\n    if (size \u003e 0) {\n        // be like clone(), allocate array based upon size not capacity\n        int capacity = calculateCapacity(elementData, size);\n        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);\n        ensureCapacityInternal(size);\n\n        Object[] a = elementData;\n        // Read in all elements in the proper order.\n        for (int i=0; i\u003csize; i++) {\n            a[i] = s.readObject();\n        }\n    }\n}\n由于 elementData 的扩容机制，数组中可能有空元素。因此，每次序列化的时候调用 writeObject() 方法，进而调用 defaultWriteObject() 方法忽略 elementData 先序列化 ArrayList 中的非 transient 元素，然后再通过遍历 elementData 只序列化那些有的元素。\n```\n\n这样一来，既\u003cstrong\u003e加快了序列化的速度，又减小了序列化之后的文件大小 。\u003c/strong\u003e\n\n反序列化时调用 readObject，从 ObjectInputStream 获取 size 和 element，再恢复到 elementData。\n\n//todo\n\n#### 遍历方式\n\nArrayList 支持 3 种遍历方式\n\n\u003cstrong\u003e第一种，通过迭代器遍历：\u003c/strong\u003e\n\n```java\nInteger value = null;\nIterator iter = list.iterator();\nwhile (iter.hasNext()) {\n    value = ter.next();\n}\n```\n\n\u003cstrong\u003e第二种，随机访问，通过索引值去遍历：\u003c/strong\u003e\n\n由于 ArrayList 实现了 RandomAccess 接口，它支持通过索引值去随机访问元素。\n\n```java\nInteger value = null;\nfor (int i = 0; i \u003c list.size(); i++) {\n    value = list.get(i);        \n}\n```\n\n\u003cstrong\u003e第三种，for 循环遍历：\u003c/strong\u003e\n\n```java\nInteger value = null;\nfor (Integer item : list) {\n    value = item;\n}\n```\n\n\u003cstrong\u003e遍历 ArrayList 时，使用随机访问(通过索引序号访问)效率最高，而使用迭代器的效率最低。\u003c/strong\u003e\n\n\u003cstrong\u003e//todo\u003c/strong\u003e\n\n### Vector 类\n\nVector 和 ArrayList 的实现基本类似，以 remove 方法为例：\n\n```java\npublic synchronized E remove(int index) {\n    modCount++;\n    if (index \u003e= elementCount)\n        throw new ArrayIndexOutOfBoundsException(index);\n    E oldValue = elementData(index);\n\n    int numMoved = elementCount - index - 1;\n    if (numMoved \u003e 0)\n        //复制数组，假设数组移除了中间某元素，后边有效值前移1位\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--elementCount] = null; // Let gc do its work\n\n    return oldValue;\n}\n```\n\n它的关键方法都加上了 synchronized 关键字，所以它是\u003cstrong\u003e线程安全\u003c/strong\u003e的，并且也因此\u003cstrong\u003e降低了性能\u003c/strong\u003e。\n\n除此之外，它的扩容机制也与 ArrayList 有所不同：\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    //扩容大小\n    int newCapacity = oldCapacity + ((capacityIncrement \u003e 0) ?\n                                     capacityIncrement : oldCapacity);\n    if (newCapacity - minCapacity \u003c 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE \u003e 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n当构造没有设置 capacityIncrement 时，一次扩容数组变成原来两倍，否则每次容量增加  capacityIncrement。\n\n#### Stack 类\n\nStack 是 Vector 的子类，用于模拟“栈”这种数据结构，即“后进先出”(LIFO)的容器。它提供了如下方法：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095956.png)\n\n由于继承自 Vector，Stack 自然也继承了 Vecor 线程安全和性能较低的特点。因此 Stack 类基本处于废弃状态，实现栈结构可由 LinkedList 代替。\n\n### LinkedList 类\n\nLinkedList 类是 List 接口的实现类——这意味着它是一个 List 集合，可以根据索引来随机访问集合中的元素。\n\n```java\npublic class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e\n             implements List\u003cE\u003e, Deque\u003cE\u003e {\n    transient int size = 0;\n\n    transient Node\u003cE\u003e first;\n\n    transient Node\u003cE\u003e last;\n\n    public LinkedList() {\n    }\n\n    public LinkedList(Collection\u003c? extends E\u003e c) {\n        this();\n        addAll(c);\n    }\n    ...\n}\n```\n\n可以看出，LinkedList 还实现了 Deque 接口，可以被当作成双端队列来使用，因此既可以被当成\u003cstrong\u003e栈\u003c/strong\u003e来使用，也可以当成\u003cstrong\u003e队列\u003c/strong\u003e来使用。\n\nLinkedList 的实现机制与 ArrayList 完全不同。ArrayList 内部是以数组的形式来保存集合中的元素的，因此随机访问集合元素时有较好的性能；而 L inkedList 内部以链表的形式来保存集合中的元素，因此随机访问集合元素时性能较差，但在插入、删除元素时性能比较出色。\n\n由于 LinkedList 双端队列的特性，所以新增了一些方法。\n\n#### 方法概览\n\n```java\nvoid addFirst(E e):将指定元素插入此列表的开头。\nvoid addLast(E e): 将指定元素添加到此列表的结尾。\nE getFirst(E e): 返回此列表的第一个元素。\nE getLast(E e): 返回此列表的最后一个元素。\nboolean offerFirst(E e): 在此列表的开头插入指定的元素。\nboolean offerLast(E e): 在此列表末尾插入指定的元素。\nE peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。\nE peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。\nE pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。\nE pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。\nE removeFirst(E e): 移除并返回此列表的第一个元素。\nboolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\nE removeLast(E e): 移除并返回此列表的最后一个元素。\nboolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n```\n\n#### 实现原理\n\nLinkedList 调用默认构造函数，创建一个链表。由于维护了一个表头，表尾的 Node 对象的变量。可以进行后续的添加元素到链表中的操作，以及其他删除，插入等操作。也因此实现了双向队列的功能，即可向表头加入元素，也可以向表尾加入元素。\n\nNode 定义如下：\n\n```java\nprivate static class Node\u003cE\u003e {\n    E item;//节点值\n    Node\u003cE\u003e next;//后继节点\n    Node\u003cE\u003e prev;//前驱节点\n    Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n新增操作 add(E e)，默认使用尾插法添加元素：\n\n```java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n\nvoid linkLast(E e) {\n    final Node\u003cE\u003e l = last;\n    final Node\u003cE\u003e newNode = new Node\u003c\u003e(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n```\n\n删除指定元素 remove(Object o): \n\n```java\npublic boolean remove(Object o) {\n    //如果删除对象为null\n    if (o == null) {\n        //从头开始遍历\n        for (Node\u003cE\u003e x = first; x != null; x = x.next) {\n            //找到元素\n            if (x.item == null) {\n                //从链表中移除找到的元素\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        //从头开始遍历\n        for (Node\u003cE\u003e x = first; x != null; x = x.next) {\n            //找到元素\n            if (o.equals(x.item)) {\n                //从链表中移除找到的元素\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nE unlink(Node\u003cE\u003e x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node\u003cE\u003e next = x.next;//得到后继节点\n    final Node\u003cE\u003e prev = x.prev;//得到前驱节点\n    //删除前驱指针\n    if (prev == null) {\n        first = next;// 如果删除的节点是头节点,令头节点指向该节点的后继节点\n    } else {\n        prev.next = next;// 将前驱节点的后继节点指向后继节点\n        x.prev = null;\n    }\n    //删除后继指针\n    if (next == null) {\n        last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n获取制定下表元素 get(int index):\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);//检查索引是否有效\n    return node(index).item;\n}\n\nNode\u003cE\u003e node(int index) {\n    // assert isElementIndex(index);\n    if (index \u003c (size \u003e\u003e 1)) {\n        Node\u003cE\u003e x = first;\n        for (int i = 0; i \u003c index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node\u003cE\u003e x = last;\n        for (int i = size - 1; i \u003e index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\nnode 方法首先会比较“index”和“双向链表长度的 1/2”；若前者小，则从链表头开始往后查找，直到 index 位置；否则，从链表末尾开始先前查找，直到 index 位置。\n\n由此可见，LinkedList 在插入、删除元素时性能比较出色，随机访问集合元素时性能较差。\n\n#### 遍历方式\n\n//todo\n\n# Map 接口\n\nMap 用于保存具有映射关系的数据。它是一种键值对的结构，即 Key-Value 结构，一个 Map 就是很多这样 K-V 键值对组成的，一个 K-V 结构我们将其称作 Entry，Key 和 Value 都可以是任何引用类型的数据。Map 的 Key 不允许重复，即同一个 Map 对象的任何两个 Key 通过 equals 方法比较总是返回 false。\n\nKey 和 Value 之间存在单向一对一关系，即通过指定的 Key，总能找到唯一的、确定的 Value。从 Map 中取出数据时，只要给出指定的 Key，就可以取出对应的 Value。\n\nMap 框架概览：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_100030.png)\n\nMap 接口的定义如下：\n\n```java\npublic interface Map\u003cK,V\u003e {\n    int size();\n\n    boolean isEmpty();\n    \n    boolean containsKey(Object key);\n    \n    boolean containsValue(Object value);\n    \n    V get(Object key);\n    \n    V put(K key, V value);\n    \n    V remove(Object key);\n\n    void putAll(Map\u003c? extends K, ? extends V\u003e m);\n    \n    void clear();\n\n    Set\u003cK\u003e keySet();\n    \n    Collection\u003cV\u003e values();\n    \n    Entry\u003cK, V\u003e\u003e entrySet();\n    \n    interface Entry\u003cK,V\u003e {\n        K getKey();\n\n        V getValue();\n        \n        V setValue(V value);\n        \n        boolean equals(Object o);\n        \n        int hashCode();\n        /**\n         * @since 1.8\n         */\n        public static \u003cK extends Comparable\u003c? super K\u003e, V\u003e Comparator\u003cMap.Entry\u003cK,V\u003e\u003e comparingByKey() {\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e c1.getKey().compareTo(c2.getKey());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V extends Comparable\u003c? super V\u003e\u003e Comparator\u003cMap.Entry\u003cK,V\u003e\u003e comparingByValue() {\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e c1.getValue().compareTo(c2.getValue());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V\u003e Comparator\u003cMap.Entry\u003cK, V\u003e\u003e comparingByKey(Comparator\u003c? super K\u003e cmp) {\n            Objects.requireNonNull(cmp);\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e cmp.compare(c1.getKey(), c2.getKey());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V\u003e Comparator\u003cMap.Entry\u003cK, V\u003e\u003e comparingByValue(Comparator\u003c? super V\u003e cmp) {\n            Objects.requireNonNull(cmp);\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e cmp.compare(c1.getValue(), c2.getValue());\n        }\n    }\n\n    boolean equals(Object o);\n\n    int hashCode();\n    // Defaultable methods\n    /**\n     * @since 1.8\n     */\n    default V getOrDefault(Object key, V defaultValue) {\n        V v;\n        return (((v = get(key)) != null) || containsKey(key))\n            ? v\n            : defaultValue;\n    }\n    /**\n     * @since 1.8\n     */\n    default void forEach(BiConsumer\u003c? super K, ? super V\u003e action) {\n        Objects.requireNonNull(action);\n        for (Map.Entry\u003cK, V\u003e entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n            action.accept(k, v);\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default void replaceAll(BiFunction\u003c? super K, ? super V, ? extends V\u003e function) {\n        Objects.requireNonNull(function);\n        for (Map.Entry\u003cK, V\u003e entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n            // ise thrown from function is not a cme.\n            v = function.apply(k, v);\n            try {\n                entry.setValue(v);\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V putIfAbsent(K key, V value) {\n        V v = get(key);\n        if (v == null) {\n            v = put(key, value);\n        }\n        return v;\n    }\n    /**\n     * @since 1.8\n     */\n    default boolean remove(Object key, Object value) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, value) ||\n            (curValue == null \u0026\u0026 !containsKey(key))) {\n            return false;\n        }\n        remove(key);\n        return true;\n    }\n    /**\n     * @since 1.8\n     */\n    default boolean replace(K key, V oldValue, V newValue) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, oldValue) ||\n            (curValue == null \u0026\u0026 !containsKey(key))) {\n            return false;\n        }\n        put(key, newValue);\n        return true;\n    }\n    /**\n     * @since 1.8\n     */\n    default V replace(K key, V value) {\n        V curValue;\n        if (((curValue = get(key)) != null) || containsKey(key)) {\n            curValue = put(key, value);\n        }\n        return curValue;\n    }\n    /**\n     * @since 1.8\n     */\n    default V computeIfAbsent(K key,\n            Function\u003c? super K, ? extends V\u003e mappingFunction) {\n        Objects.requireNonNull(mappingFunction);\n        V v;\n        if ((v = get(key)) == null) {\n            V newValue;\n            if ((newValue = mappingFunction.apply(key)) != null) {\n                put(key, newValue);\n                return newValue;\n            }\n        }\n        return v;\n    }\n    /**\n     * @since 1.8\n     */\n    default V computeIfPresent(K key,\n            BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue;\n        if ((oldValue = get(key)) != null) {\n            V newValue = remappingFunction.apply(key, oldValue);\n            if (newValue != null) {\n                put(key, newValue);\n                return newValue;\n            } else {\n                remove(key);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V compute(K key,\n            BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue = get(key);\n        V newValue = remappingFunction.apply(key, oldValue);\n        if (newValue == null) {\n            // delete mapping\n            if (oldValue != null || containsKey(key)) {\n                // something to remove\n                remove(key);\n                return null;\n            } else {\n                // nothing to do. Leave things as they were.\n                return null;\n            }\n        } else {\n            // add or replace old mapping\n            put(key, newValue);\n            return newValue;\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V merge(K key, V value,\n            BiFunction\u003c? super V, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        Objects.requireNonNull(value);\n        V oldValue = get(key);\n        V newValue = (oldValue == null) ? value :\n                   remappingFunction.apply(oldValue, value);\n        if(newValue == null) {\n            remove(key);\n        } else {\n            put(key, newValue);\n        }\n        return newValue;\n    }\n}\n```\n\nMap 接口处于整个框架的顶层，由一堆 Map 自身接口方法和一个 Entry 接口组成，Entry 接口定义了主要是关于 Key-Value 自身的一些操作，Map 接口定义的是一些属性和关于属性查找修改的一些接口方法。\n\n## HashMap\n\n见《HashMap 源码解析》\n\n### LinkedHashMap\n\nHashSet 有一个 LinkedHashSet 子类，HashMap 也有一个 LinkedHashMap 子类；LinkedHashMap 使用双向链表来维护 key-value 对的次序。\n\nLinkedHashMap 需要维护元素的插入顺序，因此性能略低于 HashMap 的性能；但是因为它以链表来维护内部顺序，所以在迭代访问 \u003cstrong\u003eMap 里的全部元素时有较好的性能\u003c/strong\u003e。迭代输出 LinkedHashMap 的元素时，将会按照添加 key-value 对的顺序输出。\n\n\u003cstrong\u003e本质上来讲，LinkedHashMap = 散列表 + 双向循环链表\u003c/strong\u003e\n\n#### \u003cstrong\u003e实现原理\u003c/strong\u003e\n\nLinkedHashMap 的主要成员变量和方法实现简化后如下：\n\n```java\npublic class LinkedHashMap\u003cK,V\u003e extends HashMap\u003cK,V\u003e \n          implements Map\u003cK,V\u003e {\n    static class Entry\u003cK,V\u003e extends HashMap.Node\u003cK,V\u003e {\n        Entry\u003cK,V\u003e before, after;\n        Entry(int hash, K key, V value, Node\u003cK,V\u003e next) {\n            super(hash, key, value, next);\n        }\n    } \n    // 双向链表的头节点\n    transient LinkedHashMap.Entry\u003cK,V\u003e head;\n    // 双向链表的尾戒低钠\n    transient LinkedHashMap.Entry\u003cK,V\u003e tail;\n    // 是否按照访问顺序排序\n    final boolean accessOrder;\n    \n    public LinkedHashMap(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor);\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(int initialCapacity) {\n        super(initialCapacity);\n        accessOrder = false;\n    }\n\n    public LinkedHashMap() {\n        super();\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(Map\u003c? extends K, ? extends V\u003e m) {\n        super();\n        accessOrder = false;\n        putMapEntries(m, false);\n    }\n\n    public LinkedHashMap(int initialCapacity,\n               float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n    \n    Node\u003cK,V\u003e newNode(int hash, K key, V value, Node\u003cK,V\u003e e) {\n        LinkedHashMap.Entry\u003cK,V\u003e p =\n            new LinkedHashMap.Entry\u003cK,V\u003e(hash, key, value, e);\n        // 将 Entry 接在双向链表的尾部\n        linkNodeLast(p);\n        return p;\n    }\n \n    @Overrid\n    Node\u003cK,V\u003e replacementNode(Node\u003cK,V\u003e p, Node\u003cK,V\u003e next) {\n        LinkedHashMap.Entry\u003cK,V\u003e q = (LinkedHashMap.Entry\u003cK,V\u003e)p;\n        LinkedHashMap.Entry\u003cK,V\u003e t = new LinkedHashMap.Entry\u003cK,V\u003e\n            (q.hash, q.key, q.value, next);\n        transferLinks(q, t);\n        return t;\n    }\n \n    @Overrid\n    TreeNode\u003cK,V\u003e newTreeNode(int hash, K key, V value, \n            Node\u003cK,V\u003e next) {\n        TreeNode\u003cK,V\u003e p = new TreeNode\u003cK,V\u003e(hash, key, value, next);\n        linkNodeLast(p);\n        return p;\n    }\n    \n    @Override\n    TreeNode\u003cK,V\u003e replacementTreeNode(Node\u003cK,V\u003e p, Node\u003cK,V\u003e next) {\n        LinkedHashMap.Entry\u003cK,V\u003e q = (LinkedHashMap.Entry\u003cK,V\u003e)p;\n        TreeNode\u003cK,V\u003e t = new TreeNode\u003cK,V\u003e(q.hash, q.key, \n            q.value, next);\n        transferLinks(q, t);\n        return t;\n    }\n    \n    // link at the end of list\n    private void linkNodeLast(LinkedHashMap.Entry\u003cK,V\u003e p) {\n        LinkedHashMap.Entry\u003cK,V\u003e last = tail;\n        tail = p;\n        // last 为 null，表明链表还未建立\n        if (last == null)\n            head = p;\n        else {\n            // 将新节点 p 接在链表尾部\n            p.before = last;\n            last.after = p;\n        }\n    }\n    \n    // apply src's links to dst\n    private void transferLinks(LinkedHashMap.Entry\u003cK,V\u003e src,\n                  LinkedHashMap.Entry\u003cK,V\u003e dst) {\n        LinkedHashMap.Entry\u003cK,V\u003e b = dst.before = src.before;\n        LinkedHashMap.Entry\u003cK,V\u003e a = dst.after = src.after;\n        if (b == null)\n            head = dst;\n        else\n            b.after = dst;\n        if (a == null)\n            tail = dst;\n        else\n            a.before = dst;\n    }\n    \n    @Override\n    void afterNodeAccess(Node\u003cK,V\u003e p) { }\n    @Override\n    void afterNodeInsertion(boolean evict) { }\n    @Override\n    void afterNodeRemoval(Node\u003cK,V\u003e e) { }\n}\n```\n\nLinkedHashMap 继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。\n\nMap 类型的集合类是通过 put(K,V) 方法插入键值对，LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。\n\n在 newNode 方法中，LinkedHashMap 创建了 Entry，并通过 linkNodeLast 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立\n\n#### afterNodeAccess()\n\n当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。\n\n```java\nvoid afterNodeAccess(Node\u003cK,V\u003e e) { // move node to last\n    LinkedHashMap.Entry\u003cK,V\u003e last;\n    if (accessOrder \u0026\u0026 (last = tail) != e) {\n        LinkedHashMap.Entry\u003cK,V\u003e p =\n            (LinkedHashMap.Entry\u003cK,V\u003e)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n```\n\n#### afterNodeInsertion()\n\n```java\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n    LinkedHashMap.Entry\u003cK,V\u003e first;\n    if (evict \u0026\u0026 (first = head) != null \u0026\u0026 removeEldestEntry(first)) {\n        K key = first.key;\n        removeNode(hash(key), key, null, false, true);\n    }\n}\n\nprotected boolean removeEldestEntry(Map.Entry\u003cK,V\u003e eldest) {\n    return false;\n}\n```\n\n在元素新增之后，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。\n\nevict 只有在构建 Map 的时候才为 false，在这里为 true。\n\nremoveEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。\n\n#### afterNodeRemoval()\n\n元素被删除后，此方法会被回调，删除双向链表中对应的节点。\n\n```java\nvoid afterNodeRemoval(Node\u003cK,V\u003e e) { // unlink\n    LinkedHashMap.Entry\u003cK,V\u003e p = (LinkedHashMap.Entry\u003cK,V\u003e)e, \n          b = p.before, a = p.after;\n    // 将 p 节点的前驱后后继引用置空\n    p.before = p.after = null;\n    // b 为 null，说明 p 是头节点\n    if (b == null)\n        head = a;\n    else\n        b.after = a;\n    // a 为 null，说明 p 是尾节点\n    if (a == null)\n        tail = b;\n    else\n        a.before = b;\n}\n```\n\n#### LRU 缓存\n\n以下是使用 LinkedHashMap 实现的一个 LRU 缓存：\n\n- 设定最大缓存空间 MAX_ENTRIES 为 3；\n- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；\n- 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。\n\n```java\nclass LRUCache\u003cK, V\u003e extends LinkedHashMap\u003cK, V\u003e {\n    private static final int MAX_ENTRIES = 3;\n\n    protected boolean removeEldestEntry(Map.Entry eldest) {\n        return size() \u003e MAX_ENTRIES;\n    }\n\n    LRUCache() {\n        super(MAX_ENTRIES, 0.75f, true);\n    }\n}\n```\n\n## TreeMap\n\nTreeMap 是 SortedMap 接口的实现类。TreeMap 是一个\u003cstrong\u003e有序的 \u003c/strong\u003ekey-value 集合，它是通过红黑树实现的，每个 key-value 对即作为红黑树的一个节点。\n\n### 排序方式\n\n和 TreeSet 一样，TreeMap 有两种排序方式：\n\n- 自然排序：TreeMap 的所有 key 必须实现 Comparable 接口，而且所有的 key 应该是同一个类的对象，否则会抛出 ClassCastException 异常。\n- 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。\n\n### 判断元素相等\n\n类似于 TreeSet 中判断两个元素相等的标准，TreeMap 中判断两个 key 相等的标准是：两个 key 通过 compareTo() 方法返回 0，TreeMap 即认为这两个 key 是相等的；判断两个 value 相等的标准是：两个 value 通过 equals() 方法比较返回 true。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e如果使用自定义类作为 TreeMap 的 key，且想让 TreeMap 良好地工作，则重写该类的 equals() 方法和 compareTo() 方法时应保持一致的返回结果：两个 key 通过 equals()方 法比较返回 true 时，它们通过 compareTo() 方法比较应该返回 0。如果两个方法的返回结果不一致，TreeMap 与 Map 接口的规则就会冲突。\n\n除此之外，与 TreeSet 类似，TreeMap 根据排序特性，也添加了一部分新的方法，与 TreeSet 中的一致。可以参考本文前面的内容。\n\n### 实现原理\n\nTreeMap 基于红黑树实现，而红黑树是一种自平衡二叉查找树，所以查找操作流程和二叉查找树一致。TreeMap 可保证在 log(n) 时间复杂度内完成 containsKey、get、put 和 remove 操作，效率很高。另一方面，由于 TreeMap 基于红黑树实现，这为 TreeMap 保持键的有序性打下了基础。总的来说，TreeMap 的核心是红黑树，其很多方法也是对红黑树增删查基础操作的一个包装。\n\n# fast-fail 机制\n\n#\n","lastmodified":"2023-03-22T14:03:38.290646017Z","tags":["Collection","Iterable","Java 容器类","Java"]},"/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0":{"title":"我的日记","content":"### 今日开发工作\n### 今日感想","lastmodified":"2023-03-22T14:03:37.998643195Z","tags":[]},"/%E6%9C%AA%E5%91%BD%E5%90%8D":{"title":"未命名","content":"","lastmodified":"2023-03-22T14:03:37.998643195Z","tags":[]},"/%E6%B3%9B%E5%9E%8B":{"title":"泛型","content":"---\ntitle: \"容器类\"\ncomments: true\ndate created: 2023-03-22\ndate modified: 2023-03-22\nid: home\nlayout: page\ntags:\n  - Collection\n  - Java 容器类\n---\n## 什么是泛型？\n\n声明中具有一个或者多个类型参数(type parameter)的类或者接口，就是泛型类或者接口。泛型类和接口统称为泛型(generic type)。\n\n每种泛型定义一组类型形参(formal type parameters)，这些类型形参有时也被简称为类型参数(type parameter)，例如对于 `List\u003cE\u003e` 而言，`List\u003cString\u003e` 就是一个参数化的类型(parameterized type)，String 就是对应于类型形参(formal type parameters)的类型实参(actual type parameter)。\n\n而如果 `List\u003cE\u003e` 不使用泛型参数，List 则为原生类型(raw type)。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。\n\n每个泛型定义一个原生类型(raw type)，即不带任何类型参数的类型名称，例如，与 `List\u003cString\u003e` 对应的原生类型是 List。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。\n\nJava 泛型是自 JDK5 起引入的一种参数化类型特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型泛型的本质是参数类型，也就是说所操作的数据类型被指定为一个参数。因为类型擦除机制，泛型不存在于 JVM 虚拟机。\n\n## 为什么使用泛型？\n\n1.使代码更健壮\n\n2.使代码更简洁(不用强转)\n\n3.使代码可复用性更高，程序更灵活\n\n通俗地说，泛型是「有远⻅的创造者」创造的「方便使用者」的工具。也就是说，使用泛型能够让开发这编写出更加灵活的代码。\n\n## 泛型的使用\n\n### 作为类/接口的类型参数\n\n可以在一个类或者接口里定义一个类型参数，等着子类/实现类去写出不同的实现：\n\n```java\npublic interface Comparable\u003cT\u003e {\n  int compareTo(T o);\n  ...\n}\n\npublic String implements Comparable\u003cString\u003e {\n  int compareTo(String anotherString);\n  ...\n}\n\npublic class Stack\u003cE\u003e extends Vector\u003cE\u003e {\n  ...\n}\n\nStack\u003cString\u003e stack = new Stack\u003c\u003e();\n```\n\n### 作为方法的返回值类型\n\n```java\nT buy();\n```\n\n### 用于类型约束\n\n由于泛型语法自身特性，某些情形下也可以用于类型约束\n\n```java\n// 约束类型参数上界\npublic \u003cE extends Runnable, Serializable\u003e void someMethod(E param);\n\n// 约束方法参数之间的关系\npublic \u003cT\u003e void merge(T item, List\u003cT\u003e list) {\n  list.add(item);\n}\n```\n\n## 泛型擦除的过程\n\n1. 类型检查：在生成字节码之前提供类型检查\n2. 类型擦除：所有类型参数都用他们的限定类型替换，包括类、变量和方法（类型擦除）\n3. 如果类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决\n4. 如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转换\n\n## 泛型的限制\n\n1. 不能用基本类型作为泛型参数\n2. 不能在运行时获取泛型类型\n3. 不能静态字段或方法中引用泛型变量\n4. 不能创建参数化类型数组\n5. 不能实例化类型变量\n6. 不能捕获泛型类的实例，类不能继承自 Exception，只能派生自 Throwable\n\n```java\npublic \u003cT extends Throwable\u003e void fun1(T t) {\n  try {\n    ...\n  } catch(T x) {//不允许\n  }\n}\n\npublic \u003cT extends Throwable\u003e void fun2(T t) throws T {\n  try {\n    ...\n  } catch(Throwable t) {\n    throw t;\n  }\n}\n```\n\n## 编译时和运行时类型\n\n```java\npublic class Fruit {}\n\npublic class Apple extends Fruit {}\n\npublic class GreenApple extends Apple {}\n\nApple apple = new Apple();//普通变量声明和初始化\n\nFruit apple = new Apple();//向上转型\n```\n\nJava 允许把一个子类对象（Apple 对象）直接赋值给一个父类引用变量（Fruit 类变量），一般我们称之为「向上转型」。apple 变量所指向的对象，其在编译时的类型是 Fruit 类型，而在运行时的类型就是 Apple 类型。\n\n因为在编译的时候，JVM 只知道 Fruit 类变量指向了一个对象，并且这个对象是 Fruit 的子类对象或自身对象，其具体的类型并不确定，有可能是 Apple 类型，也有可能是 Orange 类型。而为了安全方面的考虑，JVM 此时将 apple 属性指向的对象定义为 Fruit 类型。因为无论其是 Apple 类型还是 Orange 类型，它们都可以安全转为 Fruit 类型。\n\n而在运行时阶段，JVM 通过初始化知道了它指向了一个 Apple 对象，所以其在运行时的类型就是 Apple 类型。\n\n## 泛型类型实例化的边界\n\n在前面的例子的基础上，定义一个容器类：\n\n```java\npublic class Plate\u003cT\u003e {\n  private List\u003cT\u003e list;\n\n  public Plate(){}\n\n  public void add(T item) {\n    list.add(item);\n  }\n\n  public T get() {\n    return list.get(0);\n  }\n}\n```\n\n如果想要一个装水果的盘子，则有如下定义：\n\n```java\nPlate\u003cFruit\u003e plate = new Plate\u003cFruit\u003e();\n```\n\n这里直接定义了一个 Plate 对象，并且指定其泛型类型为 Fruit 类。这样我们就可以往里面加水果了：\n\n```java\nplate.add(new Fruit());\n\nplate.add(new Apple());\n```\n\n按照 Java 向上转型的原则，Java 泛型可以向上转型，上面关于水果盘子的定义可以变为这样：\n\n```java\nPlate\u003cFruit\u003e plate = new Plate\u003cApple\u003e();  //编译错误\n```\n\n错误的原因就是：\tJava 并不支持支持泛型的向上转型，所以不能够使用上面的写法，这样的写法在 Java 中是不被支持的。\n\n解决方法就是：使用通配符。\n\n### `\u003c? extends Xxx\u003e` 限定上界通配符\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cApple\u003e();\n```\n\n上面的这行代码表示：plate 实例可以指向任何 Fruit 类对象，或者任何 Fruit 的子类对象。Apple 是 Fruit 的子类，自然就可以正常编译了。\n\n虽然通过这种方式，Java 支持了 Java 泛型的向上转型，但是这种方式是有缺陷的：\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cApple\u003e();\n\nplate.add(new Apple()); //Compile Error\n\nplate.add(new Fruit()); //Compile Error\n\nplate.get();    // Compile Success\n```\n\n这时候发现：无法向 Plate 中添加任何对象，只能从中读取对象。\n\n这是什么原因？还得从 plate 的定义说起：\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cXXX\u003e();\n```\n\n上面对盘子的定义中，plate 可以指向任何 Fruit 类对象，或者任何 Fruit 的子类对象。也就是说，plate 属性指向的对象其在运行时可以是 Apple 类型，也可以是 Orange 类型，也可以是 Banana 类型，只要它是 Fruit 类，或任何 Fruit 的子类即可。\n\n这样子的话，在我们还未具体运行时，JVM 并不知道我们要往盘子里放的是什么水果，到底是苹果，还是橙子，还是香蕉，完全不知道。既然我们不能确定要往里面放的类型，那 JVM 就干脆什么都不给放，避免出错。\n\n那为什么又可以取出数据呢？因为无论是取出苹果，还是橙子，还是香蕉，我们都可以通过向上转型用 Fruit 类型的变量指向它，这在 Java 中都是允许的：\n\n```java\nFruit apple = plate.get(); //能够保证取出来的是水果\n\nApple apple = plate.get(); //编译报错，JVM 不能保证取出来的就是苹果\n```\n\n我们通过 extends 关键字可以实现向上转型。但是我们却失去了部分的灵活性，即我们不能往其中添加任何东西，只能取出东西。\n\n### `\u003c? super Xxx\u003e` 限定下界通配符\n\n与 extends 通配符相似的另一个通配符是 super 通配符，其特性与 extends 完全相反。\tsuper 通配符可以存入对象，但是取出对象的时候受到限制。\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n```\n\n上面这行代码表示 plate 属性可以指向一个特定类型的 Plate 对象，只要这个特定类型是 Apple 或 Apple 的父类。上面的 Fruit 类就是 Apple 类的父级，所以上面的语法是对的。\n\n也就是说，如果 Food 类是 Fruit 的父级，那么则有下面的声明：\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n\nPlate\u003c? super Apple\u003e plate2 = new Plate\u003cApple\u003e();\n\nPlate\u003c? super Apple\u003e plate3 = new Plate\u003cGreenApple\u003e(); //Error\n```\n\n既然这样，也就是说 plate 指向的具体类型可以是任何 Apple 的父级，JVM 在编译的时候肯定无法判断具体是哪个父类型。但 JVM 能确定的是：任何 Apple 的子类都可以转为 Apple 类型，但任何 Apple 的父类都无法转为 Apple 类型。\n\n所以对于使用了 super 通配符的情况，我们只能存入 T 类型及 T 类型的子类对象。\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n\nplate.add(new Apple());\n\nplate.add(new GreenApple());\n\nplate.add(new Fruit()); //Error\n```\n\n当我们向 plate 存入 Apple 对象时，编译正常。但是存入 Fruit 对象，就会报编译错误。\n\n而当我们取出数据的时候，也是类似的道理。JVM 在编译的时候知道，我们具体的运行时类型可以是任何 Apple 的父级，那么为了安全起见，我们就用一个最顶层的父级来指向取出的数据，这样就可以避免发生强制类型转换异常了。\n\n```java\nObject object = plate.get();\n\nApple apple = plate.get();  //Error\n\nFruit fruit = plate.get();  //Error\n```\n\n当使用 Apple 类型或 Fruit 类型的变量指向 plate 取出的对象，会出现编译错误。而使用 Object 类型的额变量指向 plate 取出的对象，则可以正常通过。\n\n也就是说对于使用了 super 通配符的情况，我们取出的时候只能用 Object 类型的属性指向取出的对象。\n\n### `\u003c?\u003e` 无限定边界通配符\n\n也就是不限定泛型参数的边界，所以对 Plate\u003c?\u003e 实例来说可以存放任何任意类型的对象，由于所有类型都继承自 Object，因此 Plate\u003c?\u003e等价于 `Plate\u003c? extends Object\u003e`。所以只能够对该集合进行读操作，并且只能把读取到的元素当成 Object 实例来对待。\n\n### 小结\n\n- 对于 extends 通配符，我们无法向其中加入任何对象，但是我们可以进行正常的取出。\n- 对于 super 通配符，我们可以存入 T 类型对象或 T 类型的子类对象，但是我们取出的时候只能用 Object 类变量指向取出的对象。\n\n从上面的总结可以看出，extends 通配符偏向于内容的获取，而 super 通配符更偏向于内容的存入。我们有一个 PECS 原则（Producer Extends Consumer Super）很好的解释了这两个通配符的使用场景。\n\nProducer Extends 说的是当你的情景是生产者类型，需要获取资源以供生产时，我们建议使用 extends 通配符，因为使用了 extends 通配符的类型更适合获取资源。\n\nConsumer Super 说的是当你的场景是消费者类型，需要存入资源以供消费时，我们建议使用 super 通配符，因为使用 super 通配符的类型更适合存入资源。\n\n但如果既想存入，又想取出，那么最好还是不要使用 extends 或 super 通配符。\n\n## 面试题\n\n### `List\u003cT\u003e` 和数组的区别\n\n```java\nApple apple = new Fruit();\n\nApple[] appleArr = new Fruit[5];\n```\n\n在 Java 语言中，数组是协变的，即 Apple extends Fruit，那么子类 Apple[] 数组实例是可以赋值给父类 Fruit[] 数组实例的。那是由于 Java 中的数组类型本质上会由虚拟机运行时动态生成一个类型，这个类型除了记录数组的必要属性，如长度，元素类型等，会有一个指针指向内存某个位置，这个位置就是该数组元素的起始位置。\n\n所以子类数组实例赋值父类数组实例时，只是意味着父类数组实例的引用指向堆中子类数组而已，并不会有所冲突，因此是 Java 允许这种操作的。\n\n而泛型是不允许这么做的：\n\n```java\nArrayList\u003cNumber\u003e numbers = new ArrayList\u003cInteger\u003e(); \n\nnumbers = integers;//假设编译器是能通过的 \n\nnumbers.add(23.5);//将一个浮点数放入了整型容器中\n```\n\n前面已经说过，假设 Java 允许泛型协变，那么上述代码在编译器看来是没问题的，但运行时就会出现问题。这个 add 方法实际上就将一个浮点数放入了整型容器中了，虽然由于类型擦除并不会对程序运行造成问题，但显然违背了泛型的设计初衷，容易造成逻辑混乱，所以 Java 干脆禁止泛型协变。\n\n所以虽然 `ArrayList\u003cInteger\u003e` 和 `ArrayList\u003cNumber\u003e`编译器类型擦除之后都是 ArrayList 的实例，但是起码在编译器看来，这两者是两种不同的类型。\n\n但是对于数组，尽管 Apple 可以向上转型为 Fruit，但是 fruits 对象在运行时却是 Apple[] 类型的，因此只能向数组中放入 Apple 或者其子类对象。尽管在编译时不会报错，到了运行时仍然是会报错的。\n\n```java\nFruit[] fruits = new Apple[5];\n\nfruits[0] = new Apple();\n\nfruits[1] = new GreenApple();\n\nfruits[2] = new Fruit(); //RTE：ArrayStoreException\n```\n\n### Java 为什么不支持创建泛型数组\n\n首先对于 Java 数组，必须明确知道内部元素的类型，而且 JVM 会“记住”这个类型。每次往数组里插入新元素都会进行类型检查，不匹配则抛出 ArrayStoreException 错误。\n\n而由于泛型擦除机制的存在，因此 JVM 并不能确定数组中的泛型类型，因此创建泛型数组被编译器拦下来了。\n\n```java\nList\u003cInteger\u003e[] intListArray = new List\u003cInteger\u003e[10]; //Error\n```\n\n前面说过，因为泛型是协变的，而且 Object 是所有类的共同父类。如果允许创建泛型数组，则有：\n\n```java\nList\u003cInteger\u003e[] listArr= new ArrayList\u003cInteger\u003e[10];\n\nObject[] objArr= listArr;\n\nobjArr[0] = new ArrayList\u003cString\u003e(Arrays.asList(new String[]{\"abc\"}));\n\n这样做不但编译器不能发现类型错误，就连运行时的数组存储检查对它也无能为力。它能看到的是我们往里面放 List 的对象，我们定义的 `\u003cInteger\u003e` 在这个时候已经被抹掉了。于是而对它而言，只要是 List，都是合法的。\n```\n\n想想看，我们本来定义的是存放 `List\u003cInteger\u003e` 的数组，结果我们却可以往里面放任何 List，接下来如果有代码试图按原有的定义去取值，后果可想而知。\n\n实际上，泛型数组是可以定义出来的，然后通过强制转型，也是可以为其赋值的。\n\n```java\nList\u003cInteger\u003e[] listArr= (List\u003cInteger\u003e[])new ArrayList[10];\n\nObject[] objArr= listArr;\n\nobjArr[0] = new ArrayList\u003cString\u003e(Arrays.asList(new String[]{\"abc\"}));\n```\n\n这样不但编译可以通过，而且运行时也不会报任何错误。\n\n### `List`、`List\u003c?\u003e`、`List\u003cObject\u003e`的区别\n\n容器类使用泛型的好处：\n\n- 安全性：在对参数化类型的容器中放入了错误即不匹配的类型的时候，编译器将会强制性进行错误提示。\n- 便利性：当从容器中取出元素的时候不用自己手动将 Object 转换为元素的实际类型了，编译器将隐式地进行自动转换。\n- 表述性：带有类型实参的泛型即参数化类型，可以让人看到实参就知道里面的元素 E 都是什么类型。\n\n从以上三点出发，`List\u003cObject\u003e`、`List\u003c?\u003e` 和 `List` 的区别如下：\n\n| 类型    | 名称                               | 可以接受的类型                            | 能否添加元素           | 安全性 | 便利性 | 表述性 |\n| ------- | ---------------------------------- | ----------------------------------------- | ---------------------- | ------ | ------ | ------ |\n| List    | 原始类型                           | 任何对应 List 的参数化类型， 包括 List\u003c?\u003e | 可以添加任意类型的元素 | 无     | 无     | 无     |\n| List\u003c?\u003e | 通配符类型                         | 任何对应 List 的参数化类型，包括 List     | 不能添加任何元素       | 有     | 无     | 有     |\n| List    | 实际类型参数为 Object 的参数化类型 | 仅可以接受 List 和其本身类型              | 可以添加任意类型元素   | 有     | 有     | 有     |\n\nJVM 如何解决泛型类型擦除导致多态冲突\n","lastmodified":"2023-03-22T14:03:38.290646017Z","tags":["泛型","Java"]},"/2023-03-15":{"title":"2023-03-15","content":"弄完了同步，牛逼","lastmodified":"2023-03-22T14:03:37.998643195Z","tags":[]},"/2023-03-16":{"title":"2023-03-16","content":"","lastmodified":"2023-03-22T14:03:37.998643195Z","tags":[]},"/2023-03-18":{"title":"2023-03-18","content":"# 2023-03-18\n### 今日开发工作\n### 今日感想","lastmodified":"2023-03-22T14:03:37.998643195Z","tags":["哈哈","好"]},"/2023-03-19":{"title":"2023-03-19","content":"### 今日开发工作\n### 今日感想","lastmodified":"2023-03-22T14:03:37.998643195Z","tags":[]},"/2023-03-20":{"title":"2023-03-20","content":"### 今日开发工作\n### 今日感想\nsadlfjsal \n\nfrom windows\n\n之类主页是[[AboutTheGarden]]","lastmodified":"2023-03-22T14:03:37.998643195Z","tags":[]},"/2023-03-22":{"title":"Troubleshooting and FAQ","content":"\nStill having trouble? Here are a list of common questions and problems people encounter when installing Quartz.\n\nWhile you're here, join our [Discord](https://discord.gg/cRFFHYye7t) :)\n\n### Does Quartz have Latex support?\nYes! See [CJK + Latex Support (测试)](notes/CJK%20+%20Latex%20Support%20(测试).md) for a brief demo.\n\n### Can I use \\\u003cObsidian Plugin\\\u003e in Quartz?\nUnless it produces direct Markdown output in the file, no. There currently is no way to bundle plugin code with Quartz.\n\nThe easiest way would be to add your own HTML partial that supports the functionality you are looking for.\n\n### My GitHub pages is just showing the README and not Quartz\nMake sure you set the source to deploy from `master` (and not `hugo`) using `/ (root)`! See more in the [hosting](/notes/hosting) guide\n\n### Some of my pages have 'January 1, 0001' as the last modified date\nThis is a problem caused by `git` treating files as case-insensitive by default and some of your posts probably have capitalized file names. You can turn this off in your Quartz by running this command.\n\n```shell\n# in the root of your Quartz (same folder as config.toml)\ngit config core.ignorecase true\n\n# or globally (not recommended)\ngit config --global core.ignorecase true\n```\n\n### Can I publish only a subset of my pages?\nYes! Quartz makes selective publishing really easy. Heres a guide on [excluding pages from being published](notes/ignore%20notes.md).\n\n### Can I host this myself and not on GitHub Pages?\nYes! All built files can be found under `/public` in the `master` branch. More details under [hosting](notes/hosting.md).\n\n### `command not found: hugo-obsidian`\nMake sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize `hugo-obsidian` as an executable.\n\n```shell\n# Add the following 2 lines to your ~/.bash_profile (~/.zshrc if you are on Mac)\nexport GOPATH=/Users/$USER/go\nexport PATH=$GOPATH/bin:$PATH\n\n# In your current terminal, to reload the session\nsource ~/.bash_profile # again, (~/.zshrc if you are on Mac)\n```\n\n### How come my notes aren't being rendered?\nYou probably forgot to include front matter in your Markdown files. You can either setup [Obsidian](notes/obsidian.md) to do this for you or you need to manually define it. More details in [the 'how to edit' guide](notes/editing.md).\n\n### My custom domain isn't working!\nWalk through the steps in [the hosting guide](notes/hosting.md) again. Make sure you wait 30 min to 1 hour for changes to take effect.\n\n### How do I setup analytics?\nQuartz by default uses [Plausible](https://plausible.io/) for analytics. \n\nIf you would prefer to use Google Analytics, you can follow this [guide in the Hugo documentation](https://gohugo.io/templates/internal/#google-analytics). \n\nAlternatively, you can also import your Google Analytics data into Plausible by [following this guide](https://plausible.io/docs/google-analytics-import).\n\n\n### How do I change the content on the home page?\nTo edit the main home page, open `/content/_index.md`.\n\n### How do I change the colours?\nYou can change the theme by editing `assets/custom.scss`. More details on customization and themeing can be found in the [customization guide](notes/config.md).\n\n### How do I add images?\nYou can put images anywhere in the `/content` folder.\n\n### My Interactive Graph and Backlinks aren't up to date\nBy default, the `linkIndex.json` (which Quartz needs to generate the Interactive Graph and Backlinks) are not regenerated locally. To set that up, see the guide on [local editing](notes/editing.md)\n\n### Can I use React/Vue/some other framework?\nNot out of the box. You could probably make it work by editing `/layouts/_default/single.html` but that's not what Quartz is designed to work with. 99% of things you are trying to do with those frameworks you can accomplish perfectly fine using just vanilla HTML/CSS/JS.\n\n## Still Stuck?\nQuartz isn't perfect! If you're still having troubles, file an issue in the GitHub repo with as much information as you can reasonably provide. Alternatively, you can message me on [Twitter](https://twitter.com/_jzhao) and I'll try to get back to you as soon as I can.\n\n🐛 [Submit an Issue](https://github.com/jackyzha0/quartz/issues)\n","lastmodified":"2023-03-22T14:03:38.286645979Z","tags":[]},"/About-Atlas":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: tutorial\ntitle: \"About Atlas\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\nAtlas意思是地图集。\n\n单个案例或项目的MOC，考虑直接放在对应文件夹里面，相当于起到一个个文件夹的readme和导览的作用。这里专门放这些MOC的MOC。\n\n围绕本库和obsidian的使用教程、方法和细节，也放到这里，就像是地图的指南针。\n","lastmodified":"2023-03-22T14:03:38.286645979Z","tags":[]},"/About-Extras":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: tutorial\ntitle: \"About Extras\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n[[图片保存：图床or本地]]\n","lastmodified":"2023-03-22T14:03:38.286645979Z","tags":[]},"/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90":{"title":"HashMap 源码解析","content":"## 前言  \n  \nHashMap 是 Java 中最常用 K-V 容器，使用哈希值来确定元素存储的位置，HashMap 对 Entry 进行了扩展（Node），使其形成以链表或者树的形式存储在 HashMap 的容器里。  \n  \n在 Java 8 之前和之后，HashMap 的实现有较大的不同，因此对于 put 流程、扩容机制等主要过程分析将会采用两个版本进行对比。  \n  \n## 成员变量  \n  \nHashMap 成员变量和构造方法声明如下（Java 7 和 8 大致相同，以下为 Java 8 版本）：  \n  \n```java  \npublic class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e  \n  \n    implements Map\u003cK,V\u003e, Cloneable, Serializable {  \n\n    // 初始容量 16  \n    static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16  \n  \n    // 最大容量，该数组最大值为2^31一次方。  \n    static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30;  \n  \n    // 默认的加载因子，如果构造的时候不传则为 0.75  \n    static final float DEFAULT_LOAD_FACTOR = 0.75f;  \n  \n    // @1.8：数组某个位置下的 node 链表转化为红黑树对该链表的最小长度要求  \n    static final int TREEIFY_THRESHOLD = 8;  \n  \n    // @1.8：当一个反树化的阈值，当这个 node 长度减少到该值就会从树转化成链表  \n    static final int UNTREEIFY_THRESHOLD = 6;  \n  \n    // @1.8：数组某个位置下的 node 链表转化为红黑树对元素个数的最小要求  \n    static final int MIN_TREEIFY_CAPACITY = 64;  \n  \n    // 具体存放数据的数组  \n    transient Node\u003cK,V\u003e[] table;  \n  \n    // entrySet，一个存放 k-v 缓冲区  \n    transient Set\u003cMap.Entry\u003cK,V\u003e\u003e entrySet;  \n  \n    // 存放键值对的个数。  \n    transient int size;  \n  \n    // 记录更改 map 结构次数(添加、删除、扩容？)  \n    transient int modCount;  \n  \n    // 临界值，当实际大小(容量*填充因子)超过临界值时，会进行扩容  \n  \n    int threshold;  \n  \n    // 填充因子  \n    final float loadFactor;  \n  \n    // 指定初始容量  \n    public HashMap(int initialCapacity) {  \n        this(initialCapacity, DEFAULT_LOAD_FACTOR);  \n    }  \n\n    // 默认构造函数  \n    public HashMap() {  \n        // 默认 threshold 在首次 put 时才复制，Java 7 则是调用  \n        // this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR)  \n        this.loadFactor = DEFAULT_LOAD_FACTOR;   \n    }  \n\n    // 包含另一个 Map  \n    public HashMap(Map\u003c? extends K, ? extends V\u003e m) {  \n        this.loadFactor = DEFAULT_LOAD_FACTOR;  \n  \n        putMapEntries(m, false);  \n    }  \n\n    // 指定初始容量和填充因子  \n    public HashMap(int initialCapacity, float loadFactor) {  \n        if (initialCapacity \u003c 0) // 容量不能为负数  \n  \n            throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);  \n  \n        // 当容量大于 2^31 就取最大值 1\u003c\u003c30;   \n  \n        if (initialCapacity \u003e MAXIMUM_CAPACITY)  \n  \n            initialCapacity = MAXIMUM_CAPACITY;  \n  \n        if (loadFactor \u003c= 0 || Float.isNaN(loadFactor))  \n  \n            throw new IllegalArgumentException(\"Illegal load factor: \"                + loadFactor);  \n  \n        this.loadFactor = loadFactor;  \n  \n        // tableSizeFor 保证了数组长度一定是 2 的幂次方，是大于等于    initialCapacity 最接近的值。  \n        // 这里使用 threshold 暂时保存计算后的 initialCapacity 值  \n        this.threshold = tableSizeFor(initialCapacity);  \n  \n    }  \n    ...  \n}  \n```  \n  \n## 数据结构  \n  \nJava 7 采用数组 + 链表方式进行存储，元素类型为 Entry：  \n  \n```java  \nstatic class Entry\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {  \n  \n    final K key;  \n  \n    V value;  \n  \n    Entry\u003cK,V\u003e next;  \n  \n    int hash;  \n\n    ...  \n}  \n```  \n  \n元素的存储结构如下：  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_035018.png)\nJava 8 开始，采用数组 + 链表 + 红黑树方式进行存储，元素类型为 Node 和 TreeNode：  \n  \n```java  \nstatic class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {  \n  \n    final int hash;  \n  \n    final K key;  \n  \n    V value;  \n  \n    Node\u003cK,V\u003e next;  \n\n    ...  \n}  \n  \n  \n  \nstatic final class TreeNode\u003cK,V\u003e extends LinkedHashMap.Entry\u003cK,V\u003e {  \n  \n    TreeNode\u003cK,V\u003e parent;  // red-black tree links  \n  \n    TreeNode\u003cK,V\u003e left;  \n  \n    TreeNode\u003cK,V\u003e right;  \n  \n    TreeNode\u003cK,V\u003e prev;    // needed to unlink next upon deletion  \n  \n    boolean red;  \n    \n    ...  \n}  \n```  \n  \n元素的存储结构如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_041741.png)\n\n## put 流程分析  \n  \n### Java 7 put 流程  \n  \n#### 代码分析  \n  \nJava 7 put 流程主要方法源码如下：  \n  \n```java  \npublic V put(K key, V value)  \n    if (table == EMPTY_TABLE) {  \n        // 初始化 table  \n        inflateTable(threshold);  \n    }  \n  \n    if (key == null) {  \n        // 在 table[0] 处插入 key 为 null 元素并返回  \n        return putForNullKey(value);  \n    }  \n  \n    // 先进行一次 hash 计算     \n    int hash = hash(key);  \n  \n    // 根据 hash 值计算 table 下标  \n    int i = indexFor(hash, table.length);  \n  \n    // 遍历 table[i] 处的链表  \n    for (Entry\u003cK,V\u003e e = table[i]; e != null; e = e.next) {  \n        Object k;  \n        // hash 一样且 key 相等或者 equals 方法返回 true 才进行替换  \n        if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) {  \n            V oldValue = e.value;  \n  \n            e.value = value;  \n  \n            e.recordAccess(this);  \n  \n            return oldValue;  \n        }  \n    }  \n    // 出循环意味着 table[i] 这条链表没有此元素  \n    // 更新 modCount  \n    modCount++;  \n    // 插入新元素  \n    addEntry(hash, key, value, i);  \n  \n    return null;  \n}  \n  \nprivate void inflateTable(int toSize) {  \n    // 获取大于  \n    int capacity = roundUpToPowerOf2(toSize);  \n    // 重新计算阈值  \n    threshold = (int) Math.min(capacity * loadFactor,   \n            MAXIMUM_CAPACITY + 1);  \n  \n    // 创建数组  \n    table = new Entry[capacity];  \n  \n    // 根据配置判断是否初始化 hashSeed  \n    initHashSeedAsNeeded(capacity);  \n}  \n  \nprivate V putForNullKey(V value) {  \n    // 最多循环一次，因为这个位置最多只有一个元素  \n    for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) {  \n        // key 为 null 直接替换  \n        if (e.key == null) {  \n            V oldValue = e.value;  \n            e.value = value;  \n            e.recordAccess(this);  \n  \n            return oldValue;  \n        }  \n    }  \n  \n    // 更新 modCount  \n    modCount++;  \n  \n    // 在 table[0] 处插入元素  \n    addEntry(0, null, value, 0);  \n  \n    return null;  \n}  \n  \nvoid addEntry(int hash, K key, V value, int bucketIndex) {  \n    // 元素数量达到临界值且 table[bucketIndex] 位置不为空才进行扩容  \n    if ((size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])) {  \n        // 两倍容量  \n        resize(2 * table.length);  \n  \n        // 重新计算 hash  \n        hash = (null != key) ? hash(key) : 0;  \n  \n        // 重新确定数组下标  \n        bucketIndex = indexFor(hash, table.length);  \n    }\n    // 创建并插入新元素  \n    createEntry(hash, key, value, bucketIndex);  \n}  \n  \n// 在链表头部插入新元素  \nvoid createEntry(int hash, K key, V value, int bucketIndex) {  \n    // 保存原头结点  \n    Entry\u003cK,V\u003e e = table[bucketIndex];  \n    // 创建新元素、把 next 指向头节点，并替换原来 bucketIndex 位置的链表  \n    table[bucketIndex] = new Entry\u003c\u003e(hash, key, value, e);  \n    // 元素数量++  \n    size++；  \n}  \n```  \n  \n#### 流程图示  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040358.png)\n### Java 8 put 流程  \n  \n#### 代码分析  \n  \nJava 8 put 流程主要方法源码如下：  \n  \n```java  \npublic V put(K key, V value) {  \n      // onlyIfAbsent 默认为 false，即元素存在时进行替换  \n    return putVal(hash(key), key, value, false, true);  \n}  \n  \nfinal V putVal(int hash, K key, V value,   \n          boolean onlyIfAbsent, boolean evict) {  \n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i;  \n  \n    // table 未初始化或者长度为 0，进行扩容  \n    if ((tab = table) == null || (n = tab.length) == 0)  \n        n = (tab = resize()).length;  \n  \n    // (n - 1) \u0026 hash 确定元素存放位置，位置为空则直接放入该位置  \n    if ((p = tab[i = (n - 1) \u0026 hash]) == null)  \n        tab[i] = newNode(hash, key, value, null);  \n  \n    // 数组对应位置已经存在元素  \n    else {  \n        Node\u003cK,V\u003e e; K k;  \n  \n        // 比较数组中第一个元素  \n        if (p.hash == hash \u0026\u0026  \n            ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n  \n                // 将第一个元素赋值给 e  \n                e = p;  \n        // 是否为红黑树结点  \n        else if (p instanceof TreeNode)  \n            // 放入树中  \n            e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab,   \n                        hash, key, value);  \n        // 链表结点  \n        else {  \n            // 遍历链表  \n            for (int binCount = 0; ; ++binCount) {  \n                // 到达链表的尾部，说明没有找到相等的 key  \n                if ((e = p.next) == null) {  \n                    // 在尾部插入新结点  \n                    p.next = newNode(hash, key, value, null);  \n  \n                    // 判断结点数量是否达到阈值(TREEIFY_THRESHOLD 默认为 8)  \n                    if (binCount \u003e= TREEIFY_THRESHOLD - 1) {  \n                        // 根据数组长度决定是否树化  \n                        treeifyBin(tab, hash);  \n                    }  \n  \n                    // 跳出循环  \n                    break;  \n                }  \n  \n                // 判断链表中结点的 key 值是否与插入的 key 相等  \n                if (e.hash == hash \u0026\u0026  \n                    ((k = e.key) == key ||   \n                          (key != null \u0026\u0026 key.equals(k))))  \n                    // key 相等，跳出循环，此时 e 就是目标结点  \n                    break;  \n  \n                // 与前面的 e = p.next 组合遍历链表  \n                p = e;  \n            }  \n        }  \n  \n        // 找到 key 值相等的目标结点  \n        if (e != null) {  \n  \n            V oldValue = e.value;  \n  \n            // onlyIfAbsent 为 false 或者目标接点值为 null  \n            if (!onlyIfAbsent || oldValue == null)  \n  \n                //用新值替换旧值  \n                e.value = value;  \n  \n            // 空实现，用于访问后回调给子类，如 LinkedHashMap  \n            afterNodeAccess(e);  \n  \n            // 返回旧值  \n            return oldValue;  \n        }  \n    }  \n  \n    // 结构修改，更新 modCount  \n    ++modCount;  \n  \n    // 实际大小大于阈值则扩容  \n    if (++size \u003e threshold)  \n        resize();  \n  \n    // 插入后回调  \n    afterNodeInsertion(evict);  \n  \n    return null;  \n}  \n```  \n  \n#### 流程图示  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040522.png)\n## hash 计算与元素位置确定  \n  \n### Java 7  \n  \n```java  \nint hash = hash(key);  \n  \nint i = indexFor(hash, table.length);  \n  \nfinal int hash(Object k) {  \n  \n    // 默认为 0，初始化方法见后文  \n    int h = hashSeed;  \n  \n    // 如果 hashSeed 不为零且 key 是 String 类型  \n    if (0 != h \u0026\u0026 k instanceof String) {  \n        // 返回特定 hash 值  \n        return sun.misc.Hashing.stringHash32((String) k);  \n    }  \n  \n    h ^= k.hashCode();  \n  \n    // 多次异或  \n    h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12);  \n  \n    return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4);  \n}  \n  \nstatic int indexFor(int h, int length) {  \n    // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";  \n    return h \u0026 (length-1);  \n}  \n```  \n  \n### Java 8  \n  \n```java  \npublic V put(K key, V value) {  \n    return putVal(hash(key), key, value, false, true);  \n}  \n\nstatic final int hash(Object key) {  \n    int h;  \n  \n    // 让高 16 位和低 16 位异或  \n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16);  \n}  \n\np = tab[index = (n - 1) \u0026 hash]；  \n```  \n  \n## 扩容流程  \n  \n扩容过程涉及到 rehash、复制数据等操作，非常消耗性能。  \n  \n和扩容相关的全局变量及其含义：  \n  \n| 全局变量   | 含义                                                                                                                                                                                                                                                                                                                                                                                                      |  \n| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |  \n| capacity   | table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。                                                                                                                                                                                                                                                                                                                               |  \n| size       | 存放键值对数量。                                                                                                                                                                                                                                                                                                                                                                                          |  \n| threshold  | size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。threshold = (int) (capacity * loadFactor)                                                                                                                                                                                                                                                                                                   |  \n| loadFactor | 填充因子，table 能够使用的比例。loadFactor 能够控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。\u003cbr/\u003eloadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。 |  \n  \n### Java 7 扩容流程  \n  \n#### 代码分析  \n  \nJava 7 的 resize 方法相关代码：  \n  \n```java  \nvoid resize(int newCapacity) {  \n    Entry[] oldTable = table;  \n  \n    // 记录旧容量  \n    int oldCapacity = oldTable.length;  \n  \n    // 如果容量已达到上限，则扩容阈值设置成不可能达到的最大值，即后续不再扩容  \n    if (oldCapacity == MAXIMUM_CAPACITY) {  \n        threshold = Integer.MAX_VALUE;  \n  \n        return;  \n    }  \n  \n    // 根据新容量创建出新数组  \n    Entry[] newTable = new Entry[newCapacity];  \n  \n    // 将旧数组的节点转移到新数组  \n    transfer(newTable, initHashSeedAsNeeded(newCapacity));  \n  \n    // 新旧易主  \n    table = newTable;  \n  \n    // 根据新容量重新确定新阈值  \n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);  \n}  \n \n// 从配置中获取是否启用备用 hash，用于减少字符串 hash 冲突  \nfinal boolean initHashSeedAsNeeded(int capacity) {  \n    // 是否已经启用备用 hash  \n    boolean currentAltHashing = hashSeed != 0;  \n  \n    // 虚拟机已经启动且数组容量大于 ALTERNATIVE_HASHING_THRESHOLD  \n    boolean useAltHashing = sun.misc.VM.isBooted() \u0026\u0026  \n            (capacity \u003e= Holder.ALTERNATIVE_HASHING_THRESHOLD);  \n  \n    // 异或操作判断是否切换  \n    boolean switching = currentAltHashing ^ useAltHashing;  \n    if (switching) {  \n        // useAltHashing 为 true 则 hashSeed 初始化为也给随机 hash 值  \n        hashSeed = useAltHashing  \n            ? sun.misc.Hashing.randomHashSeed(this)  \n            : 0;  \n    }  \n    return switching;  \n}  \n\nvoid transfer(Entry[] newTable, boolean rehash) {  \n    int newCapacity = newTable.length;  \n  \n    // 遍历旧数组  \n    for (Entry\u003cK,V\u003e e : table) {  \n        // 遍历数组上的链表  \n        while(null != e) {  \n            // 记录下一个位置  \n            Entry\u003cK,V\u003e next = e.next;  \n  \n            // 判断是否重新计算 hash 值  \n            if (rehash) {  \n  \n                e.hash = null == e.key ? 0 : hash(e.key);  \n  \n            }  \n  \n            // 根据新容量重新计算位置  \n            int i = indexFor(e.hash, newCapacity);  \n  \n            // 按旧链表的正序遍历链表、在新链表的头部依次插入  \n            // 因此扩容后可能出现逆序  \n            e.next = newTable[i];  \n  \n            newTable[i] = e;  \n  \n            e = next;  \n        }  \n    }  \n}  \n```  \n  \n#### 扩容流程在多线程环境下的隐患  \n  \n在 resize 扩容过程中，在将旧数组上的数据转移到新数组上时，转移数据操作是按旧链表的正序遍历链表、在新链表的头部依次插入的。在多线程的环境下，由于这些操作不具有原子性和内存可见性，转移数据、扩容后，容易出现环形链表的情况。  \n  \n### Java 8 扩容流程  \n  \n#### 代码分析  \n  \nJava 8 中的 resize 和 treeifyBin 方法：  \n  \n```java  \nfinal void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) {  \n    int n, index; Node\u003cK,V\u003e e;  \n    // 如果数组为空或者数组长度小于 64，则进行扩容  \n    if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY)  \n        resize();  \n    // 根据 hash 获取数组下标，该位置有值再进行树化  \n    else if ((e = tab[index = (n - 1) \u0026 hash]) != null) {  \n        TreeNode\u003cK,V\u003e hd = null, tl = null;  \n        // 遍历链表  \n        do {  \n            // Node 节点转换成 TreeNode 节点  \n            TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null);  \n  \n            if (tl == null)  \n                hd = p;  \n            else {  \n                p.prev = tl;  \n  \n                tl.next = p;  \n            }  \n  \n            tl = p;  \n        } while ((e = e.next) != null);  \n        \n        if ((tab[index] = hd) != null)  \n            hd.treeify(tab);  \n    }  \n}  \n\nfinal Node\u003cK,V\u003e[] resize() {  \n  \n    Node\u003cK,V\u003e[] oldTab = table;  \n  \n    int oldCap = (oldTab == null) ? 0 : oldTab.length;  \n  \n    int oldThr = threshold;  \n  \n    int newCap, newThr = 0;  \n  \n    if (oldCap \u003e 0) {  \n        // 超过最大值后续不再扩容  \n        if (oldCap \u003e= MAXIMUM_CAPACITY) {  \n            threshold = Integer.MAX_VALUE;  \n            return oldTab;  \n        }  \n  \n        // 否则扩充为原来的2倍  \n        else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 oldCap \u003e= DEFAULT_INITIAL_CAPACITY)  \n            newThr = oldThr \u003c\u003c 1; // double threshold  \n    }  \n  \n    else if (oldThr \u003e 0) // initial capacity was placed in threshold  \n        newCap = oldThr;  \n    else {  \n        // signifies using defaults  \n        newCap = DEFAULT_INITIAL_CAPACITY;  \n  \n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  \n    }  \n  \n    // 计算新的 resize 上限  \n  \n    if (newThr == 0) {  \n        float ft = (float)newCap * loadFactor;  \n        newThr = (newCap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);  \n    }  \n  \n    threshold = newThr;  \n  \n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})  \n  \n    Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap];  \n  \n    table = newTab;  \n\n    if (oldTab != null) {  \n        // 旧数组迁移至新数组  \n        for (int j = 0; j \u003c oldCap; ++j) {  \n            Node\u003cK,V\u003e e;  \n            if ((e = oldTab[j]) != null) {  \n                oldTab[j] = null;  \n                if (e.next == null)  \n                    newTab[e.hash \u0026 (newCap - 1)] = e;  \n                else if (e instanceof TreeNode)  \n                    ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap);  \n                else {  \n                    Node\u003cK,V\u003e loHead = null, loTail = null;  \n                    Node\u003cK,V\u003e hiHead = null, hiTail = null;  \n                    Node\u003cK,V\u003e next;  \n                    do {  \n                        next = e.next;  \n                        // 原索引  \n                        if ((e.hash \u0026 oldCap) == 0) {  \n                            if (loTail == null)  \n                                loHead = e;  \n                            else  \n                                loTail.next = e;  \n                            loTail = e;  \n                        }  \n  \n                        // 原索引+oldCap  \n                        else {  \n                            if (hiTail == null)  \n                                hiHead = e;  \n                            else  \n                                hiTail.next = e;  \n                            hiTail = e;  \n                        }  \n                    } while ((e = next) != null);  \n  \n                    // 原索引元素放到新数组中  \n                    if (loTail != null) {  \n                        loTail.next = null;  \n                        newTab[j] = loHead;  \n                    }  \n  \n                    // 原索引 +oldCap 元素放到新数组中  \n                    if (hiTail != null) {  \n                        hiTail.next = null;  \n                        newTab[j + oldCap] = hiHead;  \n                    }  \n                }  \n            }  \n        }  \n    }  \n    return newTab;  \n}  \n```  \n  \nresize 方法中的前半段，关于 newCap 和 newThr 的计算过程，简化后如下：  \n  \n```java  \nif (oldCap \u003e 0) {  \n    // 嵌套条件分支  \n    if (oldCap \u003e= MAXIMUM_CAPACITY) {...}  \n    else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026  \n                 oldCap \u003e= DEFAULT_INITIAL_CAPACITY) {...}  \n}   \nelse if (oldThr \u003e 0) {...}  \n  \nelse {...}  \n```  \n  \n这些判断分别对应以下几种条件：  \n  \n| 条件                       | 覆盖情况                            | 备注                                                                                                                         |  \n| -------------------------- | ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |  \n| oldCap \u003e 0                 | 桶数组 table 已经被初始化           |                                                                                                                              |  \n| oldThr \u003e 0                 | threshold \u003e 0，且桶数组未被初始化   | 调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况，此种情况下 newCap = oldThr，newThr 在第二个条件分支中算出 |  \n| oldCap == 0 \u0026\u0026 oldThr == 0 | 桶数组未被初始化，且 threshold 为 0 | 调用 HashMap() 构造方法会产生这种情况。                                                                                      |  \n  \noldCap \u003e 0 时表示 table 数组已经被初始化过，这时需要再次计算容量和阈值：  \n  \n| 条件                        | 覆盖情况                                      | 备注                                                      |  \n| --------------------------- | --------------------------------------------- | --------------------------------------------------------- |  \n| oldCap \u003e= 230               | 桶数组容量大于或等于最大桶容量 230            | 后续不再扩容                                              |  \n| newCap \u003c 230 \u0026\u0026 oldCap \u003e 16 | 新桶数组容量小于最大值，且旧桶数组容量大于 16 | 该种情况下新阈值 newThr = oldThr \u003c\u003c 1，移位可能会导致溢出 |  \n  \nresize 方法后续过程中可以看出，Java 8 转移数据操作是按旧链表的正序遍历链表、在新链表的尾部依次插入的，所以不会出现链表 逆序、倒置的情况，故不容易出现环形链表的情况。但仍然还是线程不安全，因为没有加同步锁保护。  \n  \n### 扩容流程对比  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040805.png)\n## get 流程分析  \n  \n### Java 7\n  \n```java  \npublic V get(Object key) {  \n    if (key == null)  \n        return getForNullKey();  \n    Entry\u003cK,V\u003e entry = getEntry(key);  \n    return null == entry ? null : entry.getValue();  \n}  \n  \nprivate V getForNullKey() {  \n    if (size == 0) {  \n        return null;  \n    }  \n  \n    // 下标为 0 处获取 key 为 null 的元素  \n    for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) {  \n        if (e.key == null)  \n            return e.value;  \n    }  \n    return null;  \n}  \n\nfinal Entry\u003cK,V\u003e getEntry(Object key) {  \n    if (size == 0) {  \n        return null;  \n    }  \n  \n    int hash = (key == null) ? 0 : hash(key);  \n    for (Entry\u003cK,V\u003e e = table[indexFor(hash, table.length)];  \n             e != null; e = e.next) {  \n        Object k;  \n        if (e.hash == hash \u0026\u0026  \n            ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n            return e;  \n    }  \n    return null;  \n}  \n```  \n  \n### Java 8\n  \n```java  \npublic V get(Object key) {  \n    Node\u003cK,V\u003e e;  \n    return (e = getNode(hash(key), key)) == null ? null : e.value;  \n}  \n\nfinal Node\u003cK,V\u003e getNode(int hash, Object key) {  \n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n; K k;  \n    if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026  \n        (first = tab[(n - 1) \u0026 hash]) != null) {  \n        // 先判断 tab[index] 中的第一个元素  \n        if (first.hash == hash \u0026\u0026 // always check first node  \n            ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n            return first;  \n        if ((e = first.next) != null) {  \n            // 结点为红黑树则使用 TreeNode 的方法获取  \n            if (first instanceof TreeNode)  \n                return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key);  \n            do { //否则遍历链表  \n                if (e.hash == hash \u0026\u0026  \n                    ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n                    return e;  \n            } while ((e = e.next) != null);  \n        }  \n    }  \n    return null;  \n}  \n```  \n  \n遍历方式  \n  \n```java  \nMap\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e() {{  \n    put(\"a\", 10);  \n    put(\"b\", 20);  \n}};  \n  \n// 方式一：迭代 entrySet  \n  \nfor (Map.Entry\u003cString, Integer\u003e entry : map.entrySet()) {  \n    String key = entry.getKey();  \n    int value = entry.getValue();  \n}  \n\n// 方式二：单独迭代 keySet 或 values  \n// 迭代键  \nfor (String key : map.keySet()) {  \n    System.out.println(\"Key = \" + key);  \n}  \n  \n// 迭代值  \nfor (Integer value : map.values()) {  \n    System.out.println(\"Value = \" + value);  \n}  \n\n// 方式三：使用 iterator  \n  \nIterator\u003cMap.Entry\u003cString, Integer\u003e\u003e entries =         \n          map.entrySet().iterator();  \n  \nwhile (entries.hasNext()) {  \n    Map.Entry\u003cString, Integer\u003e entry = entries.next();  \n    String key = entry.getKey();  \n    int value = entry.getValue();  \n}  \n\n// 方式四：Lambda 表达式  \nmap.forEach((k, v) -\u003e System.out.println(\"key: \" + k + \" value:\" + v));  \n```  \n  \n## 面试题  \n  \n### 为什么 HashMap 数组长度为 2 的幂次方？  \n  \n如果数组中 hash 冲突太过频繁，某些位置的元素形成过长的链表，就会导致数据存取效率过低，因此要使元素均匀地分布在数组中，hash 碰撞就不能太频繁。而 hash 值范围为 -2147483648 到 2147483647，如果用如此长的数组来进行存放加上合理 hash 映射确实可以使 hash 碰撞降到很低的水平，但这明显是不现实的。  \n  \n因此这个 hash 值是不能直接使用的，首先需要进行二次 hash 使得结果更加随机，这时理论上可以使用 hash % length 得到一个不小于数组长度 length 的 index 值，这样不但能避免产生数组越界，并且可以使元素均匀分布，事实上很多 hash 算法都是采用该方法。但是在计算机中，% 取模运算比位 \u0026 运算的效率要低得多，而当 length 为 2 的幂次方时，hash % length 刚好等于 hash \u0026 (length - 1) ，从而能够将 % 运算转换成 \u0026 运算，更加快速地得到 index 值。  \n  \n因此采用 2 的幂次方作为数组的长度的好处是：使元素均匀分部以降低 hash 冲突的基础上，大大加快了计算元素所在数组位置的速度。  \n  \n### hash 冲突有哪些解决方法？HashMap 是怎样解决的？  \n  \n1. 二次 hash，通过高 16 位与低 16 位异或运算，使得结果更加随机；  \n2. 拉链地址法，将 hash 值相同的元素串成一个链表或者转为红黑树。  \n  \n### HashMap 会造成哪些安全问题？怎么解决？  \n  \n如前面文章所述，在 Java 7 中，HashMap 在扩容的时候是通过遍历旧数组，然后在新数组中使用头插法进行转移元素的。这在单线程环境中是没有问题的，但是到了多线程环境下，由于 JMM 的特性，会以一定的概率形成环形链表的情况。在 Java 8 中这个问题通过使用尾插法得到解决，但是多线程下很多操作仍然会导致线程安全问题，比如多个线程 put 后某些元素丢失等。因此多线程环境下要保证线程安全，可以使用 ConcurentHashMap 代替 HashMap。  \n  \n### 使用对象作为 HashMap 的 key 应该注意什么？  \n  \n应当重写对象的 hashCode() 和 equals() 方法。如前面代码所示，HashMap 在 put 一个元素的时候，会调用此元素的 key 值的 hashCode 方法确定元素存放位置，并且会调用 hashCode 和 equals 方法判断元素是否相等。因此如果没有重写这两个方法，或者方法重写的时候没有遵守规则，HashMap 通过 put 存入一组元素后，再通过此元素的 key 值去 get 对象的时候就有可能出现跟预期结果不一致的情况。  \n  \n在重写 equals 方法的时候，需要遵守下面的通用约定：  \n  \n- \u003cstrong\u003e自反性\u003c/strong\u003e：对于任何非空引用 x，x.equals(x) 必须返回 true；  \n- \u003cstrong\u003e对称性\u003c/strong\u003e：对于任何非空引用 x 和 y，如果且仅当 y.equals(x) 返回 true 时 x.equals(y) 必须返回 true；  \n- \u003cstrong\u003e传递性\u003c/strong\u003e：对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 必须返回 true；  \n- \u003cstrong\u003e一致性\u003c/strong\u003e：对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 x.equals(y) 的多次调用必须始终返回 true 或始终返回 false；  \n- \u003cstrong\u003e非空性\u003c/strong\u003e：对于任何非空引用 x，x.equals(null) 必须返回 false。  \n  \n\u003cstrong\u003e重写 hashCode 方法的大致方式（非强制）：\u003c/strong\u003e  \n  \n1. 把某个非零常数值，比如说 31（最好是素数，考虑到 HashMap 源码中的异或操作），保存在一个叫 result 的 int 类型的变量中。  \n2. 对于对象中每一个关键域 f（值 equals 方法中考虑的每一个域），完成以下步骤：  \n3. 为该域计算 int 类型的散列码 c:  \n  \n```  \n1. 如果该域是 boolean 类型，则计算 (f?0:1)  \n  \n2. 如果该域是 byte、char、short 或者 int 类型，则计算 (int)f  \n  \n3. 如果该域是 float 类型，则计算 Float.floatToIntBits(f)  \n  \n4. 如果该域是 long 类型，则计算 (int)(f ^ (f\u003e\u003e\u003e32))  \n  \n5. 如果该域是double类型，则计算 Double.doubleToLongBits(f) 得到一个 long 类型的值，然后按照步骤 4，对该 long 型值计算散列值  \n  \n6. 如果该域是一个对象引用，并且该类的 equals 方法通过递归调用 equals 的方式来比较这个域，则同样对这个对象递归调用 hashCode 方法。  \n  \n7. 如果该域是一个数组，则把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤下面的做法把这些散列值组合起来。  \n```  \n  \n2. 按照下面的公式，把步骤 1 中计算得到的散列码 c 组合到 result 中：result = 31 x result+c。  \n3. 返回 result。  \n4. 写完 hashCode 方法之后，确认是否相等的实例具有相等的散列码。如果不是的话，找出原因，并修改。  \n  \n样例：  \n  \n```java  \npublic class Student {  \n  \n    private String name;  \n  \n    private int age;  \n  \n    private Grades grades;  \n  \n    public Student(String name, int age, Grades grades) {  \n        this.name = name;  \n        this.age = age;  \n        this.grades = grades;  \n    }  \n\n    @Override  \n    public int hashCode() {  \n        final int prime = 31;  \n        int result = 1;  \n        \n        result = prime * result + age;  \n        result = prime * result +  \n                ((name == null) ? 0 : name.hashCode());  \n        result = prime * result +  \n                (grades == null ? 0 : grades.hashCode());  \n  \n        return result;  \n  \n    }  \n  \n    @Override  \n    public boolean equals(Object obj) {  \n        if (this == obj) return true;  \n  \n        if (obj == null || getClass() != obj.getClass()) return false;  \n  \n        Student other = (Student) obj;  \n  \n        if (age != other.age) return false;  \n  \n        if (name != null ? !name.equals(other.name) :   \n              other.name != null) return false;  \n  \n        if (grades != null ? !grades.equals(other.grades) :           \n              other.grades != null) return false;  \n  \n        return true;  \n    }  \n}  \n```","lastmodified":"2023-03-22T14:03:38.286645979Z","tags":["HashMap","源码解析","Java"]},"/IO":{"title":"IO","content":"","lastmodified":"2023-03-22T14:03:38.286645979Z","tags":["Java","IO"]},"/Index-for-Atlases":{"title":"Untitled Page","content":"---\ndate created: 2022-06-22\ndate modified: 2022-08-20\ntags: dataview\ntitle: \"Index for Atlases\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n```dataviewjs\n// 获取当前文件所在的文件夹\nconst currentFolder = dv.current().file.folder\n// 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息\nconst groups =  dv.pages(`\"${currentFolder}\"`).groupBy(p =\u003e p.file.folder)\nfor (let group of groups) {\n\tdv.header(4, group.key);\n\tdv.table([\"Name\",\"标签\",\"入链\", \"创建日期\", \"修改日期\"],\n\t\tgroup.rows\n\t\t\t.sort(k =\u003e k.file.name, 'asc')\n\t\t\t.map(k =\u003e [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday]))\n}\n```\n","lastmodified":"2023-03-22T14:03:38.286645979Z","tags":[]},"/Index-for-Extras":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: dataview\ntitle: \"Index for Extras\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n```dataviewjs\n// 获取当前文件所在的文件夹\nconst currentFolder = dv.current().file.folder\n// 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息\nconst groups =  dv.pages(`\"${currentFolder}\"`).groupBy(p =\u003e p.file.folder)\nfor (let group of groups) {\n\tdv.header(4, group.key);\n\tdv.table([\"Name\",\"标签\",\"入链\", \"创建日期\", \"修改日期\"],\n\t\tgroup.rows\n\t\t\t.sort(k =\u003e k.file.name, 'asc')\n\t\t\t.map(k =\u003e [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday]))\n}\n```\n","lastmodified":"2023-03-22T14:03:38.286645979Z","tags":[]}}