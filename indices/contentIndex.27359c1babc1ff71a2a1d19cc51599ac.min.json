{"/":{"title":"Home","content":"Nothing!\n\n## 标题一\n\n### 标题二\n\n是的辅导老师放假\n\n## 哈哈哈","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":[]},"/%E4%B8%80Binder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E6%A6%82%E5%BF%B5%E7%AF%87":{"title":"一、Binder 机制分析——概念篇","content":"[上次没砍我的,这次我又来了。看完这篇还不明白 Binder 你砍我(一) - 掘金](https://juejin.cn/post/6867139592739356686)\n\n[不懂砍我之看完这篇还不明白 Binder 你砍我(二) - 掘金](https://juejin.cn/post/6868901776368926734)\n\n[不懂砍我之看完这篇还不明白 Binder 你砍我(三) - 掘金](https://juejin.cn/post/6869953788388573192)\n\n[不懂砍我之看完这篇还不明白 Binder 你砍我(四)完结篇 - 掘金](https://juejin.cn/post/6872987936753876999)\n\n[听说你 Binder 机制学的不错，来解决下这几个问题(一) - 掘金](https://juejin.cn/post/6844903469971685390)\n\n[听说你 Binder 机制学的不错，来解决下这几个问题(二) - 掘金](https://juejin.cn/post/6844903469984268296)\n\n[听说你 Binder 机制学的不错，来解决下这几个问题(三) - 掘金](https://juejin.cn/post/6844903469988446221)\n\n[3 分钟带你看懂 android 的 Binder 机制 - 掘金](https://juejin.cn/post/6844903764986462221)\n\n[图解 Android 中的 binder 机制 - 掘金](https://juejin.cn/post/6844904115777044488)\n\n[写给 Android 应用工程师的 Binder 原理剖析](https://zhuanlan.zhihu.com/p/35519585)\n\n[Android 中 mmap 原理及应用简析 - 掘金](https://juejin.cn/post/6844903762146885640)\n\n[认真分析 mmap:是什么 为什么 怎么用 - 胡潇 - 博客园](https://www.cnblogs.com/huxiao-tee/p/4660352.html)\n\n[图解 | 不得错过的 Binder 浅析(一) - 掘金](https://juejin.cn/post/6890088205916307469)\n\n[图解 | 不得错过的 Binder 浅析(二) - 掘金](https://juejin.cn/post/6897868762410811405)\n\n[Android Frameworks 研究 - 悠然红茶的个人页面 - OSCHINA - 中文开源技术交流社区](https://my.oschina.net/youranhongcha?tab=newest\u0026catalogId=373547)\n\n# 前言\n\n在开始之前有必要了解一下几点知识，方便文章的理解。\n\n## 进程隔离\n\n以下内容来自 [维基百科](https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E9%9A%94%E7%A6%BB)：\n\n\t进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程 A 写入进程 B 的情况发生。 进程的隔离实现，使用了\u003cstrong\u003e虚拟地址空间\u003c/strong\u003e。进程 A 的虚拟地址和进程 B 的虚拟地址不同，这样就防止进程 A 将数据信息写入进程 B。\n\n## 进程空间划分：用户空间 (User Space)/内核空间 (Kernel Space)\n\n现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。\n\n简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-1/clipboard_20230323_044233.png)\n\n## 系统调用：用户态与内核态\n\n虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助\u003cstrong\u003e系统调用\u003c/strong\u003e来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。\n\nLinux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用：\n\n当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于\u003cstrong\u003e内核运行态（内核态）\u003c/strong\u003e。此时处理器处于特权级最高的（0 级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。\n\n而当进程在执行用户自己的代码的时候，我们称其处于\u003cstrong\u003e用户运行态（用户态）\u003c/strong\u003e。此时处理器在特权级最低的（3 级）用户代码中运行。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-1/clipboard_20230323_044239.png)\n\n## Linux IPC 原理\n\n由于进程 A 和进程 B 占用的虚拟内存地址不同，因此它们之间是相互透明的，都以为自己独享了系统的资源，当然也不能直接跟对方交互。但是，有些情况下有些进程难免会需要跟其他进程进行交互，这个交互过程就叫 IPC(Inter-Process Communication，进程间通信)。IPC 的实质就是数据的交互，因此我们这里将进行 IPC 过程中的通信调用方和被调用方分别称为数据发送方和数据接收方，IPC 通信的过程如下：\n\n1. 数据发送方进程将数据放在\u003cstrong\u003e内存缓存区\u003c/strong\u003e，通过系统调用陷入内核态\n2. 内核程序在内核空间开辟一块\u003cstrong\u003e内核缓存区\u003c/strong\u003e，通过系统调用 copy_from_user 函数将数据从数据发送方用户空间的内存缓存区拷贝到内核空间的内核缓存区中\n3. 数据接收方进程在自己的用户空间开辟一块内存缓存区\n4. 内核程序将内核缓存区中通过系统调用 copy_to_user 函数将数据拷贝到数据接收方进程的内存缓存区\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-1/clipboard_20230323_044242.png)\n\n通过以上过程，一次 IPC 就完成了，但是这种传统的 IPC 机制有两个问题：\n\n- 性能比较低：整个过程数据的传递需要经历发送方内存缓存区——内核缓存区——接收方内存缓存区的过程\n- 接收方进程事先不知道需要开辟多大的内存用于存放数据，因此需要开辟尽可能大的空间或者事先调\n\n# 为什么要学习 Binder 机制\n\n作为 Android 工程师，开发过程中难免会产生如下疑问：\n\n- 为什么 Activity 之前传递数据需要进行序列化，而且数据大小超过 1M 的时候会 Crash？\n- 四大组件的启动流程为何那么复杂，它们之间的通讯机制是怎么建立的？\n- AIDL 通讯的实现原理是什么？\n\n其实上面的问题都和 Binder 的概念密切相关，事实上，在应用程序底层 Binder 的存在感相当高：四大组件之间跨进程通讯、卸载/安装应用程序、启动/关闭一个 Activity 和 show/hide 一个 Dialog 等场景都要依赖 Binder 机制，Binder 是 Android 系统用于跨进程通讯的框架，因此了解 Binder 机制则是回答以上问题的关键。\n\n# 为什么是 Binder\n\nAndroid 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等传统的 IPC 机制，为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于\u003cstrong\u003e性能\u003c/strong\u003e、\u003cstrong\u003e稳定性\u003c/strong\u003e和\u003cstrong\u003e安全性\u003c/strong\u003e几方面的原因。\n\n## 性能\n\n从性能的角度来说，传统的 IPC 方式有如下特点：\n\n- socket：传输效率低，开销大，它主要用在跨网络的进程间通信和本机上进程间的低速通信\n- 消息队列和管道：采用存储 - 转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程\n- 共享内存：虽然无需拷贝，但控制复杂，难以使用\n\nSocket、管道和消息队列通讯过程：\n\n## 安全性\n\nAndroid 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取通信录并上传隐私数据、后台偷跑流量和消耗手机电量等。传统的 IPC 没有任何安全措施，完全依赖上层协议来保证。\n\nAndroid 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。但是传统的 IPC 接收方无法获得对方可靠的进程用户 ID/进程 ID（UID/PID），从而无法鉴别对方身份。只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。\n\n其次，传统 IPC 访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V 的键值，socket 的 ip 地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。\n\n而同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。\n\n## 稳定性\n\n再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。\n\n## 小结\n\nBinder 相对于其它通讯方式的特点：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-1/clipboard_20230323_044250.png)\n\n# Binder 原理解析\n\n从字面上看 Binder 是胶水的意思，在这里，Binder 的职责是在不同的进程之间扮演一个桥梁的角色，让它们之间能够相互通信。进程间的通讯少不了 Linux 内核的支持，而 Binder 并不属于内核的一部分，但是，得益于 Linux 的 LKM(Loadable Kernel Module) 机制：\n\n\u003e 模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行\n\n因此，Binder 作为这种模块存在于内核之中，也称为 Binder 驱动。回顾上一小节的内容，传统 Linux IPC 的过程需要经历两次数据拷贝，Binder 借助 Linux 的另一个特性，只用一次数据拷贝，就能实现 IPC 过程，这就是\u003cstrong\u003e内存映射\u003c/strong\u003e：\n\n\u003e Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间，映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。\n\n内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。\n\n## Binder 通讯模型\n\nBinder IPC 通信过程大致如下：\n\n1. Binder 驱动在内核空间创建一个\u003cstrong\u003e数据接收缓存区\u003c/strong\u003e\n2. 然后在内核空间开辟一块\u003cstrong\u003e内存缓存区\u003c/strong\u003e并与数据接收缓存区建立映射关系，同时，通过 mmap 函数建立\u003cstrong\u003e数据接收缓存区\u003c/strong\u003e与\u003cstrong\u003e数据接收方的内存缓存区\u003c/strong\u003e的映射关系\n3. 数据发送方通过系统调用 copy_from_user() 函数将数据从内存缓存区拷贝到内核缓存区，由于内核缓存区通过数据接收缓存区跟数据接收方的内存缓存区存在间接的映射关系，相当于将数据直接拷贝到了接收方的用户空间，这样便完成了一次 IPC 的过程。\n\nBinder 通讯过程示意：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-1/clipboard_20230323_044253.png)\n\n在进行 Binder IPC 的时候，实际情况比上面介绍的要复杂，Binder 通讯模型是基于 C/S 架构的，通信调用方进程称为 Client 进程，被调用方称为 Server 进程，除此之外还需要 ServiceManager 和 Binder 驱动的参与，它们都是通过 open/mmap/iotl 等系统调用来访问设备文件 dev/binder 来实现 IPC 过程的。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-1/clipboard_20230323_044256.png)\n\n其中，Client、Server 和 ServiceManager 运行在用户空间，Binder Driver 运行在内核空间，Client 和 Server 需由用户自己实现，ServiceManager 和 Binder Driver 则由系统提供。\n\n[Android Binder 设计与实现](https://blog.csdn.net/universus/article/details/6211589) 文章中对 Client 和 Server 等角色有详细的描述：\n\n\u003e \u003cstrong\u003eBinder 驱动\u003c/strong\u003e\n\n\u003e Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。\n\n\u003e\n\n\u003e \u003cstrong\u003eServiceManager 与实名 Binder\u003c/strong\u003e\n\n\u003e ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址以外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。\n\n\u003e\n\n\u003e 细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER\u003cem\u003eSET\u003c/em\u003eCONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（\u003cstrong\u003e这就是那只预先造好的那只鸡\u003c/strong\u003e）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。\n\n\u003e\n\n\u003e \u003cstrong\u003eClient 获得实名 Binder 的引用\u003c/strong\u003e\n\n\u003e Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。\n\n因此，ServiceManager 是 Binder IPC 通信过程的核心，是上下文的管理者。\n\n## ServiceManager 启动流程\n\n好多文章称 ServiceManager 是 Binder 驱动的守护进程、大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-1/clipboard_20230323_044300.png)\n\n1. ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。\n2. ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。\n3. ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。\n\n## Binder 通讯过程\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-1/clipboard_20230323_044304.png)\n\n1. 首先，一个进程使用 \u003cstrong\u003eBINDER_SET_CONTEXT_MGR\u003c/strong\u003e 命令通过 Binder 驱动将自己注册成为 ServiceManager；\n2. 各个 Server 通过 Binder 驱动向 ServiceManager 注册 Binder 实体，表明自己可以对外提供服务，这时 Binder 驱动会为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对该节点的引用，并将名字和该引用打包给 ServiceManager，ServiceManager 接收到数据包后将数据包中的名字和引用填入查找表中（svcinfo）。\n3. Client 通过上面 Server 的名字在 Binder 驱动的帮助下从 ServiceManager 中获取到该 Server 对应的 Binder \u003cstrong\u003e引用对象 \u003c/strong\u003eBinderProxy，由于 BinderProxy 同样具有 Server 的能力，因此 Client 可以通过这个引用与真实的 Server 进行交互。\n\n```java\n//获取WindowManager服务引用\nWindowManager wm = (WindowManager)getSystemService(getApplication()\n        .WINDOW_SERVICE);\n```\n\n4. 当 Client 端发送数据到 Server 时，首先通过 BinderProxy 可将请求参数发送给内核，再通过共享内存的方式使用内核方法 copy_from_user() 将参数先拷贝到内核空间，这时的 Client 进入等待状态。而 Server 端（作为数据接收端）与内核共享数据，不再需要拷贝数据，而是通过内存地址空间的偏移量，即可获悉内存地址，从而获取到 Client 发送过来的数据，整个过程只发生一次内存拷贝。\n\n还是 [universus 老师](https://blog.csdn.net/universus) 的图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-1/clipboard_20230323_044308.png)\n\n## \u003cstrong\u003eBinder 机制跨进程原理\u003c/strong\u003e\n\n上文给出了 Binder 的通讯模型，指出了通讯过程的四个角色: Client、Server、ServiceManager 和 Binder 驱动， 但是我们仍然不清楚 Client 具体是如何与 Server 完成通讯的。\n\n假设 Client 进程想要调用 Server 进程的 object 对象的一个方法 add，对于这个跨进程通讯过程，我们来看看 Binder 是如何做的。 （通讯是一个广泛的概念，只要一个进程能调用另外一个进程里面某对象的方法，那么具体要完成什么通讯内容就很容易了。）\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-1/clipboard_20230323_044311.png)\n\n1. 首先，Server 进程要向 SM 注册，告诉自己是谁，自己有什么能力；在这个场景就是 Server 告诉 SM，它叫 zhangsan，它有一个 object 对象，可以执行 add 操作；于是 SM 在表上新增一条记录：zhangsan 这个名字对应进程 Server。\n2. 然后 Client 通过 SM 向上述表中查询：我需要联系一个名字叫做 zhangsan 的进程里面的 object 对象；这时候关键来了：进程之间通信的数据都会经过运行在内核空间里面的驱动，驱动在数据流过的时候做了一点手脚，它并不会给 Client 进程返回一个真正的 object 对象，而是返回一个看起来跟 object 一模一样的代理对象 objectProxy，这个 objectProxy 也有一个 add 方法，但是这个 add 方法没有 Server 进程里面 object 对象的 add 方法那个能力；objectProxy 的 add 只是一个傀儡，它唯一做的事情就是把参数包装然后交给驱动。(这里我们简化了 SM 的流程，见下文)\n3. 但是 Client 进程并不知道驱动返回给它的对象动过手脚，毕竟伪装的太像了，如假包换。Client 开开心心地拿着 objectProxy 对象然后调用 add 方法；我们说过，这个 add 什么也不做，直接把参数做一些包装然后直接转发给 Binder 驱动。\n4. 驱动收到这个消息，发现是这个 objectProxy；一查表就明白了：我之前用 objectProxy 替换了 object 发送给 Client 了，它真正应该要访问的是 object 对象的 add 方法；于是 Binder 驱动通知 Server 进程：\u003cem\u003e调用你的 object 对象的 add 方法，然后把结果发给我\u003c/em\u003e，Sever 进程收到这个消息，照做之后将结果返回驱动，驱动然后把结果返回给 Client 进程；于是整个过程就完成了。\n\n由于驱动返回的 objectProxy 与 Server 进程里面原始的 object 是如此相似，给人感觉好像是\u003cstrong\u003e直接把 Server 进程里面的对象 object 传递到了 Client 进程\u003c/strong\u003e；因此，我们可以说 \u003cstrong\u003eBinder 对象是可以进行跨进程传递的对象。\u003c/strong\u003e\n\n但事实上我们知道，Binder 跨进程传输并不是真的把一个对象传输到了另外一个进程；传输过程好像是 Binder 跨进程穿越的时候，它在一个进程留下了一个真身，在另外一个进程幻化出一个影子（这个影子可以很多个）；Client 进程的操作其实是对于影子的操作，影子利用 Binder 驱动最终让真身完成操作。\n\n理解这一点非常重要，务必仔细体会。另外，Android 系统实现这种机制使用的是\u003cem\u003e代理模式\u003c/em\u003e, 对于 Binder 的访问，如果是在同一个进程（不需要跨进程），那么直接返回原始的 Binder 实体；如果在不同进程，那么就给他一个代理对象（影子）；我们在系统源码以及 AIDL 的生成代码里面可以看到很多这种实现，在下一篇文章中会进行详细分析。\n\n另外我们为了简化整个流程，隐藏了 SM 这一部分驱动进行的操作；实际上，由于 SM 与 Server 通常不在一个进程，Server 进程向 SM 注册的过程也是跨进程通信，驱动也会对这个过程进行暗箱操作：SM 中存在的 Server 端的对象实际上也是代理对象，后面 Client 向 SM 查询的时候，驱动会给 Client 返回另外一个代理对象。Sever 进程的本地对象仅有一个，其他进程所拥有的全部都是它的代理。\n\n## 小结\n\n现在我们可以对 Binder 做个更加全面的定义了：\n\n- 从进程间通信的角度看，Binder 是一种进程间通信的机制；\n- 从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 本地对象；\n- 从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理；\n- 从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象做一点点特殊处理，自动完成代理对象和本地对象之间的转换。\n\n一句话总结就是：\u003cstrong\u003eClient 进程只不过是持有了 Server 端的代理对象；代理对象协助驱动完成了跨进程通信。\u003c/strong\u003e\n\n# 总结\n\n进程隔离虽然使操作系统的安全性和应用程序的稳定性得到了提升，但同时也给 IPC 带来了一定的难度，Android 系统巧妙地应用了 Binder 机制，使得系统得以在存储空间和硬件性能等有限的移动设备上能够流畅地运行。关于 Binder 在应用层的使用和分析，请看下一篇文章内容：[[二、Binder 机制分析——应用篇]]\n\u003cstrong\u003e参考文章\u003c/strong\u003e\n\n[写给 Android 应用工程师的 Binder 原理剖析](https://zhuanlan.zhihu.com/p/35519585)\n\n[Binder 学习指南](https://cloud.tencent.com/developer/article/1329601)\n\n\u003e 如果你对文章内容有疑问或者有不同意见，欢迎留言，我们一同探讨。\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["Binder","IPC","ServiceManager","Framework"]},"/%E4%B8%83View-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90":{"title":"七、View 事件机制分析","content":"不知不觉，系列文章已经更新到第四篇了，从手机电源被按下到 App 被点击再到 UI 呈现在屏幕上，从系统内核到 framework 层再到应用层，期间发生了无数次交互，最终才使得我们五彩斑斓的 View 得于被渲染并出现在我们的眼前。可是，有了这些还不够，用户也是需要跟 App 进行交互的，其中最重要也是最直接的交互方式便是触摸手机屏幕了！\n\n而我们的手指的触摸事件是怎样被一屏幕上的 View 感知的呢？本文将继续基于 Android Nougat 的源码来讲解这个过程。\n\n# 触摸事件的产生\n\n- ab\n- cd\n\n\n有硬件基础的同学应该都知道，计算机（当然包括手机）输入输出设备是通过触发硬件中断来\n\n# 触摸事件的传递\n\nsdlfjsaldf\n\n# 触摸事件的分发\n\nsdfk","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["事件分发","Framework"]},"/%E4%B8%89Handler-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90":{"title":"三、Handler 原理分析","content":"[看完这篇还不明白 Handler 你砍我 - 掘金](https://juejin.cn/post/6866015512192876557)\n\n# 基本使用\n\nAndroid 应用层通常使用 Handler 实现线程之间的消息通讯，Handler 是 Android 消息机制中非常重要的一员。以下分析通过剖析 Handler 的工作原理来深入了解 Android 应用开发过程中最常见也是最实用的消息收发机制。\n\n在分析之前，先回顾一下 Handler 的使用方式：首先，最常用的是子线程往主线程发送消息：\n\n```java\nHandler handler = new Handler() {\n    @Override\n    public void handleMessage(final Message msg) {\n        Log.e(\"gpj\", \"Main thread handler received msg:\" + msg.what);\n    }\n};\n\n//发送Message消息对象\nMessage message = handler.obtainMessage();\nmessage.what = 0;\nmessage.obj = \"Hello\";\nhandler.sendMessage(message);\n\n//发送Runnable对象\nhandler.post(new Runnable() {\n    @Override\n    public void run() {\n        Log.e(\"gpj\", \"Runnable has been called\");\n    }\n});\n\nLog输出：\nMain thread handler received msg:0\nRunnable has been called\n```\n\n如果需要反过来在主线程中往某个子线程发送消息，可以使用如下方法：\n\n```java\npublic class WorkThread extends Thread {\n\n    private Handler mHandler;\n    private Looper mLooper;\n\n    @Override\n    public void run() {\n        Looper.prepare();\n\n        synchronized (this) {\n            mLooper = Looper.myLooper();\n            Log.e(\"gpj\", Thread.currentThread().getName() +\n                 \":Looper prepared\");\n            //通知等待Looper的线程\n            notifyAll();\n        }\n\n        Looper.loop();\n    }\n\n\n    public Handler getWorkHandler() {\n        if (mHandler == null) {\n            mHandler = new Handler(getLooper()) {\n                @Override\n                public void handleMessage(@NonNull Message msg) {\n                    Log.e(\"gpj\", \"WorkThread received msg:\" + msg.what);\n                }\n            };\n        }\n        return mHandler;\n    }\n\n    public Looper getLooper() {\n        synchronized (this) {\n            while (isAlive() \u0026\u0026 mLooper == null) {\n                try {\n                    //等待Looper\n                    Log.e(\"gpj\", Thread.currentThread().getName() + \n                        \":Wait for looper\");\n                    wait();\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n        return mLooper;\n    }\n}\n\n//创建WorkThread线程并运行\nWorkThread workThread = new WorkThread();\nworkThread.start();\n\n//获取WorkThread线程中的Handler\nHandler handler = workThread.getWorkHandler();\n\n//向WorkThread线程发送消息\nMessage msg = handler.obtainMessage();\nmsg.what = 1;\nhandler.sendMessage(msg);\n\nLog输出：\nmain:Wait for looper\nThread-3:Looper prepared\nWorkThread received msg:1\n```\n\n需要注意的是，虽然 WorkThread 线程启动方法 start() 先执行，但是由于线程调度的原因，通过 getWorkHandler() 获取 WorkThread 中的 Handler 时，里面的 getLooper() 方法往往会被更早地执行，因此这里需要加入 wait/notifiy 操作，以确保 Looper 先被创建。\n\n这里会涉及到 Looper、MessageQueue、Message、ThreadLocal 等概念，下面就围绕这几个概念深度分析 Handler 的工作原理。\n\n# ThreadLocal 原理分析\n\n## ThreadLocal 概念和使用方式\n\nThreadLocal——顾名思义，即用于存储线程本地变量的类。通常情况下，普通变量是可以被任何一个线程访问的，而使用 ThreadLocal 创建的变量只能被当前线程访问，其它线程不能访问也不能够对它进行修改。\n\n在实现上，每个使用 ThreadLocal 变量的线程都会初始化一个完全独立的实例副本，当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收。\n\n总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。\n\n```java\npublic static void main(String[] args) {\n    ThreadLocal\u003cString\u003e threadLocal = new ThreadLocal\u003c\u003e();\n    threadLocal.set(\"a\");\n\n    System.out.println(\"Thread:\" + Thread.currentThread().getName() \n        + \":\" + threadLocal.get());\n\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            threadLocal.set(\"b\");\n            System.out.println(\"Thread:\" + Thread.currentThread().getName()\n                + \":\" + threadLocal.get());\n        }\n    }).start();\n\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            threadLocal.set(\"c\");\n            System.out.println(\"Thread:\" + Thread.currentThread().getName() \n                + \":\" + threadLocal.get());\n        }\n    }).start();\n\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n## ThreadLocal 的 set 和 get 方法\n\n首先，查看它的 set 方法源码：\n\n```java\n/**\n * Sets the current thread's copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread's copy of\n *        this thread-local.\n */\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n```\n\nSet 方法可分为三个步骤：\n\n- 首先获取当前线程实例；\n- 利用当前线程作为参数获取一个 ThreadLocalMap 的对象；\n- 如果上述 ThreadLocalMap 对象不为空，则设置值，否则创建这个 ThreadLocalMap 对象并设置值。\n\n获取 ThreadLocalMap 的 getMap 方法如下：\n\n```java\n/**\n * Get the map associated with a ThreadLocal. Overridden in\n * InheritableThreadLocal.\n *\n * @param  t the current thread\n * @return the map\n */\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\nthreadLocals 是 Thread 类的一个成员变量：\n\n```java\npulbic class Thread implements Runnable {\n    ...\n    /* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n    ...\n}\n```\n\n前面的 set 方法中，如果 ThreadLocalMap 对象未创建，则新建 ThreadLocalMap 对象，并设置初始值。createMap 方法如下：\n\n```java\n/**\n * Create the map associated with a ThreadLocal. Overridden in\n * InheritableThreadLocal.\n *\n * @param t the current thread\n * @param firstValue value for the initial entry of the map\n */\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n\n相应地，它的 get 方法就是获取当前线程的 ThreadLocalMap 对象，并根据 Key 获取对应的 Value：\n\n```java\n/**\n * Returns the value in the current thread's copy of this\n * thread-local variable.  If the variable has no value for the\n * current thread, it is first initialized to the value returned\n * by an invocation of the {@link #initialValue} method.\n *\n * @return the current thread's value of this thread-local\n */\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n```\n\n## 关于内存泄漏\n\n有人分析 ThreadLocal 将会导致内存泄漏，理由如下：\n\n- 首先 ThreadLocal 实例被线程的 ThreadLocalMap 实例持有，也可以看成被线程持有\n- 如果应用使用了线程池，那么之前的线程实例处理完之后出于复用的目的依然存活\n- 所以，ThreadLocal 设定的值被持有，会导致内存泄露\n\n```java\n/**\n * ThreadLocalMap is a customized hash map suitable only for\n * maintaining thread local values. No operations are exported\n * outside of the ThreadLocal class. The class is package private to\n * allow declaration of fields in class Thread.  To help deal with\n * very large and long-lived usages, the hash table entries use\n * WeakReferences for keys. However, since reference queues are not\n * used, stale entries are guaranteed to be removed only when\n * the table starts running out of space.\n */\nstatic class ThreadLocalMap {\n\n    /**\n     * The entries in this hash map extend WeakReference, using\n     * its main ref field as the key (which is always a\n     * ThreadLocal object).  Note that null keys (i.e. entry.get()\n     * == null) mean that the key is no longer referenced, so the\n     * entry can be expunged from table.  Such entries are referred to\n     * as \"stale entries\" in the code that follows.\n     */\n    static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e {\n        /** The value associated with this ThreadLocal. */\n        Object value;\n\n        Entry(ThreadLocal\u003c?\u003e k, Object v) {\n            super(k);\n            value = v;\n        }\n    }\n    ...\n}\n```\n\nThreadLocalMap 的 Key 并不是直接使用 ThreadLocal 实例，而是 ThreadLocal 实例的弱引用。弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。\n\n但是这里仅仅回收作为 Key 的 ThreadLocal 对象，Entry 对象和 Value 并没有回收，ThreadLocalMap 里就可能存在很多 Key 为 null 的 Entry。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。以 get 方法为例，源码如下:\n\n```java\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    return setInitialValue();\n}\n\nprivate Entry getEntry(ThreadLocal\u003c?\u003e key) {\n    int i = key.threadLocalHashCode \u0026 (table.length - 1);\n    Entry e = table[i];\n    if (e != null \u0026\u0026 e.get() == key)\n        return e;\n    else\n        //当前位置没有找到,可能Hash碰撞了\n        return getEntryAfterMiss(key, i, e);\n}\n\nprivate Entry getEntryAfterMiss(ThreadLocal\u003c?\u003e key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    while (e != null) {\n        ThreadLocal\u003c?\u003e k = e.get();\n        if (k == key)\n            //找到了直接返回\n            return e;\n        if (k == null)\n            //检测到有个ThreadLocal对象被回收了,这个时候去清理后面所有Key为null的Entry\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n\n从源码中可以看到，ThreadLocalMap 清理掉 Key 为 null 的 Entry 的时机是根据 ThreadLocal 对象的 hashCode 去获取 Entry 时发生了 hash 碰撞的情况下，并且下一个 Entry 的 Key 为 null 的时候。因为 ThreadLocalMap 的 Entry 和普通 Map 的不太一样，一般的 Map 是一个链表数组，而它的数组每个元素就是一个 Entry，如果出现 Hash 碰撞了就放到数组的下一个位置，因此如果 get 的时候发现没有碰撞可以认为当前 Map 中的元素还不多，一旦检测到碰撞了并且下一个 Entry 的 Key 被回收了，就调用                             expungeStaleEntry 方法来释放 ThreadLocal 为 null 的那些 Entry，进一步避免了内存泄露。\n\n```java\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal\u003c?\u003e k = e.get();\n        if (k == null) {\n            //清理key为null的entry\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode \u0026 (len - 1);\n            //hashCode发生了变化,重新放置entry\n            if (h != i) {\n                tab[i] = null;\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n那只如果在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下，还是有可能会出现内存泄漏的情况。因此，强烈建议回收自定义的 ThreadLocal 变量，尤其在线程池场景下，因为线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。 并且尽量在代理中使用 try-finally 块进行回收：\n\n```java\nobjectThreadLocal.set(userInfo); \ntry {\n    ... \n} finally {\n    objectThreadLocal.remove(); \n}\n```\n\n## \u003cstrong\u003e使用场景\u003c/strong\u003e\n\n根据以上分析，ThreadLocal 适用于如下两种场景\n\n- 每个线程需要有自己单独的实例\n- 实例需要在多个方法中共享，但不希望被多线程共享\n\n对于第一点，每个线程拥有自己实例，实现它的方式很多。例如可以在线程内部构建一个单独的实例。ThreadLocal 可以以非常方便的形式满足该需求。\n\n对于第二点，可以在满足第一点（每个线程有自己的实例）的条件下，通过方法间引用传递的形式实现。ThreadLocal 使得代码耦合度更低，且实现更优雅。\n\n## 小结\n\nThreadLocal 可以保证每个线程拥有一个变量的副本，实现了线程隔离。在实现上，每个 Thread 类持有有一个 ThreadLocalMap 对象，ThreadLocalMap 保存了该线程拥有的所有 ThreadLocal 对象，并利用弱引用机制避免了 Map 无限增大并避免了内存泄露的问题。\n\n# Message\n\n## 消息对象\n\nMessage 类是应用层消息的载体，是消息机制中的流通对象。它的结构如下：\n\n## 消息池\n\n由于 Handler 消息机制在 framework 层和应用层充当了非常广泛的作用，这也意味着它的使用会非常频繁，因此对于 Message 的创建和回收的优化就显得非常必要。当消息池不为空时，可以直接从消息池中获取 Message 对象，而不是直接创建，提高效率。\n\n```java\nprivate static Message sPool;\nprivate static int sPoolSize = 0;\n\nprivate static final int MAX_POOL_SIZE = 50;\n\nprivate static boolean gCheckRecycle = true;\n```\n\n静态变量 sPool 的 Message，可以认为是消息池的头部，每个 Message 通过 next 成员变量引用下一个 Message 对象；sPoolSize 代表当前消息池的长度；静态变量 MAX_POOL_SIZE 代表消息池的可用大小；消息池的默认大小为 50。\n\n### Message.obtain()\n\n静态方法 obtain() 可用来获取一个消息：\n\n```java\npublic static Message obtain() {\n    synchronized (sPoolSync) {\n        if (sPool != null) {\n            Message m = sPool;\n            sPool = m.next;\n            m.next = null; //从sPool中取出一个Message对象，并消息链表断开\n            m.flags = 0; // 清除in-use flag\n            sPoolSize--; //消息池的可用大小进行减1操作\n            return m;\n        }\n    }\n    return new Message(); // 当消息池为空时，直接创建Message对象\n}\n```\n\n从消息池获取 Message 操作就是把消息池的头部 Message 取走，再将头部指向它的 next。\n\n### recycler()\n\n通过 recycler() 方法可以把不再使用的消息加入消息池：\n\n```java\npublic void recycle() {\n    if (isInUse()) { //判断消息是否正在使用\n        if (gCheckRecycle) { //Android 5.0以后的版本默认为true,之前的版本默认为false.\n            throw new IllegalStateException(\"This message cannot be recycled because it is still in use.\");\n        }\n        return;\n    }\n    recycleUnchecked();\n}\n\n//对于不再使用的消息，加入到消息池\nvoid recycleUnchecked() {\n    //将消息标示位置为IN_USE，并清空消息所有的参数。\n    flags = FLAG_IN_USE;\n    what = 0;\n    arg1 = 0;\n    arg2 = 0;\n    obj = null;\n    replyTo = null;\n    sendingUid = -1;\n    when = 0;\n    target = null;\n    callback = null;\n    data = null;\n    \n    synchronized (sPoolSync) {\n        if (sPoolSize \u003c MAX_POOL_SIZE) { //当消息池没有满时，将Message对象加入消息池\n            next = sPool;\n            sPool = this;\n            sPoolSize++; //消息池的可用大小进行加1操作\n        }\n    }\n}\n```\n\nrecycle() 操作将 Message 加入到消息池的过程，其实就是把 Message 加到消息池的头部。\n\n## setAsynchronous(boolean async)\n\n设置消息类型为同步或者异步：\n\n```java\n/**\n * Sets whether the message is asynchronous, meaning that it is not\n * subject to {@link Looper} synchronization barriers.\n * \u003cp\u003e\n * Certain operations, such as view invalidation, may introduce synchronization\n * barriers into the {@link Looper}'s message queue to prevent subsequent messages\n * from being delivered until some condition is met.  In the case of view invalidation,\n * messages which are posted after a call to {@link android.view.View#invalidate}\n * are suspended by means of a synchronization barrier until the next frame is\n * ready to be drawn.  The synchronization barrier ensures that the invalidation\n * request is completely handled before resuming.\n * \u003c/p\u003e\u003cp\u003e\n * Asynchronous messages are exempt from synchronization barriers.  They typically\n * represent interrupts, input events, and other signals that must be handled independently\n * even while other work has been suspended.\n * \u003c/p\u003e\u003cp\u003e\n * Note that asynchronous messages may be delivered out of order with respect to\n * synchronous messages although they are always delivered in order among themselves.\n * If the relative order of these messages matters then they probably should not be\n * asynchronous in the first place.  Use with caution.\n * \u003c/p\u003e\n *\n * @param async True if the message is asynchronous.\n *\n * @see #isAsynchronous()\n */\npublic void setAsynchronous(boolean async) {\n    if (async) {\n        flags |= FLAG_ASYNCHRONOUS;\n    } else {\n        flags \u0026= ~FLAG_ASYNCHRONOUS;\n    }\n}\n```\n\n# Looper 工作原理分析\n\n## Looper 与 Handler 的关联\n\n通常我们会通过以下构造方法创建 Handler 对象：\n\n```java\n@Deprecated\npublic Handler() {\n    this(null, false);\n}\n\n@Deprecated\npublic Handler(@Nullable Callback callback) {\n    this(callback, false);\n}\n\npublic Handler(@Nullable Callback callback, boolean async) {\n    if (FIND_POTENTIAL_LEAKS) {\n        final Class\u003c? extends Handler\u003e klass = getClass();\n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) \u0026\u0026\n                (klass.getModifiers() \u0026 Modifier.STATIC) == 0) {\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                klass.getCanonicalName());\n        }\n    }\n\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()\n                    + \" that has not called Looper.prepare()\");\n    }\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n\npublic Handler(@NonNull Looper looper) {\n    this(looper, null, false);\n}\n\npublic Handler(@NonNull Looper looper, @Nullable Callback callback) {\n    this(looper, callback, false);\n}\n\n@UnsupportedAppUsage\npublic Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) {\n    mLooper = looper;\n    mQueue = looper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n\n可以看到，前面两个 Handler 已被标记为废弃，因为的创建必需依赖与 Looper，如果 Handler 被创建于没有 Looper 的线程中将会抛出异常，因此推荐使用后面两种构造方法。\n\n在构造方法中，成员变量 mQueue 将被赋值为 Looper 中的 MessageQueue 示例；mCallback 则被赋值为调用者传入的对象；mAsynchronous 默认为 false（@UnsupportedAppUsage 标记的构造方法不能直接被外面调用）。\n\n## Looper 的创建与获取\n\n那么 Looper 怎么获取呢？如果要在主线程或者当前线程中接收消息，可以这样创建：\n\n```java\nHandler handler = new Handler(Looper.getMainLooper()) {\n    @Override\n    public void handleMessage(final Message msg) {\n        ...\n    }\n};\n\nHandler handler = new Handler(Looper.myLooper()) {\n    @Override\n    public void handleMessage(final Message msg) {\n        ...\n    }\n};\n```\n\n当然，也可以像本文开头部分示例的方式一样，传入一个在其它线程中创建的 Looper，表示该 Handler 将在对应的线程中处理消息。那么如何为一个线程创建 Looper 呢？只需要调用 Looper.prepare() 方法即可：\n\n```java\npublic class WorkThread extends Thread {\n\n    private Handler mHandler;\n\n    @Override\n    public void run() {\n        Looper.prepare();\n\n        mHandler = new Handler(Looper.myLooper());\n\n        Looper.loop();\n    }\n    \n    ...\n}\n```\n\nprepare() 是 Looper 类的一个静态方法：\n\n```java\npublic static void prepare() {\n    prepare(true);\n}\n\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n\nprivate Looper(boolean quitAllowed) {\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\n\n可以看到，这里的 Looper 来自于 ThreadLocal 中，并且每个线程最多只能拥有一个 Looper 对象。结合前面的分析可知，这个 Looper 对象只属于当前线程。在创建 Looper 的同时，mQueue 也将被初始化，quitAllowed 表示是否可以退出，意味着每个线程也最多拥有一个 MessageQueue。\n\n## Looper.loop()\n\n接着看 Looper 的 loop() 方法，提取关键部分后的代码如下：\n\n```java\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    ...\n    final MessageQueue queue = me.mQueue;\n    ...\n    for (;;) {\n        // 不断获取Message消息\n        Message msg = queue.next(); // might block\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            return;\n        }\n        ...\n        try {\n            msg.target.dispatchMessage(msg);\n            ...\n        } finally {\n            ...\n        }\n        ...\n        msg.recycleUnchecked();\n    }\n}\n```\n\n可以看到，loop() 方法是一个死循环，这个死循环唯一的退出途径就是 queue.next() 方法返回 null 的时候。循环里面会不断调用 MessageQueue.next() 方法来获取 Message 对象，next() 方法在没有返回 Message 时方法将被阻塞。Looper 处理 Message 的方式是调用它的 target 对象的 dispatchMessage 方法，并把 Message 对象作为参数传进去。\n\n## MessageQueue 原理分析\n\nMessageQueue 字面意义为消息队列，但其实它的结构是一个单向链表。它的 next() 和 enqueueMessage() 方法分别对应该链表的获取和添加元素操作。为了方便理解，下面仍然称之为消息队列。\n\n### MessageQueue 的创建\n\nMessageQueue 只有一个构造方法：\n\n```java\nprivate long mPtr; // used by native code\n\nMessageQueue(boolean quitAllowed) {\n    mQuitAllowed = quitAllowed;\n    // 初始化消息队列，mPtr是供native代码调用的一个变量    \n    mPtr = nativeInit();\n}\n```\n\n### next() 方法分析\n\nMessageQueue 的 next() 方法如下：\n\n```java\n@UnsupportedAppUsage\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n    final long ptr = mPtr;\n    if (ptr == 0) {//表示当MessageQueue已经退出，则直接返回\n        return null;\n    }\n\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n        //阻塞操作，等待时长nextPollTimeoutMillis后，或者消息队列被唤醒，都会返回\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n            if (msg != null \u0026\u0026 msg.target == null) {\n                // 碰到同步屏障，则跳过同步消息，只取出异步消息，并且不会移除屏障\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null \u0026\u0026 !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                if (now \u003c msg.when) {\n                    // 当前Message的触发事件在当前时间时间之后，则继续等待\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // 将目标Message对象从队列中移除，并返回\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                    // 设置消息的使用状态：flags |= FLAG_IN_USE\n                    msg.markInUse();\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n            // Process the quit message now that all pending messages have been handled.\n            if (mQuitting) {\n                dispose();\n                return null;\n            }\n\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            if (pendingIdleHandlerCount \u003c 0\n                    \u0026\u0026 (mMessages == null || now \u003c mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount \u003c= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                mBlocked = true;\n                continue;\n            }\n\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        for (int i = 0; i \u003c pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(TAG, \"IdleHandler threw exception\", t);\n            }\n\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // Reset the idle handler count to 0 so we do not run them again.\n        pendingIdleHandlerCount = 0;\n\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n\n这里也同样创建了一个死循环，nativePollOnce() 方法在 JNI 层会调用到内核中的 epoll_wait() 方法，这是阻塞方法（阻塞时线程休眠，释放 CPU 资源），用于等待事件发生或者超时，当被事件到来或者等待 nextPollTimeoutMillis（时间） 后会被唤醒。因此，这里的 `for(;;)` 并不会造成无限循环。\n\n\u003e 当 nextPollTimeoutMillis = -1 时，表示消息队列中无消息，会一直等待；当 nextPollTimeoutMillis = 0 时会直接返回。\n\nmsg.target == null 表示队列头部的消息是一个同步屏障，此时只会处理异步消息，直到同步屏障被移除。文章后面会补充更详细的关于同步屏障的理解。\n\n这里后半部分代码中，当处于空闲时，往往会执行 IdleHandler 中的方法。当 nativePollOnce() 返回后， next() 从 mMessages 中提取一个消息。\n\n### enqueueMessage() 方法分析\n\n再来看 enqueueMessage() 方法：\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n    // 普通Message必须设置target\n    if (msg.target == null) {\n        throw new IllegalArgumentException(\"Message must have a target.\");\n    }\n\n    synchronized (this) {\n        // 如果Message具有FLAG_IN_USE标记，则不允许再使用\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        // MessageQueue正在退出时，需要回收该Message并加入到消息池，返回false\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            Log.w(TAG, e.getMessage(), e);\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;// 头节点\n        boolean needWake; // 需要唤醒MessageQueue\n        if (p == null || when == 0 || when \u003c p.when) {\n            // p == null表示MessageQueue为空；when == 0表示msg为插队消息；\n            // when \u003c p.when表示该消息触发时间是最早的（mMessages为链表头结点）\n            // 这三种情况都把msg加入到队列头部\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            // 将消息按时间顺序插入到MessageQueue。一般不需要唤醒MessageQueue，\n            // 除非最头部存在barrier，并且同时Message是队列中最早的异步消息。\n            needWake = mBlocked \u0026\u0026 p.target == null \u0026\u0026 msg.isAsynchronous();\n            Message prev;\n            // 遍历队列，对比when，找到合适的位置并插入\n            for (;;) {\n                prev = p;\n                p = p.next;\n                // 如果到达队尾或者when在当前结点之前，表示找到插入位置\n                if (p == null || when \u003c p.when) {\n                    break;\n                }\n                // 当前结点也是异步消息，则不需要唤醒了\n                if (needWake \u0026\u0026 p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            //插入链表\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n```\n\n根据以上分析可知，MessageQueue 是按照 Message 触发时间的先后顺序排列的，队列头部的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头部开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。\n\n消息插入一般不需要唤醒 MessageQueue，但是在 MessageQueue 当前处于阻塞状态的大前提下，消息的插入位置为 MessageQueue 头部，或者最头部存在同步障碍时 Message 是队列中最早的异步消息，意味着当前消息需要马上处理，插入后就需要唤醒阻塞中的 MessageQueue。\n\n当需要唤醒时，通过 nativeWake() 方法在 JNI 层会最终调用到内核中的调用 Looper::wake() 方法向管道 mWakeEventfd 写入字符，此时会唤醒 MessageQueue.next() 方法 nativePollOnce() 处的代码继续向下执行。\n\n### removeMessage() 方法分析\n\n```java\nvoid removeMessages(Handler h, int what, Object object) {\n    if (h == null) {\n        return;\n    }\n\n    synchronized (this) {\n        Message p = mMessages;\n\n        // Remove all messages at front.\n        while (p != null \u0026\u0026 p.target == h \u0026\u0026 p.what == what\n               \u0026\u0026 (object == null || p.obj == object)) {\n            Message n = p.next;\n            mMessages = n;\n            p.recycleUnchecked();\n            p = n;\n        }\n\n        // Remove all messages after front.\n        while (p != null) {\n            Message n = p.next;\n            if (n != null) {\n                if (n.target == h \u0026\u0026 n.what == what\n                    \u0026\u0026 (object == null || n.obj == object)) {\n                    Message nn = n.next;\n                    n.recycleUnchecked();\n                    p.next = nn;\n                    continue;\n                }\n            }\n            p = n;\n        }\n    }\n}\n```\n\n这个移除消息的方法，采用了两个 while 循环，第一个循环是从队头开始，移除符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。\n\n### 同步屏障 SyncBarrier、同步消息和异步消息\n\n默认情况下，我们向某个 Handler 发送的消息默认都是异步消息。试想一下，如果某些时候想要让消息快速地发送到指定线程，但是如果该线程的 MessageQueue 中积累了大量未处理消息，则达不到预期的效果。\n\n因此 Handler 体系提供了一套同步屏障机制，通过区分同步消息和异步消息，让某些特殊的消息得以更快被执行的机制。这也从前面 next() 方法分析中得到验证。\n\n那么如何设置和取消一个同步屏障呢？方法就是调用它的 postSyncBarrier() 和 removeSyncBarrier () 方法：\n\n```java\n@UnsupportedAppUsage\n@TestApi\npublic int postSyncBarrier() {\n    return postSyncBarrier(SystemClock.uptimeMillis());\n}\n\nprivate int postSyncBarrier(long when) {\n    // Enqueue a new sync barrier token.\n    // We don't need to wake the queue because the purpose of a barrier is to stall it.\n    synchronized (this) {\n        final int token = mNextBarrierToken++;\n        final Message msg = Message.obtain();\n        msg.markInUse();\n        msg.when = when;\n        msg.arg1 = token;\n\n        Message prev = null;\n        Message p = mMessages;\n        if (when != 0) {\n            while (p != null \u0026\u0026 p.when \u003c= when) {\n                prev = p;\n                p = p.next;\n            }\n        }\n        if (prev != null) { // invariant: p == prev.next\n            msg.next = p;\n            prev.next = msg;\n        } else {\n            msg.next = p;\n            mMessages = msg;\n        }\n        return token;\n    }\n}\n\npublic void removeSyncBarrier(int token) {\n    // Remove a sync barrier token from the queue.\n    // If the queue is no longer stalled by a barrier then wake it.\n    synchronized (this) {\n        Message prev = null;\n        Message p = mMessages;\n        while (p != null \u0026\u0026 (p.target != null || p.arg1 != token)) {\n            prev = p;\n            p = p.next;\n        }\n        if (p == null) {\n            throw new IllegalStateException(\"The specified message queue synchronization \"\n                    + \" barrier token has not been posted or has already been removed.\");\n        }\n        final boolean needWake;\n        if (prev != null) {\n            prev.next = p.next;\n            needWake = false;\n        } else {\n            mMessages = p.next;\n            needWake = mMessages == null || mMessages.target != null;\n        }\n        p.recycleUnchecked();\n\n        // If the loop is quitting then it is already awake.\n        // We can assume mPtr != 0 when mQuitting is false.\n        if (needWake \u0026\u0026 !mQuitting) {\n            nativeWake(mPtr);\n        }\n    }\n}\n```\n\n前面提到过，普通 Message 必须设置一个 target，对于特殊的 Message 是没有 target 的。 这个消息的价值就是用于拦截同步消息，所以并不会唤醒 Looper。\n\npostSyncBarrier 方法会返回一个 int 类型的 token，调用 removeSyncBarrier 并传入这个 token 则可以移除同步屏障。\n\n这两个方法都被标记了 @UnsupportedAppUsage 注解，因此普通开发者无法直接调用。那么它在什么时候会被调用呢？Android 应用框架中为了更快的响应 UI 刷新事件，在 ViewRootImpl.scheduleTraversals 中使用了同步屏障：\n\n```java\nvoid scheduleTraversals() {\n    if (!mTraversalScheduled) {\n        mTraversalScheduled = true;\n        // 设置同步障碍，暂停处理后面的同步消息\n        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n        // 在下一帧到来的时候执行 mTraversalRunnable\n        mChoreographer.postCallback(\n                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n        ...\n    }\n}\n\nfinal TraversalRunnable mTraversalRunnable = new TraversalRunnable();\n\nfinal class TraversalRunnable implements Runnable {\n    @Override\n    public void run() {\n        doTraversal();\n    }\n}\n\nvoid doTraversal() {\n    if (mTraversalScheduled) {\n        mTraversalScheduled = false;\n        // 移除同步障碍\n        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n        ...\n        // 正式进入 View 绘制流程\n        performTraversals();\n         ...\n    }\n}\n```\n\npostCallback 方法跟踪：\n\n```java\n@UnsupportedAppUsage\n@TestApi\npublic void postCallback(int callbackType, Runnable action, Object token) {\n    postCallbackDelayed(callbackType, action, token, 0);\n}\n\n@UnsupportedAppUsage\n@TestApi\npublic void postCallbackDelayed(int callbackType,\n        Runnable action, Object token, long delayMillis) {\n    if (action == null) {\n        throw new IllegalArgumentException(\"action must not be null\");\n    }\n    if (callbackType \u003c 0 || callbackType \u003e CALLBACK_LAST) {\n        throw new IllegalArgumentException(\"callbackType is invalid\");\n    }\n\n    postCallbackDelayedInternal(callbackType, action, token, delayMillis);\n}\n\nprivate void postCallbackDelayedInternal(int callbackType,\n        Object action, Object token, long delayMillis) {\n    if (DEBUG_FRAMES) {\n        Log.d(TAG, \"PostCallback: type=\" + callbackType\n                + \", action=\" + action + \", token=\" + token\n                + \", delayMillis=\" + delayMillis);\n    }\n\n    synchronized (mLock) {\n        final long now = SystemClock.uptimeMillis();\n        final long dueTime = now + delayMillis;\n        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);\n\n        if (dueTime \u003c= now) {\n            scheduleFrameLocked(now);\n        } else {\n            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);\n            msg.arg1 = callbackType;\n            // 将消息类型设置为异步\n            msg.setAsynchronous(true);\n            mHandler.sendMessageAtTime(msg, dueTime);\n        }\n    }\n}\n```\n\n可以看到，最后通过 setAsynchronous() 方法可以将消息设置成异步消息。\n\n通过设置同步障碍，并且发送异步消息，就可以确保 mTraversalRunnable 优先被执行，mTraversalRunnable 最终会调用 performTraversals 方法触发 View 树的 measure、layout 和 draw 等操作，因此使用同步屏障可以防止 UI 显示出现卡顿。\n\n这里也可以看到，调用 performTraversals 方法之前会将同步障碍移除掉。\n\n综合以上分析可知，同步消息必须配合同步障碍才能达到屏蔽异步消息的作用，也就是说，如果没有设置同步屏障，同步消息与异步消息在 Handler 体系中没有任何区别。\n\n# Handler 发送和接收消息\n\n前面的分析中，Looper 在 loop() 方法中获取到每一个 Message 对象后，会调用它的 target 对象的 dispatchMessage() 方法，并把 Message 本身作为参数传入。那么 这个 target 对象又是何方神圣？\n\n## 发送 Message\n\n再来看 Handler 发送消息的过程：\n\n```java\nMessage message = handler.obtainMessage();\nmessage.what = 0;\nmessage.obj = \"Hello\";\nhandler.sendMessage(message);\n```\n\n这里会将包装好的 Message 对象传入 sendMessage 方法中：\n\n```java\npublic final boolean sendMessage(@NonNull Message msg) {\n    return sendMessageDelayed(msg, 0);\n}\n\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n    if (delayMillis \u003c 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\npublic final boolean sendEmptyMessage(int what){\n    return sendEmptyMessageDelayed(what, 0);\n}\n\npublic final boolean sendEmptyMessageDelayed(int what, long delayMillis) {\n    Message msg = Message.obtain();\n    msg.what = what;\n    return sendMessageDelayed(msg, delayMillis);\n}\n\npublic final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) {\n    Message msg = Message.obtain();\n    msg.what = what;\n    return sendMessageAtTime(msg, uptimeMillis);\n}\n```\n\n可以看到，无论是发送普通消息还是延时消息，最终都会调用到 enqueueMessage() 方法。它们之间的关系如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Handler/clipboard_20230323_044956.png)\n\nenqueueMessage() 方法源码如下：\n\n```java\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, \n        @NonNull Message msg, long uptimeMillis) {\n    msg.target = this;\n    msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n\n可以看到，每个消息的 target 都被赋值为 Handler 本身了。这里传进来的 MessageQueue 就是 Handler 中的 mQueue 成员变量，它来自 Looper.mQueue。enqueueMessage() 方法就是将封装好的消息加入到 MessageQueue 中。\n\n## 接收 Message\n\n回过头来看 Handler 的 dispatchMessage() 方法：\n\n```java\npublic void dispatchMessage(@NonNull Message msg) {\n    if (msg.callback != null) {\n        handleCallback(msg);\n    } else {\n        if (mCallback != null) {\n            if (mCallback.handleMessage(msg)) {\n                return;\n            }\n        }\n        handleMessage(msg);\n    }\n}\n```\n\n可以看到，这里一共有三种不同的途径处理 Message。\n\n### msg.callback.run()\n\n```java\nif (msg.callback != null) {\n    handleCallback(msg);\n}\n\nprivate static void handleCallback(Message message) {\n    message.callback.run();\n}\n```\n\n首先，会判断 Message 的 callback 是否为空，如果不为空则会调用它的 run 方法。那什么时候这个 callback 会被赋值呢？原来 Handler 还有另外一种打开方式：\n\n```java\npublic final boolean post(@NonNull Runnable r) {\n   return  sendMessageDelayed(getPostMessage(r), 0);\n}\n\npublic final boolean postAtTime(@NonNull Runnable r, long uptimeMillis) {\n    return sendMessageAtTime(getPostMessage(r), uptimeMillis);\n}\n\npublic final boolean postAtTime(\n        @NonNull Runnable r, @Nullable Object token, long uptimeMillis) {\n    return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);\n}\n\npublic final boolean postDelayed(@NonNull Runnable r, long delayMillis) {\n    return sendMessageDelayed(getPostMessage(r), delayMillis);\n}\n\npublic final boolean postDelayed(Runnable r, int what, long delayMillis) {\n    return sendMessageDelayed(getPostMessage(r).setWhat(what), delayMillis);\n}\n\npublic final boolean postDelayed(\n        @NonNull Runnable r, @Nullable Object token, long delayMillis) {\n    return sendMessageDelayed(getPostMessage(r, token), delayMillis);\n}\n\nprivate static Message getPostMessage(Runnable r) {\n    Message m = Message.obtain();\n    m.callback = r;\n    return m;\n}\n```\n\n通过传入一个 Runnable 对象，最终也会被封装成一个 Message 对象，而这个 Message 对象的 callback 就是传入的 Runnable。\n\n### mCallback.handleMessage(msg)\n\n```java\nif (mCallback != null) {\n    if (mCallback.handleMessage(msg)) {\n        return;\n    }\n}\n```\n\n在 msg.callback == null 的情况下，如果 mCallback != null 则调用 mCallback.handleMessage(msg)。这个 mCallback 对象又是从何而来？答案在 Handler 的创建过程：\n\n```typescript\npublic Handler(@NonNull Looper looper) {\n    this(looper, null, false);\n}\n\npublic Handler(@NonNull Looper looper, @Nullable Callback callback) {\n    this(looper, callback, false);\n}\n\n@UnsupportedAppUsage\npublic Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) {\n    mLooper = looper;\n    mQueue = looper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n\npublic interface Callback {\n    /**\n     * @param msg A {@link android.os.Message Message} object\n     * @return True if no further handling is desired\n     */\n    boolean handleMessage(@NonNull Message msg);\n}\n```\n\n需要注意的是，如果 mCallback.handleMessage(msg) 返回了 true，那么代表消息处理完成，直接返回；如果返回 false，则会继续调用 handleMessage(msg) 方法。\n\n### handleMessage(msg)\n\n```java\n/**\n * Subclasses must implement this to receive messages.\n */\npublic void handleMessage(@NonNull Message msg) {\n}\n```\n\n从注释中可以看出，Handler 的子类必须实现这个方法才能接收 Message，因此这种方式是提供给它的子类接收并处理消息的。\n\n# 总结\n\n\u003cstrong\u003eMessage:\u003c/strong\u003e 消息载体，用于携带消息参数、消息目标等。可以通过它的 obtain() 和 recycle() 方法进行复用和回收消息。\n\n\u003cstrong\u003eMessageQueue:\u003c/strong\u003e 消息队列，用来存放 Handler 发送过来的 Message，按照 when 字段进行优先级排序，其本身是一个以 Message 串联起来的一个单链表。enqueueMessage() 和 next() 方法是生产、消费关系，next() 在队列中没有消息或者消息处理时间未到时会进行阻塞；enqueueMessage() 方法会将消息插入到队列指定位置，并且如果当前消息需要马上处理的时候会唤醒阻塞中的队列。\n\n\u003cstrong\u003eHandler:\u003c/strong\u003e 调用目标线程的 MessageQueue 的 enqueueMessage() 方法发送消息，并且处理接收到的消息。\n\n\u003cstrong\u003eLooper:\u003c/strong\u003e 轮询调用 MessageQueue 的 next() 方法获取 Message，并调用目标 Handler 进行处理。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Handler/clipboard_20230323_045002.png)\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["Handler","Framework","Message","消息机制","ThreadLocal"]},"/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86":{"title":"二叉树遍历","content":"\n```Python\nimport sys\nimport io\nimport json\nfrom typing import List\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def preOrderIterate(self, root: TreeNode) -\u003e List[int]:\n        res = []\n        if not root:\n            return res\n        \n        stack = []\n        node = root\n\n        while node or stack:\n            if node:\n                res.append(node.val)\n                stack.append(node)\n                node = node.left\n            else:\n                node = stack.pop()\n                node = node.right\n\n        return res\n\n    def preOrderIterate2(self, root: TreeNode) -\u003e List[int]:\n        res = []\n        if not root:\n            return res\n        \n        stack = [root]\n\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n\n        return res\n\n    def inOrderIterate(self, root: TreeNode) -\u003e List[int]:\n        res = []\n        if not root:\n            return res\n        \n        stack = []\n        node = root\n\n        while node or stack:\n            if node:\n                stack.append(node)\n                node = node.left\n            else:\n                node = stack.pop()\n                res.append(node.val)\n                node = node.right\n\n        return res\n\n    def postOrderIterate(self, root: TreeNode) -\u003e List[int]:\n        if not root:\n            return list()\n        \n        res = list()\n        stack = list()\n        prev = None\n\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            if not root.right or root.right == prev:\n                res.append(root.val)\n                prev = root\n                root = None\n            else:\n                stack.append(root)\n                root = root.right\n        \n        return res\n\n    def levelOrderIterate(self, root: TreeNode) -\u003e List[int]:\n        res = []\n        if not root:\n            return res\n\n        queue = [root]\n\n        while queue:\n            node = queue.pop(0)\n            res.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\n        return res\n\ndef stringToTreeNode(input):\n    input = input.strip()\n    input = input[1:-1]\n    if not input:\n        return None\n\n    inputValues = [s.strip() for s in input.split(',')]\n    root = TreeNode(int(inputValues[0]))\n    nodeQueue = [root]\n    front = 0\n    index = 1\n    while index \u003c len(inputValues):\n        node = nodeQueue[front]\n        front = front + 1\n\n        item = inputValues[index]\n        index = index + 1\n        if item != \"null\":\n            leftNumber = int(item)\n            node.left = TreeNode(leftNumber)\n            nodeQueue.append(node.left)\n\n        if index \u003e= len(inputValues):\n            break\n\n        item = inputValues[index]\n        index = index + 1\n        if item != \"null\":\n            rightNumber = int(item)\n            node.right = TreeNode(rightNumber)\n            nodeQueue.append(node.right)\n    return root\n\ndef integerListToString(nums, len_of_list=None):\n    if not len_of_list:\n        len_of_list = len(nums)\n    return json.dumps(nums[:len_of_list])\n\ndef main():\n    def readlines():\n        for line in io.TextIOWrapper(sys.stdin.buffer, encoding='utf-8'):\n            yield line.strip('\\n')\n\n    lines = readlines()\n    while True:\n        try:\n            line = next(lines)\n            root = stringToTreeNode(line)\n            \n            ret = Solution().inOrderIterate(root)\n\n            out = integerListToString(ret)\n            print(out)\n        except StopIteration:\n            break\n\nif __name__ == '__main__':\n    main()\n```","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["二叉树"]},"/%E4%BA%8CBinder-%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90%E5%BA%94%E7%94%A8%E7%AF%87":{"title":"二、Binder 机制分析——应用篇","content":"\nAIDL 是 Android Interface Definition Language（Android 接口定义语言）的缩写，它是 Android 进程间通信的接口语言。由于 Android 系统的 Linux 内核采用了进程隔离机制，使得不同的应用程序运行在不同的进程当中，有时候两个应用之间需要传递或者共享某些数据，就需要进行进程间的通信讯。\n\n在上一篇文章——[[一、Binder 机制分析——概念篇]]中我们已经分析了使用 Binder 机制的原因以及分析了 Binder 机制，而 AIDL 也正是运用了 Binder 机制来实现进程间的通讯，本章我们将继续从 AIDL 的使用过程体验 Binder 在应用层的使用和原理。\n\n# AIDL 使用步骤\n\n## 1、创建 .aidl 接口文件\n\n首先在 aidl 文件夹这种新建文件并且命名为 IMyService.aidl\u003cem\u003e，\u003c/em\u003e并且按照以下格式添加方法。此举是为了声明作为 Server 端的远程 Service 具有哪些能力：\n\n```java\npackage com.me.guanpj.binder;\n\nimport com.me.guanpj.binder.User;\n// Declare any non-default types here with import statements\n\ninterface IMyService {\n    void addUser(in User user);\n\n    List\u003cUser\u003e getUserList();\n}\n```\n\n对于对象引用，还需要引入实体类 User.aidl\u003cem\u003e：\u003c/em\u003e\n\n```java\n// User.aidl\npackage com.me.guanpj.binder;\n\n// Declare any non-default types here with import statements\n\nparcelable User;\n```\n\n跨进程传输的 User 实体必须实现 Parcelable 接口：\n\n```java\npublic class User implements Parcelable {\n    public int id;\n    public String name;\n\n    public User() {}\n\n    public User(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    protected User(Parcel in) {\n        id = in.readInt();\n        name = in.readString();\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeInt(id);\n        dest.writeString(name);\n    }\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    public static final Creator\u003cUser\u003e CREATOR = new Creator\u003cUser\u003e() {\n        @Override\n        public User createFromParcel(Parcel in) {\n            return new User(in);\n        }\n\n        @Override\n        public User[] newArray(int size) {\n            return new User[size];\n        }\n    };\n}\n```\n\n在创建 IMyService.aidl 文件并且 ReBuild 项目之后，IDE 会自动在 build 目录生成一个与 IMyService.java 接口类：\n\n```java\npackage com.me.guanpj.binder;\n// Declare any non-default types here with import statements\n\npublic interface IMyService extends android.os.IInterface\n{\n    /** Local-side IPC implementation stub class. */\n    public static abstract class Stub extends android.os.Binder implements com.me.guanpj.binder.IMyService\n    {\n        private static final java.lang.String DESCRIPTOR = \"com.me.guanpj.binder.IMyService\";\n        /** Construct the stub at attach it to the interface. */\n        public Stub()\n        {\n            this.attachInterface(this, DESCRIPTOR);\n        }\n        /**\n         * Cast an IBinder object into an com.me.guanpj.binder.IMyService interface,\n         * generating a proxy if needed.\n         */\n        public static com.me.guanpj.binder.IMyService asInterface(android.os.IBinder obj)\n        {\n            if ((obj==null)) {\n                return null;\n            }\n            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n            if (((iin!=null)\u0026\u0026(iin instanceof com.me.guanpj.binder.IMyService))) {\n                return ((com.me.guanpj.binder.IMyService)iin);\n            }\n            return new com.me.guanpj.binder.IMyService.Stub.Proxy(obj);\n        }\n        @Override public android.os.IBinder asBinder()\n        {\n            return this;\n        }\n        @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException\n        {\n            java.lang.String descriptor = DESCRIPTOR;\n            switch (code)\n            {\n                case INTERFACE_TRANSACTION:\n                {\n                    reply.writeString(descriptor);\n                    return true;\n                }\n                case TRANSACTION_addUser:\n                {\n                    data.enforceInterface(descriptor);\n                    com.me.guanpj.binder.User _arg0;\n                    if ((0!=data.readInt())) {\n                        _arg0 = com.me.guanpj.binder.User.CREATOR.createFromParcel(data);\n                    }\n                    else {\n                        _arg0 = null;\n                    }\n                    this.addUser(_arg0);\n                    reply.writeNoException();\n                    return true;\n                }\n                case TRANSACTION_getUserList:\n                {\n                    data.enforceInterface(descriptor);\n                    java.util.List\u003ccom.me.guanpj.binder.User\u003e _result = this.getUserList();\n                    reply.writeNoException();\n                    reply.writeTypedList(_result);\n                    return true;\n                }\n                default:\n                {\n                    return super.onTransact(code, data, reply, flags);\n                }\n            }\n        }\n        private static class Proxy implements com.me.guanpj.binder.IMyService\n        {\n            private android.os.IBinder mRemote;\n            Proxy(android.os.IBinder remote)\n            {\n                mRemote = remote;\n            }\n            @Override public android.os.IBinder asBinder()\n            {\n                return mRemote;\n            }\n            public java.lang.String getInterfaceDescriptor()\n            {\n                return DESCRIPTOR;\n            }\n            @Override public void addUser(com.me.guanpj.binder.User user) throws android.os.RemoteException\n            {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    if ((user!=null)) {\n                        _data.writeInt(1);\n                        user.writeToParcel(_data, 0);\n                    }\n                    else {\n                        _data.writeInt(0);\n                    }\n                    mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, 0);\n                    _reply.readException();\n                }\n                finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n            }\n            @Override public java.util.List\u003ccom.me.guanpj.binder.User\u003e getUserList() throws android.os.RemoteException\n            {\n                android.os.Parcel _data = android.os.Parcel.obtain();\n                android.os.Parcel _reply = android.os.Parcel.obtain();\n                java.util.List\u003ccom.me.guanpj.binder.User\u003e _result;\n                try {\n                    _data.writeInterfaceToken(DESCRIPTOR);\n                    mRemote.transact(Stub.TRANSACTION_getUserList, _data, _reply, 0);\n                    _reply.readException();\n                    _result = _reply.createTypedArrayList(com.me.guanpj.binder.User.CREATOR);\n                }\n                finally {\n                    _reply.recycle();\n                    _data.recycle();\n                }\n                return _result;\n            }\n        }\n        static final int TRANSACTION_addUser = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n        static final int TRANSACTION_getUserList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);\n    }\n    public void addUser(com.me.guanpj.binder.User user) throws android.os.RemoteException;\n    public java.util.List\u003ccom.me.guanpj.binder.User\u003e getUserList() throws android.os.RemoteException;\n}\n```\n\n它继承了 IInterface 接口，IMyService 接口只有一个静态抽象类 Stub，它继承自 Binder 并实现了 IMyService 接口。\n\nStub 里面也有一个静态内部类 Proxy，它也继承了 IMyService（是不是有点乱，乱就对了，我也很乱）。如此嵌套是为了避免有多个 .aidl 文件的时候自动生成这些类的类名不会重复。\n\n为了提高代码可读性，这里将生成的 Stub 内部类单独抽取到文件 Stub.java 文件中，并在关键方法上添加了注释和 Log：\n\n```java\npublic abstract class Stub extends Binder implements IMyService {\n    /**\n     * Construct the mLocalStub at attach it to the interface.\n     */\n    public Stub() {\n        this.attachInterface(this, DESCRIPTOR);\n    }\n\n    /**\n     * 根据 Binder 本地对象或者代理对象返回 IMyServcie 接口\n     */\n    public static IMyService asInterface(android.os.IBinder obj) {\n        if ((obj == null)) {\n            return null;\n        }\n        //查找本地对象\n        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n        if (((iin != null) \u0026\u0026 (iin instanceof IMyService))) {\n            Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————返回本地对象\");\n            return ((IMyService) iin);\n        }\n        Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————返回代理对象\");\n        return new Stub.Proxy(obj);\n    }\n\n    @Override\n    public android.os.IBinder asBinder() {\n        return this;\n    }\n\n    @Override\n    public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n        switch (code) {\n            case INTERFACE_TRANSACTION: {\n                reply.writeString(DESCRIPTOR);\n                return true;\n            }\n            case TRANSACTION_addUser: {\n                Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————本地对象通过 Binder 执行 addUser\");\n                data.enforceInterface(DESCRIPTOR);\n                User arg0;\n                if ((0 != data.readInt())) {\n                    //取出客户端传递过来的数据\n                    arg0 = User.CREATOR.createFromParcel(data);\n                } else {\n                    arg0 = null;\n                }\n                //调用 Binder 本地对象\n                this.addUser(arg0);\n                reply.writeNoException();\n                return true;\n            }\n            case TRANSACTION_getUserList: {\n                Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————本地对象通过 Binder 执行 getUserList\");\n                data.enforceInterface(DESCRIPTOR);\n                //调用 Binder 本地对象\n                List\u003cUser\u003e result = this.getUserList();\n                reply.writeNoException();\n                //将结果返回给客户端\n                reply.writeTypedList(result);\n                return true;\n            }\n            default:\n                break;\n        }\n        return super.onTransact(code, data, reply, flags);\n    }\n\n\n    private static class Proxy implements IMyService {\n        private android.os.IBinder mRemote;\n\n        Proxy(android.os.IBinder remote) {\n            mRemote = remote;\n        }\n\n        @Override\n        public android.os.IBinder asBinder() {\n            return mRemote;\n        }\n\n        public java.lang.String getInterfaceDescriptor() {\n            return DESCRIPTOR;\n        }\n\n        @Override\n        public void addUser(User user) throws android.os.RemoteException {\n            android.os.Parcel _data = android.os.Parcel.obtain();\n            android.os.Parcel _reply = android.os.Parcel.obtain();\n            try {\n                _data.writeInterfaceToken(DESCRIPTOR);\n               if (user != null) {\n                   _data.writeInt(1);\n                   //将 user 对象的值写入 _data\n                   user.writeToParcel(_data, 0);\n               } else {\n                   _data.writeInt(0);\n               }\n               Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————代理对象通过 Binder 调用 addUser\");\n               //通过 transact 跟 Server 交互\n               mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, 0);\n                _reply.readException();\n            } finally {\n                _reply.recycle();\n                _data.recycle();\n            }\n        }\n\n        @Override\n        public List\u003cUser\u003e getUserList() throws android.os.RemoteException {\n            android.os.Parcel _data = android.os.Parcel.obtain();\n            android.os.Parcel _reply = android.os.Parcel.obtain();\n            List\u003cUser\u003e _result;\n            try {\n                _data.writeInterfaceToken(DESCRIPTOR);\n                Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————代理对象通过 Binder 调用 getUserList\");\n                //通过 transact 跟 Server 交互\n                mRemote.transact(Stub.TRANSACTION_getUserList, _data, _reply, 0);\n                _reply.readException();\n                //获取 Server 的返回值并进程转换\n                _result = _reply.createTypedArrayList(User.CREATOR);\n            } finally {\n                _reply.recycle();\n                _data.recycle();\n            }\n            return _result;\n        }\n    }\n}\n```\n\n## 2、创建 Service\n\n创建 UserServer 类并继承自 Service，并且创建一个内部类 IMyServiceNative 并且继承 Stub 类，然后将该实现类的实例在 onBind 方法返回：\n\n```java\npublic class UserServer extends Service {\n\n    class IMyServiceNative extends Stub {\n\n        List\u003cUser\u003e users = new ArrayList\u003c\u003e();\n\n        @Override\n        public void addUser(User user) {\n            Log.e(\"gpj\", \"进程：\" + Utils.getProcessName(getApplicationContext())\n                    + \"，线程：\" + Thread.currentThread().getName() + \"————Server 执行 addUser\");\n            users.add(user);\n        }\n\n        @Override\n        public List\u003cUser\u003e getUserList() {\n            Log.e(\"gpj\", \"进程：\" + Utils.getProcessName(getApplicationContext())\n                    + \"，线程：\" + Thread.currentThread().getName() + \"————Server 执行 getUserList\");\n            return users;\n        }\n    }\n\n    private IMyServiceNative mMyServcieNative = new IMyServiceNative();\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.e(\"gpj\", \"进程：\" + Utils.getProcessName(getApplicationContext())\n                + \"，线程：\" + Thread.currentThread().getName() + \"————Server onBind\");\n        return mMyServcieNative;\n    }\n}\n```\n\n因为 Stub 抽象类实现了 IMyService 接口，它声明了 Server 端具有的能力。因此在 IMyServiceNative 中应该实现 IMyService 接口中声明的 addUser 和 getUserList 方法。\n\n除此之外，还需要在 Menifest 文件中声明 MyService 并标记为远程 Service：\n\n```xml\n\u003cservice android:name=\".MyService\"\n    android:process=\":remote\"\u003e\n    \u003cintent-filter\u003e\n        \u003caction android:name=\"com.me.guanpj.binder\"/\u003e\n    \u003c/intent-filter\u003e\n\u003c/service\u003e\n```\n\n## 3、绑定 Service\n\n作为客户端，在 ClientActivity 中绑定远程 Service：\n\n```java\nprivate void bindService() {\n    Intent intent = new Intent();\n    intent.setAction(\"com.me.guanpj.binder\");\n    intent.setComponent(new ComponentName(\"com.me.guanpj.binder\", \"com.me.guanpj.binder.MyService\"));\n\n    Log.e(\"gpj\", \"进程：\" + Utils.getProcessName(getApplicationContext())\n            + \"，线程：\" + Thread.currentThread().getName() + \"————开始绑定 Servcie\");\n    bindService(intent, mConn, Context.BIND_AUTO_CREATE);\n}\n\nIMyService myService;\n\nprivate ServiceConnection mConn = new ServiceConnection() {\n    @Override\n    public void onServiceConnected(ComponentName name, IBinder service) {\n        Log.e(\"gpj\", \"进程：\" + Utils.getProcessName(getApplicationContext())\n                + \"，线程：\" + Thread.currentThread().getName() + \"————Client onServiceConnected\");\n        myService = Stub.asInterface(service);\n    }\n\n    @Override\n    public void onServiceDisconnected(ComponentName name) {\n        myService = null;\n    }\n};\n```\n\n在 onServiceConnected 回调方法中，将 Binder 驱动返回的 service 包装成 Stub 对象并赋值给 myService，随后就可以使用 myService 实例与 Server 端交互了。\n\n## 4、Client 端与 Server 端交互\n\n绑定远程 Service 并且获取到 Server 端的代理对象后，Client 端便可通过代理对象与 Server 端进行通讯了：\n\n```java\n@Override\npublic void onClick(View v) {\n    switch (v.getId()) {\n        case R.id.btn_bind:\n            bindService();\n            break;\n        case R.id.btn_add_user:\n            if (null != myService) {\n                try {\n                    Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————Client 调用 addUser\");\n                    myService.addUser(new User(111, \"gpj\"));\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                Toast.makeText(ClientActivity.this, \"先绑定 Service 才能调用方法\", Toast.LENGTH_LONG).show();\n            }\n            break;\n        case R.id.btn_get_size:\n            if (null != myService) {\n                try {\n                    Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————Client 调用 getUserList\");\n                    List\u003cUser\u003e userList = myService.getUserList();\n                    tvResult.setText(\"getUserList size:\" + userList.size());\n                    Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————UserList Size：\" + userList.size());\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                Toast.makeText(ClientActivity.this, \"先绑定 Service 才能调用方法\", Toast.LENGTH_LONG).show();\n            }\n            break;\n        default:\n    }\n}\n```\n\n## 5、结果展示\n\n经过以上步骤，处于 Client 端的 Activity 与作为服务端的远程 Service 虽然运行在不同的进程中，通过 AIDL 生成的模板代码并且依赖 Binder 机制，它们之间实现了数据的传递。\n\n运行结果如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-2/clipboard_20230323_044626.png)\n\n首先点击 BindService 按钮，此时会绑定远程 Service 并且获取到服务端的代理对象 myService：\n\n```plain text\nE/gpj: 进程：com.me.guanpj.binder，线程：main————开始绑定 Servcie\nE/gpj: 进程：com.me.guanpj.binder:remote，线程：main————Server onBind\nE/gpj: 进程：com.me.guanpj.binder，线程：main————Client onServiceConnected\nE/gpj: 进程：com.me.guanpj.binder，线程：main————返回代理对象\n```\n\n点击 Add User 按钮往 Server 端增加一名用户：\n\n```plain text\nE/gpj: 进程：com.me.guanpj.binder，线程：main————Client 调用 addUser\nE/gpj: 进程：com.me.guanpj.binder，线程：main————代理对象通过 Binder 调用 addUser\nE/gpj: 进程：com.me.guanpj.binder:remote，线程：Binder:4072_3————本地对象通过 Binder 执行 addUser\nE/gpj: 进程：com.me.guanpj.binder:remote，线程：Binder:4072_3————Server 执行 addUser:User{id=111, name='gpj'}\n```\n\n点击 Get Size 按钮查询用户数量：\n\n```plain text\nE/gpj: 进程：com.me.guanpj.binder，线程：main————Client 调用 getUserList\nE/gpj: 进程：com.me.guanpj.binder，线程：main————代理对象通过 Binder 调用 getUserList\nE/gpj: 进程：com.me.guanpj.binder:remote，线程：Binder:4072_3————本地对象通过 Binder 执行 getUserList\nE/gpj: 进程：com.me.guanpj.binder:remote，线程：Binder:4072_3————Server 执行 getUserList\nE/gpj: 进程：com.me.guanpj.binder，线程：main————UserList Size：1\n```\n\n# AIDL 通讯过程分析\n\n## 关键类职责描述\n\n以上代码已经上传到了 [Github](https://github.com/guanpj/BinderDemo)，关键的类以及它们之间的关系如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-2/clipboard_20230323_044631.png)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-2/clipboard_20230323_044634.png)\n\n- \u003cstrong\u003eIInterface:\u003c/strong\u003e 声明（自动生成或者手动创建）AIDL 性质的接口必须继承这个接口，这个接口只有一个 IBinder asBinder() 方法，实现它的类代表它能够进程跨进程传输（ Server 端的 Binder 本地对象）或者持有能够进程跨进程传输的对象的引用（Binder 代理对象）。\n- \u003cstrong\u003eI\u003c/strong\u003e\u003cstrong\u003eMyServcie\u003c/strong\u003e\u003cstrong\u003e:\u003c/strong\u003e 如 1 中所述，它需要继承 IInterface 接口，并且定义方法（声明 Server 端具有的能力： addUser 和 getUserList）。\n- \u003cstrong\u003eIBinder:\u003c/strong\u003e 它也是一个接口，实现这个接口的对象就具有了跨进程传输的能力（由驱动底层支持），在跨进程数据流经驱动的时候，驱动会识别 IBinder 类型的数据，从而自动完成不同进程 Binder 本地对象以及 Binder 代理对象的转换。\n- \u003cstrong\u003eBinder:\u003c/strong\u003e Java 层的 Binder 类，代表 Binder 本地对象。\n- \u003cstrong\u003eBinderProxy\u003c/strong\u003e\u003cstrong\u003e: \u003c/strong\u003eBinder 类的内部类，是 Server 端 Binder 对象的本地代理，它们都继承了 IBinder 接口，因此都能跨进程进行传输，Binder 驱动在跨进程传输的时候会将这两个对象自动进行转换。\n- \u003cstrong\u003eStub\u003c/strong\u003e\u003cstrong\u003e:\u003c/strong\u003e 由 IDE 自动生成的抽象类，字面意义为“存根”，这里指待服务端实现的意思。它继承自 Binder 并实现了 IInterface 接口，说明它是 Server 端的 Binder 本地对象，并拥有 Server 承诺给 Client 的能力。\n- \u003cstrong\u003eClientActivity:\u003c/strong\u003e 在这里充当 Client 端的门面，它持有 IMyService 接口的实例 myService，并且通过 myService 与服务端进行通讯。\n- \u003cstrong\u003eUserServer:\u003c/strong\u003e 它是一个 Service 组件，可以运行在独立的进程中。当作为远程 Service 需要与 Client 端进行绑定时，必须在 onBind 方法中返回一个 IBinder 对象，Client 端才能与之进行交互。\n- \u003cstrong\u003eMyServiceNative: \u003c/strong\u003eServer 端的 Binder 本地对象。它实现了 IMyServcie 声明的能力（方法），Client 可以间接调用到它从而实现通讯功能\n\n## 通讯过程分析\n\n一次跨进程通信必然会涉及到两个进程，在这个例子中 UserServer 处于服务端进程，使用内部类 MyServiceNative\u003cstrong\u003e \u003c/strong\u003e提供服务；ClientActivity 作为客户端进程，使用 UserServer 提供的服务。\n\n先从 ClientActivity 中绑定服务后的回调方法着手：\n\n```java\npublic class ClientActivity extends AppCompatActivity {\n    ...\n    private ServiceConnection mConn = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder service) {\n            Log.e(\"gpj\", \"进程：\" + Utils.getProcessName()\n                    + \"，线程：\" + Thread.currentThread().getName() + \"————Client onServiceConnected\");\n            myService = Stub.asInterface(service);\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) {\n            myService = null;\n        }\n    };\n    ...\n}\n```\n\nonServiceConnected 的参数中，第一个是 Service 组件的名字，表示哪个服务被启动了；\n\n重点是类型为 IBinder 的第二个参数，在 UserServer 中的 onBind 方法中，已经把 Server 端的本地对象 MyServiceNative 的实例返回给 Binder 驱动了：\n\n```java\npublic class UserServer extends Service {\n    ...\n    private MyServiceNative mMyServcieNative = new MyServiceNative();\n\n    @Override\n    public IBinder onBind(Intent intent) {\n        Log.e(\"gpj\", \"进程：\" + Utils.getProcessName()\n                + \"，线程：\" + Thread.currentThread().getName() + \"————Server onBind\");\n        return mMyServcieNative;\n    }\n}\n```\n\n因此，当该服务被绑定的时候，Binder 驱动会为根据该服务所在的进程决定是返回本地对象还是代理对象给客户端：\n\n当 Service 与 ClientActivity 位于同一个进程当中的时候，onServiceConnected 返回 Binder 本地对象——即 MyServcieNative 实例给客户端：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-2/clipboard_20230323_044640.png)\n\n当 Service 运行在不同进程中的时候（Manifest 中声明 Service 的时候设置 proces 属性），返回的是 BinderProxy 实例：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-2/clipboard_20230323_044643.png)\n\n接着会将这个 IBinder 实例传给 Stub 的 asInterface 方法：\n\n```java\n/**\n * 根据 Binder 本地对象或者代理对象返回 IMyService 接口\n */\npublic static IMyService asInterface(android.os.IBinder obj) {\n    if ((obj == null)) {\n        return null;\n    }\n    //查找本地对象\n    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\n    if (((iin != null) \u0026\u0026 (iin instanceof IMyService))) {\n        Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————返回本地对象\");\n        return ((IMyService) iin);\n    }\n    Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————返回代理对象\");\n    return new Stub.Proxy(obj);\n}\n```\n\n首先，会根据 DESCRIPTOR 调用 IBinder 对象的 queryLocalInterface 方法，那么就得看 IBinder 的实现类怎么处理这个方法了：\n\n\u003cstrong\u003e在 Binder 类中的实现：\u003c/strong\u003e\n\n```java\npublic @Nullable IInterface queryLocalInterface(@NonNull String descriptor) {\n    //判断 mDescriptor 跟参数 DESCRIPTOR 相同，返回 mOwner\n    if (mDescriptor != null \u0026\u0026 mDescriptor.equals(descriptor)) {\n        return mOwner;\n    }\n    return null;\n}\n```\n\n那么这个 mOwner 和 mDescriptor 又是什么时候被赋值的呢？答案在 Binder 的子类 Stub 的构造方法里面，：\n\n```java\npublic Stub() {\n    //将 Stub 和 DESCRIPTOR 注入到父类（Binder）\n    this.attachInterface(this, DESCRIPTOR);\n}\n```\n\n\u003cstrong\u003e在 Binder$BinderProxy 类中的实现：\u003c/strong\u003e\n\nBinderProxy 并不是 Binder 本地对象，而是 Binder 的本地代理，因此 queryLocalInterface 返回的是 null：\n\n```java\npublic IInterface queryLocalInterface(String descriptor) {\n    return null;\n}\n```\n\n根据以上分析可以得出结论：\n\n当 UserServer 与客户端处于相同进程时，obj.queryLocalInterface(DESCRIPTOR) 方法存在返回值并且是 IMyService 实例，而它就是 MyServiceNative，将它直接返回给 Client 调用；\n\n处于不同进程时，obj.queryLocalInterface(DESCRIPTOR) 返回 null，这时使用 Stub$Proxy 类将其进行包装后再返回。Proxy 类也实现了 IMyService 接口，因此，在 Client 看来，它也具有 Server 承诺给 Client 的能力。\n\n那么，经过包装后的 Stub$Proxy 对象怎么和 Server 进行交互呢？首先，它会把 BinderProxy 对象保存下来：\n\n```java\nprivate android.os.IBinder mRemote;\n\nProxy(android.os.IBinder remote) {\n    mRemote = remote;\n}\n```\n\n然后，实现 IMyService 的方法：\n\n```java\n@Override\npublic void addUser(User user) throws android.os.RemoteException {\n    android.os.Parcel _data = android.os.Parcel.obtain();\n    android.os.Parcel _reply = android.os.Parcel.obtain();\n    try {\n        _data.writeInterfaceToken(DESCRIPTOR);\n        if (user != null) {\n            _data.writeInt(1);\n            //将 user 对象的值写入 _data\n            user.writeToParcel(_data, 0);\n        } else {\n            _data.writeInt(0);\n        }\n        Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————代理对象通过 Binder 调用 addUser\");\n        //通过 transact 跟 Server 交互\n        mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, 0);\n        _reply.readException();\n    } finally {\n        _reply.recycle();\n        _data.recycle();\n    }\n}\n\n@Override\npublic List\u003cUser\u003e getUserList() throws android.os.RemoteException {\n    android.os.Parcel _data = android.os.Parcel.obtain();\n    android.os.Parcel _reply = android.os.Parcel.obtain();\n    List\u003cUser\u003e _result;\n    try {\n        _data.writeInterfaceToken(DESCRIPTOR);\n        Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————代理对象通过 Binder 调用 getUserList\");\n        //通过 transact 跟 Server 交互\n        mRemote.transact(Stub.TRANSACTION_getUserList, _data, _reply, 0);\n        _reply.readException();\n        //获取 Server 的返回值并进程转换\n        _result = _reply.createTypedArrayList(User.CREATOR);\n    } finally {\n        _reply.recycle();\n        _data.recycle();\n    }\n    return _result;\n}\n```\n\n可以看到，不管什么方法，都是是将服务端的方法代号、处理过的参数和接收返回值的对象等通过 mRemote.transact() 方法 Server 进行交互，mRemote 是 BinderProxy 类型，在 BinderProxy 类中，最终调用的是 transactNative 方法：\n\n```java\npublic native boolean transactNative(int code, Parcel data, Parcel reply, int flags) throws RemoteException;\n```\n\n它的最终实现在 Native 层进行，Binder 驱动会通过 ioctl 系统调用唤醒 Server 进程，并调用本地对象 MyServiceNative 的 onTransact 函数（在 Stub 类中）：\n\n```java\n@Override\npublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {\n    switch (code) {\n        case INTERFACE_TRANSACTION: {\n            reply.writeString(DESCRIPTOR);\n            return true;\n        }\n        case TRANSACTION_addUser: {\n            Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————本地对象通过 Binder 执行 addUser\");\n            data.enforceInterface(DESCRIPTOR);\n            User arg0;\n            if ((0 != data.readInt())) {\n                //取出客户端传递过来的数据\n                arg0 = User.CREATOR.createFromParcel(data);\n            } else {\n                arg0 = null;\n            }\n            //调用 Binder 本地对象\n            this.addUser(arg0);\n            reply.writeNoException();\n            return true;\n        }\n        case TRANSACTION_getUserList: {\n            Log.e(\"gpj\", \"线程：\" + Thread.currentThread().getName() + \"————本地对象通过 Binder 执行 getUserList\");\n            data.enforceInterface(DESCRIPTOR);\n            //调用 Binder 本地对象\n            List\u003cUser\u003e result = this.getUserList();\n            reply.writeNoException();\n            //将结果返回给客户端\n            reply.writeTypedList(result);\n            return true;\n        }\n        default:\n            break;\n    }\n    return super.onTransact(code, data, reply, flags);\n}\n```\n\n在 Server 进程中，onTransact 会根据 Client 传过来的方法代号决定调用哪个方法，得到结果后又会通过 Binder 驱动返回给 Client。\n\n回溯到 onServiceConnected 回调方法，待服务连接成功后，Client 就需要跟 Server 进行交互了，如果 Server 跟 Client 在同一个进程中，Client 可以直接调用 Server 的本地对象 ，当它们不在同一个进程中的时候，Binder 驱动会自动将 Server 的本地对象转换成 BinderProxy 代理对象，经过一层包装之后，返回一个新的代理对象给 Client。这样，整个 IPC 的过程就完成了。\n\n整个过程的流程如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-2/clipboard_20230323_044649.png)\n\n# Binder 在 Framework 层的应用\n\n在 Activity 启动的初始阶段的流程如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-2/clipboard_20230323_044652.png)\n\n其中，最后一段中的 ActivityManagerProxy 与 ActivityManagerServer 分别处于不同的进程中，它们之间的通讯也依赖 Binder 机制。\n\n这里从 Instrumentation 类的 execStartActivity() 方法开始分析：\n\n```java\npublic ActivityResult execStartActivity(\n        Context who, IBinder contextThread, IBinder token, Activity target,\n        Intent intent, int requestCode, Bundle options) {\n        ...\n    try {\n        intent.migrateExtraStreamToClipData();\n        intent.prepareToLeaveProcess(who);\n        // 获取 AMS 的代理对象并调用其 startActivity 方法\n        int result = ActivityManagerNative.getDefault()\n            .startActivity(whoThread, who.getBasePackageName(), intent,\n                    intent.resolveTypeIfNeeded(who.getContentResolver()),\n                    token, target != null ? target.mEmbeddedID : null,\n                    requestCode, 0, null, options);\n        checkStartActivityResult(result, intent);\n    } catch (RemoteException e) {\n        throw new RuntimeException(\"Failure from system\", e);\n    }\n    return null;\n}\n```\n\n以上过程是在 Launcher App 所在的进程中发生的，AMS 是运行在 system_server 进程中的，这时 AMS 就相当于 AIDL 中的远程 Service，App 进程要与 AMS 交互，需要通过 AMS 的代理对象 AMP(ActivityManagerProxy) 来完成，来看 ActivityManagerNative.getDefault() 拿到的是什么：\n\n```java\nstatic public IActivityManager getDefault() {\n    return gDefault.get();\n}\n```\n\ngetDefault 是一个静态变量：\n\n```java\nprivate static final Singleton\u003cIActivityManager\u003e gDefault = new Singleton\u003cIActivityManager\u003e() {\n    protected IActivityManager create() {\n        // 向 ServiceManager 查询一个 key 为 \"activity\" 的引用\n        IBinder b = ServiceManager.getService(\"activity\");\n        if (false) {\n            Log.v(\"ActivityManager\", \"default service binder = \" + b);\n        }\n        IActivityManager am = asInterface(b);\n        if (false) {\n            Log.v(\"ActivityManager\", \"default service = \" + am);\n        }\n        return am;\n    }\n};\n```\n\n这里通过 \"activity\" 这个名字向 ServiceManager 查询 AMS 的引用（事实上这个过程也是通过 Binder 来实现的，这里不再分析），获取 AMS 的引用后，调用 asInterface 方法：\n\n```java\nstatic public IActivityManager asInterface(IBinder obj) {\n    if (obj == null) {\n        return null;\n    }\n    // 根据 descriptor 查询 obj 是否为 Binder 本地对象，具体过程请看前文中提到的文章\n    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);\n    if (in != null) {\n        return in;\n    }\n    // 如果 obj 不是 Binder 本地对象，则将其包装成代理对象并返回\n    return new ActivityManagerProxy(obj);\n}\n```\n\n因为 AMS 与 Launcher App 不在同一个进程中，这里返回的 IBinder 对象是一个 Binder 代理对象，因此这类将其包装成 AMP(ActivityManagerProxy) 对象并返回，AMP 是 AMN(ActivityManagerNative) 的内部类，查看 AMP 类 ：\n\n```java\nclass ActivityManagerProxy implements IActivityManager\n{\n    public ActivityManagerProxy(IBinder remote)\n    {\n        mRemote = remote;\n    }\n\n    public IBinder asBinder()\n    {\n        return mRemote;\n    }\n\n    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n            String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {\n        ...\n        // 调用号为 START_ACTIVITY_TRANSACTION\n        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n        reply.readException();\n        int result = reply.readInt();\n        reply.recycle();\n        data.recycle();\n        return result;\n    }\n    ...\n    public ComponentName startService(IApplicationThread caller, Intent service,\n            String resolvedType, String callingPackage, int userId) throws RemoteException\n    {\n        ...\n        mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0);\n        reply.readException();\n        ComponentName res = ComponentName.readFromParcel(reply);\n        data.recycle();\n        reply.recycle();\n        return res;\n    }\n    ...\n}\n```\n\n可以看到，AMP 里面将客户端的请求通过 mRemote.transact() 进行转发；mRemote 正是 Binder 驱动返回来的 BinderProxy 对象的实例，通过 mRemote，Binder 驱动最终将调用处于 Binder Server 端 AMN 中的 onTransact 方法：\n\n```java\n@Override\npublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {\n    // 根据方法调用号 code 决定调用哪个方法\n    switch (code) {\n    case START_ACTIVITY_TRANSACTION:\n    {\n        ...\n        // 调用 startActivity 方法\n        int result = startActivity(app, callingPackage, intent, resolvedType,\n                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);\n        reply.writeNoException();\n        reply.writeInt(result);\n        return true;\n    }\n    ...\n    case START_SERVICE_TRANSACTION: {\n        ...\n        ComponentName cn = startService(app, service, resolvedType, callingPackage, userId);\n            reply.writeNoException();\n            ComponentName.writeToParcel(cn, reply);\n            return true;\n        }\n        ...\n    }\n}\n```\n\nAMN 是一个抽象类，它的 startActivity 为抽象方法，具体的实现在 ActivityManagerService.java 中:\n\n```java\npublic final class ActivityManagerService extends ActivityManagerNative\n        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {\n    ...\n    \n    @Override\n    public final int startActivity(IApplicationThread caller, String callingPackage,\n                                   Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n                                   int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {\n        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,\n                resultWho, requestCode, startFlags, profilerInfo, bOptions,\n                UserHandle.getCallingUserId());\n    }\n    \n    ...\n}\n```\n\n这样最终从 App 进程调用到了 AMS 中的方法，剩下的流程这里不再进行分析。\n\n# 总结\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Binder-2/clipboard_20230323_044658.png)\n\n\u003cstrong\u003e参考文章\u003c/strong\u003e\n\n[写给 Android 应用工程师的 Binder 原理剖析](https://zhuanlan.zhihu.com/p/35519585)\n\n[Binder 学习指南](https://cloud.tencent.com/developer/article/1329601)\n\n\u003e 文章中的代码已经上传至我的 Github，如果你对文章内容有疑问或者有不同的意见，欢迎留言，我们一同探讨。\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["Binder","IPC","ServiceManager","AIDL","Framework"]},"/%E4%BA%94App-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90":{"title":"五、App 启动流程分析","content":"在我的上一篇文章 [Android 系统启动流程分析](https://guanpj.cn/2017/09/17/Android-System-Startup-Flow-Analyze/)中，我们分析了系统在开机以后的一系列行为，其中最后一阶段 AMS(ActivityManagerService) 会启动 Launcher 来展示我们手机中所有已安装的应用图标，点击图标后相应的应用程序将会被系统启动运行并展示在我们面前，那么，点击了图标之后系统道理做了哪些工作呢？应用进程是怎么被启动的呢？Activity 的生命周期是什么时候被谁调用的呢？本文将继续基于 Android Nougat 的 frameworks 层源码的解答这些问题。\n\n\u003cstrong\u003e阅读建议：\u003c/strong\u003e\n\n如果你是首次阅读这个过程的源码，建议你忽略一些细枝末节的代码，先抓主干代码，从整体上理解代码的执行流程（右下角文章目录视图中可以点击跳转到相应章节），否则将会被细节的代码扰乱思路。最后可以回头多看几遍，这时候如果有需要可以追踪一些枝干代码，做到融会贯通。\n\n# 1. Launcher —— AMS\n\n## 1.1 调用过程分析\n\n### 1.1.1 Launcher.onClick\n\n在 Launcher app 的主 Activity —— Launcher.java 中，App 图标的点击事件最终会回调 Launcher.java 中的 onClick 方法，\n\n[packages/apps/Launcher3/src/com/android/launcher3/Launcher.java]([https://android.googlesource.com/platform/packages/apps/Launcher3/](https://android.googlesource.com/platform/packages/apps/Launcher3/) /nougat-release/src/com/android/launcher3/Launcher.java?autodive=0/)：\n\n```java\npublic void onClick(View v) {\n    ...\n    Object tag = v.getTag();\n    if (tag instanceof ShortcutInfo) {\n        // 从快捷方式图标启动\n        onClickAppShortcut(v);\n    } else if (tag instanceof FolderInfo) {\n        // 文件夹\n        if (v instanceof FolderIcon) {\n           onClickFolderIcon(v);\n        }\n    } else if (v == mAllAppsButton) {\n        // “所有应用”按钮\n        onClickAllAppsButton(v);\n    } else if (tag instanceof AppInfo) {\n        // 从“所有应用”中启动的应用\n        startAppShortcutOrInfoActivity(v);\n    } else if (tag instanceof LauncherAppWidgetInfo) {\n        // 组件\n        if (v instanceof PendingAppWidgetHostView) {\n            onClickPendingWidget((PendingAppWidgetHostView) v);\n        }\n    }\n}\n```\n\n### 1.1.2 Launcher.onClickAppShortcut\n\n如果是快捷方式图标，则调用 onClickAppShortcut 方法进而调用 startAppShortcutOrInfoActivity 方法：\n\n```java\n@Thunk void startAppShortcutOrInfoActivity(View v) {\n    Object tag = v.getTag();\n    final ShortcutInfo shortcut;\n    final Intent intent;\n    if (tag instanceof ShortcutInfo) {\n        shortcut = (ShortcutInfo) tag;\n        // 去除对应的 Intent 对象\n        intent = shortcut.intent;\n        int[] pos = new int[2];\n        v.getLocationOnScreen(pos);\n        intent.setSourceBounds(new Rect(pos[0], pos[1],\n                pos[0] + v.getWidth(), pos[1] + v.getHeight()));\n\n    } else if (tag instanceof AppInfo) {\n        shortcut = null;\n        intent = ((AppInfo) tag).intent;\n    } else {\n        throw new IllegalArgumentException(\"Input must be a Shortcut or AppInfo\");\n    }\n\n    // 调用 startActivitySafely 方法\n    boolean success = startActivitySafely(v, intent, tag);\n    mStats.recordLaunch(v, intent, shortcut);\n\n    if (success \u0026\u0026 v instanceof BubbleTextView) {\n        mWaitingForResume = (BubbleTextView) v;\n        mWaitingForResume.setStayPressed(true);\n    }\n}\n```\n\n### 1.1.3 Launcher.startActivity\n\n获取相应 App 的 Intent 信息之后，调用 startActivity 方法：\n\n```java\nprivate boolean startActivity(View v, Intent intent, Object tag) {\n    // 启动新的任务栈\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n    try {\n        ...\n        if (user == null || user.equals(UserHandleCompat.myUserHandle())) {\n            StrictMode.VmPolicy oldPolicy = StrictMode.getVmPolicy();\n            try {            \n                StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectAll()\n                        .penaltyLog().build());\n                // 调用 Activity 的 startActivity 方法\n                startActivity(intent, optsBundle);\n            } finally {\n                StrictMode.setVmPolicy(oldPolicy);\n            }\n        } else {\n            launcherApps.startActivityForProfile(intent.getComponent(), user,\n                    intent.getSourceBounds(), optsBundle);\n        }\n        return true;\n    } catch (SecurityException e) {      \n        ...\n    }\n    return false;\n}\n```\n\n### 1.1.4 Activity.startActivity\n\n这里最终调用了 Activity 中的 startActivity 方法，并且设置 Flag 为 FLAG_ACTIVITY_NEW_TASK。到此为止，已经跟启动普通的 Activity 流程汇合起来了，继续往下分析。\n\n[frameworks/base/core/java/android/app/Activity.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/android/app/Activity.java)：\n\n```java\n@Override\npublic void startActivity(Intent intent, @Nullable Bundle options) {\n    // 第二个参数为 -1 表示不需要回调 onActivityResult 方法\n    if (options != null) {\n        startActivityForResult(intent, -1, options);\n    } else {\n        // Note we want to go through this call for compatibility with\n        // applications that may have overridden the method.\n        startActivityForResult(intent, -1);\n    }\n}\n```\n\n### 1.1.5 Activity.startActivityForResult\n\n调用 Activity 的 startActivityForResult 方法\n\n```java\npublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode,\n           @Nullable Bundle options) {\n    // mParent 是当前 Activity 的父类，此时条件成立\n    if (mParent == null) {\n        // 调用 Instrumentation 的 execStartActivity 方法\n        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this,\n               mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);\n        ...\n    } else {\n        ...\n    }\n}\n```\n\n### 1.1.6 Instrumentation.execStartActivity\n\n[frameworks/base/core/java/android/app/Instrumentation.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/android/app/Instrumentation.java)：\n\n```java\npublic ActivityResult execStartActivity(\n        Context who, IBinder contextThread, IBinder token, Activity target,\n        Intent intent, int requestCode, Bundle options) {\n        ...\n    try {\n        intent.migrateExtraStreamToClipData();\n        intent.prepareToLeaveProcess(who);\n        // 获取 AMS 的代理对象并调用其 startActivity 方法\n        int result = ActivityManagerNative.getDefault()\n            .startActivity(whoThread, who.getBasePackageName(), intent,\n                    intent.resolveTypeIfNeeded(who.getContentResolver()),\n                    token, target != null ? target.mEmbeddedID : null,\n                    requestCode, 0, null, options);\n        checkStartActivityResult(result, intent);\n    } catch (RemoteException e) {\n        throw new RuntimeException(\"Failure from system\", e);\n    }\n    return null;\n}\n```\n\n### 1.1.7 ActivityManagerProxy.startActivity\n\n以上过程是在 Launcher App 所在的进程中发生的，在我的另外一篇文章[借助 AIDL 理解 Android Binder 机制——AIDL 的使用和原理分析](https://guanpj.cn/2017/08/13/Android-Binder-Apply/)中我们分析了 AIDL 的实现过程，由于远程 Service 跟使用 Service 的 Activity 不在同一个进程中，因此他们之间交互需要通过 Binder IPC 机制的支持，在这个过程中 Client 首先获取到 Server 端的代理对象，在 Client 看来 Server 代理对象同样具有 Server 本地对象承诺的能力，因此 Client 可以调用 Server 代理对象跟 Sever 本地对象进行数据交互，Binder 驱动作为桥梁在他们中间起到中间人的作用。\n\n同样，在 [Android 系统启动流程分析](https://guanpj.cn/2017/09/17/Android-System-Startup-Flow-Analyze/)中我们了解到，AMS 是运行在 system_server 线程中的，这时 AMS 就相当于 AIDL 中的远程 Service，App 进程要与 AMS 交互，需要通过 AMS 的代理对象 AMP(ActivityManagerProxy) 来完成，来看 ActivityManagerNative.getDefault() 拿到的是什么：\n[frameworks/base/core/java/android/app/ActivityManagerNative.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/android/app/ActivityManagerNative.java)：\n\n```java\nstatic public IActivityManager getDefault() {\n    return gDefault.get();\n}\n```\n\ngetDefault 是一个静态变量：\n\n```java\nprivate static final Singleton\u003cIActivityManager\u003e gDefault = new Singleton\u003cIActivityManager\u003e() {\n    protected IActivityManager create() {\n        // 向 ServiceManager 查询一个 key 为 \"activity\" 的引用\n        IBinder b = ServiceManager.getService(\"activity\");\n        if (false) {\n            Log.v(\"ActivityManager\", \"default service binder = \" + b);\n        }\n        IActivityManager am = asInterface(b);\n        if (false) {\n            Log.v(\"ActivityManager\", \"default service = \" + am);\n        }\n        return am;\n    }\n};\n```\n\n同样，在文章[借助 AIDL 理解 Android Binder 机制——Binder 来龙去脉](https://guanpj.cn/2017/08/10/Android-Binder-Principle-Analyze/)中也讲到过：\n\n\u003e ServiceManager 是 Binder IPC 通信过程的核心，是上下文的管理者，Binder 服务端必须先向 ServerManager 注册才能够为客户端提供服务，Binder 客户端在与服务端通信之前需要从 ServerManager 中查找并获取 Binder 服务端的引用。\n\n这里通过 \"activity\" 这个名字向 ServiceManager 查询 AMS 的引用，获取 AMS 的引用后，调用 asInterface 方法：\n\n```java\nstatic public IActivityManager asInterface(IBinder obj) {\n    if (obj == null) {\n        return null;\n    }\n    // 根据 descriptor 查询 obj 是否为 Binder 本地对象，具体过程请看前文中提到的文章\n    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);\n    if (in != null) {\n        return in;\n    }\n    // 如果 obj 不是 Binder 本地对象，则将其包装成代理对象并返回\n    return new ActivityManagerProxy(obj);\n}\n```\n\n因为 AMS 与 Launcher App 不在同一个进程中，这里返回的 IBinder 对象是一个 Binder 代理对象，因此这类将其包装成 AMP(ActivityManagerProxy) 对象并返回，AMP 是 AMN(ActivityManagerNative) 的内部类，查看 AMP 类 ：\n\n```java\nclass ActivityManagerProxy implements IActivityManager\n{\n    public ActivityManagerProxy(IBinder remote)\n    {\n        mRemote = remote;\n    }\n\n    public IBinder asBinder()\n    {\n        return mRemote;\n    }\n\n    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n            String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {\n        ...\n        // 调用号为 START_ACTIVITY_TRANSACTION\n        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n        reply.readException();\n        int result = reply.readInt();\n        reply.recycle();\n        data.recycle();\n        return result;\n    }\n    ...\n    public ComponentName startService(IApplicationThread caller, Intent service,\n            String resolvedType, String callingPackage, int userId) throws RemoteException\n    {\n        ...\n        mRemote.transact(START_SERVICE_TRANSACTION, data, reply, 0);\n        reply.readException();\n        ComponentName res = ComponentName.readFromParcel(reply);\n        data.recycle();\n        reply.recycle();\n        return res;\n    }\n    ...\n}\n```\n\n可以看到，AMP 里面将客户端的请求通过 mRemote.transact 进行转发，mRemote 对象正是 Binder 驱动返回来的 Binder Proxy 对象，通过 Binder Proxy，Binder 驱动最终将调用处于 Binder Server 端 AMN 中的 onTransact 方法：\n\n```java\n@Override\npublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {\n    // 根据方法调用号 code 决定调用哪个方法\n    switch (code) {\n    case START_ACTIVITY_TRANSACTION:\n    {\n        ...\n        // 调用 startActivity 方法\n        int result = startActivity(app, callingPackage, intent, resolvedType,\n                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);\n        reply.writeNoException();\n        reply.writeInt(result);\n        return true;\n    }\n    ...\n    case START_SERVICE_TRANSACTION: {\n        ...\n        ComponentName cn = startService(app, service, resolvedType, callingPackage, userId);\n            reply.writeNoException();\n            ComponentName.writeToParcel(cn, reply);\n            return true;\n        }\n        ...\n    }\n}\n```\n\nAMN 是一个抽象类，它的 startActivity 为抽象方法，具体的实现在 ActivityManagerService.java 中。\n\n### 1.1.8 ActivityManagerService.startActivity\n\n[frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityManagerService.java)：\n\n```java\npublic final class ActivityManagerService extends ActivityManagerNative\n        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {\n    ...\n    \n    @Override\n    public final int startActivity(IApplicationThread caller, String callingPackage,\n                                   Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n                                   int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {\n        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,\n                resultWho, requestCode, startFlags, profilerInfo, bOptions,\n                UserHandle.getCallingUserId());\n    }\n    \n    ...\n}\n```\n\n## 1.2 小结\n\n从 Launcher App 到 AMS 的调用过程中使用了 Binder IPC 机制，如果你已经看了上面提到的我之前写的两篇文章——[借助 AIDL 理解 Android Binder 机制——Binder 来龙去脉](https://guanpj.cn/2017/08/10/Android-Binder-Principle-Analyze/)和[借助 AIDL 理解 Android Binder 机制——AIDL 的使用和原理分析](https://guanpj.cn/2017/08/13/Android-Binder-Apply/)，并且运行了文章中使用到的 [Demo](https://github.com/guanpj/BinderDemo)，你应该可以发现，相对于 AIDL 的调用过程，调用方 Launcher App 相当于 AIDL 过程中的 Activity 所在的 App，充当 Clinent 的角色；AMS 相当于远程 Service 的角色，充当 Server 端角色，他们的调用过程总体上都是一样的。\n\n从 Launcher App 到 AMS 的时序图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/App-Startup/clipboard_20230323_045438.png)\n\n# 2. AMS —— zygote\n\n## 2.1 调用过程分析\n\n### 2.1.1 ActivityManagerService.startActivityAsUser\n\n接着从 AMS 的 startActivityAsUser 方法开始分析：\n\n```java\n@Override\npublic final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {\n    enforceNotIsolatedCaller(\"startActivity\");\n    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),\n                userId, false, ALLOW_FULL_ONLY, \"startActivity\", null);\n    // TODO: Switch to user app stacks here.\n    // 调用 ActivityStarter 的 startActivityMayWait 方法\n    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,\n            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n            profilerInfo, null, null, bOptions, false, userId, null, null);\n}\n```\n\n### 2.1.2 ActivityStarter.startActivityMayWait\n\n继续跟进 [frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityStarter.java)：\n\n```java\nfinal int startActivityMayWait(IApplicationThread caller, int callingUid,\n        String callingPackage, Intent intent, String resolvedType,\n        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n        IBinder resultTo, String resultWho, int requestCode, int startFlags,\n        ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,\n        Bundle bOptions, boolean ignoreTargetSecurity, int userId,\n        IActivityContainer iContainer, TaskRecord inTask) {\n   ...\n   synchronized (mService) {\n        ...\n        // 调用 startActivityLocked 方法\n        int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,\n                aInfo, rInfo, voiceSession, voiceInteractor,\n                resultTo, resultWho, requestCode, callingPid,\n                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,\n                options, ignoreTargetSecurity, componentSpecified, outRecord, container,\n                inTask);\n        ...\n        return res;\n    }\n}\n```\n\n### 2.1.3 ActivityStarter.startActivityLocked\n\n查看 startActivityLocked 方法：\n\n```java\nfinal int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,\n        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,\n        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n        IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,\n        String callingPackage, int realCallingPid, int realCallingUid, int startFlags,\n        ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,\n        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,\n        TaskRecord inTask) {\n    ...\n    // 调用 doPendingActivityLaunchesLocked 方法，传入 false 参数\n    doPendingActivityLaunchesLocked(false);\n    ...\n    return err;\n}\n```\n\n### 2.1.4 ActivityStarter.doPendingActivityLaunchesLocked\n\n查看 doPendingActivityLaunchesLocked 方法：\n\n```java\nfinal void doPendingActivityLaunchesLocked(boolean doResume) {\n    while (!mPendingActivityLaunches.isEmpty()) {\n        final PendingActivityLaunch pal = mPendingActivityLaunches.remove(0);\n        final boolean resume = doResume \u0026\u0026 mPendingActivityLaunches.isEmpty();\n        try {\n            // 调用 startActivityUnchecked 方法\n            final int result = startActivityUnchecked(pal.r, pal.sourceRecord, null, null,\n                pal.startFlags, resume, null, null);\n            postStartActivityUncheckedProcessing(pal.r, result, mSupervisor.mFocusedStack.mStackId, \n                mSourceRecord, mTargetStack);\n        } catch (Exception e) {\n            Slog.e(TAG, \"Exception during pending activity launch pal=\" + pal, e);\n            pal.sendErrorResult(e.getMessage());\n        }\n    }\n}\n```\n\n### 2.1.5 ActivityStarter.startActivityUnchecked\n\n查看 startActivityUnchecked 方法：\n\n```java\nprivate int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,\n        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n        int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) {\n    ...  \n    // 调用 ActivityStackSupervisor 的 resumeFocusedStackTopActivityLocked 方法\n    mSupervisor.resumeFocusedStackTopActivityLocked();  \n    ... \n    return START_SUCCESS;\n}\n```\n\n### 2.1.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked\n\n[frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityStackSupervisor.java)：\n\n```java\nboolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target,\n            ActivityOptions targetOptions) {\n    if (targetStack != null \u0026\u0026 isFocusedStack(targetStack)) {\n        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\n    }\n    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\n    if (r == null || r.state != RESUMED) {\n        // 调用 ActivityStack 的 resumeTopActivityUncheckedLocked 方法\n        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);\n    }\n    return false;\n}\n```\n\n### 2.1.7 ActivityStack.resumeTopActivityUncheckedLocked\n\n查看 [ActivityStack]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityStack.java) 的 resumeTopActivityUncheckedLocked 方法：\n\n```java\nboolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {\n    ...\n    try {\n        ...\n        // 调用 resumeTopActivityInnerLocked 方法\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        mStackSupervisor.inResumeTopActivity = false;\n    }\n    return result;\n}\n```\n\n### 2.1.8 ActivityStack.resumeTopActivityInnerLocked\n\n查看 resumeTopActivityInnerLocked 方法：\n\n```java\nprivate boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {\n    ...\n    final ActivityRecord next = topRunningActivityLocked();\n    ...\n    if (next.app != null \u0026\u0026 next.app.thread != null) {\n        ...\n    } else {\n        ...\n        if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Restarting \" + next);\n        // 调用 ActivityStackSupervisor 的 startSpecificActivityLocked 方法\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n    }\n    \n    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n    return true;\n}\n```\n\n### 2.1.9 ActivityStackSupervisor.startSpecificActivityLocked\n\n回到 ActivityStackSupervisor 的 startSpecificActivityLocked 方法：\n\n```java\nvoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) {\n    // 当前 Activity 附属的 Application\n    ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n            r.info.applicationInfo.uid, true);\n    r.task.stack.setLaunchTime(r);\n    // 如果 Application 已经运行\n    if (app != null \u0026\u0026 app.thread != null) {\n        try {\n            if ((r.info.flags\u0026ActivityInfo.FLAG_MULTIPROCESS) == 0\n                    || !\"android\".equals(r.info.packageName)) {\n                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,\n                        mService.mProcessStats);\n            }\n            realStartActivityLocked(r, app, andResume, checkConfig);\n            return;\n        } catch (RemoteException e) {\n            Slog.w(TAG, \"Exception when starting activity \"\n                    + r.intent.getComponent().flattenToShortString(), e);\n        }\n    }\n    // 启动新进程\n    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n            \"activity\", r.intent.getComponent(), false, false, true);\n}\n```\n\n首先，在方法中获取了当前 Activity 附属的 Application，如果已经在运行了，说明这个 App 是已经被启动过了的，这时候调用 \u003cstrong\u003erealStartActivityLocked\u003c/strong\u003e 方法就可以进入下一步的流程了，同一个 App 中不同 Activity 的相互启动就是走的这个流程。当 Application 没有运行的时候，就需要调用 AMS 的 startProcessLocked 方法启动一个进程去承载它然后完成后续的工作，顺便铺垫一下，当新进程被启动完成后还会调用回到这个方法，查看 AMS 的 startProcessLocked 方法：\n\n### 2.1.10 ActivityManagerService.startProcessLocked\n\n```java\nfinal ProcessRecord startProcessLocked(String processName,\n        ApplicationInfo info, boolean knownToBeDead, int intentFlags,\n        String hostingType, ComponentName hostingName, boolean allowWhileBooting,\n        boolean isolated, boolean keepIfLarge) {\n    return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,\n            hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge,\n            null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */,\n            null /* crashHandler */);\n}\n```\n\n### 2.1.11 ActivityManagerService.startProcessLocked\n\n调用 startProcessLocked 方法：\n\n```java\nfinal ProcessRecord startProcessLocked(String processName, ApplicationInfo info,\n        boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,\n        boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,\n        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler){\n    ...\n    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);\n    checkTime(startTime, \"startProcess: done starting proc!\");\n    return (app.pid != 0) ? app : null;\n}\n```\n\n### 2.1.12 ActivityManagerService.startProcessLocked\n\n调用 startProcessLocked 的重载方法：\n\n```java\nprivate final void startProcessLocked(ProcessRecord app, String hostingType,\n        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs){\n    ...\n    try {\n        ...\n        // 调用 Process 的 start 方法\n        Process.ProcessStartResult startResult = Process.start(entryPoint,\n                app.processName, uid, uid, gids, debugFlags, mountExternal,\n                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,\n                app.info.dataDir, entryPointArgs);\n        ...\n    } catch (RuntimeException e) {\n        ...\n    }\n}\n```\n\n### 2.1.13 Process.start\n\n[frameworks/base/services/core/java/android/os/Process.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/android/os/Process.java)：\n\n```java\npublic static final ProcessStartResult start(final String processClass,\n                                final String niceName,\n                                int uid, int gid, int[] gids,\n                                int debugFlags, int mountExternal,\n                                int targetSdkVersion,\n                                String seInfo,\n                                String abi,\n                                String instructionSet,\n                                String appDataDir,\n                                String[] zygoteArgs) {\n    try {\n        // 调用 startViaZygote 方法\n        return startViaZygote(processClass, niceName, uid, gid, gids,\n                debugFlags, mountExternal, targetSdkVersion, seInfo,\n                abi, instructionSet, appDataDir, zygoteArgs);\n    } catch (ZygoteStartFailedEx ex) {\n        Log.e(LOG_TAG,\n                \"Starting VM process through Zygote failed\");\n        throw new RuntimeException(\n                \"Starting VM process through Zygote failed\", ex);\n    }\n}\n```\n\n### 2.1.14 Process.startViaZygote\n\n查看 startViaZygote 方法：\n\n```java\nprivate static ProcessStartResult startViaZygote(final String processClass,\n                                final String niceName,\n                                final int uid, final int gid,\n                                final int[] gids,\n                                int debugFlags, int mountExternal,\n                                int targetSdkVersion,\n                                String seInfo,\n                                String abi,\n                                String instructionSet,\n                                String appDataDir,\n                                String[] extraArgs)\n                                throws ZygoteStartFailedEx {\n    synchronized(Process.class) {\n        ...\n        // 调用 zygoteSendArgsAndGetResult 方法，传入 openZygoteSocketIfNeeded 的返回值\n        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n    }\n}\n```\n\n### 2.1.15 Process.zygoteSendArgsAndGetResult、Process.openZygoteSocketIfNeeded\n\n查看 zygoteSendArgsAndGetResult 方法：\n\n```java\nprivate static ProcessStartResult zygoteSendArgsAndGetResult(\n            ZygoteState zygoteState, ArrayList\u003cString\u003e args)\n            throws ZygoteStartFailedEx {\n    try {\n        ...\n        final BufferedWriter writer = zygoteState.writer;\n        final DataInputStream inputStream = zygoteState.inputStream;\n\n        writer.write(Integer.toString(args.size()));\n        writer.newLine();\n\n        for (int i = 0; i \u003c sz; i++) {\n            String arg = args.get(i);\n            writer.write(arg);\n            writer.newLine();\n        }\n\n        writer.flush();\n\n        // Should there be a timeout on this?\n        ProcessStartResult result = new ProcessStartResult();\n\n        // 等待 socket 服务端（即zygote）返回新创建的进程pid;\n        result.pid = inputStream.readInt();\n        result.usingWrapper = inputStream.readBoolean();\n\n        if (result.pid \u003c 0) {\n            throw new ZygoteStartFailedEx(\"fork() failed\");\n        }\n        return result;\n    } catch (IOException ex) {\n        zygoteState.close();\n        throw new ZygoteStartFailedEx(ex);\n    }\n}\n```\n\n在 zygoteSendArgsAndGetResult 中等待 Socket 服务端，也就是 zygote 进程返回创建新进程的结果，这里 zygoteState 参数是由 openZygoteSocketIfNeeded 方法返回的，openZygoteSocketIfNeeded 方法则负责根据 abi 向 Zygote 进程发起连接请求：\n\n```java\nprivate static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n        try {\n            // 向主zygote发起connect()操作\n            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);\n        } catch (IOException ioe) {\n            throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n        }\n    }\n\n    if (primaryZygoteState.matches(abi)) {\n        return primaryZygoteState;\n    }\n\n    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n        try {\n            // 当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作\n            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);\n        } catch (IOException ioe) {\n            throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n        }\n    }\n\n    if (secondaryZygoteState.matches(abi)) {\n        return secondaryZygoteState;\n    }\n\n    throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n}\n```\n\n## 2.2 小结\n\n如果是从桌面新启动一个 App 中的 Activity，此时是没有进程去承载这个 App 的，因此需要通过 AMS 向 zygote 继承发起请求去完成这个任务，AMS 运行在 system_server 进程中，它通过 Socket 向 zygote 发起 fock 进程的请求，从 AMS 开始的调用时序图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/App-Startup/clipboard_20230323_045449.png)\n\n# 3. zygote —— ActivityThread\n\n## 3.1 调用过程分析\n\n### 3.1.1 ZygoteInit.main\n\n在 [Android 系统启动流程分析](https://guanpj.cn/2017/09/17/Android-System-Startup-Flow-Analyze/) 文中提到过 zygote 进程的其中一项任务就是：\n\n\u003e 调用 registerZygoteSocket() 函数建立 Socket 通道，使 zygote 进程成为 Socket 服务端，并通过 runSelectLoop() 函数等待 ActivityManagerService 发送请求创建新的应用程序进程。\n\nzygote 终于要再次上场了！接下来从 ZygoteInit.java 的 main 方法开始回顾一下 zygote 进程的工作：\n\n[frameworks/base/core/java/com/android/internal/os/ZygoteInit.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/ZygoteInit.java)：\n\n```java\npublic static void main(String argv[]) {\n    try {\n        ...\n        runSelectLoop(abiList);\n        ....\n    } catch (MethodAndArgsCaller caller) {\n        caller.run();\n    } catch (RuntimeException ex) {\n        closeServerSocket();\n        throw ex;\n    }\n}\n```\n\n### 3.1.2 ZygoteInit.runSelectLoop\n\n查看 runSelectLoop 方法：\n\n```java\nprivate static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n    ...\n    // 循环读取状态\n    while (true) {\n        ...\n        for (int i = pollFds.length - 1; i \u003e= 0; --i) {\n            // 读取的状态不是客户端连接或者数据请求时，进入下一次循环\n            if ((pollFds[i].revents \u0026 POLLIN) == 0) {\n                continue;\n            }\n            if (i == 0) {// i = 0 表示跟客户端 Socket 连接上了\n                ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                peers.add(newPeer);\n                fds.add(newPeer.getFileDesciptor());\n            } else {// i \u003e 0 表示接收到客户端 Socket 发送过来的请求\n                // runOnce 方法创建一个新的应用程序进程\n                boolean done = peers.get(i).runOnce();\n                if (done) {\n                    peers.remove(i);\n                    fds.remove(i);\n                }\n            }\n        }\n    }\n}\n```\n\n### 3.1.3 ZygoteConnection.runOnce\n\n查看 [frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/ZygoteConnection.java) 的 runOnce 方法：\n\n```java\nboolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n    String args[];\n    Arguments parsedArgs = null;\n    FileDescriptor[] descriptors;\n\n    try {\n        // 读取 socket 客户端发送过来的参数列表\n        args = readArgumentList();\n        descriptors = mSocket.getAncillaryFileDescriptors();\n    } catch (IOException ex) {\n        // EOF reached.\n        closeSocket();\n        return true;\n    }\n    ...\n    try {\n        // 将 socket 客户端传递过来的参数，解析成 Arguments 对象格式\n        parsedArgs = new Arguments(args);\n        ...\n        // 同样调用 Zygote.java 的 forkAndSpecialize 方法 fock 出子进程\n        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,\n                parsedArgs.appDataDir);\n    } catch (Exception e) {\n        ...\n    }\n\n    try {\n        if (pid == 0) {\n            // 子进程执行\n            IoUtils.closeQuietly(serverPipeFd);\n            serverPipeFd = null;\n            // 进入子进程流程\n            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n            return true;\n        } else {\n            // 父进程执行\n            IoUtils.closeQuietly(childPipeFd);\n            childPipeFd = null;\n            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n        }\n    } finally {\n        IoUtils.closeQuietly(childPipeFd);\n        IoUtils.closeQuietly(serverPipeFd);\n    }\n}\n```\n\n### 3.1.4 ZygoteConnection.handleChildProc\n\n首先解析 Socket 客户端传过来的参数，[Zygote.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/Zygote.java) 的 forkAndSpecialize 返回的 pid == 0 的时候表示此时在 fock 出来的子进程中执行，继续调用 handleChildProc 方法，并将参数继续层层传递：\n\n```java\nprivate void handleChildProc(Arguments parsedArgs, FileDescriptor[] \n    descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller {\n    /*由于 fock 出来的 system_server 进程会复制 zygote 进程的地址空间，因此它也得到了 zygote\n    进程中的 Socket，这个 Socket 对它来说并无用处，这里将其关闭 \n    */\n    closeSocket();\n    ZygoteInit.closeServerSocket();\n    ...\n    if (parsedArgs.niceName != null) {\n        // 设置进程名\n        Process.setArgV0(parsedArgs.niceName);\n    }\n\n    if (parsedArgs.invokeWith != null) {\n        ...\n    } else {\n        // 调用 RuntimeInit 的 zygoteInit 方法\n        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,\n                parsedArgs.remainingArgs, null);\n    }\n}\n```\n\n### 3.1.5 RuntimeInit.zygoteInit\n\n查看 [frameworks/base/core/java/com/android/internal/os/RuntimeInit.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/RuntimeInit.java) 的 zygoteInit 方法：\n\n```java\npublic static final void zygoteInit(int targetSdkVersion, String[] argv, \n            ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller {\n    if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\");\n\n    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\");\n    // 重定向 log 输出\n    redirectLogStreams();\n    // 初始化一些通用的设置\n    commonInit(); \n    /**\n     *通过 Native 层中 AndroidRuntime.cpp 的 JNI 方法最终调用 app_main.cpp 的 \n     *onZygoteInit 方法启动 Binder 线程池， 使 system_server 进程可以使用 Binder  *与其他进程通信\n     **/\n    nativeZygoteInit(); \n    applicationInit(targetSdkVersion, argv, classLoader);\n}\n```\n\n### 3.1.6 RuntimeInit.applicationInit\n\n继续调用 applicationInit 方法：\n\n```java\nprivate static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n    ...\n    // 提取出参数里面的要启动的类的名字\n    invokeStaticMain(args.startClass, args.startArgs, classLoader);\n}\n```\n\n### 3.1.7 RuntimeInit.invokeStaticMain\n\n主要调用了 invokeStaticMain 方法：\n\n```java\nprivate static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)\n         throws ZygoteInit.MethodAndArgsCaller {\n    Class\u003c?\u003e cl;\n    try {\n        /** className 为通过 Socket 客户端（AMS）传递过来的一系列参数中的其中一个，这里获取到的值为传\"com.android.app.ActivityThread\"，然后通过反射得到 ActivityThread 类 **/\n        cl = Class.forName(className, true, classLoader);\n    } catch (ClassNotFoundException ex) {\n        throw new RuntimeException(\n            \"Missing class when invoking static main \" + className, ex);\n    }\n    Method m;\n    try {\n        // 找到 ActivityThread 类的 main 方法\n        m = cl.getMethod(\"main\", new Class[] { String[].class });\n    } catch (NoSuchMethodException ex) {\n        throw new RuntimeException(\n            \"Missing static main on \" + className, ex);\n    } catch (SecurityException ex) {\n        throw new RuntimeException(\n            \"Problem getting static main on \" + className, ex);\n    }\n    int modifiers = m.getModifiers();\n    if (! (Modifier.isStatic(modifiers) \u0026\u0026 Modifier.isPublic(modifiers))) {\n        throw new RuntimeException(\n            \"Main method is not public and static on \" + className);\n    }\n    /** 将 main 方法包装在 ZygoteInit.MethodAndArgsCaller 类中并作为异常抛出\n    捕获异常的地方在上一小节中 ZygoteInit.java 的 main 方法 **/\n    throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n}\n```\n\n### 3.1.8 MethodAndArgsCaller.run\n\n回到 ZygoteInit 的 main 方法：\n\n```java\npublic static void main(String argv[]) {\n    ...\n    closeServerSocket();\n    } catch (MethodAndArgsCaller caller) {\n        // 接收到 caller 对象后调用它的 run 方法\n        caller.run();\n    } catch (RuntimeException ex) {\n        Log.e(TAG, \"Zygote died with exception\", ex);\n        closeServerSocket();\n        throw ex;\n    }\n}\n```\n\n跟 system_server 进程的启动过程一样，这里同样通过抛出异常的方式来清空调用 ActivityThread.main 之前的方法栈帧。\n\nZygoteInit 的 MethodAndArgsCaller 类是一个 Exception 类，同时也实现了 Runnable 接口：\n\n```java\npublic static class MethodAndArgsCaller extends Exception\n        implements Runnable {\n        \n    private final Method mMethod;\n    private final String[] mArgs;\n        \n    public MethodAndArgsCaller(Method method, String[] args) {\n        mMethod = method;\n        mArgs = args;\n    }\n    public void run() {\n        try {\n            // 调用传递过来的 mMethod\n            mMethod.invoke(null, new Object[] { mArgs });\n        } catch (IllegalAccessException ex) {\n            throw new RuntimeException(ex);\n        } catch (InvocationTargetException ex) {\n            ...\n        }\n    }\n}\n```\n\n### 3.1.9 ActivityThread .main\n\n最后通过反射调用到 ActivityThread 的 main 方法：\n\n```java\npublic static void main(String[] args) {\n    ...\n    Environment.initForCurrentUser();\n    ...\n    Process.setArgV0(\"\u003cpre-initialized\u003e\");\n    // 创建主线程 Looper\n    Looper.prepareMainLooper();\n\n    ActivityThread thread = new ActivityThread();\n    // attach 到系统进程\n    thread.attach(false);\n\n    if (sMainThreadHandler == null) {\n        sMainThreadHandler = thread.getHandler();\n    }\n\n    // 主线程进入轮询状态\n    Looper.loop();\n\n    // 抛出异常说明轮询出现问题\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n```\n\n## 3.2 小结\n\nzygote 进程作为 Socket 服务端在接收到作为客户端的 AMS 发送过来的请求和参数之后，fock 出新的进程并根据各种参数进程了初始化的工作，这个过程和 zygote 启动 system_server 进程的过程如出一辙，时序图如下所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/App-Startup/clipboard_20230323_045452.png)\n\n# 4. ActivityThread —— Activity\n\n## 4.1 调用过程分析\n\n### 4.1.1 ActivityThread.attach\n\n上一小节的最后，ActivityThread 的 main 通过反射被运行起来了，接着会调用 ActivityThread 的 attach 方法：\n\n```java\nprivate void attach(boolean system) {\n    ...\n    mSystemThread = system;\n    if (!system) {\n        ...\n        // 获取 ActivityManagerProxy 对象\n        final IActivityManager mgr = ActivityManagerNative.getDefault();\n        try {\n            // 通过 Binder 调用 AMS 的 attachApplication 方法\n            mgr.attachApplication(mAppThread);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    } else {\n        ...\n    }\n    ...\n}\n```\n\n这里，我们再一次通过 Binder IPC 机制跟 AMS 通信，通信模型跟前面 Launcher App 调用 AMS 的 startActivity 方法一样，getDefault 过程不重复分析，这次是调用了 AMS 的 attachApplication 方法，注意这里将 ApplicationThead 类型的 mAppThread 对象作为参数传递了过去，ApplicationThead 是 ActivityThread 的一个内部类，后面我们会讲到，先查看 AMP 的 attachApplication 方法：\n\n### 4.1.2 ActivityManagerProxy.attachApplication\n\n```java\npublic void attachApplication(IApplicationThread app) throws RemoteException {\n    ...\n    // 调用 asBinder 方法使其能够跨进程传输\n    data.writeStrongBinder(app.asBinder());\n    // 通过 transact 方法将数据交给 Binder 驱动\n    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); \n    reply.readException();\n    data.recycle();\n    reply.recycle();\n}\n```\n\n### 4.1.3 ActivityManagerNative.onTransact\n\n```java\npublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {\n    switch (code) {\n        ...\n        case ATTACH_APPLICATION_TRANSACTION: {\n            data.enforceInterface(IActivityManager.descriptor);\n            // 获取 ApplicationThread 的代理对象，这里返回的是 ApplicationThreadNative(ATN)\n            // 的内部类：ApplicationThreadProxy(ATP) 对象\n            IApplicationThread app = ApplicationThreadNative.asInterface(data.readStrongBinder());\n            if (app != null) {\n                // 委托给 AMS 执行\n                attachApplication(app);\n            }\n            reply.writeNoException();\n            return true;\n        }\n        ...\n    }\n}\n```\n\nasInterface 将 ActivityThread 对象转换成了 [ApplicationThreadNative(ATN)]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/android/app/ActivityManagerNative.java) 的 Binder 代理对象 ApplicationThreadProxy(ATP)，并作为参数传给 attachApplication 方法，其中 ATP 是 ATN 的内部类。\n\n### 4.1.4 ActivityManagerService.attachApplication\n\n```java\npublic final void attachApplication(IApplicationThread thread) {\n    synchronized (this) {\n        int callingPid = Binder.getCallingPid();\n        final long origId = Binder.clearCallingIdentity();\n        attachApplicationLocked(thread, callingPid);\n        Binder.restoreCallingIdentity(origId);\n    }\n}\n```\n\n### 4.1.5 ActivityManagerService.attachApplicationLocked\n\n```java\nprivate final boolean attachApplicationLocked(IApplicationThread thread, int pid) {\n    ProcessRecord app;\n    ...\n    try {\n        // 绑定死亡通知\n        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);\n        thread.asBinder().linkToDeath(adr, 0);\n        app.deathRecipient = adr;\n    } catch (RemoteException e) {\n        app.resetPackageList(mProcessStats);\n        // 如果 system_server 进程死亡则重新启动进程\n        startProcessLocked(app, \"link fail\", processName); \n        return false;\n    }\n    ...\n    try {\n        ...\n        // 获取应用appInfo\n        ApplicationInfo appInfo = app.instrumentationInfo != null\n                ? app.instrumentationInfo : app.info;\n        ...\n        // 绑定应用\n        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n                app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n                isRestrictedBackupMode || !normalMode, app.persistent,\n                new Configuration(mConfiguration), app.compat,\n                getCommonServicesLocked(app.isolated),\n                mCoreSettingsObserver.getCoreSettingsLocked());\n        ...\n    } catch (Exception e) {\n        app.resetPackageList(mProcessStats);\n        app.unlinkDeathRecipient();\n        // bindApplication 失败也要重启进程\n        startProcessLocked(app, \"bind fail\", processName);\n        return false;\n    }\n    // 如果是 Activity: 检查最顶层可见的Activity是否等待在该进程中运行\n    if (normalMode) {\n        try {\n            if (mStackSupervisor.attachApplicationLocked(app)) {\n                didSomething = true;\n            }\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n    // 如果是 Service: 寻找所有需要在该进程中运行的服务\n    if (!badApp) {\n        try {\n            didSomething |= mServices.attachApplicationLocked(app, processName);\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n\n    // 如果是 BroadcastReceiver: 检查是否在这个进程中有下一个广播接收者\n    if (!badApp \u0026\u0026 isPendingBroadcastProcessLocked(pid)) {\n        try {\n            didSomething |= sendPendingBroadcastsLocked(app);\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n    // 检查是否在这个进程中有下一个 backup 代理\n    if (!badApp \u0026\u0026 mBackupTarget != null \u0026\u0026 mBackupTarget.appInfo.uid == app.uid) {\n        ensurePackageDexOpt(mBackupTarget.appInfo.packageName);\n        try {\n            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,\n                    compatibilityInfoForPackageLocked(mBackupTarget.appInfo),\n                    mBackupTarget.backupMode);\n        } catch (Exception e) {\n            badApp = true;\n        }\n    }\n    if (badApp) { \n        // 杀掉 badApp\n        app.kill(\"error during init\", true);\n        handleAppDiedLocked(app, false, true);\n        return false;\n    }\n    if (!didSomething) {\n        // 更新 adj(组件的权值)\n        updateOomAdjLocked(); \n    }\n    return true;\n}\n```\n\n首先，通过 ATP 使用 Binder 向 ATN 发起 bindApplication 请求，然后通过 normalMode 字段判断是否为 Activity，如果是则执行 ActivityStackSupervisor 的 attachApplicationLocked 方法。\n\n#### \u003cstrong\u003e4.1.5.1 ActivityThread.java::ApplicationThread.bindApplication\u003c/strong\u003e\n\nthread 对象类型是 ATP，通过 Binder 驱动调到了 ATN 的方法，ATN 是一个抽象类，它的实现都委托给了 ApplicationThread(这跟 AMS 跟 AMN 的关系一样)，ApplicationThread 作为 ActivityThread 的内部类存在，它的 binderApplication 方法如下：\n\n[ActivityThread.java::ApplicationThread]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/android/app/ActivityThread.java)：\n\n```java\npublic final void bindApplication(String processName, ApplicationInfo appInfo,\n    List\u003cProviderInfo\u003e providers, ComponentName instrumentationName, ProfilerInfo profilerInfo,\n    Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher,\n    IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean\n    enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration\n    config, CompatibilityInfo compatInfo, Map\u003cString, IBinder\u003e services, Bundle coreSettings) {\n\n    if (services != null) {\n        // 将services缓存起来, 减少binder检索服务的次数\n        ServiceManager.initServiceCache(services);\n    }\n    ...\n    // 发送消息 H.BIND_APPLICATION 给 Handler 对象\n    sendMessage(H.BIND_APPLICATION, data);\n}\n```\n\nH 是 ActivityThread 中的一个 Handler 对象，用于处理发送过来的各种消息：\n\n```java\nprivate class H extends Handler {\n    public static final int BIND_APPLICATION        = 110;\n \n    public void handleMessage(Message msg) {\n        ...\n        case BIND_APPLICATION:\n            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n            AppBindData data = (AppBindData)msg.obj;\n            handleBindApplication(data);\n            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n            break;\n        ...\n    }\n}\n```\n\n调用了 handleBindApplication 方法：\n\n```java\nprivate void handleBindApplication(AppBindData data) {\n    // 获取 LoadedApk 对象\n    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);\n    ...\n    // 创建 ContextImpl 上下文\n    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);\n    ...\n    // 创建 Instrumentation 对象\n    if (data.instrumentationName != null) {\n        ...\n    } else {\n        mInstrumentation = new Instrumentation();\n    }\n\n    try {\n        // 调用 LoadedApk 的 makeApplication 方法创建 Application\n        Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n        mInitialApplication = app;\n        ...\n        mInstrumentation.onCreate(data.instrumentationArgs);\n        // 调用 Application.onCreate 方法\n        mInstrumentation.callApplicationOnCreate(app);\n    } finally {\n        StrictMode.setThreadPolicy(savedPolicy);\n    }\n}\n```\n\n#### \u003cstrong\u003e4.1.5.2 ActivityStackSupervisor.attachApplicationLocked\u003c/strong\u003e\n\n在 \u003cstrong\u003e4.1.4\u003c/strong\u003e 小节中通过 Binder 向 ActivityThread 发起 bindApplication 请求后，会根据启动组件的类型去做相应的处理，如果是 Acitivity，则会调用 ActivityStackSupervisor 的 attachApplicationLocked 方法：\n\n```java\nboolean attachApplicationLocked(ProcessRecord app) throws RemoteException {\n    final String processName = app.processName;\n    boolean didSomething = false;\n    for (int displayNdx = mActivityDisplays.size() - 1; displayNdx \u003e= 0; --displayNdx) {\n        ArrayList\u003cActivityStack\u003e stacks = mActivityDisplays.valueAt(displayNdx).mStacks;\n        for (int stackNdx = stacks.size() - 1; stackNdx \u003e= 0; --stackNdx) {\n            final ActivityStack stack = stacks.get(stackNdx);\n            if (!isFrontStack(stack)) {\n                continue;\n            }\n            // 获取前台stack中栈顶第一个非 finishing 状态的 Activity\n            ActivityRecord hr = stack.topRunningActivityLocked(null);\n            if (hr != null) {\n                if (hr.app == null \u0026\u0026 app.uid == hr.info.applicationInfo.uid \u0026\u0026 processName.equals(hr.processName)) {\n                    try {\n                        // 真正的启动 Activity\n                        if (realStartActivityLocked(hr, app, true, true)) {\n                            didSomething = true;\n                        }\n                    } catch (RemoteException e) {\n                        throw e;\n                    }\n                }\n            }\n        }\n    }\n    ...\n    return didSomething;\n}\n```\n\n##### \u003cstrong\u003e4.1.5.2.1 ActivityStackSupervisor.realStartActivityLocked\u003c/strong\u003e\n\n前面 \u003cstrong\u003e2.1.8 ActivityStackSupervisor.startSpecificActivityLocked\u003c/strong\u003e 小节中分析过，如果当前 Activity 依附的 Application 已经被启动，则调用 realStartActivityLocked 方法，否则创建新的进程，再创建新的进程之后，两个流程的在这里合并起来了：\n\n```java\nfinal boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException {\n    ...\n    final ActivityStack stack = task.stack;\n    try {\n        ...\n        app.forceProcessStateUpTo(mService.mTopProcessState);\n        // 通过 Binder 调用 ApplicationThread 的 scheduleLaunchActivity 方法\n        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,\n                System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),\n                new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage,\n                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,\n                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);\n        ...\n    } catch (RemoteException e) {\n        if (r.launchFailed) {\n            // 第二次启动失败，则结束该 Activity\n            mService.appDiedLocked(app);\n            stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,\n                    \"2nd-crash\", false);\n            return false;\n        }\n        // 第一个启动失败，则重启进程\n        app.activities.remove(r);\n        throw e;\n    }\n    ...\n    return true;\n}\n```\n\n这里有一次使用 Binder 调用 ApplicationThread 的 scheduleLaunchActivity 方法。\n\n##### \u003cstrong\u003e4.1.5.2.2 ApplicationThread.scheduleLaunchActivity\u003c/strong\u003e\n\n```java\npublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo \n        info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo \n        compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle \n        state, PersistableBundle persistentState, List\u003cResultInfo\u003e pendingResults, \n        List\u003cReferrerIntent\u003e pendingNewIntents, boolean notResumed, boolean isForward, \n        ProfilerInfo profilerInfo) {\n    ...\n    updateProcessState(procState, false);\n    ActivityClientRecord r = new ActivityClientRecord();\n    ...\n    sendMessage(H.LAUNCH_ACTIVITY, r);\n }\n```\n\n上面提到过，H 是 ActivityThread 中一个 Handler 类，它接收到 LAUNCH_ACTIVITY 消息后会调用 handleLaunchActivity 方法。\n\n##### \u003cstrong\u003e4.1.5.2.3 ActivityThread.handleLaunchActivity\u003c/strong\u003e\n\n```java\nprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    // 初始化 WMS\n    WindowManagerGlobal.initialize();\n    // 执行 performLaunchActivity 方法\n    Activity a = performLaunchActivity(r, customIntent);\n    if (a != null) {\n        r.createdConfig = new Configuration(mConfiguration);\n        Bundle oldState = r.state;\n        // 执行 handleResumeActivity 方法，最终调用 onStart 和 onResume 方法\n        handleResumeActivity(r.token, false, r.isForward,\n                !r.activity.mFinished \u0026\u0026 !r.startsNotResumed);\n\n        if (!r.activity.mFinished \u0026\u0026 r.startsNotResumed) {\n            r.activity.mCalled = false;\n            mInstrumentation.callActivityOnPause(r.activity);\n            r.paused = true;\n        }\n    } else {\n        // 停止该 Activity\n        ActivityManagerNative.getDefault()\n            .finishActivity(r.token, Activity.RESULT_CANCELED, null, false);\n    }\n}\n```\n\n##### \u003cstrong\u003e4.1.4.2.4 ApplicationThread.performLaunchActivity\u003c/strong\u003e\n\n```java\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    Activity activity = null;\n    try {\n        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();\n        // Instrumentation 中使用反射创建 Activity\n        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n        ...\n    } catch (Exception e) {\n        ...\n    }\n\n    try {\n        // 创建 Application 对象并调用 Application 的 onCreate 方法\n        Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n\n        if (activity != null) {\n            ...\n            Window window = null;\n            if (r.mPendingRemoveWindow != null \u0026\u0026 r.mPreserveWindow) {\n                window = r.mPendingRemoveWindow;\n                r.mPendingRemoveWindow = null;\n                r.mPendingRemoveWindowManager = null;\n            }\n            // attach 到 Window 上\n            activity.attach(appContext, this, getInstrumentation(), r.token,\n                    r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                    r.embeddedID, r.lastNonConfigurationInstances, config,\n                    r.referrer, r.voiceInteractor, window);\n\n            if (customIntent != null) {\n                activity.mIntent = customIntent;\n            }\n            r.lastNonConfigurationInstances = null;\n            activity.mStartedActivity = false;\n            int theme = r.activityInfo.getThemeResource();\n            if (theme != 0) {\n                // 设置主题\n                activity.setTheme(theme);\n            }\n\n            activity.mCalled = false;\n            if (r.isPersistable()) {\n                // 重新创建的 Activity\n                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n            } else {\n                // 第一次创建的 Activity\n                mInstrumentation.callActivityOnCreate(activity, r.state);\n            }\n            ...\n        }\n        ...\n    }  catch (Exception e) {\n        ...\n    }\n    return activity;\n}\n```\n\n##### \u003cstrong\u003e4.1.5.2.5 Instrumentation.callActivityOnCreate\u003c/strong\u003e\n\n```java\npublic void callActivityOnCreate(Activity activity, Bundle icicle,\n            PersistableBundle persistentState) {\n    prePerformCreate(activity);\n    // 调用 Activity 的 performCreate 方法\n    activity.performCreate(icicle, persistentState);\n    postPerformCreate(activity);\n}\n```\n\n##### \u003cstrong\u003e4.1.5.2.6 Activity.performCreate\u003c/strong\u003e\n\n```java\nfinal void performCreate(Bundle icicle, PersistableBundle persistentState) {\n        restoreHasCurrentPermissionRequest(icicle);\n    onCreate(icicle, persistentState);\n    mActivityTransitionState.readState(icicle);\n    performCreateCommon();\n}\n```\n\n终于，onCreate 方法被调用了！！！\n\n## 4.2 小结\n\n从 ActivityThread 到最终 Activity 被创建及生命周期被调用，核心过程涉及到了三次 Binder IPC 过程，分别是：ActivityThread 调用 AMS 的 attachApplication 方法、AMS 调用 ApplicationThread 的 bindApplication 方法、ASS 调用 Application 的 attachApplicationLocked 方法，整个过程的时序图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/App-Startup/clipboard_20230323_045420.png)\n\n# 5. 总结\n\n纵观整个过程，从 Launcher 到 AMS、从 AMS 再到 Zygote、再从 Zygote 到 ActivityThread，最后在 ActivitThread 中层层调用到 Activity 的生命周期方法，中间涉及到了无数的细节，但总体上脉络还是非常清晰的，各个 Android 版本的 Framework 层代码可以某些过程的实现不太一样，但是整个调用流程大体上也是相同的，借用 [Gityuan](http://gityuan.com/android/) 大神的一张图作为结尾：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/App-Startup/clipboard_20230323_045430.png)\n\n\u003cstrong\u003e系列文章\u003c/strong\u003e\n\n[按下电源键后竟然发生了这一幕 —— Android 系统启动流程分析](https://guanpj.cn/2017/09/17/Android-System-Startup-Flow-Analyze/)\n\n[App 竟然是这样跑起来的 —— Android App/Activity 启动流程分析](https://guanpj.cn/2017/10/23/Android-App-Startup-Flow-Analyze/)（本文）\n\n[屏幕上内容究竟是怎样画出来的 —— Android View 工作原理详解](https://guanpj.cn/2017/11/09/Android-View-Workflow/)\n\n\u003cstrong\u003e参考文章\u003c/strong\u003e\n\n[startActivity 启动过程分析](http://gityuan.com/2016/03/12/start-activity/)\n\n[Android 深入四大组件（一）应用程序启动过程（前篇）](http://liuwangshu.cn/framework/component/1-activity-start-1.html)\n\n\u003e 如果你对文章内容有疑问或者有不同的意见，欢迎留言，我们一同探讨。\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["zygote","AMS","ActivityThread","Framework"]},"/%E5%85%ADView-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90":{"title":"六、View 绘制流程分析","content":"在我的系列文章上一篇：[App 竟然是这样跑起来的 —— Android App/Activity 启动流程分析](https://guanpj.cn/2017/10/23/Android-App-Startup-Flow-Analyze/) 中已经分析了一个 App 从点击它的图标到 Activity 的 onCreate()、onStart() 和 onResume() 等生命周期被调用的整个流程。我们都知道，普通 App 屏幕上显示的内容都是由一个个自己设计的界面被系统加载而来的，而这些界面中的元素又是怎么被渲染出来的呢？本文将继续基于 Android Nougat 从源码的角度来进一步分析整个过程。\n\n在开始之前，回顾一下上一篇文章中分析的从 ActivityThread 到 Activity 过程的时序图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/View-Draw/clipboard_20230323_045616.png)\n\n# 一：初始化 PhoneWindow 和 WindowManager\n\n如上图所示，在 Activity 的 onCreate()、onStart() 和 onResume() 等生命周期被调用之前，它的 attach() 方法将会先被调用，因此，我们将 attach() 方法作为这篇文章主线的开头：\n\n```java\nfinal void attach(Context context, ActivityThread aThread,\n        Instrumentation instr, IBinder token, int ident,\n        Application application, Intent intent, ActivityInfo info,\n        CharSequence title, Activity parent, String id,\n        NonConfigurationInstances lastNonConfigurationInstances,\n        Configuration config, String referrer, IVoiceInteractor voiceInteractor,\n        Window window) {\n    attachBaseContext(context);\n    ...\n    // mWindow 是一个 PhoneWindow 对象实例\n    mWindow = new PhoneWindow(this, window);\n    mWindow.setWindowControllerCallback(this);\n    mWindow.setCallback(this);\n    mWindow.setOnWindowDismissedCallback(this);\n    mWindow.getLayoutInflater().setPrivateFactory(this);\n    ...\n    // 调用 Window 的 setWindowManager 方法\n    mWindow.setWindowManager(\n            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),\n            mToken, mComponent.flattenToString(),\n            (info.flags \u0026 ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);\n    if (mParent != null) {\n        mWindow.setContainer(mParent.getWindow());\n    }\n    // 从 Window 中获取 WindowManager\n    mWindowManager = mWindow.getWindowManager();\n    mCurrentConfig = config;\n}\n```\n\nmWindow 是一个 Window 类型的变量，在 attach() 方法中，创建了一个 PhoneWindow 对象实例并赋值给了 mWindow，PhoneWindow 直接继承自 Window 类。然后调用了 Window 的 setWindowManager() 方法：\n\n```java\npublic void setWindowManager(WindowManager wm, IBinder appToken, String appName,\n        boolean hardwareAccelerated) {\n    ...\n    // mWindowManager 就是 WindowManagerImpl 对象的实例\n    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);\n}\n```\n\n因此，Acitvity 中的 mWindow 变量就是 PhoneWindow 类的实例，而 mWindowManager 是 WindowManagerImpl 类的实例，attach() 方法的主要工作就是初始化这两个变量。\n\n# 二：初始化 DecorView\n\n## 源码分析\n\n接下来到了 onCreate 方法，我们都知道，如果想要让自己设计的 layout 布局文件或者 View 显示在 Activity 中，必须要在 Activity 的 onCreate() 方法中应该调用 setContentView() 方法将我们的布局 id 或者 View 传递过去，查看其中一个 setContentView() 方法：\n\n```java\npublic void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n```\n\n继续查看 PhoneWindow 类的 setContentView() 方法：\n\n```java\npublic void setContentView(int layoutResID) {\n    if (mContentParent == null) {// 是否首次调用\n        // 初始化 Decor\n        installDecor();\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {// 转场动画，默认 false\n        mContentParent.removeAllViews();\n    }\n\n    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        ...\n    } else {\n        // 解析布局文件\n        mLayoutInflater.inflate(layoutResID, mContentParent);\n    }\n    ...\n}\n```\n\n如果是首次调用这个方法，则 mContentParent 为 null，否则如果没有转场动画的话就移除 mContentParent 的全部子 View，继续跟踪 installDecor() 方法：\n\n```java\nprivate void installDecor() {\n    mForceDecorInstall = false;\n    if (mDecor == null) {\n        // 生成 DecorView 对象\n        mDecor = generateDecor(-1);\n        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n        mDecor.setIsRootNamespace(true);\n        if (!mInvalidatePanelMenuPosted \u0026\u0026 mInvalidatePanelMenuFeatures != 0) {\n            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);\n        }\n    } else {\n        mDecor.setWindow(this);\n    }\n    if (mContentParent == null) {\n        // 调用 generateLayout 方法\n        mContentParent = generateLayout(mDecor);\n        ...\n    }\n}\n```\n\n当 mDecor 为 null 的时候会调用 generateDecor() 方法创建一个 DecorView 类的实例，DecorView 继承自 FrameLayout。接下来判断 mContentParent 是否为 null（前面已经提到过，首次加载的时候就是 null），如果是则调用 generateLayout() 方法，这个方法就会创建 mContentParent 对象，跟踪进去：\n\n```java\nprotected ViewGroup generateLayout(DecorView decor) {\n    TypedArray a = getWindowStyle();\n    ...\n    // 通过 WindowStyle 中设置的各种属性对 Window 进行各种初始化操作\n    mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false);\n    int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR)\n            \u0026 (~getForcedWindowFlags());\n    if (mIsFloating) {\n        setLayout(WRAP_CONTENT, WRAP_CONTENT);\n        setFlags(0, flagsToUpdate);\n    } else {\n        setFlags(FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR, flagsToUpdate);\n    }\n    ....\n\n    int layoutResource;\n    int features = getLocalFeatures();\n\n    // 根据设定好的 features 值获取相应的布局文件并赋值给 layoutResource\n    if ((features \u0026 (1 \u003c\u003c FEATURE_SWIPE_TO_DISMISS)) != 0) {\n        layoutResource = R.layout.screen_swipe_dismiss;\n    } else if ((features \u0026 ((1 \u003c\u003c FEATURE_LEFT_ICON) | (1 \u003c\u003c FEATURE_RIGHT_ICON))) != 0) {\n        if (mIsFloating) {\n            TypedValue res = new TypedValue();\n            getContext().getTheme().resolveAttribute(\n                    R.attr.dialogTitleIconsDecorLayout, res, true);\n            layoutResource = res.resourceId;\n        } else {\n            layoutResource = R.layout.screen_title_icons;\n        }\n        removeFeature(FEATURE_ACTION_BAR);\n    } else if ((features \u0026 ((1 \u003c\u003c FEATURE_PROGRESS) | (1 \u003c\u003c FEATURE_INDETERMINATE_PROGRESS))) != 0\n            \u0026\u0026 (features \u0026 (1 \u003c\u003c FEATURE_ACTION_BAR)) == 0) {\n        layoutResource = R.layout.screen_progress;\n    } else if ((features \u0026 (1 \u003c\u003c FEATURE_CUSTOM_TITLE)) != 0) {\n        if (mIsFloating) {\n            TypedValue res = new TypedValue();\n            getContext().getTheme().resolveAttribute(\n                    R.attr.dialogCustomTitleDecorLayout, res, true);\n            layoutResource = res.resourceId;\n        } else {\n            layoutResource = R.layout.screen_custom_title;\n        }\n        removeFeature(FEATURE_ACTION_BAR);\n    } else if ((features \u0026 (1 \u003c\u003c FEATURE_NO_TITLE)) == 0) {\n        if (mIsFloating) {\n            TypedValue res = new TypedValue();\n            getContext().getTheme().resolveAttribute(\n                    R.attr.dialogTitleDecorLayout, res, true);\n            layoutResource = res.resourceId;\n        } else if ((features \u0026 (1 \u003c\u003c FEATURE_ACTION_BAR)) != 0) {\n            layoutResource = a.getResourceId(\n                    R.styleable.Window_windowActionBarFullscreenDecorLayout,\n                    R.layout.screen_action_bar);\n        } else {\n            layoutResource = R.layout.screen_title;\n        }\n    } else if ((features \u0026 (1 \u003c\u003c FEATURE_ACTION_MODE_OVERLAY)) != 0) {\n        layoutResource = R.layout.screen_simple_overlay_action_mode;\n    } else {\n        layoutResource = R.layout.screen_simple;\n    }\n\n    mDecor.startChanging();\n    // 调用 onResourcesLoaded 方法\n    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);\n\n    // 在 layoutResource 中根据 id:com.android.internal.R.id.content 获取一个 ViewGroup 并赋值给 contentParent  对象\n    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);\n    if (contentParent == null) {\n        throw new RuntimeException(\"Window couldn't find content container view\");\n    }\n    ...\n    mDecor.finishChanging();\n    // 返回 contentParent\n    return contentParent;\n}\n```\n\nDecorView 的 onResourcesLoaded() 方法：\n\n```java\nvoid onResourcesLoaded(LayoutInflater inflater, int layoutResource) {\n    ...\n    mDecorCaptionView = createDecorCaptionView(inflater);\n    // 解析 layoutResource 文件\n    final View root = inflater.inflate(layoutResource, null);\n    if (mDecorCaptionView != null) {\n        ...\n    } else {\n        // 作为根布局添加到 mDecor 中\n        addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));\n    }\n    mContentRoot = (ViewGroup) root;\n    initializeElevation();\n}\n```\n\n可以看到，generateLayout() 方法主要分为四个部分：\n\n1. 首先会通过 com.android.internal.R.styleable.Window 中设置的各种属性对 Window 进行各 requestFeature 或者 setFlags 等操作。\n2. 接下来是根据设定好的 features 值选择不同的窗口修饰布局文件，得到 layoutResource 值。\n\n\u003e 因此在自己的 Activity 中设置全屏的 requestFeature() 等方法也需要在 setContentView 之前调用，才能够根据你的设置来选择不同的根布局。\n\n3. 将 layoutResource 值传给 DecorView 的 onResourcesLoaded() 方法，通过 LayoutInflater 把布局转化成 View 作为根视图并将其添加到 mDecor。\n4. 在 mDecor 中查找 id 为 com.android.internal.R.id.content 的 ViewGroup 并作为返回值返回，这个 ViewGroup 一般为 FrameLayout。\n\n关于第四点，可能有人会有疑问，为什么根据 id 为 com.android.internal.R.id.content 就一定能找到对应的 ViewGroup？答案就在前面我们分析过的 generateLayout() 方法中，这里会根据设定好的 features 值获取相应的布局文件并赋值给 layoutResource，而这所有的布局文件中都包括了一个 id 为 content 的 FrameLayout，除此之外有些布局文件中还可能有 ActiionBar 和 Title 等，这些布局文件存放于 [该目录下]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/res/res/layout/)。以 R.layout.screen_simple 为例，它的内容如下：\n\n```xml\n\u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:fitsSystemWindows=\"true\"\n    android:orientation=\"vertical\"\u003e\n    \u003cViewStub android:id=\"@+id/action_mode_bar_stub\"\n          android:inflatedId=\"@+id/action_mode_bar\"\n          android:layout=\"@layout/action_mode_bar\"\n          android:layout_width=\"match_parent\"\n          android:layout_height=\"wrap_content\"\n          android:theme=\"?attr/actionBarTheme\" /\u003e\n    \u003cFrameLayout\n         android:id=\"@android:id/content\"\n         android:layout_width=\"match_parent\"\n         android:layout_height=\"match_parent\"\n         android:foregroundInsidePadding=\"false\"\n         android:foregroundGravity=\"fill_horizontal|top\"\n         android:foreground=\"?android:attr/windowContentOverlay\" /\u003e\n\u003c/LinearLayout\u003e\n```\n\n回到 PhoneWindow 的 setContentView() 方法，执行完 installDecor() 之后，mDecor 被初始化了，同时 mContentParent 也被赋了值， 回到 setContentView() 方法，最后一个重要步骤就是通过 mLayoutInflater.inflater 将我们的 layout 布局文件压入 mDecor 中 id 为 content 的 FrameLayout 中。\n\n```java\npublic void setContentView(int layoutResID) {\n    if (mContentParent == null) {// 是否首次调用\n        // 初始化 Decor\n        installDecor();\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {// 转场动画，默认 false\n        mContentParent.removeAllViews();\n    }\n\n    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        ...\n    } else {\n        // 解析布局文件\n        mLayoutInflater.inflate(layoutResID, mContentParent);\n    }\n    ...\n}\n```\n\n## 小结\n\n至此，setContentView() 方法的流程就走完了，总体来看分为三个步骤：\n\n1. 初始化 mDecor，它是 DecorView 类的实例，DecorView 继承自 FrameLayout；\n2. 根据 theme 中的属性值，选择相应的布局文件并通过 infalter.inflater() 方法将它加载出来并 add 到 mDecor 中；这些布局文件都有一个 id 为 content 的 FrameLayout；\n3. 在 Activity 的 setContentView() 方法中设置的 layout 布局文件，会通过 mLayoutInflater.inflater() 压入 mDecor 中 id 为 content 的 FrameLayout 中。\n\n这个过程的时序图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/View-Draw/clipboard_20230323_045625.png)\n\nActivity、PhoneWindow、DecorView 和 ContentView 的关系如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/View-Draw/clipboard_20230323_045628.png)\n\n但是，此时我们的布局还没有显示出来，接着往下看。\n\n# 三：初始化 ViewRootImpl 并关联 DecorView\n\n## 源码分析\n\n在开篇的时序图中我们可以看到，ActivityThread 在 handleLaunchActivity() 方法中的 performLaunchActivity() 操作间接调用了 Activity 的 attach() 和 onCreate()：\n\n```java\nprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    WindowManagerGlobal.initialize();\n    // 执行 performLaunchActivity 方法\n    Activity a = performLaunchActivity(r, customIntent);\n    if (a != null) {\n        r.createdConfig = new Configuration(mConfiguration);\n        Bundle oldState = r.state;\n        // 执行 handleResumeActivity 方法，最终调用 onStart 和 onResume 方法\n        handleResumeActivity(r.token, false, r.isForward,\n                !r.activity.mFinished \u0026\u0026 !r.startsNotResumed);\n\n        if (!r.activity.mFinished \u0026\u0026 r.startsNotResumed) {\n            r.activity.mCalled = false;\n            mInstrumentation.callActivityOnPause(r.activity);\n            r.paused = true;\n        }\n    } else {\n        // 停止该 Activity\n        ActivityManagerNative.getDefault()\n            .finishActivity(r.token, Activity.RESULT_CANCELED, null, false);\n    }\n}\n```\n\n接着会调用 handleResumeActivity() 方法：\n\n```java\nfinal void handleResumeActivity(IBinder token,\n            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {\n    ActivityClientRecord r = mActivities.get(token);\n    ...\n    // 最终会调用 onStart() 和 onResume() 等方法\n    r = performResumeActivity(token, clearHide, reason);\n\n    if (r != null) {\n        final Activity a = r.activity;\n        ...\n        if (r.window == null \u0026\u0026 !a.mFinished \u0026\u0026 willBeVisible) {\n            r.window = r.activity.getWindow();\n            // 获取 DecorView \n            View decor = r.window.getDecorView();\n            // 将 DecorView 设置成不可见\n            decor.setVisibility(View.INVISIBLE);\n            // 获取 ViewManager，这里是 WindowManagerImpl 实例\n            ViewManager wm = a.getWindowManager();\n            WindowManager.LayoutParams l = r.window.getAttributes();\n            a.mDecor = decor;\n            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n            l.softInputMode |= forwardBit;\n            ...\n            if (a.mVisibleFromClient \u0026\u0026 !a.mWindowAdded) {\n                // 标记设置为 true\n                a.mWindowAdded = true;\n                // 调用 WindowManagerImpl 的 addView 方法\n                wm.addView(decor, l);\n            } \n        } else if (!willBeVisible) {\n            ...\n        }\n        ...\n        if (!r.activity.mFinished \u0026\u0026 willBeVisible\n                \u0026\u0026 r.activity.mDecor != null \u0026\u0026 !r.hideForNow) {\n            ...\n            if (r.activity.mVisibleFromClient) {\n                // 调用 makeVisible 方法将 DecorView 设置为可见\n                r.activity.makeVisible();\n            }\n        }\n        ...\n    } else {\n        try {\n            // 在此过程出现异常，则直接杀死 Activity\n            ActivityManagerNative.getDefault()\n                .finishActivity(token, Activity.RESULT_CANCELED, null,\n                        Activity.DONT_FINISH_TASK_WITH_ACTIVITY);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }\n}\n```\n\n执行完 performResumeActivity() 方法之后，接着会取出 ActivityClientRecord 中的 Activity 对象，并得到之前在 setContentView 流程中初始化好的 DecorView 对象，然后会将它作为参数传入 ViewManager 类型的对象 wm 的 addView 方法，ViewManager 是一个接口，那么它是由谁来实现的呢？\n\n其实这就是文章开头部分提到过的，在 Activity 的 attach() 方法中，会初始化 PhoneWindow 和 WindowManager 对象，而这个 WindowManager 对象则是由 WindowManagerImpl 来实现的。\n\n所以，Activity 的 getWindowManager() 此时获取到的就是 WindowManagerImpl 对象的实例，再看它的 addView() 方法：\n\n```java\npublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {\n    applyDefaultToken(params);\n    // mGlobal 是 WindowManagerGlobal 对象的实例\n    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);\n}\n```\n\n这里将任务委托给了 mGlobal ，而它又是 WindowManagerGlobal 对象的实例，查看它的 addView() 方法：\n\n[core/java/android/view/WindowManagerGlobal.java](https://android.googlesource.com/platform/frameworks/base/+/refs/heads/nougat-release/core/java/android/view/WindowManagerGlobal.java)\n\n```java\npublic void addView(View view, ViewGroup.LayoutParams params,\n        Display display, Window parentWindow) {\n    ...\n    \n    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;\n    if (parentWindow != null) {\n        parentWindow.adjustLayoutParamsForSubWindow(wparams);\n    } else {\n        // If there's no parent, then hardware acceleration for this view is\n        // set from the application's hardware acceleration setting.\n        final Context context = view.getContext();\n        if (context != null\n               \u0026\u0026 (context.getApplicationInfo().flags\n                    \u0026 ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) {\n            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;\n        }\n    }\n        \n    ViewRootImpl root;\n    View panelParentView = null;\n\n    synchronized (mLock) {\n        ...\n        // 创建 ViewRootImpl\n        root = new ViewRootImpl(view.getContext(), display);\n\n        view.setLayoutParams(wparams);\n\n        mViews.add(view);\n        mRoots.add(root);\n        mParams.add(wparams);\n    }\n\n    try {\n        // 将传过来的 DecorView 添加到 ViewRootImpl 中\n        root.setView(view, wparams, panelParentView);\n    } catch (RuntimeException e) {\n        ...\n    }\n }\n```\n\n上面的变量中，mViews 存储的是所有 Window 对应的 View，mRoots 存储的是所有 Window 对应的 ViewRootImpl 对象，mParams 存储的是所有 Window 对应的布局参数。\n\n## 小结\n\n可以看到，ViewRootImpl 是 DecorView 的管理者，它负责 View Tree 的测量、布局和绘制，以及后面会说到的通过 Choreographer 来控制 View Tree 的刷新操作。\n\n# 四：建立 PhoneWindow 和 WindowManagerService 之间的连接\n\nWMS 是所有 Window 窗口的管理员，负责 Window 的添加和删除、Surface 的管理和事件的派发等等，因此每一个 Activity 中的 PhoneWindow 对象如果需要显示等操作，就必须通过与 WMS 的交互才能进行。\n\n## 源码分析\n\n接着上一个步骤的流程，查看 ViewRootImpl 的 setView 方法：\n\n```java\npublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {\n    synchronized (this) {\n        if (mView == null) {\n            mView = view;\n            ...\n            // 1\n            requestLayout();\n            ...\n            try {\n                ...\n                // 2\n                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,\n                      getHostVisibility(), mDisplay.getDisplayId(),\n                      mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,\n                      mAttachInfo.mOutsets, mInputChannel);\n            } catch (RemoteException e) {\n                ...\n            } finally {\n                if (restore) {\n                    attrs.restore();\n                }\n            }\n            ...\n            view.assignParent(this);\n            ...\n        }\n    }\n}\n```\n\n忽略 requestLayout 方法，先看注释 2 处：这里调用了 mWindowSession.addToDisplay() 方法来完成最终的添加流程，mWindowSession 为 IWindowSession 的实例，而 IWindowSession 是一个 Binder 的 Client 代理对象，对应的 Server 端的实现为 Session 类。在这之前代码都是运行在 app 进程的，而 Session 则是运行在 WMS 所在的进程（即 SystemServer 进程）中。\n\n如此，往 Window 中添加 View 的流程就交给 WindowManagerService 去处理了，app 进程的 ViewRootImpl 要想和 WMS 通讯则需要借助 Binder 机制并通过 Session 来进行操作。Session 的 addToDisplay() 方法如下：\n\n[services/core/java/com/android/server/wm/Session.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /refs/heads/nougat-release/services/core/java/com/android/server/wm/Session.java)\n\n```java\n@Override\npublic int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,\n        int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,\n        Rect outOutsets, InputChannel outInputChannel) {\n    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,\n            outContentInsets, outStableInsets, outOutsets, outInputChannel);\n}\n```\n\n可以看到，这里调用了 WMS 的 addWindow() 方法并将自身作为参数传了进去，每个应用程序都会对应一个 Session，WMS 会用一个 List 来保存这些 Session。接着 WMS 会为这个添加的窗口分配 Surface，并确定窗口显示次序，因此负责显示界面的是画布 Surface，而不是窗口本身。WMS 会将它管理的 Surface 交由 SurfaceFlinger 处理，SurfaceFlinger 会将这些 Surface 混合并绘制到屏幕上。\n\n关于 WMS 的详细分析会在后续的文章中进行。\n\n这个是一个典型的 Binder 双向通讯模型，Binder 机制的文章可参考 [借助 AIDL 理解 Android Binder 机制](https://www.jianshu.com/p/73e351d25773)。这个过程如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/View-Draw/clipboard_20230323_045637.png)\n\n## 小结\n\n用一张图总结 Activity、Window 和 WMS 之间的关系：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/View-Draw/clipboard_20230323_045640.png)\n\n# 五：建立与 SurfaceFlinger 的连接\n\nSurfaceFlinger 是 Android 最重要的系统服务之一，它的职责主要是进行 Layer(Surface 在 Native 叫法) 的合成和渲染。\n\n## 源码分析\n\n接上面的步骤，WindowState 的 attach() 方法将会调用到 Session 的 windowAddedLocked() 方法：\n\n[services/core/java/com/android/server/wm/WindowState.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /refs/heads/nougat-release/services/core/java/com/android/server/wm/WindowState.java)\n\n```java\nvoid attach() {\n    if (WindowManagerService.localLOGV) Slog.v(\n        TAG, \"Attaching \" + this + \" token=\" + mToken\n        + \", list=\" + mToken.windows);\n    mSession.windowAddedLocked();\n}\n```\n\nSession.java\n\n```java\nvoid windowAddedLocked(String packageName) {\n    ...\n    if (mSurfaceSession == null) { \n        ...\n        mSurfaceSession = new SurfaceSession();\n        ...\n    }\n}\n\npublic final class SurfaceSession {\n    private long mNativeClient; // SurfaceComposerClient*\n    private static native long nativeCreate();\n    ...\n\n    public SurfaceSession() {\n        mNativeClient = nativeCreate(); \n    }\n    \n    ...\n}\n```\n\nnativeCreate() 方法是一个 native 方法：\n\n[core/jni/android_view_SurfaceSession.cpp]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /refs/heads/nougat-release/core/jni/android_view_SurfaceSession.cpp)\n\n```c++\nstatic jlong nativeCreate(JNIEnv* env, jclass clazz) {\n    SurfaceComposerClient* client = new SurfaceComposerClient();\n    client-\u003eincStrong((void*)nativeCreate);\n    return reinterpret_cast\u003cjlong\u003e(client);\n}\n```\n\nnativeCreate 方法主要构造了一个 SurfaceComposerClient 对象，它是应用程序与 SurfaceFlinger 沟通的桥梁，SurfaceComposerClient 指针在第一次使用的时候会调用以下方法：\n\n```c++\nvoid SurfaceComposerClient::onFirstRef() {\n    ....\n    sp\u003cISurfaceComposerClient\u003e conn;\n    // sf 就是 SurfaceFlinger 对象指针\n    conn = (rootProducer != nullptr) ? sf-\u003ecreateScopedConnection(rootProducer) :\n            sf-\u003ecreateConnection();\n    ...\n}\n```\n\n它通过 SurfaceFlinger 的 createScopedConnection 方法创建了一个 ISurfaceComposerClient 对象：\n\n```c++\nSurfaceFlinger.cpp\n\nsp\u003cISurfaceComposerClient\u003e SurfaceFlinger::createConnection() {\n    return initClient(new Client(this)); \n}\n\nstatic sp\u003cISurfaceComposerClient\u003e initClient(const sp\u003cClient\u003e\u0026 client) {\n    status_t err = client-\u003einitCheck();\n    // 只是做了错误检查，然后返回 client 本身\n    if (err == NO_ERROR) {\n        return client;\n    }\n    return nullptr;\n}\n```\n\nClient 类实现了 ISurfaceComposerClient(继承了 IInterface) 接口，因此它可以进行跨进程通信，SurfaceComposerClient 就是通过它来和 SurfaceFlinger 通信。除此之外它还可以创建 Surface，并且维护一个应用程序的所有 Layer。\n\ninitClicent 方法做了一些错误检查，然后返回 Client 本身。\n\n## 小结\n\n这个过程如下图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/View-Draw/clipboard_20230323_045645.png)\n\n# 六：申请 Surface\n\n经过步骤四和步骤五，ViewRootImpl 与 WMS、SurfaceFlinger 都已经建立连接，但是这时 View 还是没有显示出来。我们都知道，所有的 UI 最终都是要通过 Surface 来显示的，那么 Surface 是什么时候创建的呢？回到步骤四开头部分 ViewRootImpl 的 setView 方法：\n\n```java\npublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {\n    synchronized (this) {\n        if (mView == null) {\n            mView = view;\n            ...\n            // Schedule the first layout -before- adding to the window\n            // manager, to make sure we do the relayout before receiving\n            // any other events from the system.\n            requestLayout();\n            ...\n            try {\n                ...\n                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,\n                        getHostVisibility(), mDisplay.getDisplayId(),\n                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,\n                        mAttachInfo.mOutsets, mInputChannel);\n            } \n            ...\n        }\n    }\n}\n```\n\n注释处保留了官方原文，意思大概是 WMS 除了窗口管理，还需要处理事件派发，因此在与 WMS 进行关联之前，要确保 View Tree 已经进行了 layout 操作，以接收来自 WMS 的事件。\n\n跟踪 ViewRootImpl 的 requestLayout() 方法：\n\n```java\npublic void requestLayout() {\n    if (!mHandlingLayoutInLayoutRequest) {\n        checkThread();\n        mLayoutRequested = true;\n        scheduleTraversals();\n    }\n}\n```\n\nscheduleTraversals() 方法如下：\n\n```java\nvoid scheduleTraversals() {\n    if (!mTraversalScheduled) {\n        mTraversalScheduled = true;\n        // 设置同步障碍，暂停处理后面的同步消息\n        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n        // 在下一帧到来的时候执行 mTraversalRunnable\n        mChoreographer.postCallback(\n                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n        ...\n    }\n}\n```\n\n首先，设置同步障碍，暂停处理后面的同步消息，然后利用 Choreographer 类在下一绘制帧来临的时候执行 mTraversalRunnable 对象（关于 Choreographer 原理，可查看 [Android 系统 Choreographer 机制实现过程](https://blog.csdn.net/yangwen123/article/details/39518923)）。\n\n简单地说，Choreographer 内部会接收来自 SurfaceFlinger 发出的 VSync 垂直同步信号，这个信号周期一般为 16ms 左右。SurfaceFlinger 是由 init 进程启动的运行在底层的一个系统进程，它的主要职责是合成和渲染 Surface(Layer)，并向目标进程发送垂直同步信号 VSync。因此，如果需要接收 Vsync 信号，必须先与 SurfaceFlinger 建立连接，而这正是先走步骤五流程的原因。\n\nmTraversalRunnable 是一个 Runnable 对象：\n\n```java\nfinal class TraversalRunnable implements Runnable {\n    @Override\n    public void run() {\n        doTraversal();\n    }\n}\nfinal TraversalRunnable mTraversalRunnable = new TraversalRunnable();\n```\n\nrun() 方法里面只有一句代码，doTraversal() 方法如下：\n\n```java\nvoid doTraversal() {\n    if (mTraversalScheduled) {\n        mTraversalScheduled = false;\n        // 移除同步障碍\n        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n        ...\n        // 正式进入 View 绘制流程\n        performTraversals();\n         ...\n    }\n}\n```\n\n移除了同步障碍之后，所有绘制之前的准备工作已经执行完毕，接下来会调用 performTraversals() 方法正式进入 View 的绘制流程。\n\n```java\nprivate void performTraversals() {\n    finalView host = mView; // mView 其实就是 DecorView\n    ...\n    relayoutWindow(params, viewVisibility, insetsPending);\n    ...\n    // 执行 Measure 流程\n    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n    ...\n    // 执行 Layout 流程\n    performLayout(lp, desiredWindowWidth, desiredWindowHeight);\n    ...\n    // 执行 Draw 流程\n    performLayout();\n    ...\n}\n```\n\n跟踪 relayoutWindow 方法：\n\n```java\nprivate int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,\n        boolean insetsPending) throws RemoteException {\n    ...\n    int relayoutResult = mWindowSession.relayout(\n            mWindow, mSeq, params,\n            (int) (mView.getMeasuredWidth() * appScale + 0.5f),\n            (int) (mView.getMeasuredHeight() * appScale + 0.5f),\n            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,\n            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,\n            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,\n            mSurface);\n    ...\n}\n```\n\n这里又是 Binder 调用（强烈建议掌握），它将调用到 WMS 的 relayout 方法，注意最后一个参数就是 SurfaceView 对象，它在 ViewRootImpl 中定义的时候就已经进行了初始化：\n\nfinal Surface mSurface = new Surface();\n\n再来看 WMS 的 relayoutWindow：\n\n```java\npublic int relayoutWindow(Session session, IWindow client, int seq,\n            WindowManager.LayoutParams attrs, int requestedWidth,\n            int requestedHeight, int viewVisibility, int flags,\n            Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,\n            Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,\n            Configuration outConfig, Surface outSurface){ \n    ...\n    result = createSurfaceControl(outSurface, result, win, winAnimator);  \n    ...\n}\n\nprivate int createSurfaceControl(Surface outSurface, int result, WindowState win,WindowStateAnimator winAnimator) {\n    ...\n    surfaceController = winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);\n    ...\n    surfaceController.getSurface(outSurface);\n}\n```\n\n这里首先调用 WindowStateAnimator 的 createSurfaceLocked 生成一个真正有效的 Surface 对象，这个对象是在 Native 层的，接着 getSurface 方法将 Java 层的 Surface 对象与其关联起来。\n\n# 七：正式绘制 View\n\n接上一步骤的内容，申请了 Surface 之后，ViewRootImpl 的 performTraversals() 方法将会继续执行，这个方法内容相当多，忽略条件判断，精简过后如下：\n\n```java\nprivate void performTraversals() {\n    ...\n    relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);\n    ...\n    WindowManager.LayoutParams lp = mWindowAttributes;\n    ...\n    // 获取 DecorView 宽和高的 MeasureSpec\n    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);\n    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);\n    ...\n    // 执行 Measure 流程\n    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);\n    ...\n    // 执行 Layout 流程\n    performLayout(lp, desiredWindowWidth, desiredWindowHeight);\n    ...\n    // 执行 Draw 流程\n    performLayout();\n    ...\n}\n```\n\n首先，根据 getRootMeasureSpec() 方法获取到 childWidthMeasureSpec 和 childHeightMeasureSpec 的值，用于 DecorView 的绘制。因为 DecorView 是所有子元素的根元素，子元素的布局层层嵌套，因此会接着从 DecorView 开始进行一层层地对所有子元素进行测量、布局和绘制，分别对应 performMeasure()、performLayout() 和 performLayout() 方法，整个过程的示意图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/View-Draw/clipboard_20230323_045652.png)\n\n## 理解 MeasureSpec\n\nMeasureSpec 是 View 的一个内部类，简单来说就是一个 32 位的 int 值，采用它的高 2 位表示三种 SpecMode（测量模式），低 30 位用来表示 SpecSize（某种测量模式下的规格大小）。采用这种表示方法是为了避免创建过多的对象以减少内存分配，MeasureSpec 的定义如下：\n\n```java\npublic static class MeasureSpec {\n    private static final int MODE_SHIFT = 30;\n    private static final int MODE_MASK = 0x3 \u003c\u003c MODE_SHIFT;\n\n    // 不限定测量模式：父容器不对 View 作任何限制，View 想要多大给多大，\n    // 这种模式通常用于系统内部。\n    public static final int UNSPECIFIED = 0 \u003c\u003c MODE_SHIFT;\n\n    // 精确为 SpecSize：父容器已经确定 View 需要的大小，就是 SpecSize，\n    // 对应布局参数是 match_parent 或具体数值时的情况\n    public static final int EXACTLY = 1 \u003c\u003c MODE_SHIFT;\n\n    // 最大只能是 SpecSize：父容器规定 View 最大只能是 SpecSize，\n    // 对应布局参数是 wrap_content 时的情况\n    public static final int AT_MOST = 2 \u003c\u003c MODE_SHIFT;\n\n    // 根据 SpecMode 和 SpecSize 创建一个 MeasureSpec\n    public static int makeMeasureSpec(int size, int mode) {\n        if (sUseBrokenMakeMeasureSpec) {\n            return size + mode;\n        } else {\n            return (size \u0026 ~MODE_MASK) | (mode \u0026 MODE_MASK);\n        }\n    }\n    \n    // 获取 SpecMode\n    public static int getMode(int measureSpec) {\n        return (measureSpec \u0026 MODE_MASK);\n    }\n\n    // 获取 SpecSize\n    public static int getSize(int measureSpec) {\n        return (measureSpec \u0026 ~MODE_MASK);\n    }\n\n    // 调整 MeasureSpec\n    static int adjust(int measureSpec, int delta) {\n        final int mode = getMode(measureSpec);\n        if (mode == UNSPECIFIED) {\n            return make MeasureSpec(0, UNSPECIFIED);\n        }\n        int size = getSize(measureSpec) + delta;\n        if (size \u003c 0) {\n            size = 0;\n        }\n        return makeMeasureSpec(size, mode);\n    }\n}\n```\n\n接着看 getRootMeasureSpec() 方法，传入的第一个参数是整个屏幕的宽或者高，第二个参数是 Window 的 LayoutParams：\n\n```java\nprivate static int getRootMeasureSpec(int windowSize, int rootDimension) {\n    int measureSpec;\n    switch (rootDimension) {\n    case ViewGroup.LayoutParams.MATCH_PARENT:\n        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);\n        break;\n    case ViewGroup.LayoutParams.WRAP_CONTENT:\n        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);\n        break;\n    default:\n        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);\n        break;\n    }\n    return measureSpec;\n}\n```\n\n从代码逻辑来看，DecorView 的 MeasureSpec 的产生遵循如下规律：\n\n- LayoutParams = MATCH_PARENT：精确模式，大小就是屏幕的宽或者高；\n- LayoutParams = WRAP_CONTENT：最大不能超过屏幕的宽或者高；\n- 固定大小：精确模式，大小为 LayoutParams 中指定的值。\n\n但是对于普通的 View 来说，View 的 measure() 方法是由父容器 ViewGroup 调用的，看一下 ViewGroup 的 measureChildWithMargins() 方法：\n\n```java\nprotected void measureChildWithMargins(View child,\n        int parentWidthMeasureSpec, int widthUsed,\n        int parentHeightMeasureSpec, int heightUsed) {\n    // 获取子元素的布局参数\n    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n    // 产生子元素的 MeasureSpec\n    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                    + widthUsed, lp.width);\n    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                    + heightUsed, lp.height);\n\n    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n}\n```\n\n可以看出，在调用子元素 的 measure() 方法之前，先要调用 getChildMeasureSpec() 方法产生子元素的 MeasureSpec，子元素的产生除了跟父容器的 MeasureSpec 和子元素本身的 LayoutParams 有关之外，还与子元素的 Margin 和父容器的 Padding 值以及父容器当前占用空间有关，具体的过程可以看 getChildMeasureSpec() 方法：\n\n```java\npublic static int getChildMeasureSpec(int spec, int padding, int childDimesion) {\n    int specMode = MeasureSpec.getMode(spec);\n    int specSize = MeasureSpec.getSize(spec);\n\n    // 子元素最大可用空间为父容器的尺寸减去父容器中已被占用的空间的大小\n    int size = Math.max(0, specSize - padding);\n\n    int resultSize = 0;\n    int resultMode = 0;\n\n    switch (sepcMode) {\n        // Parent has imposed an exact size on us\n        case MeasureSpec.EXACTLY:\n            if (childDimension \u003e= 0) {\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size. So be it.\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimesion == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size. It can't be\n                // bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent has imposed a maximum size on us \n        case MeasureSpec.AT_MOST:\n            if (childDimension \u003e= 0) {\n                // Child wants a specific size... so be it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size, but our size is not fixed.\n                // Constrain child to not be bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size. It can't be\n                // bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent asked to see how big we want to be\n        case MeasureSpec.UNSPECIFIED:\n            if (childDimension \u003e= 0) {\n                // Child wants a specific size... let him have it\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size... find out how big it should be\n                resultSize = 0;\n                resultMode = MeasureSpec.UNSPECIFIED;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size....\n                // find out how big it should be\n                resultSize = 0;\n                resultMode == MeasureSpec.UNSPECIFIED;\n            }\n            break;\n        }\n    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n}\n```\n\n整个过程稍微有点复杂，可以参考以下表格：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/View-Draw/clipboard_20230323_045658.png)\n\n## Measure 流程分析\n\n回到 performTraversals() 方法中，获取到 DecorView 的 MeasureSpec 后接着会调用 performMeasure() 方法：\n\n```java\nprivate void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n    ...\n    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    ...\n}\n```\n\nmView 就是之前通过 setView() 方法传递过来的 DecorView 实例，它继承自 FrameLayout，而 FrameLayout 又是一个 ViewGroup 同时继承自 View。View 的 measure() 方法是 final 类型的，不允许子类去重写，因此这里调用的实际上是 View 的 measure 方法：\n\n```java\npublic final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n    ...\n    onMeasure(widthMeasureSpec, heightMeasureSpec);\n    ...\n}\n```\n\nView 的 onMeasure() 实现：\n\n```java\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n}\n```\n\n可以看到，View 默认的 onMeasure() 方法首先会调用 getDefaultSize() 获取宽和高的默认值，然后再调用 setMeasuredDimension() 将获取的值进行设置，查看 getDefaultSize() 的代码：\n\n```java\npublic static int getDefaultSize(int size, int measureSpec) {\n    int result = size;\n    int specMode = MeasureSpec.getMode(measureSpec);\n    int specSize = MeasureSpec.getSize(measureSpec);\n\n    switch (specMode) {\n        case MeasureSpec.UNSPECIFIED:\n            result = size;\n            break;\n        case MeasureSpec.AT_MOST:\n        case MeasureSpec.EXACTLY:\n            result = specSize;\n            break;\n    }\n    return result;\n}\n```\n\n无论是 AT_MOST 还是 EXACTLY，最终返回的都是 measureSpec 中的 specSize，这个 specSize 就是测量后的最终结果。至于 UNSPECIFIED 的情况，则会返回一个建议的最小值，这个值和子元素设置的最小值它的背景大小有关。\n\n从 onMeasure() 的默认实现可以看出，如果我们自定义一个直接继承自 View 的控件如果不重写 onMeasure() 方法，在使用这个控件并把 layout_width 或 layout_height 设置成 wrap_content 的时候，效果将会和 match_parent 一样！因为布局中使用 wrap_content 的时候，根据上面 getChildMeasureSpec() 方法总结出来的表格可以知道，此时的 specMode 是 AT_MOST，specSize 是 parentSize，而 parentSize 是父容器当前剩余的空间大小，此时 getDefaultSize() 就会返回 specSize，因此子元素的宽或高就被设置成了等于当前父容器剩余空间的大小了，这显然不符合我们的预期，如何解决这个问题呢？一个通用的方案就是像如下方式重写 onMeasure() 方法：\n\n```java\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n    int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n    int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n\n    int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n    int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n\n    // 默认的宽/高\n    int mWidth = default_width;\n    int mHeight = default_height;\n\n    // 当布局参数设置为 wrap_content 时，使用默认值\n    if (getLayoutParams().width == ViewGroup.LayoutParams.WRAP_CONTENT \u0026\u0026 getLayoutParams().height == ViewGroup.LayoutParams.WRAP_CONTENT) {\n        setMeasuredDimension(mWidth, mHeight);\n    // 宽 / 高任意一个布局参数为 wrap_content 时，都使用默认值\n    } else if (getLayoutParams().width == ViewGroup.LayoutParams.WRAP_CONTENT) {\n        setMeasuredDimension(mWidth, heightSize);\n    } else if (getLayoutParams().height == ViewGroup.LayoutParams.WRAP_CONTENT) {\n        setMeasuredDimension(widthSize, mHeight);\n    }\n}\n```\n\n因为 DecorView 继承自 FrameLayout，它是一个 ViewGroup，ViewGroup 是一个抽象类，它并没有定义一个具体的测量过程，默认使用 View 的 onMeasure() 进行测量。它的测量过程需要各个子类通过重写 onMeasure() 方法去实现，因为不同的子类具有不同的布局特性，因此需要不一样的测量逻辑，DecorView 也自然重写了 onMeasure() 方法来实现自己的测量逻辑，简略后方法内容如下：\n\n```java\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    ...\n    final int widthMode = getMode(widthMeasureSpec);\n    final int heightMode = getMode(heightMeasureSpec);\n    ...\n    if (widthMode == AT_MOST) {\n        ...\n    }\n    ...\n    if (heightMode == AT_MOST) {\n        ...\n    }\n    ...\n    super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    ...\n}\n```\n\n最终会调用父类 FrameLayout 的 onMeasure() 方法，简略后方法内容如下：\n\n```java\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    int count = getChildCount();\n    ...\n    for (int i = 0; i \u003c count; i++) {\n        final View child = getChildAt(i);\n        if (mMeasureAllChildren || child.getVisibility() != GONE) {\n            measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);\n            ...\n        }\n    }\n    ...\n    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),\n            resolveSizeAndState(maxHeight, heightMeasureSpec,\n                    childState \u003c\u003c MEASURED_HEIGHT_STATE_SHIFT));\n    ...\n}\n```\n\n可以看到，这里会遍历它的每一个子元素，并调用 measureChildWithMargins() 方法，这个方法其实前面已经出现过，它的作用是计算出子元素的 MeasureSpec 后调用子元素本身的 measure() 方法：\n\n```java\nprotected void measureChildWithMargins(View child,\n        int parentWidthMeasureSpec, int widthUsed,\n        int parentHeightMeasureSpec, int heightUsed) {\n    // 获取子元素的布局参数\n    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n    // 产生子元素的 MeasureSpec\n    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                    + widthUsed, lp.width);\n    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                    + heightUsed, lp.height);\n\n    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n}\n```\n\n此时实际上调用的也是 View 的 measure() 方法，从上面的内容可以知道，子元素的 onMeasure() 方法又会被调用，这样便实现了层层递归地调用到了每个子元素的 onMeasure() 方法进行测量。\n\n## Layout 流程分析\n\n再次回到 performTraversals() 方法，执行完 performMeasure() 遍历测量所有子元素之后，接着会调用 performLayout() 方法：\n\n```java\nprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) {\n    ...\n    // 调用 DecorView 的 layout() 方法\n    host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());\n    ...\n}\n```\n\n这里的 getMeasuredWidth() 和 getMeasuredHeight() 就是 DecorView 在前面 Measure 流程中计算得到的测量值，它们都被作为参数传入 layout() 方法中，这里调用的是 View 的 layout() 方法：\n\n```java\npublic void layout(int l, int t, int r, int b) {\n    ...\n    // View 状态是否发生了变化\n    boolean changed = isLayoutModeOptical(mParent) ?\n                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);\n    // 如果 View 状态有变化，则重新布局\n    if (changed || (mPrivateFlags \u0026 PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {\n        onLayout(changed, l, t, r, b);\n        ...\n    }\n    ...\n}\n```\n\nsetOpticalFrame() 内部也直接调用了 setFrame() 方法，查看 setFrame() 方法的实现：\n\n```java\nprotected boolean setFrame(int left, int top, int right, int bottom) {\n    boolean changed = false;\n\n    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {\n        changed = true;\n        ...\n        int oldWidth = mRight - mLeft;\n        int oldHeight = mBottom - mTop;\n        int newWidth = right - left;\n        int newHeight = bottom - top;\n        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);\n\n        // Invalidate our old position\n        invalidate(sizeChanged);\n\n        // 变量初始化\n\n        mLeft = left;\n        mTop = top;\n        mRight = right;\n        mBottom = bottom;\n        // 更新用于渲染的显示列表\n        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);\n        ...\n        if (sizeChanged) {\n            // 如果 View 大小发生变化，则会在里面回调 onSizeChanged 方法\n            sizeChange(newWidth, newHeight, oldWidth, oldHeight);\n        }\n        ...\n    }\n    // 返回是否发生变化\n    return changed;\n}\n```\n\nsetFrame() 方法的主要作用有以下几点：\n\n1. 判断 View 位置是否发生变化，并根据变化情况进行相应的处理；\n2. 初始化 mLeft、mBottom、mRight 和 mTop 变量，首次调用这个方法的时候返回值为 \u003cem\u003etrue\u003c/em\u003e；\n3. 调用 RenderNode 中原生方法更新用于渲染的显示列表。\n\n回到 layout() 方法，根据 setFrame() 方法返回的状态判断是否需要调用 onLayout() 进行重新布局，查看 onLayout() 方法：\n\n```java\n/**\n * Assign a size and position to a view and all of its\n * descendants\n *\n * \u003cp\u003eThis is the second phase of the layout mechanism.\n * (The first is measuring). In this phase, each parent calls\n * layout on all of its children to position them.\n * This is typically done using the child measurements\n * that were stored in the measure pass().\u003c/p\u003e\n *\n * \u003cp\u003eDerived classes should not override this method.\n * Derived classes with children should override\n * onLayout. In that method, they should\n * call layout on each of their children.\u003c/p\u003e\n */\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n}\n```\n\nonLayout() 方法是一个空方法，从注释最后一段内容可以了解到，单一的 View 并不需要重写这个方法，当 View 的子类具有子元素（即 ViewGroup）的时候，应该重写这个方法并调用每个子元素的 layout() 方法，因此作为一个 ViewGroup，我们查看 DecorView 的 onLayout() 方法：\n\n```java\n@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    super.onLayout(changed, left, top, right, bottom);\n    ...\n}\n```\n\n这里的主要逻辑是调用父类的 onLayout() 方法，继续跟踪 FrameLayout 的 onLayout() 方法：\n\n```java\n@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    layoutChildren(left, top, right, bottom, false /* no force left gravity */);\n}\n\nvoid layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) {\n    final int count = getChildCount();\n\n    final int parentLeft = getPaddingLeftWithForeground();\n    final int parentRight = right - left - getPaddingRightWithForeground();\n\n    final int parentTop = getPaddingTopWithForeground();\n    final int parentBottom = bottom - top - getPaddingBottomWithForeground();\n\n    for (int i = 0; i \u003c count; i++) {\n        final View child = getChildAt(i);\n        if (child.getVisibility() != GONE) {\n            final LayoutParams lp = (LayoutParams) child.getLayoutParams();\n\n            final int width = child.getMeasuredWidth();\n            final int height = child.getMeasuredHeight();\n\n            int childLeft;\n            int childTop;\n\n            int gravity = lp.gravity;\n            if (gravity == -1) {\n                gravity = DEFAULT_CHILD_GRAVITY;\n            }\n\n            final int layoutDirection = getLayoutDirection();\n            final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);\n            final int verticalGravity = gravity \u0026 Gravity.VERTICAL_GRAVITY_MASK;\n\n            switch (absoluteGravity \u0026 Gravity.HORIZONTAL_GRAVITY_MASK) {\n                case Gravity.CENTER_HORIZONTAL:\n                    childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +\n                    lp.leftMargin - lp.rightMargin;\n                    break;\n                case Gravity.RIGHT:\n                    if (!forceLeftGravity) {\n                        childLeft = parentRight - width - lp.rightMargin;\n                        break;\n                    }\n                case Gravity.LEFT:\n                default:\n                    childLeft = parentLeft + lp.leftMargin;\n            }\n\n            switch (verticalGravity) {\n                case Gravity.TOP:\n                    childTop = parentTop + lp.topMargin;\n                    break;\n                case Gravity.CENTER_VERTICAL:\n                    childTop = parentTop + (parentBottom - parentTop - height) / 2 +\n                    lp.topMargin - lp.bottomMargin;\n                    break;\n                case Gravity.BOTTOM:\n                    childTop = parentBottom - height - lp.bottomMargin;\n                    break;\n                default:\n                    childTop = parentTop + lp.topMargin;\n            }\n            // 调用每个子元素的 layout 方法\n            child.layout(childLeft, childTop, childLeft + width, childTop + height);\n        }\n    }\n}\n```\n\n在 layoutChildren() 方法中，根据自己的布局逻辑，计算出每个子元素的 left、top、right 和 bottom 值，并调用它们的 layout() 方法。\n\nLayout 流程的作用是 ViewGroup 用来确定它的子元素的位置， 当 ViewGroup 的位置被确定后，在它的 onLayout() 方法中就会遍历调用所有子元素的 layout() 方法，子元素的 layout() 方法被调用的时候它的 onLayout() 方法又会被调用，这样就实现了层层递归。\n\n## Draw 流程分析\n\n最后，又一次回到主线中的 performTraversals() 方法，此时，经过 Measure 流程确定了每个 View 的大小并且经过 Layout 流程确定了每个 View 的摆放位置，下面将进入下一个流程确定每个 View 的具体绘制细节。查看 performDraw() 方法内容：\n\n```java\nprivate void performDraw() {\n    ...\n    final boolean fullRedrawNeeded = mFullRedrawNeeded;\n    mFullRedrawNeeded = false;\n\n    mIsDrawing = true;\n    try {\n        draw(fullRedrawNeeded);\n    } finally {\n        mIsDrawing = false;\n    }\n    ...\n}\n```\n\n跟踪 draw() 方法：\n\n```java\nprivate void draw(boolean fullRedrawNeeded) {\n    ...\n    // “脏”区域，即需要重绘的区域\n    final Rect dirty = mDirty;\n    ...\n    if (fullRedrawNeeded) {\n        mAttachInfo.mIgnoreDirtyState = true;\n        dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));\n    }\n    ...\n\n    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) {\n        if (mAttachInfo.mHardwareRenderer != null \u0026\u0026 mAttachInfo.mHardwareRenderer.isEnabled()) {\n            ...\n            // 调用 drawSoftware 方法\n            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {\n                return;\n            }\n        }\n    }\n    ...\n}\n```\n\n查看 drawSoftware() 方法实现：\n\n```java\nprivate boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,\n        boolean scalingRequired, Rect dirty) {\n\n    // Draw with software renderer.\n    final Canvas canvas;\n    try {\n        final int left = dirty.left;\n        final int top = dirty.top;\n        final int right = dirty.right;\n        final int bottom = dirty.bottom;\n\n        // 锁定canvas区域，由 dirty 区域决定\n        canvas = mSurface.lockCanvas(dirty);\n        ...\n        canvas.setDensity(mDensity);\n    } catch (Surface.OutOfResourcesException e) {\n        handleOutOfResourcesException(e);\n        return false;\n    } catch (IllegalArgumentException e) {\n        mLayoutRequested = true;    // ask wm for a new surface next time.\n        return false;\n    }\n\n    try {\n        ...\n        try {\n            ...\n            // 调用 DecorView 的 draw 方法\n            mView.draw(canvas);\n            ...\n        } finally {\n            ...\n        }\n    } finally {\n        mLayoutRequested = true;    // ask wm for a new surface next time.\n        //noinspection ReturnInsideFinallyBlock\n        return false;\n    }\n    return true;\n}\n```\n\n继续查看 DecorView 的 draw() 方法：\n\n```java\n@Override\npublic void draw(Canvas canvas) {\n    super.draw(canvas);\n\n    if (mMenuBackground != null) {\n        mMenuBackground.draw(canvas);\n    }\n}\n```\n\n主要是调用了父类的 draw 方法，FrameLayout 和 ViewGroup 都没有重写 draw() 方法，所以直接看 View 的 draw() 方法：\n\n```java\npublic void draw(Canvas canvas) {\n    final int privateFlags = mPrivateFlags;\n    final boolean dirtyOpaque = (privateFlags \u0026 PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE \u0026\u0026\n            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);\n    mPrivateFlags = (privateFlags \u0026 ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;\n\n    /*\n     * Draw traversal performs several drawing steps which must be executed\n     * in the appropriate order:\n     *\n     *      1. Draw the background\n     *      2. If necessary, save the canvas' layers to prepare for fading\n     *      3. Draw view's content\n     *      4. Draw children\n     *      5. If necessary, draw the fading edges and restore layers\n     *      6. Draw decorations (scrollbars for instance)\n     */\n\n    // Step 1, draw the background, if needed\n    int saveCount;\n\n    if (!dirtyOpaque) {\n        drawBackground(canvas);\n    }\n\n    // skip step 2 \u0026 5 if possible (common case)\n    final int viewFlags = mViewFlags;\n    boolean horizontalEdges = (viewFlags \u0026 FADING_EDGE_HORIZONTAL) != 0;\n    boolean verticalEdges = (viewFlags \u0026 FADING_EDGE_VERTICAL) != 0;\n    if (!verticalEdges \u0026\u0026 !horizontalEdges) {\n        // Step 3, draw the content\n        if (!dirtyOpaque) onDraw(canvas);\n\n        // Step 4, draw the children\n        dispatchDraw(canvas);\n\n        // Overlay is part of the content and draws beneath Foreground\n        if (mOverlay != null \u0026\u0026 !mOverlay.isEmpty()) {\n            mOverlay.getOverlayView().dispatchDraw(canvas);\n        }\n\n        // Step 6, draw decorations (foreground, scrollbars)\n        onDrawForeground(canvas);\n\n        // we're done...\n        return;\n    }\n\n    /*\n     * Here we do the full fledged routine...\n     * (this is an uncommon case where speed matters less,\n     * this is why we repeat some of the tests that have been\n     * done above)\n     */\n\n    boolean drawTop = false;\n    boolean drawBottom = false;\n    boolean drawLeft = false;\n    boolean drawRight = false;\n\n    float topFadeStrength = 0.0f;\n    float bottomFadeStrength = 0.0f;\n    float leftFadeStrength = 0.0f;\n    float rightFadeStrength = 0.0f;\n\n    // Step 2, save the canvas' layers\n    int paddingLeft = mPaddingLeft;\n\n    final boolean offsetRequired = isPaddingOffsetRequired();\n    if (offsetRequired) {\n        paddingLeft += getLeftPaddingOffset();\n    }\n\n    int left = mScrollX + paddingLeft;\n    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;\n    int top = mScrollY + getFadeTop(offsetRequired);\n    int bottom = top + getFadeHeight(offsetRequired);\n\n    if (offsetRequired) {\n        right += getRightPaddingOffset();\n        bottom += getBottomPaddingOffset();\n    }\n\n    final ScrollabilityCache scrollabilityCache = mScrollCache;\n    final float fadeHeight = scrollabilityCache.fadingEdgeLength;\n    int length = (int) fadeHeight;\n\n    // clip the fade length if top and bottom fades overlap\n    // overlapping fades produce odd-looking artifacts\n    if (verticalEdges \u0026\u0026 (top + length \u003e bottom - length)) {\n        length = (bottom - top) / 2;\n    }\n\n    // also clip horizontal fades if necessary\n    if (horizontalEdges \u0026\u0026 (left + length \u003e right - length)) {\n        length = (right - left) / 2;\n    }\n\n    if (verticalEdges) {\n        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));\n        drawTop = topFadeStrength * fadeHeight \u003e 1.0f;\n        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));\n        drawBottom = bottomFadeStrength * fadeHeight \u003e 1.0f;\n    }\n\n    if (horizontalEdges) {\n        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));\n        drawLeft = leftFadeStrength * fadeHeight \u003e 1.0f;\n        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));\n        drawRight = rightFadeStrength * fadeHeight \u003e 1.0f;\n    }\n\n    saveCount = canvas.getSaveCount();\n\n    int solidColor = getSolidColor();\n    if (solidColor == 0) {\n        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;\n\n        if (drawTop) {\n            canvas.saveLayer(left, top, right, top + length, null, flags);\n        }\n\n        if (drawBottom) {\n            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);\n        }\n\n        if (drawLeft) {\n            canvas.saveLayer(left, top, left + length, bottom, null, flags);\n        }\n\n        if (drawRight) {\n            canvas.saveLayer(right - length, top, right, bottom, null, flags);\n        }\n    } else {\n        scrollabilityCache.setFadeColor(solidColor);\n    }\n\n    // Step 3, draw the content\n    if (!dirtyOpaque) onDraw(canvas);\n\n    // Step 4, draw the children\n    dispatchDraw(canvas);\n\n    // Step 5, draw the fade effect and restore layers\n    final Paint p = scrollabilityCache.paint;\n    final Matrix matrix = scrollabilityCache.matrix;\n    final Shader fade = scrollabilityCache.shader;\n\n    if (drawTop) {\n        matrix.setScale(1, fadeHeight * topFadeStrength);\n        matrix.postTranslate(left, top);\n        fade.setLocalMatrix(matrix);\n        p.setShader(fade);\n        canvas.drawRect(left, top, right, top + length, p);\n    }\n\n    if (drawBottom) {\n        matrix.setScale(1, fadeHeight * bottomFadeStrength);\n        matrix.postRotate(180);\n        matrix.postTranslate(left, bottom);\n        fade.setLocalMatrix(matrix);\n        p.setShader(fade);\n        canvas.drawRect(left, bottom - length, right, bottom, p);\n    }\n\n    if (drawLeft) {\n        matrix.setScale(1, fadeHeight * leftFadeStrength);\n        matrix.postRotate(-90);\n        matrix.postTranslate(left, top);\n        fade.setLocalMatrix(matrix);\n        p.setShader(fade);\n        canvas.drawRect(left, top, left + length, bottom, p);\n    }\n\n    if (drawRight) {\n        matrix.setScale(1, fadeHeight * rightFadeStrength);\n        matrix.postRotate(90);\n        matrix.postTranslate(right, top);\n        fade.setLocalMatrix(matrix);\n        p.setShader(fade);\n        canvas.drawRect(right - length, top, right, bottom, p);\n    }\n\n    canvas.restoreToCount(saveCount);\n\n    // Overlay is part of the content and draws beneath Foreground\n    if (mOverlay != null \u0026\u0026 !mOverlay.isEmpty()) {\n        mOverlay.getOverlayView().dispatchDraw(canvas);\n    }\n\n    // Step 6, draw decorations (foreground, scrollbars)\n    onDrawForeground(canvas);\n}\n```\n\n从代码注释中可以看到，draw() 过程分为六个步骤，分别是：\n\n1. 绘制 View 的背景；\n2. 保存当前 canvas 的图层；\n3. 绘制 View 的内容；\n4. 如果有子元素，则调用子元素的 draw() 方法；\n5. 绘制淡入淡出效果并恢复图层；\n6. 绘制 View 的装饰（滚动条等）。\n\n其中第二步和第五步一般情况下不会用到，我们继续看第三步，看看它是如何分配子元素的绘制的：\n\n```java\nprotected void dispatchDraw(Canvas canvas) {\n}\n```\n\n显然，单一的 View 并没有子元素，因此，看看 ViewGroup 是怎么实现这个过程的：\n\n```java\n@Override\nprotected void dispatchDraw(Canvas canvas) {\n    ...\n    for (int i = 0; i \u003c childrenCount; i++) {\n        while (transientIndex \u003e= 0 \u0026\u0026 mTransientIndices.get(transientIndex) == i) {\n            final View transientChild = mTransientViews.get(transientIndex);\n            if ((transientChild.mViewFlags \u0026 VISIBILITY_MASK) == VISIBLE ||\n                    transientChild.getAnimation() != null) {\n                more |= drawChild(canvas, transientChild, drawingTime);\n            }\n            ...\n        }\n        ...\n    }\n    ...  \n}\n\nprotected boolean drawChild(Canvas canvas, View child, long drawingTime) {\n    return child.draw(canvas, this, drawingTime);\n}\n```\n\n在 ViewGroup 的 dispatchDraw() 中，遍历每个子元素并调用了它们的 draw() 方法，由此实现了层层递归调用，最终完成绘制。\n\n## 小结\n\n纵观整个 Measure、Layout 和 Draw 过程，使用流程图表示如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/View-Draw/clipboard_20230323_045712.png)\n\n# 八：显示 View\n\n不知道你还记不记得，上一步骤中执行的 View 的 Measure、Layout 和 Draw 流程都是前面 handleResumeActivity() 中的 wm.addView() 方法为源头的，回顾 handleResumeActivity() 方法：\n\n```java\nfinal void handleResumeActivity(IBinder token,\n            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {\n    ActivityClientRecord r = mActivities.get(token);\n    ...\n    // 最终会调用 onStart() 和 onResume() 等方法\n    r = performResumeActivity(token, clearHide, reason);\n\n    if (r != null) {\n        final Activity a = r.activity;\n        ...\n        if (r.window == null \u0026\u0026 !a.mFinished \u0026\u0026 willBeVisible) {\n            r.window = r.activity.getWindow();\n            // 获取 DecorView \n            View decor = r.window.getDecorView();\n            // 将 DecorView 设置成不可见\n            decor.setVisibility(View.INVISIBLE);\n            // 获取 ViewManager，这里是 WindowManagerImpl 实例\n            ViewManager wm = a.getWindowManager();\n            WindowManager.LayoutParams l = r.window.getAttributes();\n            a.mDecor = decor;\n            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n            l.softInputMode |= forwardBit;\n            ...\n            if (a.mVisibleFromClient \u0026\u0026 !a.mWindowAdded) {\n                // 标记设置为 true\n                a.mWindowAdded = true;\n                // 调用 WindowManagerImpl 的 addView 方法\n                wm.addView(decor, l);\n            } \n        } else if (!willBeVisible) {\n            ...\n        }\n        ...\n        if (!r.activity.mFinished \u0026\u0026 willBeVisible\n                \u0026\u0026 r.activity.mDecor != null \u0026\u0026 !r.hideForNow) {\n            ...\n            if (r.activity.mVisibleFromClient) {\n                // 调用 makeVisible 方法将 DecorView 设置为可见\n                r.activity.makeVisible();\n            }\n        }\n        ...\n    } else {\n        try {\n            // 在此过程出现异常，则直接杀死 Activity\n            ActivityManagerNative.getDefault()\n                .finishActivity(token, Activity.RESULT_CANCELED, null,\n                        Activity.DONT_FINISH_TASK_WITH_ACTIVITY);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }\n}\n```\n\n可以看到在调用 wm.addView() 方法之前，DecorView 是处于不可见的状态的，因此，即使经过了 Measure、Layout 和 Draw 流程，我们的 View 仍然没有显示在屏幕上，看看 Activity 的 makeVisible() 方法：\n\n```java\nvoid makeVisible() {\n    if (!mWindowAdded) {\n        ViewManager wm = getWindowManager();\n        wm.addView(mDecor, getWindow().getAttributes());\n        mWindowAdded = true;\n    }\n    mDecor.setVisibility(View.VISIBLE);\n}\n```\n\n执行 DecorView 的 setVisibility() 之后，我们的 View 才正式出现在屏幕上！\n\n# 总结\n\n- Window 是一个抽象类，提供了各种窗口操作的方法；\n- PhoneWindow 是 Window 的唯一实现类，每个 Acitvity 中都会有一个 PhoneWindw 实例；\n- DecorView —— 顶级视图，它继承自 FrameLayout，setContentView() 时，PhoneWindow 会创建 DecorView 并与 DecorView 建立关联；\n- PhoneWindow 会根据 Theme 和 Feature 等将对应的布局文件将布局解析并添加到 DecorView 中，这些布局中都包含了一个 id 为 content 的 FrameLayout；\n- setContentView() 方法中设置的 layout 布局文件会被 PhoneWindow 解析并压入 DecorView 中 id 为 content 的 FrameLayout 中；\n- View 的正式绘制是从 ViewRootImpl 的 performTraversals() 方法开始的；\n- 单一 View 一般需要重写 onMeasure() 方法根据布局参数和父 View 的测量规格计算自己的宽高并保存；\n- ViewGroup 需要重写 onMeasure() 方法计算所有子元素的尺寸然后计算自己的尺寸并保存；\n- 单一 View 一般不需要重写 onLayout() 方法；\n- ViewGroup 需要重写 onLayot() 方法根据测量的值确定所有子元素的位置；\n- 单一 View 需要重写 onDraw() 方法绘制自身；\n- ViewGroup 需要重写 onDraw() 方法绘制自身以及遍历子元素对它们进行绘制。\n- 在 Activity 的 onResume() 生命周期被调用后，ActivityThread 才会调用 activity.makeVisible() 让 DecorView 可见。\n\n\u003cstrong\u003e系列文章\u003c/strong\u003e\n\n[按下电源键后竟然发生了这一幕 —— Android 系统启动流程分析](https://guanpj.cn/2017/09/17/Android-System-Startup-Flow-Analyze/)\n\n[App 竟然是这样跑起来的 —— Android App/Activity 启动流程分析](https://guanpj.cn/2017/10/23/Android-App-Startup-Flow-Analyze/)\n\n[屏幕上内容究竟是怎样画出来的 —— Android View 工作原理详解](https://guanpj.cn/2017/11/09/Android-View-Workflow/)（本文）\n\n\u003cstrong\u003e参考文章\u003c/strong\u003e\n\n[Android 应用层 View 绘制流程与源码分析](https://blog.csdn.net/yanbober/article/details/46128379)\n\n[（3）自定义 View Layout 过程 - 最易懂的自定义 View 原理系列](https://www.jianshu.com/p/158736a2549d)\n\n\u003e 如果你对文章内容有疑问或者有不同的意见，欢迎留言，我们一同探讨。\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["DecorView","ViewRootImpl","WMS","Framework"]},"/%E5%8D%8F%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90":{"title":"协程使用和原理分析","content":"# 概念\n\n# 如何使用\n\n# 源码结构\n# 原理分析\n## ","lastmodified":"2023-04-21T14:55:32.613227217Z","tags":[]},"/%E5%9B%9B%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90":{"title":"四、系统启动流程分析","content":"作为一名 Android 程序员，你有没有想过：那么复杂的 Android 系统，它是怎样运行起来的，我们的 App 又是怎样被 Android 系统加载后呈现在屏幕上的呢？Android 系统的启动是一个比较复杂的过程，涉及到了一些我们没有接触过的知识，本文将基于 Android Nougat 最新的代码上讲述 Android 系统的启动流程。\n\n# Bootloader —— 第一个程序\n\n当按下电源键（加电）或者系统重启（复位）的时候，引导芯片会从 [ROM](https://zh.wikipedia.org/wiki/%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94)（这里一般指 Flash ROM，即闪存）中预定义的位置将 Bootloader 载入到 RAM 中，接着，Bootloader 将会把 Linux 内核载入到 RAM 中并启动。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/System-Boot/clipboard_20230323_045201.png)\n\nBootloader 是在系统内核运行之前运行的一段小程序，也是系统运行的第一个程序，它的主要作用是：\n\n1. 初始化 [RAM](https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8)（一般指内存）\n2. 初始化硬件设备\n3. 加载内核和内存空间影像图\n4. 跳转到内核\n\n# init 进程 —— 1 号进程\n\nLinux 内核启动过程中会创建 init 进程，init 进程是用户空间的第一个进程（pid=1），对应的可执行程序的源文件文件为 [/system/core/init/Init.cpp]([https://android.googlesource.com/platform/system/core/](https://android.googlesource.com/platform/system/core/) /nougat-release/init/init.cpp)，它的 main 方法如下：\n\n```c++\nint main(int argc, char** argv) {\n    if (!strcmp(basename(argv[0]), \"ueventd\")) {\n        return ueventd_main(argc, argv);\n    }\n    if (!strcmp(basename(argv[0]), \"watchdogd\")) {\n        return watchdogd_main(argc, argv);\n    }\n    umask(0);\n    add_environment(\"PATH\", _PATH_DEFPATH);\n    bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0);\n    // 创建文件并挂载\n    if (is_first_stage) {\n        mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\");\n        mkdir(\"/dev/pts\", 0755);\n        mkdir(\"/dev/socket\", 0755);\n        mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL);\n        #define MAKE_STR(x) __STRING(x)\n        mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC));\n        mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);\n    }\n    open_devnull_stdio();\n    klog_init();\n    klog_set_level(KLOG_NOTICE_LEVEL);\n    NOTICE(\"init %s started!\\n\", is_first_stage ? \"first stage\" : \"second stage\");\n    if (!is_first_stage) {\n        // Indicate that booting is in progress to background fw loaders, etc.\n        close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000));\n        // 初始化属性相关资源\n        property_init();\n        process_kernel_dt();\n        process_kernel_cmdline();\n        export_kernel_boot_props();\n    }\n    ...\n    // 启动属性服务\n    start_property_service();\n    const BuiltinFunctionMap function_map;\n    Action::set_function_map(\u0026function_map);\n    Parser\u0026 parser = Parser::GetInstance();\n    parser.AddSectionParser(\"service\",std::make_unique\u003cServiceParser\u003e());\n    parser.AddSectionParser(\"on\", std::make_unique\u003cActionParser\u003e());\n    parser.AddSectionParser(\"import\", std::make_unique\u003cImportParser\u003e());\n    // 解析init.rc配置文件\n    parser.ParseConfig(\"/init.rc\");\n    ...   \n    while (true) {\n        if (!waiting_for_exec) {\n            am.ExecuteOneCommand();\n            restart_processes();\n        }\n        int timeout = -1;\n        if (process_needs_restart) {\n            timeout = (process_needs_restart - gettime()) * 1000;\n            if (timeout \u003c 0)\n                timeout = 0;\n        }\n        if (am.HasMoreCommands()) {\n            timeout = 0;\n        }\n        bootchart_sample(\u0026timeout);\n        epoll_event ev;\n        int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, \u0026ev, 1, timeout));\n        if (nr == -1) {\n            ERROR(\"epoll_wait failed: %s\\n\", strerror(errno));\n        } else if (nr == 1) {\n            ((void (*)()) ev.data.ptr)();\n        }\n    }\n    return 0;\n}\n```\n\ninit 进程的职责主要有四个：\n\n1. 解析和运行所有 init.rc 文件\n2. 生成设备驱动节点\n3. 处理子进程的终结\n4. 提供属性服务\n\n这里重点看第一点，[init.rc]([https://android.googlesource.com/platform/system/core/](https://android.googlesource.com/platform/system/core/) /nougat-release/rootdir/init.rc) 是一个配置文件，它由 Android 初始化语言编写，zygote 进程和 servicemanager 进程都是由 init 进程解析 init.rc 中特定的语句启动的，比如，启动 zygote 进程的代码格式如下：\n\n```plain text\nservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server\n    class main\n    socket zygote stream 660 root system\n    onrestart write /sys/android_power/request_state wake\n    onrestart write /sys/power/state on\n    onrestart restart audioserver\n    onrestart restart cameraserver\n    onrestart restart media\n    onrestart restart netd\n    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks\n```\n\n事实上，在 [system/core/rootdir]([https://android.googlesource.com/platform/system/core/](https://android.googlesource.com/platform/system/core/) /nougat-release/rootdir) 目录下，有多个 init.rc 文件，在不同的硬件环境下，相应的 init.rc 文件会被导入，比如在 64 位操作系统中，上面启动 zygote 进程的代码是从 [init.zygote64.rc]([https://android.googlesource.com/platform/system/core/](https://android.googlesource.com/platform/system/core/) /nougat-release/rootdir/init.zygote64.rc) 文件中导入的。它的含义主要为：\n\n1. service zygote 表示启动一个名为 zygote 的服务\n2. /system/bin/app_process64 表示服务对应执行文件的路径\n3. -Xzygote /system/bin --zygote --start-system-server 表示启动服务的参数\n\n# servicemanager 进程 —— Binder 服务的总管\n\n我在文章 [Binder 机制分析](https://ywue4d2ujm.feishu.cn/docs/doccnnNIKMdICh9atjwTbBRYxpf#)中讲到“Binder 通信模型和通信过程”的时候提到过 ServerManager，它是 Binder IPC 的核心，是上下文的管理者，Binder 服务端必须先向 ServerManager 注册才能够为客户端提供服务，Binder 客户端在与服务端通信之前需要从 ServerManager 中查找并获取 Binder 服务端的引用。然而 ServerManager 在向 Binder 驱动申请成为上下文管理者的时候又涉及到了 Binder IPC 过程，这时候应该怎么处理呢？\n\nservicemanager 进程是由 init 进程通过解析 init.rc 文件来启动的，对应的代码如下：\n\n```\nservice servicemanager /system/bin/servicemanager\n    class core\n    user system\n    group system\n    critical\n    onrestart restart healthd\n    onrestart restart zygote\n    onrestart restart media\n    onrestart restart surfaceflinger\n    onrestart restart drm\n```\n\nservicemanager 进程对应可执行程序的源文件为 [framework/native/cmds/servicemanager/service_manager.c]([https://android.googlesource.com/platform/frameworks/native/](https://android.googlesource.com/platform/frameworks/native/) /nougat-release/cmds/servicemanager/service_manager.c)，简化后的代码如下：\n\n```c\nint main(int argc, char **argv) {\n    struct binder_state *bs;\n    // 打开binder驱动，申请 128k 字节大小的内存空间\n    bs = binder_open(128*1024);\n    ...\n\n    // 成为上下文管理者\n    if (binder_become_context_manager(bs)) {\n        return -1;\n    }\n\n    // 验证 selinux 权限，判断进程是否有权注册或查看指定服务\n    selinux_enabled = is_selinux_enabled();\n    sehandle = selinux_android_service_context_handle();\n    selinux_status_open(true);\n\n    if (selinux_enabled \u003e 0) {\n        if (sehandle == NULL) {  \n            abort();\n        }\n        if (getcon(\u0026service_manager_context) != 0) {\n            abort();\n        }\n    }\n    ...\n\n    // 进入无限循环，处理 client 端发来的请求 \n    binder_loop(bs, svcmgr_handler);\n    return 0;\n}\n```\n\n这里重点关注两点，首先，在申请了一块大小为 128k 的内存空间并验证 selinux 权限后，接着调用 [framework/native/cmds/servicemanager/binder.c]([https://android.googlesource.com/platform/frameworks/native/](https://android.googlesource.com/platform/frameworks/native/) /nougat-release/cmds/servicemanager/binder.c) 中的 binder_become_context_manager 方法：\n\n```c\nint binder_become_context_manager(struct binder_state *bs) {\n    // 通过ioctl，发送 BINDER_SET_CONTEXT_MGR 指令\n    return ioctl(bs-\u003efd, BINDER_SET_CONTEXT_MGR, 0);\n}\n```\n\n然后，调用 binder_loop 方法进入循环来处理 client 发来的请求，注意第二个参数是一个方法体，用于处理各种状态回调：\n\n```c\nint svcmgr_handler(struct binder_state *bs,\n                   struct binder_transaction_data *txn,\n                   struct binder_io *msg,\n                   struct binder_io *reply)\n{\n    struct svcinfo *si;\n    uint16_t *s;\n    size_t len;\n    uint32_t handle;\n    uint32_t strict_policy;\n    int allow_isolated;\n    ...\n    \n    strict_policy = bio_get_uint32(msg);\n    s = bio_get_string16(msg, \u0026len);\n    ...\n\n    switch(txn-\u003ecode) {\n    case SVC_MGR_GET_SERVICE:\n    case SVC_MGR_CHECK_SERVICE: \n        // 获取服务名\n        s = bio_get_string16(msg, \u0026len); \n        // 根据名称查找相应服务\n        handle = do_find_service(bs, s, len, txn-\u003esender_euid, txn-\u003esender_pid);\n        bio_put_ref(reply, handle);\n        return 0;\n\n    case SVC_MGR_ADD_SERVICE: \n        // 获取服务名\n        s = bio_get_string16(msg, \u0026len);\n        handle = bio_get_ref(msg);\n        allow_isolated = bio_get_uint32(msg) ? 1 : 0;\n         // 注册指定服务\n        if (do_add_service(bs, s, len, handle, txn-\u003esender_euid,\n            allow_isolated, txn-\u003esender_pid))\n            return -1;\n        break;\n    }\n}\n```\n\nservicemanager 进程在启动过程的工作内容如下：\n\n1. 调用 binder_open 方法打开 Binder 驱动，并申请分配一块 128k 的内存空间\n2. 调用 binder_become_context_manager 方法发送 BINDER_SET_CONTEXT_MGR 给 Binder 驱动，使自己成为上下文管理者\n3. 验证 selinux 权限，判断进程是否有注册或查看指定服务的权限\n4. 调用 binder_loop 方法进入循环状态，等待 Client 请求\n5. 根据服务名称注册服务·\n6. 接收 Binder 死亡通知\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/System-Boot/clipboard_20230323_045211.png)\n\n# zygote 进程 —— Java 进程的始祖\n\n## 1.启动 Java 虚拟机\n\n通过解析 init.rc 文件，zygote 进程对应的可执行程序的源文件为 [frameworks/base/cmds/app_process/app_main.cpp]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/cmds/app_process/app_main.cpp)，它的 main 方法如下：\n\n```c++\nint main(int argc, char* const argv[])\n{\n    ...\n    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));\n    ...\n    // Parse runtime arguments.  Stop at first unrecognized option.\n    bool zygote = false;\n    bool startSystemServer = false;\n    bool application = false;\n    String8 niceName;\n    String8 className;\n    \n    ++i;  // Skip unused \"parent dir\" argument.\n    while (i \u003c argc) {\n        const char* arg = argv[i++];\n        if (strcmp(arg, \"--zygote\") == 0) {\n            // 当前进程是否用于承载 zygote\n            zygote = true;\n            niceName = ZYGOTE_NICE_NAME;\n        } else if (strcmp(arg, \"--start-system-server\") == 0) { \n            // 是否需要启动 system_server 进程\n            startSystemServer = true;\n        } else if (strcmp(arg, \"--application\") == 0) {\n            // 启动进入独立的程序模式\n            application = true;\n        } else if (strncmp(arg, \"--nice-name=\", 12) == 0) {\n            // 此进程的别名\n            niceName.setTo(arg + 12);\n        } else if (strncmp(arg, \"--\", 2) != 0) {\n            className.setTo(arg);\n            break;\n        } else {\n            --i;\n            break;\n        }\n    }\n    \n    ...\n    \n    if (zygote) {\n        // 调用 AppRuntime 父类 AndroidRuntime 的 start 方法创建 zygote 进程\n        runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);\n    } else if (className) {\n        runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote);\n    } else {\n        fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\");\n        app_usage();\n        LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\");\n        return 10;\n    }\n}\n```\n\n在我们的场景中， init.rc 指定了 --zygote 选项，结合以上代码的注释可知，app_process64 接下来将启动 “ZygoteInit” 并传入 “start-system-server” 作为参数。\n\n之后 ZygoteInit 将会运行于 Java 虚拟机上——因为 runtime 变量实际上就是一个 AndroidRuntime 对象， [frameworks/base/core/jni/AndroidRuntime.cpp]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/jni/AndroidRuntime.cpp) 的 start 方法如下：\n\n```c++\nvoid AndroidRuntime::start(const char* className, const Vector\u003cString8\u003e\u0026 options, bool zygote)\n{\n    ...\n    /* start the virtual machine */\n    JniInvocation jni_invocation;\n    jni_invocation.Init(NULL);\n    JNIEnv* env;\n    // 启动 DVM\n    if (startVm(\u0026mJavaVM, \u0026env, zygote) != 0) {\n        return;\n    }\n    // 虚拟机启动后的回调\n    onVmCreated(env);\n    // 注册 JNI 方法\n    if (startReg(env) \u003c 0) {\n        ALOGE(\"Unable to register all android natives\\n\");\n        return;\n    }\n    jclass stringClass;\n    jobjectArray strArray;\n    jstring classNameStr;\n\n    stringClass = env-\u003eFindClass(\"java/lang/String\");\n    assert(stringClass != NULL);\n    // 创建数组\n    strArray = env-\u003eNewObjectArray(options.size() + 1, stringClass, NULL);\n    assert(strArray != NULL);\n    // 从 app_main 的 main 函数得知 className 为 com.android.internal.os.ZygoteInit\n    classNameStr = env-\u003eNewStringUTF(className);\n    assert(classNameStr != NULL);\n    env-\u003eSetObjectArrayElement(strArray, 0, classNameStr);\n\n    for (size_t i = 0; i \u003c options.size(); ++i) {\n        jstring optionsStr = env-\u003eNewStringUTF(options.itemAt(i).string());\n        assert(optionsStr != NULL);\n        env-\u003eSetObjectArrayElement(strArray, i + 1, optionsStr);\n    }\n    char* slashClassName = toSlashClassName(className);\n    jclass startClass = env-\u003eFindClass(slashClassName);\n    if (startClass == NULL) {\n        ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName);\n        /* keep going */\n    } else {\n        // 找到 ZygoteInit 的 main 函数\n        jmethodID startMeth = env-\u003eGetStaticMethodID(startClass, \"main\",\n            \"([Ljava/lang/String;)V\");\n        if (startMeth == NULL) {\n            ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className);\n            /* keep going */\n        } else {\n            // 通过 JNI 调用 ZygoteInit 的 main 函数\n            env-\u003eCallStaticVoidMethod(startClass, startMeth, strArray);\n            if (env-\u003eExceptionCheck())\n                threadExitUncaughtException(env);\n        }\n    }\n  ...\n}\n```\n\n## 2.加载 ZygoteInit\n\n通过 JNI 的方式进入 [frameworks/base/core/java/com/android/internal/os/ZygoteInit.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/ZygoteInit.java)：\n\n```java\npublic static void main(String argv[]) {\n    ...\n    try {\n        ...       \n        // 注册Zygote用的Socket\n        registerZygoteSocket(socketName);\n        ...\n        // 预加载类和资源\n        preload();//2\n        ...\n        if (startSystemServer) {\n            // 启动SystemServer进程\n            startSystemServer(abiList, socketName);\n        }\n        Log.i(TAG, \"Accepting command socket connections\");\n        // 等待客户端请求\n        runSelectLoop(abiList);\n        closeServerSocket();\n    } catch (MethodAndArgsCaller caller) {\n        caller.run();\n    } catch (RuntimeException ex) {\n        Log.e(TAG, \"Zygote died with exception\", ex);\n        closeServerSocket();\n        throw ex;\n    }\n}\n```\n\n### 1.注册一个 Socket\n\nregisterZygoteSocket 方法：\n\n```java\nprivate static void registerZygoteSocket(String socketName) {\n    if (sServerSocket == null) {\n        int fileDesc;\n        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;\n        try {\n            String env = System.getenv(fullSocketName);\n            fileDesc = Integer.parseInt(env);\n        } catch (RuntimeException ex) {\n            throw new RuntimeException(fullSocketName + \" unset or invalid\", ex);\n        }\n        try {\n            FileDescriptor fd = new FileDescriptor();\n            fd.setInt$(fileDesc);\n            // 创建 Socket 客户端\n            sServerSocket = new LocalServerSocket(fd);\n        } catch (IOException ex) {\n            throw new RuntimeException(\n                \"Error binding to local socket '\" + fileDesc + \"'\", ex);\n        }\n    }\n}\n```\n\n### 2.预加载各类资源\n\nPreload 方法：\n\n```java\nstatic void preload() {\n    Log.d(TAG, \"begin preload\");\n    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"BeginIcuCachePinning\");\n    beginIcuCachePinning();\n    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadClasses\");\n    preloadClasses();\n    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadResources\");\n    preloadResources();\n    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, \"PreloadOpenGL\");\n    preloadOpenGL();\n    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);\n    preloadSharedLibraries();\n    preloadTextResources();\n    // Ask the WebViewFactory to do any initialization that must run in the zygote process,\n    // for memory sharing purposes.\n    WebViewFactory.prepareWebViewInZygote();\n    endIcuCachePinning();\n    warmUpJcaProviders();\n    Log.d(TAG, \"end preload\");\n}\n```\n\n### 3.启动 system_server 进程\n\nstartSystemServer 方法：\n\n```java\nprivate static boolean startSystemServer(String abiList, String socketName)\n            throws MethodAndArgsCaller, RuntimeException {\n    ...\n    /* Hardcoded command line to start the system server */\n    // SystemServer 启动参数\n    String args[] = {\n        \"--setuid=1000\",\n        \"--setgid=1000\",\n        \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007,3009,3010\",\n        \"--capabilities=\" + capabilities + \",\" + capabilities,\n        \"--nice-name=system_server\",\n        \"--runtime-args\", \n        \"com.android.server.SystemServer\",\n    };\n    ZygoteConnection.Arguments parsedArgs = null;\n\n    int pid;\n\n    try {\n        parsedArgs = new ZygoteConnection.Arguments(args);\n        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n        // 调用 Zygote.java fock 出新线程，名字叫 system_server\n        pid = Zygote.forkSystemServer(\n                parsedArgs.uid, parsedArgs.gid,\n                parsedArgs.gids,\n                parsedArgs.debugFlags,\n                null,\n                parsedArgs.permittedCapabilities,\n                parsedArgs.effectiveCapabilities);\n    } catch (IllegalArgumentException ex) {\n        throw new RuntimeException(ex);\n    }\n    // pid 为 0 则为 fock 出来的子线程\n    if (pid == 0) {\n        if (hasSecondZygote(abiList)) {\n            waitForSecondaryZygote(socketName);\n        }\n        // 启动 SystemServer 进程\n        handleSystemServerProcess(parsedArgs);\n    }\n\n    return true;\n}\n```\n\n首先，拼装启动参数——注意，最后一个选现 --runtime-args 的参数为 \u003cstrong\u003e\"com.android.server.SystemServer\"\u003c/strong\u003e，接着会调用 [frameworks/base/core/java/com/android/internal/os/Zygote.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/Zygote.java) 的 forkSystemServer 方法：\n\n```java\npublic static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,\n            int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {\n    VM_HOOKS.preFork();\n    // 调用 Native 层的方法 fock 出子线程\n    int pid = nativeForkSystemServer(\n            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);\n    // Enable tracing as soon as we enter the system_server.\n    if (pid == 0) {// fock 出来的子线程中执行\n        Trace.setTracingEnabled(true);\n    }\n    VM_HOOKS.postForkCommon();\n    return pid;\n}\n```\n\n通过 nativeForkSystemServer 方法内部调用 nativeForkSystemServer 这个 Native 方法在当前进程中 fork 出一个子进程，随后这个进程会通过 handleSystemServerProcess() 方法来启动各种支撑系统运行的 system_server 进程。\n\n### 4.开启循环循环等待 fork 进程请求\n\n回头接着看 ZygoteInit.java 流程中的 runSelectLoop 方法：\n\n```java\nprivate static void runSelectLoop(String abiList) throws MethodAndArgsCaller {\n    ArrayList\u003cFileDescriptor\u003e fds = new ArrayList\u003cFileDescriptor\u003e();\n    ArrayList\u003cZygoteConnection\u003e peers = new ArrayList\u003cZygoteConnection\u003e();\n    // sServerSocket 对象就是刚才在 registerZygoteSocket 方法中创建的服务端 Socket\n    fds.add(sServerSocket.getFileDescriptor());\n    peers.add(null);\n\n    // 循环读取状态\n    while (true) {\n        StructPollfd[] pollFds = new StructPollfd[fds.size()];\n        for (int i = 0; i \u003c pollFds.length; ++i) {\n            pollFds[i] = new StructPollfd();\n            pollFds[i].fd = fds.get(i);\n            pollFds[i].events = (short) POLLIN;\n        }\n        try {\n            Os.poll(pollFds, -1);\n        } catch (ErrnoException ex) {\n            throw new RuntimeException(\"poll failed\", ex);\n        }\n        for (int i = pollFds.length - 1; i \u003e= 0; --i) {\n            // 读取的状态不是客户端连接或者数据请求时，进入下一次循环\n            if ((pollFds[i].revents \u0026 POLLIN) == 0) {\n                continue;\n            }\n            if (i == 0) {// i = 0 表示跟客户端 Socket 连接上了\n                ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                peers.add(newPeer);\n                fds.add(newPeer.getFileDesciptor());\n            } else {// i \u003e 0 表示接收到客户端 Socket 发送过来的请求\n                // runOnce 方法创建一个新的应用程序进程\n                boolean done = peers.get(i).runOnce();\n                if (done) {\n                    peers.remove(i);\n                    fds.remove(i);\n                }\n            }\n        }\n    }\n}\n```\n\nrunSelectLoop 方法的主体是一个 while 死循环，这决定了它作为 zygote 的守护体存在。\n\n[frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/ZygoteConnection.java) 的 runOnce 方法：\n\n```java\nboolean runOnce() throws ZygoteInit.MethodAndArgsCaller {\n\n    String args[];\n    Arguments parsedArgs = null;\n    FileDescriptor[] descriptors;\n\n    try {\n        // 读取 socket 客户端发送过来的参数列表\n        args = readArgumentList();\n        descriptors = mSocket.getAncillaryFileDescriptors();\n    } catch (IOException ex) {\n        // EOF reached.\n        closeSocket();\n        return true;\n    }\n    ...\n\n    try {\n        // 将 socket 客户端传递过来的参数，解析成 Arguments 对象格式\n        parsedArgs = new Arguments(args);\n        \n        ...\n        \n        // 调用 forkAndSpecialize 方法 fock 出子进程\n        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,\n                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,\n                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,\n                parsedArgs.appDataDir);\n    } catch (Exception e) {\n        ...\n    }\n\n    try {\n        if (pid == 0) {\n            // 子进程执行\n            IoUtils.closeQuietly(serverPipeFd);\n            serverPipeFd = null;\n            // 进入子进程流程\n            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);\n            return true;\n        } else {\n            // 父进程执行\n            IoUtils.closeQuietly(childPipeFd);\n            childPipeFd = null;\n            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);\n        }\n    } finally {\n        IoUtils.closeQuietly(childPipeFd);\n        IoUtils.closeQuietly(serverPipeFd);\n    }\n}\n```\n\n当收到 fork 请求时，首先获取从 socket 客户端传入的参数并存入 parsedArgs 变量，接着在代码块 25 行调用的是 [Zygote.java](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/Zygote.java) 的 forkAndSpecialize() 方法来 fork 出子进程，从这里开始一分为二，父进程和子进程继续往下执行。\n\n### 5.子进程执行入口函数\n\npid==0 表示为子进程这个分支，接着会执行 handleChildProc() 方法并将 parsedArgs 传入：\n\n```java\nprivate void handleChildProc(Arguments parsedArgs,\n        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)\n        throws ZygoteInit.MethodAndArgsCaller {\n        \n     // 关闭 socket\n     closeSocket();\n     ZygoteInit.closeServerSocket();\n     \n     ...\n     \n    if (parsedArgs.niceName != null) {\n        Process.setArgV0(parsedArgs.niceName);\n    }\n    // End of the postFork event.\n    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    if (parsedArgs.invokeWith != null) {\n        WrapperInit.execApplication(parsedArgs.invokeWith,\n                parsedArgs.niceName, parsedArgs.targetSdkVersion,\n                VMRuntime.getCurrentInstructionSet(),\n                pipeFd, parsedArgs.remainingArgs);\n    } else {\n        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,\n                parsedArgs.remainingArgs, null /* classLoader */);\n    }\n}\n```\n\n由于子进程 fork 自 zygote，因此也复制了 zygote 进程的地址空间，因此也会得到 zygote 进程创建的 socket，而这个 socket 对于子进程是无用的，因此需要关闭该 socket。\n\n接着在最后会调用 RuntimeInit 的 zygoteInit 方法并传入 parsedArgs.remainingArgs。这里先不看 zygoteInit 的内容，但是可以剧透一下：后面的一系列流程概括起来就是找到并执行目标进程的入口函数，并执行它的 main 函数。\n\n### 6.番外：Socket 客户端发送创建进程请求\n\n应用程序启动时，必须要启动一个进程用于承载这个应用，而向 zygote 进程发送 fork 进程请求的则是 ActivityManagerService，简称 AMS：\n\n```java\nprivate final void startProcessLocked(ProcessRecord app, String hostingType,\n            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {\n        {\n    ...\n    try {\n        ...\n        // Start the process.  It will either succeed and return a result containing\n        // the PID of the new process, or else throw a RuntimeException.\n        boolean isActivityProcess = (entryPoint == null);\n        if (entryPoint == null) entryPoint = \"android.app.ActivityThread\";\n        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" +\n                app.processName);\n        checkTime(startTime, \"startProcess: asking zygote to start proc\");\n        Process.ProcessStartResult startResult = Process.start(entryPoint,\n                app.processName, uid, uid, gids, debugFlags, mountExternal,\n                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,\n                app.info.dataDir, entryPointArgs);\n        checkTime(startTime, \"startProcess: returned from zygote!\");\n        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n        ...\n    } catch (RuntimeException e) {\n        ...\n    }\n}\n```\n\n可以看到，Process.start 方法显示就是去启动一个新的进程以承载业务，而第一个参数 entryPoint 经过兜兜转转最终就是 invokeStaticMain() 方法的 className 参数，entryPoint 的默认值为 \"android.app.ActivityThread\"。\n\n也就是说，zygote 进程在接到 AMS 请求的时候，会 fork 出一个子进程并且将 ActivityThread 作为入口，而 ActivityThread 就是我们熟知的 Android 应用程序的“主线程”：\n\n```java\npublic static void main(String[] args) {\n    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\");\n    ...\n    Looper.prepareMainLooper();\n    ActivityThread thread = new ActivityThread();\n    thread.attach(false);\n    if (sMainThreadHandler == null) {\n        sMainThreadHandler = thread.getHandler();\n    }\n    if (false) {\n        Looper.myLooper().setMessageLogging(new\n                LogPrinter(Log.DEBUG, \"ActivityThread\"));\n    }\n    // End of event ActivityThreadMain.\n    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n    Looper.loop();\n    throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n}\n```\n\n## 小结\n\n从 App_main 开始，zygote 启动过程的时序图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/System-Boot/clipboard_20230323_045226.png)\n\n可以看到，这个过程中 zygote 首先启动了 AndroidRuntime 并通过它反射调用了 ZygoteInit.main() 方法，由此进入了 Java 的世界，因此 zygote 是 Java 层的第一个进程，也是其他 Java 进程的始祖，其他 Java 进程的创建必须依赖 zygote。\n\nzygote 进程的任务分别是：\n\n1. 创建 AppRuntime（继承自 AndroidRuntime）， 并调用它的 \u003cstrong\u003estart\u003c/strong\u003e 方法\n2. 调用 AndroidRuntime 的 \u003cstrong\u003estartVM()\u003c/strong\u003e 方法创建 DVM（Dalvik Virtual Machine），并调用 \u003cstrong\u003estartReg()\u003c/strong\u003e 方法为 DVM 注册 JNI\n3. 通过 JNI 调用 \u003cstrong\u003eZygoteInit.main()\u003c/strong\u003e 方法，第一次进入 Java 的世界\n4. 调用 \u003cstrong\u003eregisterZygoteSocket()\u003c/strong\u003e 函数建立 Socket 通道，使 zygote 进程成为 Socket 服务端\n5. 调用 \u003cstrong\u003epreload()\u003c/strong\u003e 方法预加载各种资源\n6. 调用 \u003cstrong\u003estartSystemServer()\u003c/strong\u003e 函数 fock 出 system_server 进程\n7. 通过 \u003cstrong\u003erunSelectLoop()\u003c/strong\u003e 函数等待 ActivityManagerService 发送请求创建新的应用程序进程\n\n# system_server 进程 —— 承载 framework 层核心业务\n\nsystem_server 进程主要用户创建系统服务，framework 层的 AMS、WMS 和 PMS 等关键服务都是由它创建出来的。\n\n在上一小节中我们已经知道，zygote 进程在启动的过程中会通过 startSystemServer 方法 fock 出了一个叫 system_server 的进程，然后在该方法内执行了 handleSystemServerProcess 方法：\n\n```java\nprivate static void handleSystemServerProcess(\n          ZygoteConnection.Arguments parsedArgs)\n          throws ZygoteInit.MethodAndArgsCaller {\n    /** 这个 Socket 对 system_server 来说同样无用处，这里将其关闭 **/\n    closeServerSocket();\n    ...\n    if (parsedArgs.invokeWith != null) {\n        ...\n    } else {\n        ClassLoader cl = null;\n        if (systemServerClasspath != null) {\n            cl = createSystemServerClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);\n            Thread.currentThread().setContextClassLoader(cl);\n        }\n        // 又是调用了它的 zygoteInit 方法\n        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);\n    }\n}\n```\n\n这里再次出现了 [RuntimeInit](https://android.googlesource.com/platform/frameworks/base/+/nougat-release/core/java/com/android/internal/os/RuntimeInit.java).zygoteInit() 方法：\n\n```java\npublic static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n    if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\");\n    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\");\n    redirectLogStreams();\n    commonInit();\n    // 通过 Native 层中 AndroidRuntime.cpp 的 JNI 方法最终调用 app_main.cpp \n    // 的 onZygoteInit 方法启动 Binder 线程池， \n    // 使 system_server 进程可以使用 Binder 与其他进程通信 \n    nativeZygoteInit();\n    // 继续往下调用\n    applicationInit(targetSdkVersion, argv, classLoader);\n}\n```\n\n顾名思义，这是一个初始化方法，它将通过三个方面来完成初始化。\n\n首先是 commonInit，通用部分的初始化，包括设置默认的 uncaught exception handler、为 HttpURLConnection 准备好默认的 HTTP User-Agent 等；接着，nativeZygoteInit() 这个是一个 Native 层的初始化方法；最后是 applicatInit()，它是程序运行的起点。\n\n经过这两个过程的初始化后，程序现在会出现两个分支：nativeZygoteInit 主导的 Native 层系统服务启动，以及 applicationInit 负责的 Java 层系统服务的启动。\n\n## 1.启动 Native 层系统服务\n\nnativeZygoteInit() 是一个 Native 方法，它对应的文件为  [frameworks/base/core/jni/AndroidRuntime.cpp]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/jni/AndroidRuntime.cpp)，与该方法对应的函数为：\n\n```c++\nstatic void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)\n{\n    gCurRuntime-\u003eonZygoteInit();\n}\n```\n\ngCurRuntime 是一个 AndroidRuntime 对象全局变量，结合之前的分析可以猜测，AndroidRuntime 是一个父类，真正的实现则在 [frameworks/base/cmds/app_process/app_main.cpp]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/cmds/app_process/app_main.cpp) 中的 AppRuntime 。当新建 AppRuntime 实例时，它的父类构造函数就会被调用并为 gCurRuntime 赋值。上述的 onZygoteInit() 方法也在 app_main 中：\n\n```c++\nvirtual void onZygoteInit()\n{\n    sp\u003cProcessState\u003e proc = ProcessState::self();\n    ALOGV(\"App process: starting thread pool.\\n\");\n    proc-\u003estartThreadPool();\n}\n```\n\n这段代码是 Binder 机制中的重要组成部分，其中 startThreadPool() 方法将开启 Binder 线程池以保证其它线程可以正确访问到 Zygote 启动的服务。Zygote 通过 JNI 和回调的方式非常巧妙地把 Native 层和 Java 层、SystemServe 和 app_process 关联起来了。\n\n## 2.启动 Java 层系统服务\n\n接着看 RuntimeInit 的 applicationInit() 方法：\n\n```java\nprivate static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)\n            throws ZygoteInit.MethodAndArgsCaller {\n    ...\n    invokeStaticMain(args.startClass, args.startArgs, classLoader);\n}\n```\n\nRuntimeInit 的 invokeStaticMain 方法：\n\n```java\nprivate static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)\n         throws ZygoteInit.MethodAndArgsCaller {\n    Class\u003c?\u003e cl;\n    try {\n        /** className 为 ZygoteInit.java 中 startSystemServer 方法\n        传递过来的 \"com.android.server.SystemServer\"，这里通过反射得到 SystemServer 类 **/\n        cl = Class.forName(className, true, classLoader);\n    } catch (ClassNotFoundException ex) {\n        throw new RuntimeException(\n            \"Missing class when invoking static main \" + className, ex);\n    }\n    Method m;\n    try {\n        // 找到 SystemServer 类的 main 方法\n        m = cl.getMethod(\"main\", new Class[] { String[].class });\n    } catch (NoSuchMethodException ex) {\n        throw new RuntimeException(\n            \"Missing static main on \" + className, ex);\n    } catch (SecurityException ex) {\n        throw new RuntimeException(\n            \"Problem getting static main on \" + className, ex);\n    }\n    int modifiers = m.getModifiers();\n    if (! (Modifier.isStatic(modifiers) \u0026\u0026 Modifier.isPublic(modifiers))) {\n        throw new RuntimeException(\n            \"Main method is not public and static on \" + className);\n    }\n    /** 将 main 方法包装在 ZygoteInit.MethodAndArgsCaller 类中并作为异常抛出\n    捕获异常的地方在上一小节中 ZygoteInit.java 的 main 方法 **/\n    throw new ZygoteInit.MethodAndArgsCaller(m, argv);\n}\n```\n\n结合注释内容来看捕获这个异常的 [frameworks/base/core/java/com/android/internal/os/ZygoteInit.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/core/java/com/android/internal/os/ZygoteInit.java) 的 main 方法：\n\n```java\npublic static void main(String argv[]) {\n    ...\n    closeServerSocket();\n    } catch (MethodAndArgsCaller caller) {\n        // 接收到 caller 对象后调用它的 run 方法\n        caller.run();\n    } catch (RuntimeException ex) {\n        Log.e(TAG, \"Zygote died with exception\", ex);\n        closeServerSocket();\n        throw ex;\n    }\n}\n```\n\nZygoteInit 的 MethodAndArgsCaller 类是一个 Exception 类，同时也实现了 Runnable 接口：\n\n```java\npublic static class MethodAndArgsCaller extends Exception\n        implements Runnable {\n        \n    private final Method mMethod;\n    private final String[] mArgs;\n        \n    public MethodAndArgsCaller(Method method, String[] args) {\n        mMethod = method;\n        mArgs = args;\n    }\n    public void run() {\n        try {\n            // 调用传递过来的 mMethod\n            mMethod.invoke(null, new Object[] { mArgs });\n        } catch (IllegalAccessException ex) {\n            throw new RuntimeException(ex);\n        } catch (InvocationTargetException ex) {\n            ...\n        }\n    }\n}\n```\n\n这样，system_server 进程便启动起来并进入了 SystemServer.java 的 main 方法。\n\n这里需要思考一下，为什么需要抛出异常到 ZygoteInit 中执行？官方解释就是抛出异常的时候 Android 虚拟机会清空该进程堆内存中的栈帧，因此前面一系列启动 system_server 进程的过程中方法调用过程就被清除了，节省了堆栈的空间，使 ZygoteInit.java 的 main 方法处于所有 Java 进程的方法栈中的栈顶。\n\n同样地，zygote 进程接收到 AMS 请求并创建进程后，也会执行 ActivityThread 的 main 方法并将其作为 app 进程方法栈中的栈顶。\n\n\u003e 从最新 Android Pie 的代码中看，[ZygoteInit]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /pie-release/core/java/com/android/internal/os/ZygoteInit.java) 中的这个过程从 forkSystemServer() 方法开始，以及 runSelectLoop() 方法，已经变成在每一步中将包装好的 MethodAndArgsCaller 对象作为返回值返回，最后再执行这个对象的 call 方法，这样每个方法都在返回过程被弹出栈帧了，同样达到了以上的效果。\n\n查看 [frameworks/base/services/java/com/android/server/SystemServer.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/java/com/android/server/SystemServer.java) 的源码：\n\n```java\n/**\n * The main entry point from zygote.\n */\npublic static void main(String[] args) {\n    // 调用 run 方法\n    new SystemServer().run();\n}\n```\n\n```java\nprivate void run() {\n    ...\n    // 加载 libandroid_servers.so\n    System.loadLibrary(\"android_servers\");\n    ...\n    // 创建 SystemServiceManager\n    mSystemServiceManager = new SystemServiceManager(mSystemContext);\n    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);\n    ...    \n    try {\n        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \"StartServices\");\n        // 启动引导服务\n        startBootstrapServices();\n        // 启动核心服务\n        startCoreServices();\n        // 启动其他服务\n        startOtherServices();\n    } catch (Throwable ex) {\n        ...\n    } finally {\n        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);\n    }\n    ...\n}\n```\n\n可以看到，在 run 方法中，主要执行了启动引导服务、核心服务和其他服务的任务，这些服务加起来一共有 80 多个，它们对应这个各种不同的功能，部分服务如下：\n\n| 引导服务               | 作用                                                                           |\n| ---------------------- | ------------------------------------------------------------------------------ |\n| Installer              | 系统安装 apk 时的一个服务类，启动完成 Installer 服务之后才能启动其他的系统服务 |\n| ActivityManagerService | 负责四大组件的启动、切换、调度。                                               |\n| PowerManagerService    | 计算系统中和 Power 相关的计算，然后决策系统应该如何反应                        |\n| LightsService          | 管理和显示背光 LED                                                             |\n| DisplayManagerService  | 用来管理所有显示设备                                                           |\n| UserManagerService     | 多用户模式管理                                                                 |\n| SensorService          | 为系统提供各种感应器服务                                                       |\n| PackageManagerService  | 用来对 apk 进行安装、解析、删除、卸载等等操作                                  |\n\n| 核心服务             | 作用                                    |\n| -------------------- | --------------------------------------- |\n| BatteryService       | 管理电池相关的服务                      |\n| UsageStatsService    | 收集用户使用每一个 APP 的频率、使用时常 |\n| WebViewUpdateService | WebView 更新服务                        |\n\n| 其他服务                    | 作用               |\n| --------------------------- | ------------------ |\n| CameraService               | 摄像头相关服务     |\n| AlarmManagerService         | 全局定时器管理服务 |\n| InputManagerService         | 管理输入事件       |\n| WindowManagerService        | 窗口管理服务       |\n| VrManagerService            | VR 模式管理服务    |\n| BluetoothService            | 蓝牙管理服务       |\n| NotificationManagerService  | 通知管理服务       |\n| DeviceStorageMonitorService | 存储相关管理服务   |\n| LocationManagerService      | 定位管理服务       |\n| AudioService                | 音频相关管理服务   |\n| ...                         | ...                |\n\n## 小结\n\nsystem_server 进程在启动过程中完成的工作分别是:\n\n1. 通用部分的初始化\n2. 启动 Binder 线程池，使进程可以通过 Binder 与其他进程进程通信\n3. 创建 SystemServiceManager\n4. 使用 SystemServiceManager 对各种系统服务进行创建、启动和生命周期管理\n\n# Launcher —— Android 系统的“桌面”\n\n在上一节 [frameworks/base/services/java/com/android/server/SystemServer.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/java/com/android/server/SystemServer.java) 的 main 方法中，有一句：\n\n```java\nprivate void startOtherServices() {\n    ...\n    // 调用 AMS 的 systemReady 方法\n    mActivityManagerService.systemReady(new Runnable() {\n        @Override\n        public void run() {\n            ...\n        }\n    }\n    ...\n}\n```\n\n继续跟踪：\n\n[frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityManagerService.java)：\n\n```java\npublic void systemReady(final Runnable goingCallback) {\n    ...\n    synchronized (this) {\n        ...\n        // 调用 ActivityStackSupervisor 的 resumeFocusedStackTopActivityLocked 方法\n        mStackSupervisor.resumeFocusedStackTopActivityLocked();\n        mUserController.sendUserSwitchBroadcastsLocked(-1, currentUserId);\n    }\n}\n```\n\n[frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityStackSupervisor.java)：\n\n```java\nboolean resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target,\n        ActivityOptions targetOptions) {\n    if (targetStack != null \u0026\u0026 isFocusedStack(targetStack)) {\n        // 调用 ActivityStack 的 resumeTopActivityUncheckedLocked 方法\n        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);\n    }\n    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();\n    if (r == null || r.state != RESUMED) {\n        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);\n    }\n    return false;\n}\n```\n\n[ActivityStack]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityStack.java)：\n\n```java\nboolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {\n    if (mStackSupervisor.inResumeTopActivity) {\n        return false;\n    }\n\n    boolean result = false;\n    try {\n        // Protect against recursion.\n        mStackSupervisor.inResumeTopActivity = true;\n        if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) {\n            mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN;\n            mService.updateSleepIfNeededLocked();\n        }\n        // 调用 resumeTopActivityInnerLocked 方法\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        mStackSupervisor.inResumeTopActivity = false;\n    }\n    return result;\n}\n```\n\n```java\nprivate boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {\n   ...\n   // 回到 ActivityStackSupervisor 的 resumeHomeStackTask 方法\n   return isOnHomeDisplay() \u0026\u0026 mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, \"prevFinished\");\n   ...                 \n}\n```\n\n[frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java]([https://android.googlesource.com/platform/frameworks/base/](https://android.googlesource.com/platform/frameworks/base/) /nougat-release/services/core/java/com/android/server/am/ActivityStackSupervisor.java)：\n\n```java\nboolean resumeHomeStackTask(int homeStackTaskType, ActivityRecord prev, String reason) {\n    ...\n    if (r != null \u0026\u0026 !r.finishing) {\n        mService.setFocusedActivityLocked(r, myReason);\n        return resumeFocusedStackTopActivityLocked(mHomeStack, prev, null);\n    }\n    // 再次回到 AMS 的 startHomeActivityLocked 方法\n    return mService.startHomeActivityLocked(mCurrentUser, myReason);\n}\n```\n\n```java\nboolean startHomeActivityLocked(int userId, String reason) {\n    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL\n            \u0026\u0026 mTopAction == null) {\n        return false;\n    }\n    // 获取 Intent\n    Intent intent = getHomeIntent();\n    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);\n    if (aInfo != null) {\n        intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));\n        aInfo = new ActivityInfo(aInfo);\n        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);\n        ProcessRecord app = getProcessRecordLocked(aInfo.processName,\n                aInfo.applicationInfo.uid, true);\n        if (app == null || app.instrumentationClass == null) {\n            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);\n            // 使用 mActivityStarter 启动 app，这里不再详细跟踪\n            mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);\n        }\n    } else {\n            Slog.wtf(TAG, \"No home screen found for \" + intent, new Throwable());\n    }\n\n    return true;\n}\n```\n\ngetHomeIntent 方法：\n\n```java\nIntent getHomeIntent() {\n    Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);\n    intent.setComponent(mTopComponent);\n    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);\n    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {\n        // 添加 android.intent.category.HOME\n        intent.addCategory(Intent.CATEGORY_HOME);\n    }\n    return intent;\n}\n```\n\n可以看到，最后通过一个隐式 Intent 使用 Intent.FLAG_ACTIVITY_NEW_TASK 模式启动了一个带 Intent.CATEGORY_HOME 标签的 Activity，而带有 Intent.CATEGORY_HOME 标签的 Activity 正是 Launcher App，它的 [AndroidManifest]([https://android.googlesource.com/platform/packages/apps/Launcher3/](https://android.googlesource.com/platform/packages/apps/Launcher3/) /nougat-release/AndroidManifest.xml?autodive=0) 文件如下：\n\n```xml\n\u003cmanifest\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.android.launcher3\"\u003e\n    \u003cuses-sdk android:targetSdkVersion=\"23\" android:minSdkVersion=\"16\"/\u003e\n    \n    ...\n    \n    \u003capplication\n        android:allowBackup=\"@bool/enable_backup\"\n        android:backupAgent=\"com.android.launcher3.LauncherBackupAgentHelper\"\n        android:hardwareAccelerated=\"true\"\n        android:icon=\"@mipmap/ic_launcher_home\"\n        android:label=\"@string/app_name\"\n        android:largeHeap=\"@bool/config_largeHeap\"\n        android:restoreAnyVersion=\"true\"\n        android:supportsRtl=\"true\" \u003e\n        \u003cactivity\n            android:name=\"com.android.launcher3.Launcher\"\n            android:launchMode=\"singleTask\"\n            android:clearTaskOnLaunch=\"true\"\n            android:stateNotNeeded=\"true\"\n            android:theme=\"@style/Theme\"\n            android:windowSoftInputMode=\"adjustPan\"\n            android:screenOrientation=\"nosensor\"\n            android:configChanges=\"keyboard|keyboardHidden|navigation\"\n            android:resumeWhilePausing=\"true\"\n            android:taskAffinity=\"\"\n            android:enabled=\"true\"\u003e\n            \u003cintent-filter\u003e\n                \u003caction android:name=\"android.intent.action.MAIN\" /\u003e\n                \u003ccategory android:name=\"android.intent.category.HOME\" /\u003e\n                \u003ccategory android:name=\"android.intent.category.DEFAULT\" /\u003e\n                \u003ccategory android:name=\"android.intent.category.MONKEY\"/\u003e\n            \u003c/intent-filter\u003e\n        \u003c/activity\u003e\n        \n        ...\n        \n    \u003c/application\u003e\n\u003c/manifest\u003e\n```\n\nLauncher 启动后会将所有已安装的应用图标展示在一个网格布局的 RecyclerView 里面，这时候用户就可以通过点击这些图标来启动相应的 app 了。\n\n这个过程的时序图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/System-Boot/clipboard_20230323_045238.png)\n\n关于 Launcher 如何将 App 图标显示出来等更多工作细节，可以参考 [Android M Launcher3 主流程源码浅析](https://blog.csdn.net/yanbober/article/details/50525559) 和 [Android 系统启动流程（四）Launcher 启动过程与系统启动流程](http://liuwangshu.cn/framework/booting/4-launcher.html)这两篇文章。\n\n# 总结\n\n最后，从整体上来看 Android 系统的启动流程：\n\n1. 按下电源，固化在 ROM 中预定位置的 Bootloader 将会被加载到内存中\n2. Bootloader 初始化完软硬件环境后将 Linux 内核启动起来\n3. Linux 内核启动时会做设置缓存、被保护存储器、计划列表和加载驱动等一些列操作，内核启动完成后会启动 init 进程\n4. init 进程会初始化并启动属性服务，并且解析并执行所有 init.rc 文件\n5. init 通过执行特定的 init.rc 文件启动 servermanager 进程，servermanager 被启动后会向 Binder 驱动发送命令让自己成为守护进程并管理所有上下文\n6. init 通过解析 init.rc 文件启动 zygote 进程\n7. zygote 进程启动的过程会创建 DVM 并为其注册 JNI 函数，然后创建服务端 Socket、启动 system_server 进程\n8. 启动 system_server 进程的过程会创建 Binder 线程池使其具有 IPC 能力，然后启动 AMS 等各种系统服务\n9. AMS 启动 Launcher，Launcher 被启动后会将已安装应用的图标显示在界面上\n\n原来，一个复杂的 Android 系统就这么被运行起来了，碍于本人有限的水平，描述这个过程其实也还简化了很多操作，下面这个图比较全面地总结了这个流程：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/System-Boot/clipboard_20230323_045241.png)\n\n\u003cstrong\u003e系列文章\u003c/strong\u003e\n\n[按下电源键后竟然发生了这一幕 —— Android 系统启动流程分析](https://guanpj.cn/2017/09/17/Android-System-Startup-Flow-Analyze/)（本文）\n\n[App 竟然是这样跑起来的 —— Android App/Activity 启动流程分析](https://guanpj.cn/2017/10/23/Android-App-Startup-Flow-Analyze/)\n\n[屏幕上内容究竟是怎样画出来的 —— Android View 工作原理详解](https://guanpj.cn/2017/11/09/Android-View-Workflow/)\n\n\u003cstrong\u003e参考文章\u003c/strong\u003e\n\n[Gityuan 大神的系列文章](http://gityuan.com/android/)\n\n[刘望舒老师的系列文章](http://liuwangshu.cn/tags/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8/)\n\n[嵌入式系统 Boot Loader 技术内幕](https://www.ibm.com/developerworks/cn/linux/l-btloader/index.html)\n\n\u003e 如果你对文章内容有疑问或者有不同的意见，欢迎留言，我们一同探讨。\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["zygote","Bootloader","Framework"]},"/%E5%A7%94%E6%89%98":{"title":"委托","content":"https://juejin.cn/post/7043843490366619685","lastmodified":"2023-04-21T14:55:32.613227217Z","tags":[]},"/%E5%AE%B9%E5%99%A8%E7%B1%BB":{"title":"容器类","content":"全家福：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095328.png)\n# Iterable 接口\n\n可迭代的意思，实现此接口允许对象成为“for-each”循环语句的目标，提供 iterator 方法用于遍历元素。\n\n```java\npublic interface Iterable\u003cT\u003e {\n    Iterator\u003cT\u003e iterator();\n\n    default void forEach(Consumer\u003c? super T\u003e action) {\n        Objects.requireNonNull(action);\n        for (T t : this) {\n            action.accept(t);\n        }\n    }\n\n    default Spliterator\u003cT\u003e spliterator() {\n        return Spliterators.spliteratorUnknownSize(iterator(), 0);\n    }\n}\n```\n\nIterator 意思为迭代器，它的定义如下：\n\n```java\npublic interface Iterator\u003cE\u003e {\n    boolean hasNext();\n\n    E next();\n\n    default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n\n    default void forEachRemaining(Consumer\u003c? super E\u003e action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n```\n\n迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的接口。它是一个经典的设计模式——迭代器模式（Iterator）。 迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e当使用 Iterator 对集合元素进行迭代时，Iterator 并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量），所以修改迭代变量的值对集合元素本身没有任何影响。\n\n# Collection 接口\n\nCollection 接口为集合层次的根接口，Collection 框架概览如图：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095429.png)\nCollection 接口中的关键方法定义如下：\n\n```java\npublic interface Collection\u003cE\u003e extends Iterable\u003cE\u003e {\n    // 集合大小\n    int size();\n    // 是否为空\n    boolean isEmpty();\n    // 是否包含此元素 o\n    boolean contains(Object o);\n    // 迭代器\n    Iterator\u003cE\u003e iterator();\n    // 转换成数组\n    Object[] toArray();\n    // 转换成指定类型数组\n    \u003cT\u003e T[] toArray(T[] a);\n    // 添加元素 e\n    boolean add(E e);\n    // 移除元素 o\n    boolean remove(Object o);\n    // 是否包含另一集合 c\n    boolean containsAll(Collection\u003c?\u003e c);\n    // 移除所有集合 c 中的元素\n    boolean removeAll(Collection\u003c?\u003e c);\n    /**\n     * 移除符合条件的元素\n     * @since 1.8\n     */\n    default boolean removeIf(Predicate\u003c? super E\u003e filter) {\n        Objects.requireNonNull(filter);\n        boolean removed = false;\n        final Iterator\u003cE\u003e each = iterator();\n        while (each.hasNext()) {\n            if (filter.test(each.next())) {\n                each.remove();\n                removed = true;\n            }\n        }\n        return removed;\n    }\n    // 判断集合中是否有不存在集合 c 中的元素\n    boolean retainAll(Collection\u003c?\u003e c);\n    // 清空所有元素\n    void clear();\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, 0);\n    }\n    /**\n     * @since 1.8\n     */\n    default Stream\u003cE\u003e stream() {\n        return StreamSupport.stream(spliterator(), false);\n    }\n    /**\n     * @since 1.8\n     */\n    default Stream\u003cE\u003e parallelStream() {\n        return StreamSupport.stream(spliterator(), true);\n    }\n}\n可以看出 Collection 有添加、删除和清除元素等方法。\n```\n\nCollection 接口下属有三个关键子借口，分别为 Set、Queue 和 List。\n\n## Set 接口\n\nSet 集合与 Collection 集合基本相同，没有提供任何额外的方法。实际上 Set 就是 Collection，只是行为略有不同（Set 不允许包含重复元素）。\n\nSet 集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个 Set 集合中，则 add() 方法会返回 false，且新元素不会被加入。\n\n```java\npublic interface Set\u003cE\u003e extends Collection\u003cE\u003e {\n    int size();\n\n    boolean isEmpty();\n\n    boolean contains(Object o);\n\n    Iterator\u003cE\u003e iterator();\n    \n    Object[] toArray();\n\n    \u003cT\u003e T[] toArray(T[] a);\n\n    boolean add(E e);\n\n    boolean remove(Object o);\n\n    boolean containsAll(Collection\u003c?\u003e c);\n\n    boolean addAll(Collection\u003c? extends E\u003e c);\n    \n    boolean removeAll(Collection\u003c?\u003e c);\n\n    void clear();\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT);\n    }\n}\n```\n\n### HashSet 类\n\nHashSet 是 Set 接口的典型实现，实现了 Set 接口中的所有方法，并没有添加额外的方法，大多数时候使用 Set 集合时就是使用这个实现类。使用的底层结构是 HashMap，按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。它的实现如下：\n\n```java\npublic class HashSet\u003cE\u003e extends AbstractSet\u003cE\u003e implements Set\u003cE\u003e {\n    static final long serialVersionUID = -5024744406713321676L;\n\n    private transient HashMap\u003cE,Object\u003e map;\n\n    private static final Object PRESENT = new Object();\n\n    public HashSet() {\n        map = new HashMap\u003c\u003e();\n    }\n\n    public HashSet(Collection\u003c? extends E\u003e c) {\n        map = new HashMap\u003c\u003e(Math.max((int) (c.size()/.75f) + 1, 16));\n        addAll(c);\n    }\n\n    public HashSet(int initialCapacity, float loadFactor) {\n        map = new HashMap\u003c\u003e(initialCapacity, loadFactor);\n    }\n\n    public HashSet(int initialCapacity) {\n        map = new HashMap\u003c\u003e(initialCapacity);\n    }\n\n    // dummy 并没有作用，只是用来区分重载构造方法\n    HashSet(int initialCapacity, float loadFactor, boolean dummy) {\n        map = new LinkedHashMap\u003c\u003e(initialCapacity, loadFactor);\n    }\n\n    public Iterator\u003cE\u003e iterator() {\n        return map.keySet().iterator();\n    }\n\n    public int size() {\n        return map.size();\n    }\n\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    public boolean contains(Object o) {\n        return map.containsKey(o);\n    }\n\n    public boolean add(E e) {\n        return map.put(e, PRESENT)==null;\n    }\n\n    public boolean remove(Object o) {\n        return map.remove(o)==PRESENT;\n    }\n\n    public void clear() {\n        map.clear();\n    }\n}\n```\n\n可以看出 HashSet 内部其实是一个 HashMap。它的 add(E e) 方法会调用 HashMap 的 put 方法，插入的值会作为 put 的 key 并且把 PRESENT 作为 put 方法的 value 值进行插入，put 方法新增一个原来不存在的值会返回 null，如果原来存在的话会返回原来存在的值，所以是 HashMap 保证了元素不重复。\n\n#### 特点\n\n- 不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。\n- HashSet 不是线程安全的，如果多个线程同时访问一个 HashSet，则必须通过代码来保证其同步。\n- 集合元素值可以是 null。\n\n#### 添加元素规则\n\n两个对象比较，具体分为如下四个情况：\n\n1. equals() 方法返回 false，hashCode() 方法返回不相等，HashSet 将会把它们存储在不同的位置。\n2. equals() 方法返回 true，hashCode() 方法返回不相等，HashSet 将会把它们存储在不同的位置。\n3. equals() 方法返回 true，hashCode() 方法比较相等，HashSet 将会把它们存储在相同的位置，在这个位置以链表式结构来保存多个对象。这是因为当向 HashSet 集合中存入一个元素时，HashSet 会调用对象的 hashCode() 方法来得到对象的 hashCode 值，然后根据该 hashCode 值来决定该对象存储在 HashSet 中存储位置。\n4. equals() 方法返回 true，hashCode() 方法返回 true，HashSet 将不予添加。\n\n如果 HashSet 中两个以上的元素具有相同的 hashCode 值，将会导致性能下降。所以如果重写类的 equals() 方法和 hashCode() 方法时，应尽量保证两个对象通过 hashCode() 方法返回值相等时，通过 equals() 方法比较返回 true。\n\n### LinkedHashSet 类\n\nLinkedHashSet 是 HashSet 的子类，也是根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素是以插入的顺序来保存的。当遍历 LinkedHashSet 集合里的元素时，LinkedHashSet 将会按元素的添加顺序来访问集合里的元素。但是由于要维护元素的插入顺序，在性能上略低与 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。\n\n它的实现如下：\n\n```java\npublic class LinkedHashSet\u003cE\u003e extends HashSet\u003cE\u003e implements Set\u003cE\u003e {\n\n    private static final long serialVersionUID = -2851667679971038690L;\n\n    public LinkedHashSet(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor, true);\n    }\n\n    public LinkedHashSet(int initialCapacity) {\n        super(initialCapacity, .75f, true);\n    }\n\n    public LinkedHashSet() {\n        super(16, .75f, true);\n    }\n\n    public LinkedHashSet(Collection\u003c? extends E\u003e c) {\n        super(Math.max(2*c.size(), 11), .75f, true);\n        addAll(c);\n    }\n\n    @Override\n    public Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.DISTINCT | \nSpliterator.ORDERED);\n    }\n}\n\n```\n\n可以看到，它的构造方法都是通过调用父类 HashSet 的三个参数的构造方法。\n\nHashSet 的构造分方法如下：\n\n```java\nHashSet(int initialCapacity, float loadFactor, boolean dummy) {\n    map = new LinkedHashMap\u003c\u003e(initialCapacity, loadFactor)\n}\n```\n\nLinkedHashMap 的实现见后文。\n\n### TreeSet 类\n\nTreeSet 是 SortedSet 接口的实现类，正如 SortedSet 名字所暗示的，TreeSet 可以确保集合元素处于排序状态。此外，TreeSet 还提供了几个额外的方法。\n\n#### 主要方法\n\ncomparator()：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。\n\nfirst()：返回此 set 中当前第一个（最低）元素。\n\nlast()：返回此 set 中当前最后一个（最高）元素。\n\nlower(E e)：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。\n\nhigher(E e)：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。\n\nfloor(E e)：返回此 set 中小于等于给定元素的最小值；如果不存在这样的元素，则返回 null。\n\nceiling(E e)：返回此 set 中大于给定元素的最大值；如果不存在这样的元素，则返回 null。\n\nsubSet(E fromElement, E toElement)：返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。\n\nheadSet(E toElement)：返回此 set 的部分视图，其元素小于 toElement。\n\ntailSet(E fromElement)：返回此 set 的部分视图，其元素大于等于 fromElement。\n\n#### 排序方式\n\nTreeSet 中所谓的有序，不同于之前所讲的插入顺序，而是通过集合中元素属性进行排序方式来实现的。TreeSet 支持两种排序方法：自然排序和定制排序。在默认情况下，TreeSet 采用自然排序。\n\n##### \u003cstrong\u003e自然排序\u003c/strong\u003e\n\nTreeSet 会调用集合中元素所属类的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列，即把通过 compareTo(Object obj) 方法比较后比较大的的往后排。这种方式就是自然排序。\n\n除了已经实现 Comparable 接口类（String 和 Integer 等）之外，如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口，否则就会出现异常。\n\n\u003cstrong\u003e注意：\u003c/strong\u003eTreeSet 中只能添加同一种类型的对象，否则无法比较，会出现异常。\n\n当一个对象调用该方法与另一个对象比较时，例如 obj1.compareTo(obj2)，如果该方法返回 0，则表明两个对象相等；如果该方法返回一个正整数，则表明 obj1 大于 obj2；如果该方法返回一个负整数，则表明 obj1 小于 obj2。\n\n##### \u003cstrong\u003e定制排序\u003c/strong\u003e\n\n定制排序是通过 Comparator 接口实现的。该接口包含一个 int compare(T o1,T o2) 方法，该方法用于比较 o1, o2 的大小：如果该方法返回正整数，则表明 o1 大于 o2；如果该方法返回 0，则表明 o1 等于 o2；如果该方法返回负整数，则表明 o1 小于 o2。\n\n如果要实现定制排序，则需要在创建 TreeSet 时，调用一个带参构造器，传入 Comparator 对 象。并有该 Comparator 对象负责集合元素的排序逻辑，此时集合元素可以不必实现 Comparable 接口。\n\n#### 判断元素相等\n\n对于 TreeSet 集合而言，判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较是否返回 0——如果通过 compareTo(Object obj) 方法比较返回 0，TreeSet 则会认为它们相等，不予添加入集合内；否则就认为它们不相等，添加到集合内。\n\n\u003cstrong\u003eTreeSet 是根据红黑树结构找到集合元素的存储位置。\u003c/strong\u003e\n\n注意：\n\n1. 无论使用自然排序还是定制排序，都可以通过自定义比较逻辑实现各种各样的排序方式。\n2. 如果向 TreeSet 中添加了一个可变对象后，并且后面程序修改了该可变对象的实例变量，这将导致它与其他对象的大小顺序发生了改变，但 TreeSet 不会再次调整它们。\n3. TreeSet 也是非线程安全的。\n\n### HashSet 和 TreeSet 对比\n\n\u003cstrong\u003e性能：HashSet \u003e LinkedHashSet \u003eTreeSet\u003c/strong\u003e\n\n- HashSet 以 hash 算法进行位置存储，特别适合用于添加、查询操作。\n- LinkedHashSet 由于要维护链表，性能比 HashSet 差点，但是有了链表，LinkedHashSet 更适合于插入、删除以及遍历操作。\n- TreeSet 需要额外的红黑树算法来维护集合的次序，性能最次。\n\n但是具体使用要考虑具体的使用场景。\n\n当需要一个特定排序的集合时，使用 TreeSet 集合。\n\n当经常使用添加、查询操作时，使用 HashSet。\n\n当经常插入排序或使用删除、插入及遍历操作时，使用 LinkedHashSet。\n\n## Queue 接口\n\nQueue 用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常队列不允许随机访问其中的元素。\n\n```java\npublic interface Queue\u003cE\u003e extends Collection\u003cE\u003e {\n    // 插入元素，容量已满时抛出 IllegalStateException 异常\n    boolean add(E e);\n    // 插入元素，容量已满时返回 false\n    boolean offer(E e);\n    // 移除队列头部元素并返回，当集合为空时抛出异常\n    E remove();\n    // 移除队列头部元素并返回，当集合为空时返回 null\n    E poll();\n    // 获取队列中第一个元素，当集合为空时抛出异常\n    E element();\n    // 获取队列中第一个元素，当集合为空时返回 null\n    E peek();\n}\n```\n\n### Deque 接口\n\nDeque 接口是 Queue 接口的子接口，它代表一个双端队列。\n\n就是说对于这个队列容器，既可以从头部插入也可以从尾部插入，既可以从头部获取，也可以从尾部获取，其机制如下图所示：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095517.png)\nLinkedList 也实现了 Deque 接口，所以也可以被当作双端队列使用。\n\n#### 主要方法\n\nvoid addFirst(E e):将指定元素插入此列表的开头。\n\nvoid addLast(E e): 将指定元素添加到此列表的结尾。\n\nE getFirst(E e): 返回此列表的第一个元素。\n\nE getLast(E e): 返回此列表的最后一个元素。\n\nboolean offerFirst(E e): 在此列表的开头插入指定的元素。\n\nboolean offerLast(E e): 在此列表末尾插入指定的元素。\n\nE peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。\n\nE peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。\n\nE pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。\n\nE pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。\n\nE removeFirst(E e): 移除并返回此列表的第一个元素。\n\nboolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\n\nE removeLast(E e): 移除并返回此列表的最后一个元素。\n\nboolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n\n从上面方法中可以看出，Deque 不仅可以当成双端队列使用，而且可以被当成栈来使用，因为该类里还包含了 pop(出栈)、push(入栈)两个方法。\n\n#### 与 Queue、Stack 的关系\n\n当 Deque 当做 Queue 队列使用时（FIFO），添加元素是添加到队尾，删除时删除的是头部元素。从 Queue 接口继承的方法对应 Deque 的方法如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095628.png)\nDeque 也能当 Stack 栈用（LIFO）。这时入栈、出栈元素都是在双端队列的头部进行。Deque  中和 Stack 对应的方法如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095654.png)\n\u003cstrong\u003e注意：\u003c/strong\u003eStack 过于古老，并且实现地非常不好，因此现在基本已经不用了，可以直接用 Deque 来代替 Stack 进行栈操作。\n\n#### ArrayDeque 类\n\n顾名思义，就是用数组实现的 Deque。既然底层是数组那肯定也可以指定其 capacity，也可以不指定，\u003cstrong\u003e默认长度是 16\u003c/strong\u003e，然后根据添加的元素的个数，动态扩展。ArrayDeque 由于是两端队列，所以其顺序是按照元素插入数组中对应位置产生的（下面会具体说明）。\n\n由于本身数据结构的限制，ArrayDeque 没有像 ArrayList 中的 trimToSize 方法可以为自己瘦身。ArrayDeque 的使用方法就是上面的 Deque 的使用方法，基本没有对 Deque 拓展什么方法。\n\n##### \u003cstrong\u003e实现原理\u003c/strong\u003e\n\nArrayDeque 为了满足可以同时在数组两端插入或删除元素的需求，其内部的动态数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。\n\nArrayDeque 维护了两个变量，表示 ArrayDeque 的头和尾：\n\n```java\n//具体存放元素的数组，数组大小一定是2的幂次方\ntransient Object[] elements; // non-private to \n//队列头索引\ntransient int head;\n//队列尾索引\ntransient int tail;\n//默认的最小初始化容量，即传入的容量小于8容量为8，而默认容量是16\nprivate static final int MIN_INITIAL_CAPACITY = 8;\n```\n\n当向头部插入元素时，head 下标减一然后插入元素。而 tail 表示的索引为当前末尾元素表示的索引值加一。若当向尾部插入元素时，直接向 tail 表示的位置插入，然后 tail 再减一。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095736.png)\n\n最初头部和尾部索引都是 0，addLast 方向往右，addFirst 方向往左，所以数组中间可能是空的，当头指针和尾指针相遇的时候对数组进行扩容，并对元素位置进行调整。\n\n注意：ArrayDeque 不是线程安全的。 当作为栈使用时，性能比 Stack 好；当作为队列使用时，性能比 LinkedList 好。\n\n### PriorityQueue 类\n\nPriorityQueue 是 Java 中唯一一个 Queue 接口的直接实现。PriorityQueue 保存队列元素的顺序不是按加入队列的顺序，而是按特定规则进行排序的。因此当调用 peek() 或 poll() 方法取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列中按规则排序最小的元素。\n\n#### 方法概览\n\nPriorityQueue 实现了 Queue 接口，下面列举出 PriorityQueue 的方法。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095901.png)\n\n#### 排序方式\n\n与 TreeSet 相同，PriorityQueue 中的元素可以默认自然排序（也就是数字默认是小的在队列头，字符串则按字典序排列）或者通过提供的 Comparator（比较器）在队列实例化时指定的排序方式。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e\n\n1. 队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素——选择方法是任意的。\n2. 当 PriorityQueue 中没有指定 Comparator 时，加入 PriorityQueue 的元素必须实现 Comparable 接口（即元素是可比较的），否则会导致 ClassCastException。\n\n#### 实现原理\n\nPriorityQueue 本质也是一个动态数组，在这一方面与 ArrayList 是一致的。它的成员变量和构造方法如下：\n\n```java\npublic class PriorityQueue\u003cE\u003e extends AbstractQueue\u003cE\u003e\n    implements java.io.Serializable {\n    private static final int DEFAULT_INITIAL_CAPACITY = 11;\n\n    transient Object[] queue; // non-private to simplify nested class access\n\n\n    private int size = 0;\n\n    private final Comparator\u003c? super E\u003e comparator;\n\n    transient int modCount = 0; // non-private to simplify nested class access\n\n    public PriorityQueue() {\n      this(DEFAULT_INITIAL_CAPACITY, null);\n    }\n\n    public PriorityQueue(int initialCapacity) {\n      this(initialCapacity, null);\n    }\n\n    public PriorityQueue(int initialCapacity,\n                         Comparator\u003c? super E\u003e comparator) {\n      // Note: This restriction of at least one is not actually \n      needed,but continues for 1.5 compatibility\n      if (initialCapacity \u003c 1)\n        throw new IllegalArgumentException();\n      this.queue = new Object[initialCapacity];\n      this.comparator = comparator;\n    }\n    ...\n}\n```\n\nPriorityQueue 可由以下三种构造方法创建：\n\n- 调用默认的构造方法时，使用默认的初始容量（DEFAULT_INITIAL_CAPACITY=11），并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable）。\n- 使用指定的初始容量，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable）。\n- 使用指定的初始容量，并根据指定的比较器 comparator 来排序其元素。\n\n从第三个构造方法可以看出，内部维护了一个动态数组。当添加元素到集合时，会先检查数组是否还有余量，有余量则把新元素加入集合，没余量则调用  grow() 方法增加容量，然后调用 siftUp 将新加入的元素排序插入对应位置。\n\n```java\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i \u003e= queue.length)\n        grow(i + 1);\n    size = i + 1;\n    if (i == 0)\n        queue[0] = e;\n    else\n        siftUp(i, e);\n    return true;\n}\n```\n\n除此之外，还要注意：\n\n1. PriorityQueue 不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的 PriorityBlockingQueue 类。\n2. 不允许插入 null 元素。\n3. PriorityQueue 实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是 O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是 O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是 O(1)。所以在遍历时，若不需要删除元素，则以 peek 的方式遍历每个元素。\n4. 方法 iterator() 中提供的迭代器并不保证以有序的方式遍历优 PriorityQueue 中的元素。\n\n## List 接口\n\nList 集合代表一个\u003cstrong\u003e元素有序、可重复\u003c/strong\u003e的集合，集合中每个元素都有其对应的顺序索引。List 集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List 集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为 0，第二个添加的元素索引为 1......\n\nList 作为 Collection 接口的子接口，可以使用 Collection 接口里的全部方法。而且由于 List 是有序集合，因此 List 集合里增加了一些根据索引来操作集合元素的方法。\n\n```java\npublic interface List\u003cE\u003e extends Collection\u003cE\u003e {\n    int size();\n\n    boolean isEmpty();\n\n    boolean contains(Object o);\n\n    Iterator\u003cE\u003e iterator();\n\n    Object[] toArray();\n\n    \u003cT\u003e T[] toArray(T[] a);\n\n    boolean add(E e);\n\n    boolean remove(Object o);\n\n    boolean containsAll(Collection\u003c?\u003e c);\n    \n    boolean addAll(Collection\u003c? extends E\u003e c);\n    \n    boolean addAll(int index, Collection\u003c? extends E\u003e c);\n    \n    boolean removeAll(Collection\u003c?\u003e c);\n    \n    boolean retainAll(Collection\u003c?\u003e c);\n    /**\n     * 根据 operator 指定的计算规则重新设置 List 集合的所有元素\n     * @since 1.8\n     */\n    default void replaceAll(UnaryOperator\u003cE\u003e operator) {\n        Objects.requireNonNull(operator);\n        final ListIterator\u003cE\u003e li = this.listIterator();\n        while (li.hasNext()) {\n            li.set(operator.apply(li.next()));\n        }\n    }\n    /**\n     * 根据Comparator参数对List集合的元素排序\n     * @since 1.8\n     */\n    default void sort(Comparator\u003c? super E\u003e c) {\n        Object[] a = this.toArray();\n        Arrays.sort(a, (Comparator) c);\n        ListIterator\u003cE\u003e i = this.listIterator();\n        for (Object e : a) {\n            i.next();\n            i.set((E) e);\n        }\n    }\n\n    void clear();\n    // 根据下标获取元素\n    E get(int index);\n    // 替换指定下标位置的元素\n    E set(int index, E element);\n    // 在指定下标位置插入元素\n    void add(int index, E element);\n    // 根据下标删除元素\n    E remove(int index);\n    // 获取元素下标，不存在则返回 -1\n    int indexOf(Object o);\n    // 获取与元素最后一个下标，，不存在则返回 -1\n    int lastIndexOf(Object o);\n\n    ListIterator\u003cE\u003e listIterator();\n    \n    ListIterator\u003cE\u003e listIterator(int index);\n    \n    List\u003cE\u003e subList(int fromIndex, int toIndex);\n    /**\n     * @since 1.8\n     */\n    @Override\n    default Spliterator\u003cE\u003e spliterator() {\n        return Spliterators.spliterator(this, Spliterator.ORDERED);\n    }\n}\n```\n\n可以看出，经过扩展之后，List 相比于 Collection 多了“顺序”的概念，并且支持根据下表对集合进行操作。\n\nisEmpty()、contains() 等方法重新声明是为了为了方便查看文档。比如在 java doc 文档里，在 List 接口里也能看到 Collecion 声明的相关接口。\n\n此外，Java 8 为 List 接口添加了如下两个默认方法：\n\n- \u003cstrong\u003evoid replaceAll(UnaryOperator operator)：\u003c/strong\u003e根据 operator 指定的计算规则重新设置 List 集合的所有元素。\n- \u003cstrong\u003evoid sort(Comparator c)：\u003c/strong\u003e根据 Comparator 参数对 List 集合的元素排序。\n\nListIterator 接口在 Iterator 接口基础上增加了如下方法：\n\n- \u003cstrong\u003eboolean hasPrevious()：\u003c/strong\u003e 如果以逆向遍历列表。如果迭代器有上一个元素，则返回 true。\n- \u003cstrong\u003eObject previous()：\u003c/strong\u003e返回迭代器的前一个元素。\n- \u003cstrong\u003evoid add(Object o)：\u003c/strong\u003e将指定的元素插入列表（可选操作）。\n\n与 Iterator 相比，ListIterator 增加了前向迭代的功能，还可以通过 add() 方法向 List 集合中添加元素。\n\n### ArrayList 类\n\nArrayList 作为 List 类的典型实现，完全支持之前介绍的 List 接口的全部功能。它的成员变量和构造方法声明如下：\n\n```java\npublic class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e\n        implements List\u003cE\u003e, RandomAccess {\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    transient Object[] elementData;\n    \n    private int size;\n    \n    /**\n     * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n    \n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity \u003e 0) {//初始容量大于0\n            //创建 initialCapacity 大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            // 创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {// 初始容量小于 0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n   /**\n    * 构造包含指定 collection 元素的列表，这些元素利用该集合的迭代器按顺序返回\n    * 如果指定的集合为 null，throws NullPointerException。\n    */\n     public ArrayList(Collection\u003c? extends E\u003e c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n    ...\n}\n```\n\nArrayList 是基于数组实现的 List 类，所以 ArrayList 类封装了一个动态的、允许再分配的 Object[] 数组。ArrayList 对象使用 initalCapacity 参数来设置该数组的长度，当向 ArrayList 中添加元素超过了该数组的长度时，它们的 initalCapacity 会自动增加。下面我们通过阅读 JDK 8 ArrayList 源码来了解这些内容。\n\n#### 扩容机制\n\n以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 \n\nJDK 7 new 无参构造的 ArrayList 对象时，直接创建了长度是 10 的 Object[] 数组 elementData 。并且 JDK 7 中的 ArrayList 的对象的创建类似于单例的饿汉式，而 JDK 8 中的 ArrayList 的对象的创建类似于单例的懒汉式。\n\n添加元素时，首先调用 add 方法：\n\n```java\n/**\n * 将指定的元素追加到此列表的末尾。\n */\npublic boolean add(E e) {\n    //添加元素之前，先调用ensureCapacityInternal方法\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    //这里看到ArrayList添加元素的实质就相当于为数组赋值\n    elementData[size++] = e;\n    return true;\n}\n```\n\n先调用了一个 ensureCapacityInternal() 方法，该方法用来确保数组中是否还有足够容量。\n\n\u003cstrong\u003e注意 ：JDK 11 移除了 ensureCapacityInternal() 和 ensureExplicitCapacity() 方法 \u003c/strong\u003e\n\n经过一系列方法，最后有个判断：如果剩余容量足够存放这个数据，则进行下一步，如果不够，则需要执行一个重要的方法：\n\n```java\n/**\n * 要分配的最大数组大小\n */\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n/**\n * ArrayList 扩容的核心方法。\n */\nprivate void grow(int minCapacity) {\n   // oldCapacity 为旧容量，newCapacity 为新容量\n   int oldCapacity = elementData.length;\n   //将 oldCapacity 右移一位，其效果相当于 oldCapacity / 2，\n   int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1);\n   //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n   if (newCapacity - minCapacity \u003c 0)\n      newCapacity = minCapacity;\n   // 如果新容量大于 MAX_ARRAY_SIZE，进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n   //如果 minCapacity大 于最大容量，则新容量则为 Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即 Integer.MAX_VALUE - 8。\n   if (newCapacity - MAX_ARRAY_SIZE \u003e 0)\n      newCapacity = hugeCapacity(minCapacity);\n   // minCapacity is usually close to size, so this is a win:\n   elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n`int newCapacity = oldCapacity + (oldCapacity \u003e\u003e 1)`，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）。\n\n由此可见，ArrayList 是一个能够进行动态扩展的数组。\n\n#### System.arraycopy() 和 Arrays.copyOf() 方法\n\nArrays.copyOf() 内部调用了 System.arraycopy() 方法，arraycopy() 方法由 native 层实现：\n\n```java\npublic static int[] copyOf(int[] original, int newLength) {\n   // 申请一个新的数组\n   int[] copy = new int[newLength];\n   // 调用System.arraycopy，将源数组中的数据进行拷贝，并返回新的数组\n   System.arraycopy(original, 0, copy, 0,\n           Math.min(original.length, newLength));\n   return copy;\n}\n\n/**\n * @param src 源数组\n * @param srcPos 源数组中的起始位置\n * @param dest 目标数组\n * @param destPos 目标数组中的起始位置\n * @param length 要复制的数组元素的数量\n */\npublic static native void arraycopy(Object src,  int  srcPos,\n                                    Object dest, int destPos,\n                                    int length);\n```\n\nensureCapacity() 和 trimToSize() 方法\n\n- \u003cstrong\u003evoid ensureCapacity(int minCapacity): \u003c/strong\u003e如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。\u003cstrong\u003e在增加大量数据之前，调用此方法，可以减少扩容次数。\u003c/strong\u003e\n- \u003cstrong\u003evoid trimToSize(): \u003c/strong\u003e将此 ArrayList 实例的容量调整为列表的当前大小。\n\n#### transient 的作用\n\n从构造方法中可以看到，实际存放集合元素的数组声明时时被 transient 所修饰的：\n\n`transient Object[] elementData;`\n\n当一个对象被序行化的时候，transient 修饰的变量的值是不包括在序行化的表示中的。但是 ArrayList 又是可序行化的类，elementData 是 ArrayList 具体存放元素的成员，用 transient 来修饰 elementData，岂不是反序列化后的 ArrayList 丢失了原先的元素？\n\n来看下面两个方法：\n\n```java\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException{\n    // Write out element count, and any hidden stuff\n    int expectedModCount = modCount;\n    s.defaultWriteObject();\n\n    // Write out size as capacity for behavioural compatibility with clone()\n    s.writeInt(size);\n\n    // Write out all elements in the proper order.\n    for (int i=0; i\u003csize; i++) {\n        s.writeObject(elementData[i]);\n    }\n\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n\n/**\n * Reconstitute the \u003ctt\u003eArrayList\u003c/tt\u003e instance from a stream (that is,\n * deserialize it).\n */\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n    elementData = EMPTY_ELEMENTDATA;\n\n    // Read in size, and any hidden stuff\n    s.defaultReadObject();\n\n    // Read in capacity\n    s.readInt(); // ignored\n\n    if (size \u003e 0) {\n        // be like clone(), allocate array based upon size not capacity\n        int capacity = calculateCapacity(elementData, size);\n        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);\n        ensureCapacityInternal(size);\n\n        Object[] a = elementData;\n        // Read in all elements in the proper order.\n        for (int i=0; i\u003csize; i++) {\n            a[i] = s.readObject();\n        }\n    }\n}\n由于 elementData 的扩容机制，数组中可能有空元素。因此，每次序列化的时候调用 writeObject() 方法，进而调用 defaultWriteObject() 方法忽略 elementData 先序列化 ArrayList 中的非 transient 元素，然后再通过遍历 elementData 只序列化那些有的元素。\n```\n\n这样一来，既\u003cstrong\u003e加快了序列化的速度，又减小了序列化之后的文件大小 。\u003c/strong\u003e\n\n反序列化时调用 readObject，从 ObjectInputStream 获取 size 和 element，再恢复到 elementData。\n\n//todo\n\n#### 遍历方式\n\nArrayList 支持 3 种遍历方式\n\n\u003cstrong\u003e第一种，通过迭代器遍历：\u003c/strong\u003e\n\n```java\nInteger value = null;\nIterator iter = list.iterator();\nwhile (iter.hasNext()) {\n    value = ter.next();\n}\n```\n\n\u003cstrong\u003e第二种，随机访问，通过索引值去遍历：\u003c/strong\u003e\n\n由于 ArrayList 实现了 RandomAccess 接口，它支持通过索引值去随机访问元素。\n\n```java\nInteger value = null;\nfor (int i = 0; i \u003c list.size(); i++) {\n    value = list.get(i);        \n}\n```\n\n\u003cstrong\u003e第三种，for 循环遍历：\u003c/strong\u003e\n\n```java\nInteger value = null;\nfor (Integer item : list) {\n    value = item;\n}\n```\n\n\u003cstrong\u003e遍历 ArrayList 时，使用随机访问(通过索引序号访问)效率最高，而使用迭代器的效率最低。\u003c/strong\u003e\n\n\u003cstrong\u003e//todo\u003c/strong\u003e\n\n### Vector 类\n\nVector 和 ArrayList 的实现基本类似，以 remove 方法为例：\n\n```java\npublic synchronized E remove(int index) {\n    modCount++;\n    if (index \u003e= elementCount)\n        throw new ArrayIndexOutOfBoundsException(index);\n    E oldValue = elementData(index);\n\n    int numMoved = elementCount - index - 1;\n    if (numMoved \u003e 0)\n        //复制数组，假设数组移除了中间某元素，后边有效值前移1位\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--elementCount] = null; // Let gc do its work\n\n    return oldValue;\n}\n```\n\n它的关键方法都加上了 synchronized 关键字，所以它是\u003cstrong\u003e线程安全\u003c/strong\u003e的，并且也因此\u003cstrong\u003e降低了性能\u003c/strong\u003e。\n\n除此之外，它的扩容机制也与 ArrayList 有所不同：\n\n```java\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    //扩容大小\n    int newCapacity = oldCapacity + ((capacityIncrement \u003e 0) ?\n                                     capacityIncrement : oldCapacity);\n    if (newCapacity - minCapacity \u003c 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE \u003e 0)\n        newCapacity = hugeCapacity(minCapacity);\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n当构造没有设置 capacityIncrement 时，一次扩容数组变成原来两倍，否则每次容量增加  capacityIncrement。\n\n#### Stack 类\n\nStack 是 Vector 的子类，用于模拟“栈”这种数据结构，即“后进先出”(LIFO)的容器。它提供了如下方法：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_095956.png)\n\n由于继承自 Vector，Stack 自然也继承了 Vecor 线程安全和性能较低的特点。因此 Stack 类基本处于废弃状态，实现栈结构可由 LinkedList 代替。\n\n### LinkedList 类\n\nLinkedList 类是 List 接口的实现类——这意味着它是一个 List 集合，可以根据索引来随机访问集合中的元素。\n\n```java\npublic class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e\n             implements List\u003cE\u003e, Deque\u003cE\u003e {\n    transient int size = 0;\n\n    transient Node\u003cE\u003e first;\n\n    transient Node\u003cE\u003e last;\n\n    public LinkedList() {\n    }\n\n    public LinkedList(Collection\u003c? extends E\u003e c) {\n        this();\n        addAll(c);\n    }\n    ...\n}\n```\n\n可以看出，LinkedList 还实现了 Deque 接口，可以被当作成双端队列来使用，因此既可以被当成\u003cstrong\u003e栈\u003c/strong\u003e来使用，也可以当成\u003cstrong\u003e队列\u003c/strong\u003e来使用。\n\nLinkedList 的实现机制与 ArrayList 完全不同。ArrayList 内部是以数组的形式来保存集合中的元素的，因此随机访问集合元素时有较好的性能；而 L inkedList 内部以链表的形式来保存集合中的元素，因此随机访问集合元素时性能较差，但在插入、删除元素时性能比较出色。\n\n由于 LinkedList 双端队列的特性，所以新增了一些方法。\n\n#### 方法概览\n\n```java\nvoid addFirst(E e):将指定元素插入此列表的开头。\nvoid addLast(E e): 将指定元素添加到此列表的结尾。\nE getFirst(E e): 返回此列表的第一个元素。\nE getLast(E e): 返回此列表的最后一个元素。\nboolean offerFirst(E e): 在此列表的开头插入指定的元素。\nboolean offerLast(E e): 在此列表末尾插入指定的元素。\nE peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。\nE peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。\nE pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。\nE pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。\nE removeFirst(E e): 移除并返回此列表的第一个元素。\nboolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\nE removeLast(E e): 移除并返回此列表的最后一个元素。\nboolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n```\n\n#### 实现原理\n\nLinkedList 调用默认构造函数，创建一个链表。由于维护了一个表头，表尾的 Node 对象的变量。可以进行后续的添加元素到链表中的操作，以及其他删除，插入等操作。也因此实现了双向队列的功能，即可向表头加入元素，也可以向表尾加入元素。\n\nNode 定义如下：\n\n```java\nprivate static class Node\u003cE\u003e {\n    E item;//节点值\n    Node\u003cE\u003e next;//后继节点\n    Node\u003cE\u003e prev;//前驱节点\n    Node(Node\u003cE\u003e prev, E element, Node\u003cE\u003e next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\n新增操作 add(E e)，默认使用尾插法添加元素：\n\n```java\npublic boolean add(E e) {\n    linkLast(e);\n    return true;\n}\n\nvoid linkLast(E e) {\n    final Node\u003cE\u003e l = last;\n    final Node\u003cE\u003e newNode = new Node\u003c\u003e(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n```\n\n删除指定元素 remove(Object o): \n\n```java\npublic boolean remove(Object o) {\n    //如果删除对象为null\n    if (o == null) {\n        //从头开始遍历\n        for (Node\u003cE\u003e x = first; x != null; x = x.next) {\n            //找到元素\n            if (x.item == null) {\n                //从链表中移除找到的元素\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        //从头开始遍历\n        for (Node\u003cE\u003e x = first; x != null; x = x.next) {\n            //找到元素\n            if (o.equals(x.item)) {\n                //从链表中移除找到的元素\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nE unlink(Node\u003cE\u003e x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node\u003cE\u003e next = x.next;//得到后继节点\n    final Node\u003cE\u003e prev = x.prev;//得到前驱节点\n    //删除前驱指针\n    if (prev == null) {\n        first = next;// 如果删除的节点是头节点,令头节点指向该节点的后继节点\n    } else {\n        prev.next = next;// 将前驱节点的后继节点指向后继节点\n        x.prev = null;\n    }\n    //删除后继指针\n    if (next == null) {\n        last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n```\n\n获取制定下表元素 get(int index):\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);//检查索引是否有效\n    return node(index).item;\n}\n\nNode\u003cE\u003e node(int index) {\n    // assert isElementIndex(index);\n    if (index \u003c (size \u003e\u003e 1)) {\n        Node\u003cE\u003e x = first;\n        for (int i = 0; i \u003c index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node\u003cE\u003e x = last;\n        for (int i = size - 1; i \u003e index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n```\n\nnode 方法首先会比较“index”和“双向链表长度的 1/2”；若前者小，则从链表头开始往后查找，直到 index 位置；否则，从链表末尾开始先前查找，直到 index 位置。\n\n由此可见，LinkedList 在插入、删除元素时性能比较出色，随机访问集合元素时性能较差。\n\n#### 遍历方式\n\n//todo\n\n# Map 接口\n\nMap 用于保存具有映射关系的数据。它是一种键值对的结构，即 Key-Value 结构，一个 Map 就是很多这样 K-V 键值对组成的，一个 K-V 结构我们将其称作 Entry，Key 和 Value 都可以是任何引用类型的数据。Map 的 Key 不允许重复，即同一个 Map 对象的任何两个 Key 通过 equals 方法比较总是返回 false。\n\nKey 和 Value 之间存在单向一对一关系，即通过指定的 Key，总能找到唯一的、确定的 Value。从 Map 中取出数据时，只要给出指定的 Key，就可以取出对应的 Value。\n\nMap 框架概览：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Iterable/clipboard_20230322_100030.png)\n\nMap 接口的定义如下：\n\n```java\npublic interface Map\u003cK,V\u003e {\n    int size();\n\n    boolean isEmpty();\n    \n    boolean containsKey(Object key);\n    \n    boolean containsValue(Object value);\n    \n    V get(Object key);\n    \n    V put(K key, V value);\n    \n    V remove(Object key);\n\n    void putAll(Map\u003c? extends K, ? extends V\u003e m);\n    \n    void clear();\n\n    Set\u003cK\u003e keySet();\n    \n    Collection\u003cV\u003e values();\n    \n    Entry\u003cK, V\u003e\u003e entrySet();\n    \n    interface Entry\u003cK,V\u003e {\n        K getKey();\n\n        V getValue();\n        \n        V setValue(V value);\n        \n        boolean equals(Object o);\n        \n        int hashCode();\n        /**\n         * @since 1.8\n         */\n        public static \u003cK extends Comparable\u003c? super K\u003e, V\u003e Comparator\u003cMap.Entry\u003cK,V\u003e\u003e comparingByKey() {\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e c1.getKey().compareTo(c2.getKey());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V extends Comparable\u003c? super V\u003e\u003e Comparator\u003cMap.Entry\u003cK,V\u003e\u003e comparingByValue() {\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e c1.getValue().compareTo(c2.getValue());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V\u003e Comparator\u003cMap.Entry\u003cK, V\u003e\u003e comparingByKey(Comparator\u003c? super K\u003e cmp) {\n            Objects.requireNonNull(cmp);\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e cmp.compare(c1.getKey(), c2.getKey());\n        }\n        /**\n         * @since 1.8\n         */\n        public static \u003cK, V\u003e Comparator\u003cMap.Entry\u003cK, V\u003e\u003e comparingByValue(Comparator\u003c? super V\u003e cmp) {\n            Objects.requireNonNull(cmp);\n            return (Comparator\u003cMap.Entry\u003cK, V\u003e\u003e \u0026 Serializable)\n                (c1, c2) -\u003e cmp.compare(c1.getValue(), c2.getValue());\n        }\n    }\n\n    boolean equals(Object o);\n\n    int hashCode();\n    // Defaultable methods\n    /**\n     * @since 1.8\n     */\n    default V getOrDefault(Object key, V defaultValue) {\n        V v;\n        return (((v = get(key)) != null) || containsKey(key))\n            ? v\n            : defaultValue;\n    }\n    /**\n     * @since 1.8\n     */\n    default void forEach(BiConsumer\u003c? super K, ? super V\u003e action) {\n        Objects.requireNonNull(action);\n        for (Map.Entry\u003cK, V\u003e entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n            action.accept(k, v);\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default void replaceAll(BiFunction\u003c? super K, ? super V, ? extends V\u003e function) {\n        Objects.requireNonNull(function);\n        for (Map.Entry\u003cK, V\u003e entry : entrySet()) {\n            K k;\n            V v;\n            try {\n                k = entry.getKey();\n                v = entry.getValue();\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n            // ise thrown from function is not a cme.\n            v = function.apply(k, v);\n            try {\n                entry.setValue(v);\n            } catch(IllegalStateException ise) {\n                // this usually means the entry is no longer in the map.\n                throw new ConcurrentModificationException(ise);\n            }\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V putIfAbsent(K key, V value) {\n        V v = get(key);\n        if (v == null) {\n            v = put(key, value);\n        }\n        return v;\n    }\n    /**\n     * @since 1.8\n     */\n    default boolean remove(Object key, Object value) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, value) ||\n            (curValue == null \u0026\u0026 !containsKey(key))) {\n            return false;\n        }\n        remove(key);\n        return true;\n    }\n    /**\n     * @since 1.8\n     */\n    default boolean replace(K key, V oldValue, V newValue) {\n        Object curValue = get(key);\n        if (!Objects.equals(curValue, oldValue) ||\n            (curValue == null \u0026\u0026 !containsKey(key))) {\n            return false;\n        }\n        put(key, newValue);\n        return true;\n    }\n    /**\n     * @since 1.8\n     */\n    default V replace(K key, V value) {\n        V curValue;\n        if (((curValue = get(key)) != null) || containsKey(key)) {\n            curValue = put(key, value);\n        }\n        return curValue;\n    }\n    /**\n     * @since 1.8\n     */\n    default V computeIfAbsent(K key,\n            Function\u003c? super K, ? extends V\u003e mappingFunction) {\n        Objects.requireNonNull(mappingFunction);\n        V v;\n        if ((v = get(key)) == null) {\n            V newValue;\n            if ((newValue = mappingFunction.apply(key)) != null) {\n                put(key, newValue);\n                return newValue;\n            }\n        }\n        return v;\n    }\n    /**\n     * @since 1.8\n     */\n    default V computeIfPresent(K key,\n            BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue;\n        if ((oldValue = get(key)) != null) {\n            V newValue = remappingFunction.apply(key, oldValue);\n            if (newValue != null) {\n                put(key, newValue);\n                return newValue;\n            } else {\n                remove(key);\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V compute(K key,\n            BiFunction\u003c? super K, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        V oldValue = get(key);\n        V newValue = remappingFunction.apply(key, oldValue);\n        if (newValue == null) {\n            // delete mapping\n            if (oldValue != null || containsKey(key)) {\n                // something to remove\n                remove(key);\n                return null;\n            } else {\n                // nothing to do. Leave things as they were.\n                return null;\n            }\n        } else {\n            // add or replace old mapping\n            put(key, newValue);\n            return newValue;\n        }\n    }\n    /**\n     * @since 1.8\n     */\n    default V merge(K key, V value,\n            BiFunction\u003c? super V, ? super V, ? extends V\u003e remappingFunction) {\n        Objects.requireNonNull(remappingFunction);\n        Objects.requireNonNull(value);\n        V oldValue = get(key);\n        V newValue = (oldValue == null) ? value :\n                   remappingFunction.apply(oldValue, value);\n        if(newValue == null) {\n            remove(key);\n        } else {\n            put(key, newValue);\n        }\n        return newValue;\n    }\n}\n```\n\nMap 接口处于整个框架的顶层，由一堆 Map 自身接口方法和一个 Entry 接口组成，Entry 接口定义了主要是关于 Key-Value 自身的一些操作，Map 接口定义的是一些属性和关于属性查找修改的一些接口方法。\n\n## HashMap\n\n见《HashMap 源码解析》\n\n### LinkedHashMap\n\nHashSet 有一个 LinkedHashSet 子类，HashMap 也有一个 LinkedHashMap 子类；LinkedHashMap 使用双向链表来维护 key-value 对的次序。\n\nLinkedHashMap 需要维护元素的插入顺序，因此性能略低于 HashMap 的性能；但是因为它以链表来维护内部顺序，所以在迭代访问 \u003cstrong\u003eMap 里的全部元素时有较好的性能\u003c/strong\u003e。迭代输出 LinkedHashMap 的元素时，将会按照添加 key-value 对的顺序输出。\n\n\u003cstrong\u003e本质上来讲，LinkedHashMap = 散列表 + 双向循环链表\u003c/strong\u003e\n\n#### \u003cstrong\u003e实现原理\u003c/strong\u003e\n\nLinkedHashMap 的主要成员变量和方法实现简化后如下：\n\n```java\npublic class LinkedHashMap\u003cK,V\u003e extends HashMap\u003cK,V\u003e \n          implements Map\u003cK,V\u003e {\n    static class Entry\u003cK,V\u003e extends HashMap.Node\u003cK,V\u003e {\n        Entry\u003cK,V\u003e before, after;\n        Entry(int hash, K key, V value, Node\u003cK,V\u003e next) {\n            super(hash, key, value, next);\n        }\n    } \n    // 双向链表的头节点\n    transient LinkedHashMap.Entry\u003cK,V\u003e head;\n    // 双向链表的尾戒低钠\n    transient LinkedHashMap.Entry\u003cK,V\u003e tail;\n    // 是否按照访问顺序排序\n    final boolean accessOrder;\n    \n    public LinkedHashMap(int initialCapacity, float loadFactor) {\n        super(initialCapacity, loadFactor);\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(int initialCapacity) {\n        super(initialCapacity);\n        accessOrder = false;\n    }\n\n    public LinkedHashMap() {\n        super();\n        accessOrder = false;\n    }\n\n    public LinkedHashMap(Map\u003c? extends K, ? extends V\u003e m) {\n        super();\n        accessOrder = false;\n        putMapEntries(m, false);\n    }\n\n    public LinkedHashMap(int initialCapacity,\n               float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n    \n    Node\u003cK,V\u003e newNode(int hash, K key, V value, Node\u003cK,V\u003e e) {\n        LinkedHashMap.Entry\u003cK,V\u003e p =\n            new LinkedHashMap.Entry\u003cK,V\u003e(hash, key, value, e);\n        // 将 Entry 接在双向链表的尾部\n        linkNodeLast(p);\n        return p;\n    }\n \n    @Overrid\n    Node\u003cK,V\u003e replacementNode(Node\u003cK,V\u003e p, Node\u003cK,V\u003e next) {\n        LinkedHashMap.Entry\u003cK,V\u003e q = (LinkedHashMap.Entry\u003cK,V\u003e)p;\n        LinkedHashMap.Entry\u003cK,V\u003e t = new LinkedHashMap.Entry\u003cK,V\u003e\n            (q.hash, q.key, q.value, next);\n        transferLinks(q, t);\n        return t;\n    }\n \n    @Overrid\n    TreeNode\u003cK,V\u003e newTreeNode(int hash, K key, V value, \n            Node\u003cK,V\u003e next) {\n        TreeNode\u003cK,V\u003e p = new TreeNode\u003cK,V\u003e(hash, key, value, next);\n        linkNodeLast(p);\n        return p;\n    }\n    \n    @Override\n    TreeNode\u003cK,V\u003e replacementTreeNode(Node\u003cK,V\u003e p, Node\u003cK,V\u003e next) {\n        LinkedHashMap.Entry\u003cK,V\u003e q = (LinkedHashMap.Entry\u003cK,V\u003e)p;\n        TreeNode\u003cK,V\u003e t = new TreeNode\u003cK,V\u003e(q.hash, q.key, \n            q.value, next);\n        transferLinks(q, t);\n        return t;\n    }\n    \n    // link at the end of list\n    private void linkNodeLast(LinkedHashMap.Entry\u003cK,V\u003e p) {\n        LinkedHashMap.Entry\u003cK,V\u003e last = tail;\n        tail = p;\n        // last 为 null，表明链表还未建立\n        if (last == null)\n            head = p;\n        else {\n            // 将新节点 p 接在链表尾部\n            p.before = last;\n            last.after = p;\n        }\n    }\n    \n    // apply src's links to dst\n    private void transferLinks(LinkedHashMap.Entry\u003cK,V\u003e src,\n                  LinkedHashMap.Entry\u003cK,V\u003e dst) {\n        LinkedHashMap.Entry\u003cK,V\u003e b = dst.before = src.before;\n        LinkedHashMap.Entry\u003cK,V\u003e a = dst.after = src.after;\n        if (b == null)\n            head = dst;\n        else\n            b.after = dst;\n        if (a == null)\n            tail = dst;\n        else\n            a.before = dst;\n    }\n    \n    @Override\n    void afterNodeAccess(Node\u003cK,V\u003e p) { }\n    @Override\n    void afterNodeInsertion(boolean evict) { }\n    @Override\n    void afterNodeRemoval(Node\u003cK,V\u003e e) { }\n}\n```\n\nLinkedHashMap 继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。\n\nMap 类型的集合类是通过 put(K,V) 方法插入键值对，LinkedHashMap 本身并没有覆写父类的 put 方法，而是直接使用了父类的实现。\n\n在 newNode 方法中，LinkedHashMap 创建了 Entry，并通过 linkNodeLast 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立\n\n#### afterNodeAccess()\n\n当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。\n\n```java\nvoid afterNodeAccess(Node\u003cK,V\u003e e) { // move node to last\n    LinkedHashMap.Entry\u003cK,V\u003e last;\n    if (accessOrder \u0026\u0026 (last = tail) != e) {\n        LinkedHashMap.Entry\u003cK,V\u003e p =\n            (LinkedHashMap.Entry\u003cK,V\u003e)e, b = p.before, a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n```\n\n#### afterNodeInsertion()\n\n```java\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n    LinkedHashMap.Entry\u003cK,V\u003e first;\n    if (evict \u0026\u0026 (first = head) != null \u0026\u0026 removeEldestEntry(first)) {\n        K key = first.key;\n        removeNode(hash(key), key, null, false, true);\n    }\n}\n\nprotected boolean removeEldestEntry(Map.Entry\u003cK,V\u003e eldest) {\n    return false;\n}\n```\n\n在元素新增之后，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。\n\nevict 只有在构建 Map 的时候才为 false，在这里为 true。\n\nremoveEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。\n\n#### afterNodeRemoval()\n\n元素被删除后，此方法会被回调，删除双向链表中对应的节点。\n\n```java\nvoid afterNodeRemoval(Node\u003cK,V\u003e e) { // unlink\n    LinkedHashMap.Entry\u003cK,V\u003e p = (LinkedHashMap.Entry\u003cK,V\u003e)e, \n          b = p.before, a = p.after;\n    // 将 p 节点的前驱后后继引用置空\n    p.before = p.after = null;\n    // b 为 null，说明 p 是头节点\n    if (b == null)\n        head = a;\n    else\n        b.after = a;\n    // a 为 null，说明 p 是尾节点\n    if (a == null)\n        tail = b;\n    else\n        a.before = b;\n}\n```\n\n#### LRU 缓存\n\n以下是使用 LinkedHashMap 实现的一个 LRU 缓存：\n\n- 设定最大缓存空间 MAX_ENTRIES 为 3；\n- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；\n- 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。\n\n```java\nclass LRUCache\u003cK, V\u003e extends LinkedHashMap\u003cK, V\u003e {\n    private static final int MAX_ENTRIES = 3;\n\n    protected boolean removeEldestEntry(Map.Entry eldest) {\n        return size() \u003e MAX_ENTRIES;\n    }\n\n    LRUCache() {\n        super(MAX_ENTRIES, 0.75f, true);\n    }\n}\n```\n\n## TreeMap\n\nTreeMap 是 SortedMap 接口的实现类。TreeMap 是一个\u003cstrong\u003e有序的 \u003c/strong\u003ekey-value 集合，它是通过红黑树实现的，每个 key-value 对即作为红黑树的一个节点。\n\n### 排序方式\n\n和 TreeSet 一样，TreeMap 有两种排序方式：\n\n- 自然排序：TreeMap 的所有 key 必须实现 Comparable 接口，而且所有的 key 应该是同一个类的对象，否则会抛出 ClassCastException 异常。\n- 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。\n\n### 判断元素相等\n\n类似于 TreeSet 中判断两个元素相等的标准，TreeMap 中判断两个 key 相等的标准是：两个 key 通过 compareTo() 方法返回 0，TreeMap 即认为这两个 key 是相等的；判断两个 value 相等的标准是：两个 value 通过 equals() 方法比较返回 true。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e如果使用自定义类作为 TreeMap 的 key，且想让 TreeMap 良好地工作，则重写该类的 equals() 方法和 compareTo() 方法时应保持一致的返回结果：两个 key 通过 equals()方 法比较返回 true 时，它们通过 compareTo() 方法比较应该返回 0。如果两个方法的返回结果不一致，TreeMap 与 Map 接口的规则就会冲突。\n\n除此之外，与 TreeSet 类似，TreeMap 根据排序特性，也添加了一部分新的方法，与 TreeSet 中的一致。可以参考本文前面的内容。\n\n### 实现原理\n\nTreeMap 基于红黑树实现，而红黑树是一种自平衡二叉查找树，所以查找操作流程和二叉查找树一致。TreeMap 可保证在 log(n) 时间复杂度内完成 containsKey、get、put 和 remove 操作，效率很高。另一方面，由于 TreeMap 基于红黑树实现，这为 TreeMap 保持键的有序性打下了基础。总的来说，TreeMap 的核心是红黑树，其很多方法也是对红黑树增删查基础操作的一个包装。\n\n# fast-fail 机制\n\n#\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["Collection","Iterable","Java 容器类","Java"]},"/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8":{"title":"并发容器","content":"# ConcurentHashMap\n\n## Java 7 实现\n\nJava 7 版本的 ConcurrentHashMap 数据结构示意图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurent-Container/clipboard_20230323_094240.png)\n\nConcurrentHashMap 内部进行了 Segment 分段，Segment 继承了 ReentrantLock，可以理解为一把锁，各个 Segment 之间都是相互独立上锁的，互不影响。相比于之前的 Hashtable 每次操作都需要把整个对象锁住而言，大大提高了并发效率。因为它的锁与锁之间是独立的，而不是整个对象只有一把锁。\n\n每个 Segment 的底层数据结构与 HashMap 类似，仍然是数组和链表组成的拉链法结构。默认有 0~15 共 16 个 Segment，所以最多可以同时支持 16 个线程并发操作（操作分别分布在不同的 Segment 上）。16 这个默认值可以在初始化的时候设置为其他值，但是一旦确认初始化以后，是不可以扩容的。\n\n### 构造方法\n\n```java\npublic ConcurrentHashMap(int initialCapacity,\n                         float loadFactor, int concurrencyLevel) {\n    if (!(loadFactor \u003e 0) || initialCapacity \u003c 0 \n            || concurrencyLevel \u003c= 0)\n        throw new IllegalArgumentException();\n    if (concurrencyLevel \u003e MAX_SEGMENTS)\n        concurrencyLevel = MAX_SEGMENTS;\n    // Find power-of-two sizes best matching arguments\n    int sshift = 0;\n    int ssize = 1;\n    while (ssize \u003c concurrencyLevel) {\n        ++sshift;\n        ssize \u003c\u003c= 1;\n    }\n    this.segmentShift = 32 - sshift;\n    this.segmentMask = ssize - 1;\n    if (initialCapacity \u003e MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    int c = initialCapacity / ssize;\n    if (c * ssize \u003c initialCapacity)\n        ++c;\n    int cap = MIN_SEGMENT_TABLE_CAPACITY;\n    while (cap \u003c c)\n        cap \u003c\u003c= 1;\n    // create segments and segments[0]\n    Segment\u003cK,V\u003e s0 =\n        new Segment\u003cK,V\u003e(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry\u003cK,V\u003e[])new HashEntry[cap]);\n    Segment\u003cK,V\u003e[] ss = (Segment\u003cK,V\u003e[])new Segment[ssize];\n    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n    this.segments = ss;\n}\n```\n\n### Segment\n\n```java\nstatic final class Segment\u003cK,V\u003e extends ReentrantLock {\n    static final int MAX_SCAN_RETRIES =\n        Runtime.getRuntime().availableProcessors() \u003e 1 ? 64 : 1;\n        \n    transient volatile HashEntry\u003cK,V\u003e[] table;\n    \n    transient int count;\n    \n    transient int modCount;\n    \n    transient int threshold;\n    \n    final float loadFactor;\n    \n    ...\n    final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n        HashEntry\u003cK,V\u003e node = tryLock() ? null :\n            scanAndLockForPut(key, hash, value);\n        V oldValue;\n        try {\n            HashEntry\u003cK,V\u003e[] tab = table;\n            int index = (tab.length - 1) \u0026 hash;\n            HashEntry\u003cK,V\u003e first = entryAt(tab, index);\n            for (HashEntry\u003cK,V\u003e e = first;;) {\n                if (e != null) {\n                    K k;\n                    if ((k = e.key) == key ||\n                        (e.hash == hash \u0026\u0026 key.equals(k))) {\n                        oldValue = e.value;\n                        if (!onlyIfAbsent) {\n                            e.value = value;\n                            ++modCount;\n                        }\n                        break;\n                    }\n                    e = e.next;\n                }\n                else {\n                    if (node != null)\n                        node.setNext(first);\n                    else\n                        node = new HashEntry\u003cK,V\u003e(hash, \n                                key, value, first);\n                    int c = count + 1;\n                    if (c \u003e threshold \u0026\u0026 \n                          tab.length \u003c MAXIMUM_CAPACITY)\n                        rehash(node);\n                    else\n                        setEntryAt(tab, index, node);\n                    ++modCount;\n                    count = c;\n                    oldValue = null;\n                    break;\n                }\n            }\n        } finally {\n            unlock();\n        }\n        return oldValue;\n    }\n    \n    private HashEntry\u003cK,V\u003e scanAndLockForPut(K key, \n            int hash, V value) {\n        HashEntry\u003cK,V\u003e first = entryForHash(this, hash);\n        HashEntry\u003cK,V\u003e e = first;\n        HashEntry\u003cK,V\u003e node = null;\n        int retries = -1; // negative while locating node\n        while (!tryLock()) {\n            HashEntry\u003cK,V\u003e f; // to recheck first below\n            if (retries \u003c 0) {\n                if (e == null) {\n                    if (node == null) // speculatively create node\n                        node = new HashEntry\u003cK,V\u003e(hash, \n                                key, value, null);\n                    retries = 0;\n                }\n                else if (key.equals(e.key))\n                    retries = 0;\n                else\n                    e = e.next;\n            }\n            else if (++retries \u003e MAX_SCAN_RETRIES) {\n                lock();\n                break;\n            }\n            else if ((retries \u0026 1) == 0 \u0026\u0026\n                 (f = entryForHash(this, hash)) != first) {\n                e = first = f; // re-traverse if entry changed\n                retries = -1;\n            }\n        }\n        return node;\n    }\n    \n    private void rehash(HashEntry\u003cK,V\u003e node) {\n        HashEntry\u003cK,V\u003e[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        int newCapacity = oldCapacity \u003c\u003c 1;\n        threshold = (int)(newCapacity * loadFactor);\n        HashEntry\u003cK,V\u003e[] newTable =\n            (HashEntry\u003cK,V\u003e[]) new HashEntry[newCapacity];\n        int sizeMask = newCapacity - 1;\n        for (int i = 0; i \u003c oldCapacity ; i++) {\n            HashEntry\u003cK,V\u003e e = oldTable[i];\n            if (e != null) {\n                HashEntry\u003cK,V\u003e next = e.next;\n                int idx = e.hash \u0026 sizeMask;\n                if (next == null)   //  Single node on list\n                    newTable[idx] = e;\n                  else { // Reuse consecutive sequence at same slot\n                   HashEntry\u003cK,V\u003e lastRun = e;\n                    int lastIdx = idx;\n                    for (HashEntry\u003cK,V\u003e last = next;\n                         last != null;\n                         last = last.next) {\n                        int k = last.hash \u0026 sizeMask;\n                        if (k != lastIdx) {\n                            lastIdx = k;\n                            lastRun = last;\n                        }\n                    }\n                    newTable[lastIdx] = lastRun;\n                    // Clone remaining nodes\n                    for (HashEntry\u003cK,V\u003e p = e; p != lastRun; \n                            p = p.next) {\n                        V v = p.value;\n                        int h = p.hash;\n                        int k = h \u0026 sizeMask;\n                        HashEntry\u003cK,V\u003e n = newTable[k];\n                        newTable[k] = new HashEntry\u003cK,V\u003e(h, \n                                p.key, v, n);\n                    }\n                }\n            }\n        }\n        int nodeIndex = node.hash \u0026 sizeMask; // add the new node\n        node.setNext(newTable[nodeIndex]);\n        newTable[nodeIndex] = node;\n        table = newTable;\n    }\n}\n```\n\n### put 流程分析\n\n```java\npublic V put(K key, V value) {\n    Segment\u003cK,V\u003e s;\n    if (value == null)\n        throw new NullPointerException();\n    int hash = hash(key);\n    int j = (hash \u003e\u003e\u003e segmentShift) \u0026 segmentMask;\n    if ((s = (Segment\u003cK,V\u003e)UNSAFE.getObject  // nonvolatile; recheck\n         (segments, (j \u003c\u003c SSHIFT) + SBASE)) == null) \n        //in ensureSegment\n        s = ensureSegment(j);\n    return s.put(key, hash, value, false);\n}\n\nprivate Segment\u003cK,V\u003e ensureSegment(int k) {\n    final Segment\u003cK,V\u003e[] ss = this.segments;\n    long u = (k \u003c\u003c SSHIFT) + SBASE; // raw offset\n    Segment\u003cK,V\u003e seg;\n    if ((seg = (Segment\u003cK,V\u003e)UNSAFE\n            .getObjectVolatile(ss, u)) == null) {\n        Segment\u003cK,V\u003e proto = ss[0]; // use segment 0 as prototype\n        int cap = proto.table.length;\n        float lf = proto.loadFactor;\n        int threshold = (int)(cap * lf);\n        HashEntry\u003cK,V\u003e[] tab = (HashEntry\u003cK,V\u003e[])new HashEntry[cap];\n        if ((seg = (Segment\u003cK,V\u003e)UNSAFE.getObjectVolatile(ss, u))\n            == null) { // recheck\n            Segment\u003cK,V\u003e s = new Segment\u003cK,V\u003e(lf, threshold, tab);\n            while ((seg = (Segment\u003cK,V\u003e)UNSAFE\n                      .getObjectVolatile(ss, u))\n                   == null) {\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}\n```\n\n### get 流程分析\n\n```java\npublic V get(Object key) {\n    Segment\u003cK,V\u003e s; // manually integrate access methods to reduce overhead\n    HashEntry\u003cK,V\u003e[] tab;\n    int h = hash(key);\n    long u = (((h \u003e\u003e\u003e segmentShift) \u0026 segmentMask) \u003c\u003c SSHIFT) + SBASE;\n    if ((s = (Segment\u003cK,V\u003e)UNSAFE.getObjectVolatile(segments, u)) \n              != null \u0026\u0026 (tab = s.table) != null) {\n        for (HashEntry\u003cK,V\u003e e = (HashEntry\u003cK,V\u003e)         \n                UNSAFE.getObjectVolatile(tab, \n                ((long)(((tab.length - 1) \u0026 h)) \u003c\u003c TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h \u0026\u0026 key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}\n```\n\n## Java 8 实现\n\nJava 8 版本的 ConcurrentHashMap 数据结构示意图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurent-Container/clipboard_20230323_094255.png)\n\n### Node 节点\n\n内部存储结构 Node 源码：\n\n```java\nstatic class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {\n    final int hash;\n    final K key;\n    volatile V val;\n    volatile Node\u003cK,V\u003e next;\n    // ...\n}\n```\n\n可以看出，每个 Node 里面是 key-value 的形式，并且把 value 用 volatile 修饰，以便保证可见性，同时内部还有一个指向下一个节点的 next 指针，方便产生链表结构。\n\n### put 方法源码分析\n\n```java\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\n\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) {\n        throw new NullPointerException();\n    }\n    //计算 hash 值\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node\u003cK, V\u003e[] tab = table; ; ) {\n        Node\u003cK, V\u003e f;\n        int n, i, fh;\n        //如果数组是空的，就进行初始化\n        if (tab == null || (n = tab.length) == 0) {\n            tab = initTable();\n        }\n        // 找该 hash 值对应的数组下标\n        else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) {\n            //如果该位置是空的，就用 CAS 的方式放入新值\n            if (casTabAt(tab, i, null,\n                    new Node\u003cK, V\u003e(hash, key, value, null))) {\n                break;\n            }\n        }\n        //hash值等于 MOVED 代表在扩容\n        else if ((fh = f.hash) == MOVED) {\n            tab = helpTransfer(tab, f);\n        }\n        // 槽点上是有值的情况\n        else {\n            V oldVal = null;\n            // 用 synchronized 锁住当前槽点，保证并发安全\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    // 如果是链表的形式\n                    if (fh \u003e= 0) {\n                        binCount = 1;\n                        // 遍历链表\n                        for (Node\u003cK, V\u003e e = f; ; ++binCount) {\n                            K ek;\n                            // 如果发现该 key 已存在，\n                            // 就判断是否需要进行覆盖，然后返回\n                            if (e.hash == hash \u0026\u0026\n                                    ((ek = e.key) == key ||\n                                    (ek != null \u0026\u0026 key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent) {\n                                    e.val = value;\n                                }\n                                break;\n                            }\n                            Node\u003cK, V\u003e pred = e;\n                            // 到了链表的尾部也没有发现该 key，\n                            // 说明之前不存在，就把新值添加到链表的最后\n                            if ((e = e.next) == null) {\n                                pred.next = new Node\u003cK, V\u003e(hash, key,\n                                        value, null);\n                                break;\n                            }\n                        }\n                    }\n                    //如果是红黑树的形式\n                    else if (f instanceof TreeBin) {\n                        Node\u003cK, V\u003e p;\n                        binCount = 2;\n                        //调用 putTreeVal 方法往红黑树里增加数据\n                        if ((p = ((TreeBin\u003cK, V\u003e) f).putTreeVal(hash,         \n                                key, value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent) {\n                                p.val = value;\n                            }\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                // 检查是否满足条件并把链表转换为红黑树的形式，       \n                // 默认的 TREEIFY_THRESHOLD 阈值是 8\n                if (binCount \u003e= TREEIFY_THRESHOLD) {\n                    treeifyBin(tab, i);\n                }\n                // putVal 的返回是添加前的旧值，所以返回 oldVal\n                if (oldVal != null) {\n                    return oldVal;\n                }\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n通过以上的源码分析，我们对于 putVal 方法有了详细的认识，可以看出，方法中会逐步根据当前槽点是未初始化、空、扩容、链表、红黑树等不同情况做出不同的处理。\n\n### get 方法源码分析\n\nget 方法比较简单，同样用源码注释的方式来分析一下：\n\n```java\npublic V get(Object key) {\n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e e, p; int n, eh; K ek;\n    // 计算 hash 值\n    int h = spread(key.hashCode());\n    // 如果整个数组是空的，或者当前槽点的数据是空的，\n    // 说明 key 对应的 value 不存在，直接返回 null\n    if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026\n            (e = tabAt(tab, (n - 1) \u0026 h)) != null) {\n        // 判断头结点是否就是我们需要的节点，如果是则直接返回\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null \u0026\u0026 key.equals(ek)))\n                return e.val;\n        }\n        // 如果头结点 hash 值小于 0，说明是红黑树或者正在扩容，\n        // 就用对应的 find 方法来查找\n        else if (eh \u003c 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        // 遍历链表来查找\n        while ((e = e.next) != null) {\n            if (e.hash == h \u0026\u0026 ((ek = e.key) == key \n                  || (ek != null \u0026\u0026 key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\n\n总结一下 get 的过程：\n\n1. 计算 Hash 值，并由此值找到对应的槽点；\n2. 如果数组是空的或者该位置为 null，那么直接返回 null 就可以了；\n3. 如果该位置处的节点刚好就是我们需要的，直接返回该节点的值；\n4. 如果该位置节点是红黑树或者正在扩容，就用 find 方法继续查找；\n5. 否则那就是链表，就进行遍历链表查找。\n\n## 对比 Java7 和 Java8 版本的异同和优缺点\n\n- 数据结构\n\n正如最开始的两个结构示意图所示，Java 7 采用 Segment 分段锁来实现，而 Java 8 中的 ConcurrentHashMap 使用数组 + 链表 + 红黑树，在这一点上它们的差别非常大。\n\n- 并发度\n\nJava 7 中，每个 Segment 独立加锁，最大并发个数就是 Segment 的个数，默认是 16。\n\n但是到了 Java 8 中，锁粒度更细，理想情况下 table 数组元素的个数（也就是数组长度）就是其支持并发的最大个数，并发度比之前有提高。\n\n- 保证并发安全的原理\n\nJava 7 采用 Segment 分段锁来保证安全，而 Segment 是继承自 ReentrantLock。\n\nJava 8 中放弃了 Segment 的设计，采用 Node + CAS + synchronized 保证线程安全。\n\n- 处理 Hash 冲突\n\nJava 7 在 Hash 冲突时，会使用拉链法，也就是链表的形式。\n\nJava 8 先使用拉链法，在链表长度超过一定阈值时，将链表转换为红黑树，来提高查找效率。\n\n- 查询时间复杂度\n\nJava 7 遍历链表的时间复杂度是 O(n)，n 为链表长度。\n\nJava 8 如果变成遍历红黑树，那么时间复杂度降低为 O(log(n))，n 为树的节点个数。\n\n# CopyOnWriteArrayList\n\n在 CopyOnWriteArrayList 出现之前，已经有了 ArrayList 和 LinkedList 作为 List 的数组和链表的实现，而且也有了线程安全的 Vector 和 Collections.synchronizedList() 可以使用。\n\nVector 内部是使用 synchronized 来保证线程安全的，并且锁的粒度比较大，都是方法级别的锁，在并发量高的时候，很容易发生竞争，并发效率相对比较低。在这一点上，Vector 和 Hashtable 很类似。\n\n并且，前面这几种 List 在迭代期间不允许编辑，如果在迭代期间进行添加或删除元素等操作，则会抛出 ConcurrentModificationException 异常，这样的特点也在很多情况下给使用者带来了麻烦。\n\n所以从 JDK1.5 开始，Java 并发包里提供了使用 CopyOnWrite 机制实现的并发容器  CopyOnWriteArrayList 作为主要的并发 List，CopyOnWrite 的并发集合还包括 CopyOnWriteArraySet，其底层正是利用 CopyOnWriteArrayList 实现的。\n\n## 适用场景\n\n- 读操作可以尽可能的快，而写即使慢一些也没关系\n\n在很多应用场景中，读操作可能会远远多于写操作。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。\n\n- 读多写少\n\n黑名单是最典型的场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单并不需要实时更新，可能每天晚上更新一次就可以了。当用户搜索时，会检查当前关键字在不在黑名单中，如果在，则提示不能搜索。这种读多写少的场景也很适合使用 CopyOnWrite 集合。\n\n## 读写规则\n\n- 读写锁的规则\n\n读写锁的思想是：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥），原因是由于读操作不会修改原有的数据，因此并发读并不会有安全问题；而写操作是危险的，所以当写操作发生时，不允许有读操作加入，也不允许第二个写线程加入。\n\n- 对读写锁规则的升级\n\nCopyOnWriteArrayList 的思想比读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。\n\n## 特点\n\n- CopyOnWrite 的含义\n\n从 CopyOnWriteArrayList 的名字就能看出它是满足 CopyOnWrite 的 ArrayList，CopyOnWrite 的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，完成修改之后，再将原容器的引用指向新的容器。这样就完成了整个修改过程。\n\n这样做的好处是，CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本，所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改。\n\nCopyOnWriteArrayList 的所有修改操作（add，set 等）都是通过创建底层数组的新副本来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，读和写使用不同的容器。\n\n- 迭代期间允许修改集合内容\n\n我们知道 ArrayList 在迭代期间如果修改集合的内容，会抛出 ConcurrentModificationException 异常。CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了，CopyOnWriteArrayList 不会报 ConcurrentModificationException 的异常，因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了\n\n## 源码分析\n\n### 数据结构\n\n```java\npublic class CopyOnWriteArrayList\u003cE\u003e implements List\u003cE\u003e,\n             RandomAccess {\n    /** The lock protecting all mutators */\n    final transient ReentrantLock lock = new ReentrantLock();\n    /** The array, accessed only via getArray/setArray. */\n    private transient volatile Object[] array;\n\n    final Object[] getArray() {\n        return array;\n    }\n\n    final void setArray(Object[] a) {\n        array = a;\n    }\n\n    public CopyOnWriteArrayList() {\n        setArray(new Object[0]);\n    }\n   \n    public CopyOnWriteArrayList(Collection\u003c? extends E\u003e c) {\n        Object[] elements;\n        if (c.getClass() == CopyOnWriteArrayList.class)\n            elements = ((CopyOnWriteArrayList\u003c?\u003e)c).getArray();\n        else {\n            elements = c.toArray();\n            if (c.getClass() != ArrayList.class)\n                elements = Arrays.copyOf(elements, elements.length, Object[].class);\n        }\n        setArray(elements);\n    }\n    \n    ...\n}\n```\n\n在这个类中首先会有一个 ReentrantLock 锁，用来保证修改操作的线程安全。下面被命名为 array 的 Object[] 数组是被 volatile 修饰的，可以保证数组的可见性，这正是存储元素的数组，同样，我们可以从 getArray()、setArray 以及它的构造方法看出，CopyOnWriteArrayList 的底层正是利用数组实现的，这也符合它的名字。\n\n### \u003cstrong\u003eadd 方法\u003c/strong\u003e\n\n```java\npublic boolean add(E e) {\n    // 加锁\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 得到原数组的长度和元素\n        Object[] elements = getArray();\n        int len = elements.length;\n        // 复制出一个新数组\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        // 添加时，将新元素添加到新数组中\n        newElements[len] = e;\n        // 将volatile Object[] array 的指向替换成新数组\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\nadd 方法的作用是往 CopyOnWriteArrayList 中添加元素，是一种修改操作。首先需要利用 ReentrantLock 的 lock 方法进行加锁，获取锁之后，得到原数组的长度和元素，也就是利用 getArray 方法得到 elements 并且保存 length。之后利用 Arrays.copyOf 方法复制出一个新的数组，得到一个和原数组内容相同的新数组，并且把新元素添加到新数组中。完成添加动作后，需要转换引用所指向的对象，利用 setArray(newElements) 操作就可以把 volatile Object[] array 的指向替换成新数组，最后在 finally 中把锁解除。\n\n总结流程：在添加的时候首先上锁，并复制一个新数组，增加操作在新数组上完成，然后将 array 指向到新数组，最后解锁。\n\n上面的步骤实现了 CopyOnWrite 的思想：写操作是在原来容器的拷贝上进行的，并且在读取数据的时候不会锁住 list。而且可以看到，如果对容器拷贝操作的过程中有新的读线程进来，那么读到的还是旧的数据，因为在那个时候对象的引用还没有被更改。\n\n### get 方法\n\n```java\npublic E get(int index) {\n    return get(getArray(), index);\n}\nfinal Object[] getArray() {\n    return array;\n}\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n```\n\n可以看出，get 相关的操作没有加锁，保证了读取操作的高速。\n\n### \u003cstrong\u003e迭代器 COWIterator 类\u003c/strong\u003e\n\n这个迭代器有两个重要的属性，分别是 Object[] snapshot 和 int cursor。其中 snapshot 代表数组的快照，也就是创建迭代器那个时刻的数组情况，而 cursor 则是迭代器的游标。迭代器的构造方法如下：\n\n```java\nprivate COWIterator(Object[] elements, int initialCursor) {\n    cursor = initialCursor;\n    snapshot = elements;\n}\n```\n\n可以看出，迭代器在被构建的时候，会把当时的 elements 赋值给 snapshot，而之后的迭代器所有的操作都基于 snapshot 数组进行的，比如：\n\n```java\npublic E next() {\n    if (! hasNext())\n        throw new NoSuchElementException();\n    return (E) snapshot[cursor++];\n}\n```\n\n在 next 方法中可以看到，返回的内容是 snapshot 对象，所以，后续就算原数组被修改，这个 snapshot 既不会感知到，也不会受影响，执行迭代操作不需要加锁，也不会因此抛出异常。迭代器返回的结果，和创建迭代器的时候的内容一致。\n\n# CopyOnWriteArraySet\n\n# ConcurrentLinkedQueue\n\nJava 提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。\n\n从名字可以看出，ConcurrentLinkedQueue 这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。\n\nConcurrentLinkedQueue 内部代码这里就不分析了，主要使用 CAS 非阻塞算法来实现线程安全。\n\nConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["并发","ConcurentHashMap","CopyOnWriteArrayList","Java"]},"/%E5%BC%95%E7%94%A8":{"title":"引用","content":"```C++\n#include \u003ciostream\u003e\nusing namespace std;\n \n// 函数声明\nvoid swap(int\u0026 x, int\u0026 y);\nvoid swap1(int* x, int* y);\nvoid swap2(int x, int y);\nvoid swap3(int* x, int* y);\n \nint main ()\n{\n  // 局部变量声明\n  int a = 100;\n  int b = 200;\n \n  cout \u003c\u003c \"交换前，\u0026a 的值：\" \u003c\u003c \u0026a \u003c\u003c endl;\n  cout \u003c\u003c \"交换前，\u0026b 的值：\" \u003c\u003c \u0026b \u003c\u003c endl;\n\n  cout \u003c\u003c \"交换前，a 的值：\" \u003c\u003c a \u003c\u003c endl;\n  cout \u003c\u003c \"交换前，b 的值：\" \u003c\u003c b \u003c\u003c endl;\n \n  /* 调用函数来交换值 */\n  //swap(a, b);\n  //swap1(\u0026a, \u0026b);\n  //swap2(a, b);\n  swap3(\u0026a, \u0026b);\n \n  cout \u003c\u003c \"交换后，a 的值：\" \u003c\u003c a \u003c\u003c endl;\n  cout \u003c\u003c \"交换后，b 的值：\" \u003c\u003c b \u003c\u003c endl;\n\n  cout \u003c\u003c \"交换后，\u0026a 的值：\" \u003c\u003c \u0026a \u003c\u003c endl;\n  cout \u003c\u003c \"交换后，\u0026b 的值：\" \u003c\u003c \u0026b \u003c\u003c endl;\n \n  return 0;\n}\n \n// 函数定义\nvoid swap(int\u0026 x, int\u0026 y)\n{\n  cout \u003c\u003c \"swap\" \u003c\u003c endl;\n  int temp;\n  temp = x;\n  x = y;\n  y = temp;\n}\n\nvoid swap1(int* x, int* y)\n{\n  cout \u003c\u003c \"swap1\" \u003c\u003c endl;\n  int* temp;\n  temp = x;\n  x = y;\n  y = temp;\n}\n\nvoid swap2(int x, int y)\n{\n  cout \u003c\u003c \"swap2\" \u003c\u003c endl;\n  int temp;\n  temp = x;\n  x = y; \n  y = temp;\n}\n\nvoid swap3(int* x, int* y)\n{\n  cout \u003c\u003c \"swap3\" \u003c\u003c endl;\n  int temp;\n  temp = *x;\n  *x = *y;\n  *y = temp;\n}\n```","lastmodified":"2023-04-21T14:55:32.613227217Z","tags":[]},"/%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0":{"title":"扩展函数","content":"```Kotlin\nfun main() {\n\t\"a\".aaa {\n\t\tprintln(this)\n\t}\n\n\t\"b\".bbb {\n\t\tprintln(this)\n\t}\n\n\t\"c\".ccc {\n\t\tprintln(it)\n\t}\n}\n\nfun \u003cT\u003e T.aaa(block: T.() -\u003e Unit) {\n\tblock(this)\n}\n\nfun \u003cT\u003e T.bbb(block: T.() -\u003e Unit) {\n\tthis.block()\n}\n\nfun \u003cT\u003e T.ccc(block: (T) -\u003e Unit) {\n\tblock(this)\n}\n```","lastmodified":"2023-04-21T14:55:32.613227217Z","tags":[]},"/%E6%8C%87%E9%92%88":{"title":"指针","content":"```C++\n#include \u003ciostream\u003e\n \nusing namespace std;\n \nint main ()\n{\n    int  var;\n    int  *ptr;\n    int  **pptr;\n    int  ***ppptr;\n \n    var = 3000;\n \n    // 获取 var 的地址\n    ptr = \u0026var;\n \n    // 使用运算符 \u0026 获取 ptr 的地址\n    pptr = \u0026ptr;\n\n    ppptr = \u0026pptr;\n\n    cout \u003c\u003c \"var 值为 :\" \u003c\u003c var \u003c\u003c endl;\n    cout \u003c\u003c \"ptr 值为:\" \u003c\u003c ptr \u003c\u003c endl;\n    cout \u003c\u003c \"pptr 值为:\" \u003c\u003c pptr \u003c\u003c endl;\n    cout \u003c\u003c \"ppptr 值为:\" \u003c\u003c ppptr \u003c\u003c endl;\n\n    cout \u003c\u003c \"-------------------\" \u003c\u003c endl;\n\n    cout \u003c\u003c \"*\u0026var 值为:\" \u003c\u003c *\u0026*\u0026var \u003c\u003c endl;\n    //cout \u003c\u003c \"pptr 值为:\" \u003c\u003c pptr \u003c\u003c endl;\n    //cout \u003c\u003c \"ppptr 值为:\" \u003c\u003c ppptr \u003c\u003c endl;\n\n    cout \u003c\u003c \"-------------------\" \u003c\u003c endl;\n \n    cout \u003c\u003c \"var 值为 :\" \u003c\u003c var \u003c\u003c endl;\n    cout \u003c\u003c \"*ptr 值为:\" \u003c\u003c *ptr \u003c\u003c endl;\n    cout \u003c\u003c \"**pptr 值为:\" \u003c\u003c **pptr \u003c\u003c endl;\n    cout \u003c\u003c \"***ppptr 值为:\" \u003c\u003c ***ppptr \u003c\u003c endl;\n \n    return 0;\n}\n```","lastmodified":"2023-04-21T14:55:32.613227217Z","tags":[]},"/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2":{"title":"文件读取、文本替换","content":"```Python\nfilename = 'user.txt'\n\nwith open(filename) as f:\n    lines = f.readlines()\n\nnewData = \"\"\n\nfor line in lines:\n    lineArr = line.rstrip().split(' ')\n    if len(lineArr) == 2:\n        idNum = lineArr[1]\n        sex = \"女\" if int(idNum[len(idNum) - 2], 10) % 2 == 0 else \"男\"\n        newData += '{} {} {} \\n'.format(lineArr[0], idNum, sex)\n\nwith open(filename, \"w\") as f:\n    f.write(newData)\n```","lastmodified":"2023-04-21T14:55:32.613227217Z","tags":[]},"/%E6%B3%9B%E5%9E%8B":{"title":"泛型","content":"# 什么是泛型？\n\n声明中具有一个或者多个类型参数(type parameter)的类或者接口，就是泛型类或者接口。泛型类和接口统称为泛型(generic type)。\n\n每种泛型定义一组类型形参(formal type parameters)，这些类型形参有时也被简称为类型参数(type parameter)，例如对于 `List\u003cE\u003e` 而言，`List\u003cString\u003e` 就是一个参数化的类型(parameterized type)，String 就是对应于类型形参(formal type parameters)的类型实参(actual type parameter)。\n\n而如果 `List\u003cE\u003e` 不使用泛型参数，List 则为原生类型(raw type)。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。\n\n每个泛型定义一个原生类型(raw type)，即不带任何类型参数的类型名称，例如，与 `List\u003cString\u003e` 对应的原生类型是 List。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。\n\nJava 泛型是自 JDK5 起引入的一种参数化类型特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型泛型的本质是参数类型，也就是说所操作的数据类型被指定为一个参数。因为类型擦除机制，泛型不存在于 JVM 虚拟机。\n\n# 为什么使用泛型？\n\n1.使代码更健壮\n\n2.使代码更简洁(不用强转)\n\n3.使代码可复用性更高，程序更灵活\n\n通俗地说，泛型是「有远⻅的创造者」创造的「方便使用者」的工具。也就是说，使用泛型能够让开发这编写出更加灵活的代码。\n\n## 泛型的使用\n\n## 作为类/接口的类型参数\n\n可以在一个类或者接口里定义一个类型参数，等着子类/实现类去写出不同的实现：\n\n```java\npublic interface Comparable\u003cT\u003e {\n  int compareTo(T o);\n  ...\n}\n\npublic String implements Comparable\u003cString\u003e {\n  int compareTo(String anotherString);\n  ...\n}\n\npublic class Stack\u003cE\u003e extends Vector\u003cE\u003e {\n  ...\n}\n\nStack\u003cString\u003e stack = new Stack\u003c\u003e();\n```\n\n## 作为方法的返回值类型\n\n```java\nT buy();\n```\n\n## 用于类型约束\n\n由于泛型语法自身特性，某些情形下也可以用于类型约束\n\n```java\n// 约束类型参数上界\npublic \u003cE extends Runnable, Serializable\u003e void someMethod(E param);\n\n// 约束方法参数之间的关系\npublic \u003cT\u003e void merge(T item, List\u003cT\u003e list) {\n  list.add(item);\n}\n```\n\n# 泛型擦除的过程\n\n1. 类型检查：在生成字节码之前提供类型检查\n2. 类型擦除：所有类型参数都用他们的限定类型替换，包括类、变量和方法（类型擦除）\n3. 如果类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决\n4. 如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转换\n\n# 泛型的限制\n\n1. 不能用基本类型作为泛型参数\n2. 不能在运行时获取泛型类型\n3. 不能静态字段或方法中引用泛型变量\n4. 不能创建参数化类型数组\n5. 不能实例化类型变量\n6. 不能捕获泛型类的实例，类不能继承自 Exception，只能派生自 Throwable\n\n```java\npublic \u003cT extends Throwable\u003e void fun1(T t) {\n  try {\n    ...\n  } catch(T x) {//不允许\n  }\n}\n\npublic \u003cT extends Throwable\u003e void fun2(T t) throws T {\n  try {\n    ...\n  } catch(Throwable t) {\n    throw t;\n  }\n}\n```\n\n# 编译时和运行时类型\n\n```java\npublic class Fruit {}\n\npublic class Apple extends Fruit {}\n\npublic class GreenApple extends Apple {}\n\nApple apple = new Apple();//普通变量声明和初始化\n\nFruit apple = new Apple();//向上转型\n```\n\nJava 允许把一个子类对象（Apple 对象）直接赋值给一个父类引用变量（Fruit 类变量），一般我们称之为「向上转型」。apple 变量所指向的对象，其在编译时的类型是 Fruit 类型，而在运行时的类型就是 Apple 类型。\n\n因为在编译的时候，JVM 只知道 Fruit 类变量指向了一个对象，并且这个对象是 Fruit 的子类对象或自身对象，其具体的类型并不确定，有可能是 Apple 类型，也有可能是 Orange 类型。而为了安全方面的考虑，JVM 此时将 apple 属性指向的对象定义为 Fruit 类型。因为无论其是 Apple 类型还是 Orange 类型，它们都可以安全转为 Fruit 类型。\n\n而在运行时阶段，JVM 通过初始化知道了它指向了一个 Apple 对象，所以其在运行时的类型就是 Apple 类型。\n\n# 泛型类型实例化的边界\n\n在前面的例子的基础上，定义一个容器类：\n\n```java\npublic class Plate\u003cT\u003e {\n  private List\u003cT\u003e list;\n\n  public Plate(){}\n\n  public void add(T item) {\n    list.add(item);\n  }\n\n  public T get() {\n    return list.get(0);\n  }\n}\n```\n\n如果想要一个装水果的盘子，则有如下定义：\n\n```java\nPlate\u003cFruit\u003e plate = new Plate\u003cFruit\u003e();\n```\n\n这里直接定义了一个 Plate 对象，并且指定其泛型类型为 Fruit 类。这样我们就可以往里面加水果了：\n\n```java\nplate.add(new Fruit());\n\nplate.add(new Apple());\n```\n\n按照 Java 向上转型的原则，Java 泛型可以向上转型，上面关于水果盘子的定义可以变为这样：\n\n```java\nPlate\u003cFruit\u003e plate = new Plate\u003cApple\u003e();  //编译错误\n```\n\n错误的原因就是：\tJava 并不支持支持泛型的向上转型，所以不能够使用上面的写法，这样的写法在 Java 中是不被支持的。\n\n解决方法就是：使用通配符。\n\n## `\u003c? extends Xxx\u003e` 限定上界通配符\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cApple\u003e();\n```\n\n上面的这行代码表示：plate 实例可以指向任何 Fruit 类对象，或者任何 Fruit 的子类对象。Apple 是 Fruit 的子类，自然就可以正常编译了。\n\n虽然通过这种方式，Java 支持了 Java 泛型的向上转型，但是这种方式是有缺陷的：\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cApple\u003e();\n\nplate.add(new Apple()); //Compile Error\n\nplate.add(new Fruit()); //Compile Error\n\nplate.get();    // Compile Success\n```\n\n这时候发现：无法向 Plate 中添加任何对象，只能从中读取对象。\n\n这是什么原因？还得从 plate 的定义说起：\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cXXX\u003e();\n```\n\n上面对盘子的定义中，plate 可以指向任何 Fruit 类对象，或者任何 Fruit 的子类对象。也就是说，plate 属性指向的对象其在运行时可以是 Apple 类型，也可以是 Orange 类型，也可以是 Banana 类型，只要它是 Fruit 类，或任何 Fruit 的子类即可。\n\n这样子的话，在我们还未具体运行时，JVM 并不知道我们要往盘子里放的是什么水果，到底是苹果，还是橙子，还是香蕉，完全不知道。既然我们不能确定要往里面放的类型，那 JVM 就干脆什么都不给放，避免出错。\n\n那为什么又可以取出数据呢？因为无论是取出苹果，还是橙子，还是香蕉，我们都可以通过向上转型用 Fruit 类型的变量指向它，这在 Java 中都是允许的：\n\n```java\nFruit apple = plate.get(); //能够保证取出来的是水果\n\nApple apple = plate.get(); //编译报错，JVM 不能保证取出来的就是苹果\n```\n\n我们通过 extends 关键字可以实现向上转型。但是我们却失去了部分的灵活性，即我们不能往其中添加任何东西，只能取出东西。\n\n## `\u003c? super Xxx\u003e` 限定下界通配符\n\n与 extends 通配符相似的另一个通配符是 super 通配符，其特性与 extends 完全相反。\tsuper 通配符可以存入对象，但是取出对象的时候受到限制。\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n```\n\n上面这行代码表示 plate 属性可以指向一个特定类型的 Plate 对象，只要这个特定类型是 Apple 或 Apple 的父类。上面的 Fruit 类就是 Apple 类的父级，所以上面的语法是对的。\n\n也就是说，如果 Food 类是 Fruit 的父级，那么则有下面的声明：\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n\nPlate\u003c? super Apple\u003e plate2 = new Plate\u003cApple\u003e();\n\nPlate\u003c? super Apple\u003e plate3 = new Plate\u003cGreenApple\u003e(); //Error\n```\n\n既然这样，也就是说 plate 指向的具体类型可以是任何 Apple 的父级，JVM 在编译的时候肯定无法判断具体是哪个父类型。但 JVM 能确定的是：任何 Apple 的子类都可以转为 Apple 类型，但任何 Apple 的父类都无法转为 Apple 类型。\n\n所以对于使用了 super 通配符的情况，我们只能存入 T 类型及 T 类型的子类对象。\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n\nplate.add(new Apple());\n\nplate.add(new GreenApple());\n\nplate.add(new Fruit()); //Error\n```\n\n当我们向 plate 存入 Apple 对象时，编译正常。但是存入 Fruit 对象，就会报编译错误。\n\n而当我们取出数据的时候，也是类似的道理。JVM 在编译的时候知道，我们具体的运行时类型可以是任何 Apple 的父级，那么为了安全起见，我们就用一个最顶层的父级来指向取出的数据，这样就可以避免发生强制类型转换异常了。\n\n```java\nObject object = plate.get();\n\nApple apple = plate.get();  //Error\n\nFruit fruit = plate.get();  //Error\n```\n\n当使用 Apple 类型或 Fruit 类型的变量指向 plate 取出的对象，会出现编译错误。而使用 Object 类型的额变量指向 plate 取出的对象，则可以正常通过。\n\n也就是说对于使用了 super 通配符的情况，我们取出的时候只能用 Object 类型的属性指向取出的对象。\n\n## `\u003c?\u003e` 无限定边界通配符\n\n也就是不限定泛型参数的边界，所以对 Plate\u003c?\u003e 实例来说可以存放任何任意类型的对象，由于所有类型都继承自 Object，因此 Plate\u003c?\u003e等价于 `Plate\u003c? extends Object\u003e`。所以只能够对该集合进行读操作，并且只能把读取到的元素当成 Object 实例来对待。\n\n## 小结\n\n- 对于 extends 通配符，我们无法向其中加入任何对象，但是我们可以进行正常的取出。\n- 对于 super 通配符，我们可以存入 T 类型对象或 T 类型的子类对象，但是我们取出的时候只能用 Object 类变量指向取出的对象。\n\n从上面的总结可以看出，extends 通配符偏向于内容的获取，而 super 通配符更偏向于内容的存入。我们有一个 PECS 原则（Producer Extends Consumer Super）很好的解释了这两个通配符的使用场景。\n\nProducer Extends 说的是当你的情景是生产者类型，需要获取资源以供生产时，我们建议使用 extends 通配符，因为使用了 extends 通配符的类型更适合获取资源。\n\nConsumer Super 说的是当你的场景是消费者类型，需要存入资源以供消费时，我们建议使用 super 通配符，因为使用 super 通配符的类型更适合存入资源。\n\n但如果既想存入，又想取出，那么最好还是不要使用 extends 或 super 通配符。\n\n# 面试题\n\n## `List\u003cT\u003e` 和数组的区别\n\n```java\nApple apple = new Fruit();\n\nApple[] appleArr = new Fruit[5];\n```\n\n在 Java 语言中，数组是协变的，即 Apple extends Fruit，那么子类 Apple[] 数组实例是可以赋值给父类 Fruit[] 数组实例的。那是由于 Java 中的数组类型本质上会由虚拟机运行时动态生成一个类型，这个类型除了记录数组的必要属性，如长度，元素类型等，会有一个指针指向内存某个位置，这个位置就是该数组元素的起始位置。\n\n所以子类数组实例赋值父类数组实例时，只是意味着父类数组实例的引用指向堆中子类数组而已，并不会有所冲突，因此是 Java 允许这种操作的。\n\n而泛型是不允许这么做的：\n\n```java\nArrayList\u003cNumber\u003e numbers = new ArrayList\u003cInteger\u003e(); \n\nnumbers = integers;//假设编译器是能通过的 \n\nnumbers.add(23.5);//将一个浮点数放入了整型容器中\n```\n\n前面已经说过，假设 Java 允许泛型协变，那么上述代码在编译器看来是没问题的，但运行时就会出现问题。这个 add 方法实际上就将一个浮点数放入了整型容器中了，虽然由于类型擦除并不会对程序运行造成问题，但显然违背了泛型的设计初衷，容易造成逻辑混乱，所以 Java 干脆禁止泛型协变。\n\n所以虽然 `ArrayList\u003cInteger\u003e` 和 `ArrayList\u003cNumber\u003e`编译器类型擦除之后都是 ArrayList 的实例，但是起码在编译器看来，这两者是两种不同的类型。\n\n但是对于数组，尽管 Apple 可以向上转型为 Fruit，但是 fruits 对象在运行时却是 Apple[] 类型的，因此只能向数组中放入 Apple 或者其子类对象。尽管在编译时不会报错，到了运行时仍然是会报错的。\n\n```java\nFruit[] fruits = new Apple[5];\n\nfruits[0] = new Apple();\n\nfruits[1] = new GreenApple();\n\nfruits[2] = new Fruit(); //RTE：ArrayStoreException\n```\n\n## Java 为什么不支持创建泛型数组\n\n首先对于 Java 数组，必须明确知道内部元素的类型，而且 JVM 会“记住”这个类型。每次往数组里插入新元素都会进行类型检查，不匹配则抛出 ArrayStoreException 错误。\n\n而由于泛型擦除机制的存在，因此 JVM 并不能确定数组中的泛型类型，因此创建泛型数组被编译器拦下来了。\n\n```java\nList\u003cInteger\u003e[] intListArray = new List\u003cInteger\u003e[10]; //Error\n```\n\n前面说过，因为泛型是协变的，而且 Object 是所有类的共同父类。如果允许创建泛型数组，则有：\n\n```java\nList\u003cInteger\u003e[] listArr= new ArrayList\u003cInteger\u003e[10];\n\nObject[] objArr= listArr;\n\nobjArr[0] = new ArrayList\u003cString\u003e(Arrays.asList(new String[]{\"abc\"}));\n\n这样做不但编译器不能发现类型错误，就连运行时的数组存储检查对它也无能为力。它能看到的是我们往里面放 List 的对象，我们定义的 `\u003cInteger\u003e` 在这个时候已经被抹掉了。于是而对它而言，只要是 List，都是合法的。\n```\n\n想想看，我们本来定义的是存放 `List\u003cInteger\u003e` 的数组，结果我们却可以往里面放任何 List，接下来如果有代码试图按原有的定义去取值，后果可想而知。\n\n实际上，泛型数组是可以定义出来的，然后通过强制转型，也是可以为其赋值的。\n\n```java\nList\u003cInteger\u003e[] listArr= (List\u003cInteger\u003e[])new ArrayList[10];\n\nObject[] objArr= listArr;\n\nobjArr[0] = new ArrayList\u003cString\u003e(Arrays.asList(new String[]{\"abc\"}));\n```\n\n这样不但编译可以通过，而且运行时也不会报任何错误。\n\n## `List`、`List\u003c?\u003e`、`List\u003cObject\u003e`的区别\n\n容器类使用泛型的好处：\n\n- 安全性：在对参数化类型的容器中放入了错误即不匹配的类型的时候，编译器将会强制性进行错误提示。\n- 便利性：当从容器中取出元素的时候不用自己手动将 Object 转换为元素的实际类型了，编译器将隐式地进行自动转换。\n- 表述性：带有类型实参的泛型即参数化类型，可以让人看到实参就知道里面的元素 E 都是什么类型。\n\n从以上三点出发，`List\u003cObject\u003e`、`List\u003c?\u003e` 和 `List` 的区别如下：\n\n| 类型    | 名称                               | 可以接受的类型                            | 能否添加元素           | 安全性 | 便利性 | 表述性 |\n| ------- | ---------------------------------- | ----------------------------------------- | ---------------------- | ------ | ------ | ------ |\n| List    | 原始类型                           | 任何对应 List 的参数化类型， 包括 List\u003c?\u003e | 可以添加任意类型的元素 | 无     | 无     | 无     |\n| List\u003c?\u003e | 通配符类型                         | 任何对应 List 的参数化类型，包括 List     | 不能添加任何元素       | 有     | 无     | 有     |\n| List    | 实际类型参数为 Object 的参数化类型 | 仅可以接受 List 和其本身类型              | 可以添加任意类型元素   | 有     | 有     | 有     |\n\n## JVM 如何解决泛型类型擦除导致多态冲突\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["泛型","Java"]},"/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84":{"title":"注解和反射","content":"\n# \u003cstrong\u003e注解是什么？有何作用？\u003c/strong\u003e\n\nJava 注解（Annotation）又称 Java 标注，是 JDK1.5 引入的一种注释机制。是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。\n\n注解本身没有任何意义，单独的注解就是一种注释，他需要结合其他如反射、插桩等技术才有意义。\n\n# \u003cstrong\u003e元注解\u003c/strong\u003e\n\n在 JDK 中提供了 4 个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：\n\n#### \u003cstrong\u003e@Target\u003c/strong\u003e\nTarget 注解的作用是：描述注解的使用范围(即被修饰的注解可以用在什么地方).\n\nTarget 注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数），在定义注解类时使用了 @Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在 ElementType 枚举中.\n\n源码：\n```java\n@Documented \n@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) \npublic @interface Target { \n  ElementType[] value(); \n}\nElementType定义：\npublic enum ElementType { \n  TYPE, // 类、接口、枚举类 \n  FIELD, // 成员变量（包括：枚举常量） \n  METHOD, // 成员方法 \n  PARAMETER, // 方法参数 \n  CONSTRUCTOR, // 构造方法 \n  LOCAL_VARIABLE, // 局部变量 \n  ANNOTATION_TYPE, // 注解类 \n  PACKAGE, // 可用于修饰：包 \n  TYPE_PARAMETER, // 类型参数，JDK 1.8 新增 \n  TYPE_USE // 使用类型的任何地方，JDK 1.8 新增 \n}\n```\n\n#### \u003cstrong\u003e@Retention\u003c/strong\u003e\nReteniton 注解的作用是：描述注解保留的时间范围(即：被描述的注解在它所修饰的类中可以被保留到何时).\n\nReteniton 注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在 RetentionPolicy 枚举中.\n\n```java\npublic enum RetentionPolicy {\n    SOURCE,    // 只会在源文件中保留，随后会被编译器忽略\n    CLASS,     // 保留至编译期，会被 JVM 忽略，默认值\n    RUNTIME    // 保留至运行时，可通过反射去获取注解信息\n}\n```\n\n使用场景：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Annotation%26Reflection/clipboard_20230322_115319.png)\n\n#### \u003cstrong\u003e@Documented\u003c/strong\u003e\n描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。\n\n#### \u003cstrong\u003e@Inherited\u003c/strong\u003e\n使被它修饰的注解具有继承性（如果某个类使用了被 @Inherited 修饰的注解，则其子类将自动具有该注解）。\n\n# \u003cstrong\u003e反射是什么？有何作用？\u003c/strong\u003e\n\n一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的，并且能够获得此类的引用。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。\n\n如果一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。这时候，我们使用 JDK 提供的反射 API 进行反射调用。反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且都能改变它的属性。这也是 Java 被视为动态语言的关键。\n\nJava 反射机制主要提供了以下功能：\n\n- 在运行时构造任意一个类的对象\n- 在运行时获取或者修改任意一个类所具有的成员变量和方法\n- 在运行时调用任意一个对象的方法（属性）\n\n# Class 类\n\n反射始于 Class，\u003cstrong\u003eClass 是一个类，封装了当前对象所对应的类的信息。\u003c/strong\u003e一个类中有属性，方法，构造器等，比如说有一个 Person 类，一个 Order 类，一个 Book 类，这些都是不同的类，现在需要一个类，用来描述类，这就是 Class，它应该有类名，属性，方法，构造器等。Class 是用来描述类的类。\n\nClass 类是一个对象照镜子的结果，对象可以看到自己有哪些属性，方法，构造器，实现了哪些接口等等。对于每 个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 对象只能由系统建立对象，一个类（而不是一个对象）在 JVM 中只会有一个 Class 实例。 \n\n### 获取 Class 的方式\n\n#### 通过类名获取\n\n通过调用“类名.class”即可获取该类的 Class 对象\n\n```java\nClass\u003c?\u003e klass = int.class;\nClass\u003c?\u003e classInt = Integer.TYPE;\n```\n\n#### 通过对象获取\n\n获取到对象实例后，通过“对象名.getClass()”或者“对象名.getSuperClass”即可获取该类或者父类的 Class 对象。\n\n```java\nStringBuilder str = new StringBuilder(\"abc\");\nClass\u003c?\u003e klass = str.getClass(); \n```\n\n#### 通过全类名获取\n\n使用 Class.forName(全类名) 或者 classLoader.loadClass(全类名) 也可以得到 Class 对象。\n\n```java\nClass.forName(\"android.content.Intent\");\ngetClassLoader().loadClass(\"android.content.Intent\");\n```\n\n### 使用 Class 创建实例\n\n通过反射来生成对象主要有两种方式。\n\n#### 直接调用 newInstance()\n\n使用 Class 对象的 newInstance() 方法来创建 Class 对象对应类的实例。 \n\n```java\nClass\u003c?\u003e c = String.class;\nObject str = c.newInstance(); \n```\n\n#### 通过 Constructor 调用 newInstance()\n\n如果需要通过某个构造方法创建对象，则须通过 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建实例。\n\n```java\nClass\u003c?\u003e c = String.class;\n//获取String类带一个String参数的构造器\nConstructor constructor = c.getConstructor(String.class);\n//根据构造器创建实例\nObject obj = constructor.newInstance(\"abc\");\n```\n\n### 获取构造方法\n\n```java\n//获得使用特殊的参数类型的public构造函数(包括父类）\nConstructor getConstructor(Class[] params)\n//获得类的所有公共构造函数\nConstructor[] getConstructors()\n获得使用特定参数类型的构造函数(包括私有)\nConstructor getDeclaredConstructor(Class[] params)\n//获得类的所有构造函数(与接入级别无关) \nConstructor[] getDeclaredConstructors()\n```\n\n### 获取成员变量（字段）信息\n\n```java\n//获得命名的公共字段\nField getField(String name)\n//获得类的所有公共字段\nField[] getFields()\n//获得类声明的命名的字段\nField getDeclaredField(String name)\n//获得类声明的所有字段\nField[] getDeclaredFields()\n```\n\n### 调用方法\n\n```java\n//使用特定的参数类型，获得命名的公共方法\nMethod getMethod(String name, Class[] params)\n//获得类的所有公共方法\nMethod[] getMethods()\n//使用特写的参数类型，获得类声明的命名的方法\nMethod getDeclaredMethod(String name, Class[] params)\n//获得类声明的所有方法 \nMethod[] getDeclaredMethods()\n获取到 Method 对象后，调用 invoke 方法即可调用该方法，invoke 方法定义：\npublic Object invoke(Object obj, Object... args)\n```\n\n# 获取泛型的真实类型\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Annotation%26Reflection/clipboard_20230322_115426.png)\n\n当我们对一个泛型类进行反射时，需要的到泛型中的真实数据类型，来完成如 json 反序列化的操作。此时需要通过 Type 体系来完成。Type 接口包含了一个实现类(Class)和四个实现接口，他们分别是：\n\n#### TypeVariable\n\n泛型类型变量。可以泛型上下限等信息；\n\n```java\nclass TestType\u003cK extends Comparable \u0026 Serializable, V\u003e {\n    K key;\n    V value;\n}\n\n@Test\npublic void test() {\n    // 获取字段的类型\n    Field fk = null;\n    Field fv = null;\n    try {\n        fk = TestType.class.getDeclaredField(\"key\");\n        fv = TestType.class.getDeclaredField(\"value\");\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    }\n    TypeVariable keyType = (TypeVariable)fk.getGenericType();\n    TypeVariable valueType = (TypeVariable)fv.getGenericType();\n    \n    // getName 方法\n    System.out.println(keyType.getName()); // K\n    System.out.println(valueType.getName()); // V\n    \n    // getGenericDeclaration 方法\n    System.out.println(keyType.getGenericDeclaration()); \n    System.out.println(valueType.getGenericDeclaration());\n    \n    System.out.println(\"K 的上界:\"); // 有两个\n    for (Type type : keyType.getBounds()) {\n        System.out.println(type);\n    }\n    \n    System.out.println(\"V 的上界:\"); // 没明确声明上界的, 默认上界是 Object\n    for (Type type : valueType.getBounds()) {// class java.lang.Object\n        System.out.println(type);\n    }\n}\n\n输出为：\nK\nV\nclass com.test.ExampleUnitTest$TestType\nclass com.test.ExampleUnitTest$TestType\n```\n\nK 的上界:\n\n`interface java.lang.Comparable`\n\n`interface java.io.Serializable`\n\nV 的上界:\n\n`class java.lang.Object`\n\n#### ParameterizedType\n\n具体的泛型类型，可以获得元数据中泛型签名类型(泛型真实类型)\n\n```java\nclass TestType {\n    Map\u003cString, String\u003e map;\n}\n\n@Test\npublic void test() {\n    Field f = null;\n    try {\n        f = TestType.class.getDeclaredField(\"map\");\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    }\n    System.out.println(f.getGenericType());\n    ParameterizedType pType = (ParameterizedType) f.getGenericType();\n    System.out.println(pType.getRawType());\n    for (Type type : pType.getActualTypeArguments()) {\n        System.out.println(type);\n    }\n}\n\n输出为：\njava.util.Map\u003cjava.lang.String, java.lang.String\u003e\ninterface java.util.Map\nclass java.lang.String\nclass java.lang.String\n```\n\n#### GenericArrayType\n\n当需要描述的类型是\u003cstrong\u003e泛型类的数组\u003c/strong\u003e时，比如 List[],Map[]，此接口会作为 Type 的实现。\n\n```java\npublic class TestType\u003cT\u003e {\n    List\u003cString\u003e[] lists;\n}\n@Test\npublic void test() {\n    Field f = null;\n    try {\n        f = TestType.class.getDeclaredField(\"lists\");\n    } catch (NoSuchFieldException e) {\n        e.printStackTrace();\n    }\n    GenericArrayType genericType = (GenericArrayType) f.getGenericType();\n    System.out.println(genericType.getGenericComponentType());\n}\n\n输出为：\njava.util.List\u003cjava.lang.String\u003e\nWildcardType \n```\n\n通配符泛型，获得上下限信息；\n\n```java\npublic class TestType {\n    private List\u003c? extends Number\u003e a;\n    private List\u003c? super String\u003e b;\n}\n\n@Test\npublic void test() throws NoSuchFieldException {\n    Field fieldA = TestType.class.getDeclaredField(\"a\");\n    Field fieldB = TestType.class.getDeclaredField(\"b\");\n    ParameterizedType pTypeA = (ParameterizedType) fieldA.getGenericType();\n    ParameterizedType pTypeB = (ParameterizedType) fieldB.getGenericType();\n    WildcardType wTypeA = (WildcardType) pTypeA.getActualTypeArguments()[0];\n    WildcardType wTypeB = (WildcardType) pTypeB.getActualTypeArguments()[0];\n    System.out.println(wTypeA.getUpperBounds()[0]);\n    System.out.println(wTypeB.getLowerBounds()[0]);\n    System.out.println(wTypeA);\n    System.out.println(wTypeB);\n}\n\n输出为：\nclass java.lang.Number\nclass java.lang.String\n? extends java.lang.Number\n? super java.lang.String\n```\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Annotation%26Reflection/clipboard_20230322_115500.png)\n\n问题：为什么 Gson 反序列化时候需要借助 TypeToken 获取 Type？\n\n//todo\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["注解","反射","Java"]},"/%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6":{"title":"等待-通知机制","content":"# wait/notify 模式\n\npublic class MyBlockingQueueForWaitNotify {\n\n   private int maxSize = 16;\n\n   private LinkedList\u003cObject\u003e storage;\n\n \n\n   public MyBlockingQueueForWaitNotify (int size) {\n\n       this.maxSize = size;\n\n       storage = new LinkedList\u003c\u003e();\n\n   }\n\n \n\n   public synchronized void put() throws InterruptedException {\n\n       while (storage.size() == maxSize) {\n\n           this.wait();\n\n       }\n\n       storage.add(new Object());\n\n       this.notifyAll();\n\n   }\n\n \n\n   public synchronized void take() throws InterruptedException {\n\n       while (storage.size() == 0) {\n\n           this.wait();\n\n       }\n\n       System.out.println(storage.remove());\n\n       this.notifyAll();\n\n   }\n\n}\n\n# Condition 模式\n\npublic class MyBlockingQueueForCondition {\n\n \n\n   private Queue queue;\n\n   private int max = 16;\n\n   private ReentrantLock lock = new ReentrantLock();\n\n   private Condition notEmpty = lock.newCondition();\n\n   private Condition notFull = lock.newCondition();\n\n \n\n   public MyBlockingQueueForCondition(int size) {\n\n       this.max = size;\n\n       queue = new LinkedList();\n\n   }\n\n \n\n   public void put(Object o) throws InterruptedException {\n\n       lock.lock();\n\n       try {\n\n           while (queue.size() == max) {\n\n               notFull.await();\n\n           }\n\n           queue.add(o);\n\n           notEmpty.signalAll();\n\n       } finally {\n\n           lock.unlock();\n\n       }\n\n   }\n\n \n\n   public Object take() throws InterruptedException {\n\n       lock.lock();\n\n       try {\n\n           while (queue.size() == 0) {\n\n               notEmpty.await();\n\n           }\n\n           Object item = queue.remove();\n\n           notFull.signalAll();\n\n           return item;\n\n       } finally {\n\n           lock.unlock();\n\n       }\n\n   }\n\n}\n\n# 两种方式对比\n\n![](static/boxcnAqX93mnHV8T8UY1Tm93mxf.png)\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["并发","wait/notify","Java"]},"/%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BD%BF%E7%94%A8":{"title":"类的定义、使用","content":"```Python\n#类定义\nclass people:\n    #定义基本属性\n    name = ''\n    age = 0\n    #定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n    #定义构造方法\n    def __init__(self,n,a,w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n    def speak(self):\n        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))\n \n# 实例化类\np = people('runoob',10,30)\np.speak()\n```","lastmodified":"2023-04-21T14:55:32.613227217Z","tags":[]},"/%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C":{"title":"线程协作","content":"# Thread.join()\n\n## 使用\n\n```java\npublic class UseJoin {\n    public static void main(String[] args) {\n        final Thread thread1 = new Thread(() -\u003e {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"thread 1 is running\");\n        });\n        final Thread thread2 = new Thread(() -\u003e {\n            try {\n                thread1.join();\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"thread 2 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        Thread thread3 = new Thread(() -\u003e {\n            try {\n                thread2.join();\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"thread 3 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        thread3.start();\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n## 实现原理\n\n```java\npublic final void join() throws InterruptedException {\n    join(0);\n}\n\npublic final synchronized void join(long millis) \n          throws InterruptedException {\n    long base = System.currentTimeMillis();\n    long now = 0;\n\n    if (millis \u003c 0) {\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    }\n\n    if (millis == 0) {\n        // 1\n        while (isAlive()) {\n            wait(0);\n        }\n    } else {\n        while (isAlive()) {\n            long delay = millis - now;\n            if (delay \u003c= 0) {\n                break;\n            }\n            wait(delay);\n            now = System.currentTimeMillis() - base;\n        }\n    }\n}\n```\n\n首先进入 join 方法时，调用 join 的线程获取了 threadA 线程的对象锁；注释 1 处 while 循环这段的代码的意思是：如果 threadA 线程是活跃的，则循环调用 threadA.wait(0)，此时调用 join 的线程释放 threadA 线程的对象锁，其他线程可以竞争锁并进入 threadA.join(0)。一旦 threadA 线程执行完毕（状态为 TERMINATED），JVM 会调用 lock.notify_all(thread)，唤醒持有 threadA 这个对象锁的线程，至此阻塞在 threadA 对象上的线程可以继续执行后面的内容。\n\n# Object.wait()/Object.notify()\n\n## 使用\n\n```java\npublic class UseWaitNotify {\n    private static Object myLock1 = new Object();\n    private static Object myLock2 = new Object();\n    \n    private static Boolean t1Run = false;\n    private static Boolean t2Run = false;\n    \n    public static void main(String[] args) {\n        final Thread thread1 = new Thread(() -\u003e {\n            synchronized (myLock1) {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"thread 1 is running\");\n                t1Run = true;\n                myLock1.notify();\n            }\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            synchronized (myLock1) {\n                try {\n                    if (!t1Run) {\n                        myLock1.wait();\n                    }\n                    synchronized (myLock2) {\n                        Thread.sleep(1000);\n                        System.out.println(\"thread 2 is running\");\n                        myLock2.notify();\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            synchronized (myLock2) {\n                try {\n                    if (!t2Run) {\n                        myLock2.wait();\n                    }\n                    Thread.sleep(1000);\n                    System.out.println(\"thread 3 is running\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        \n        thread3.start();\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n## 实现原理\n\n# Condition\n\n## 使用\n\n```java\npublic class UseCondition {\n    private static Lock lock = new ReentrantLock();\n    private static Condition condition1 = lock.newCondition();\n    private static Condition condition2 = lock.newCondition();\n    \n    private static Boolean t1Run = false;\n    private static Boolean t2Run = false;\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            lock.lock();\n            try {\n                Thread.sleep(2000);\n                System.out.println(\"thread 1 is running\");\n                t1Run = true;\n                condition1.signal();\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            lock.lock();\n            try {\n                if (!t1Run) {\n                    condition1.await();\n                }\n                Thread.sleep(1000);\n                System.out.println(\"thread 2 is running\");\n                t2Run = true;\n                condition2.signal();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            lock.lock();\n            try {\n                if (!t2Run) {\n                    condition2.await();\n                }\n                Thread.sleep(1000);\n                System.out.println(\"thread 3 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        });\n        \n        thread3.start();\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n## 实现原理\n\n# Semaphore\n\n## 使用\n\n```java\npublic class UseSemaphore {\n    private static Semaphore semaphore1 = new Semaphore(1);\n    private static Semaphore semaphore2 = new Semaphore(0);\n    private static Semaphore semaphore3 = new Semaphore(0);\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            try {\n                semaphore1.acquire();\n                Thread.sleep(2000);\n                System.out.println(\"thread 1 is running\");\n                semaphore2.release();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            try {\n                semaphore2.acquire();\n                Thread.sleep(1000);\n                System.out.println(\"thread 2 is running\");\n                semaphore3.release();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            try {\n                semaphore3.acquire();\n                Thread.sleep(1000);\n                System.out.println(\"thread 3 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n        thread3.start();\n    }\n}\n```\n\n## 实现原理\n\n# CountDownLatch\n\n## 使用\n\n```java\npublic class UseCountDownLatch {\n    private static CountDownLatch c1 = new CountDownLatch(1);\n    private static CountDownLatch c2 = new CountDownLatch(1);\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"thread 1 is running\");\n            c1.countDown();\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            try {\n                c1.await();\n                Thread.sleep(1000);\n                System.out.println(\"thread 2 is running\");\n                c2.countDown();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            try {\n                c2.await();\n                Thread.sleep(1000);\n                System.out.println(\"thread 3 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        thread3.start();\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n## 实现原理\n\nCountDownLatch 最核心的方法只有两个，一个是 countDown 方法，每调用一次，就会将当前的 count 减一，当 count 值为 0 时，就会唤醒所有等待中的线程；另一个是 await 方法，它有两种形式，一种是阻塞式，一种是带超时机制的形式，该方法用于将当前等待“门闩”开启的线程挂起，直到 count 值为 0，这一点很类似于条件队列，相当于等待的条件就是 count 值为 0，\u003cstrong\u003e然而其底层的实现并不是用条件队列，而是共享锁。\u003c/strong\u003e\n\nCountDownLatch 主要是通过 AQS 的共享锁机制实现的，因此它的核心属性只有一个 sync，它继承自 AQS，同时覆写了 tryAcquireShared 和 tryReleaseShared，以完成具体的实现共享锁的获取与释放的逻辑。\n\n# CyclicBarrier\n\n## 使用\n\n```java\npublic class UseCyclicBarrier {\n    static CyclicBarrier barrier1 = new CyclicBarrier(2);\n    static CyclicBarrier barrier2 = new CyclicBarrier(2);\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            try {\n                Thread.sleep(2000);\n                System.out.println(\"thread 1 is running\");\n                barrier1.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            try {\n                barrier1.await();\n                Thread.sleep(1000);\n                System.out.println(\"thread 2 is running\");\n                barrier2.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            try {\n                barrier2.await();\n                Thread.sleep(1000);\n                System.out.println(\"thread 3 is running\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } catch (BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        });\n        \n        thread3.start();\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n## 实现原理\n\nCountDownLatch 是一次性的，当 count 值被减为 0 后，不会被重置;\n\n而 CyclicBarrier 在线程通过栅栏后，通过调用 reset() 方法，count 值会被重置，因此可以重复使用。\n\n# ThreadPool\n\n## 使用\n\n```java\npublic class UseThreadPool {\n    static ExecutorService executorService = \n            Executors.newSingleThreadExecutor();\n            \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"thread 1 is running\");\n        });\n        \n        Thread thread2 =new Thread(() -\u003e {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"thread 2 is running\");\n        });\n        \n        Thread thread3 = new Thread(() -\u003e {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"thread 3 is running\");\n        });\n        \n        executorService.submit(thread1);\n        executorService.submit(thread2);\n        executorService.submit(thread3);\n        executorService.shutdown();\n    }\n}\n```\n\n## 实现原理\n\nnewSingleThreadExecutor 创建的线程池核心线程数和最大线程数都为 1，因此 thread1 提交后，每个线程都会进入阻塞队列并按照提交顺序执行。\n\n## 面试题\n\n## CyclicBarrier 和 CountDownLatch 有何区别？\n\n- 工作方式：CyclicBarrier 要等固定数量的线程都到达了栅栏位置才能继续执行，而 CountDownLatch 只需等待数字倒数到 0，也就是说 CountDownLatch 作用于事件，但 CyclicBarrier 作用于线程；CountDownLatch 是在调用了 countDown 方法之后把数字倒数减 1，而 CyclicBarrier 是在某线程开始等待后把计数减 1。\n- 能否重复使用：CountDownLatch 是一次性的，当 count 值被减为 0 后，不会被重置，因此不能重复使用；而 CyclicBarrier 在线程通过栅栏后，会开启新的一代，count 值会被重置，因此可重复使用。\n- 使用锁的类型：CountDownLatch 使用的是共享锁，count 值不为 0 时，线程在 sync queue 中等待，自始至终只牵涉到 sync queue，由于使用共享锁，唤醒操作不必等待锁释放后再进行，唤醒操作很迅速；CyclicBarrier 使用的是独占锁，count 值不为 0 时，线程进入 condition queue 中等待，当 count 值降为 0 后，将被 signalAll() 方法唤醒到 sync queue 中去，然后挨个去争锁（因为是独占锁），在前驱节点释放锁以后，才能继续唤醒后继节点。\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["Thread","线程协作","wait/notify","Condition","Semaphore","CountDownLatch","CyclicBarrier","TheradPool","面试","Java"]},"/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80":{"title":"线程基础","content":"# CPU 核心数和线程数的关系\n\n增加 CPU 核心数目就是为了增加线程数，因为操作系统是通过线程来执行任务的，一般情况下它们是 1:1 对应关系，也就是说四核 CPU 一般拥有四个线程。但 Intel 引入超线程技术后，使核心数与线程数形成 1:2 的关系。\n\n# 进程和线程\n\n## 进程是程序运行资源分配的最小单位\n\n进程是操作系统进行资源分配的最小单位，其中资源包括：CPU、内存空间、磁盘等，同一进程中的多条线程共享该进程中的全部系统资源，而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。\n\n进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的、静态的，进程是活的、动态的。\n\n进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身，用户进程就是所有由你启动的进程。\n\n## 线程是 CPU 调度的最小单位，必须依赖于进程而存在\n\n线程是进程的一个实体，是 CPU 调度和分派的基本单位，它是比进程更小的、能独立运行的基本单位。\n\n线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。\n\n线程无处不在，任何一个程序都必须要创建线程。特别是 Java，不管任何程序都必须启动一个 main 函数的主线程；Java Web 开发里面的定时任务、定时器、JSP 和 Servlet、异步消息处理机制，远程访问接口 RM 等；Android 中的任何一个 onClick 事件的触发事件等都离不开线程和并发的知识。\n\n# 并行和并发\n\n举个例子，如果有条高速公路 A 上面并排有 8 条车道，那么最大的并行车辆就是 8 辆，此条高速公路 A 同时并排行走的车辆小于等于 8 辆的时候，车辆就可以并行运行。CPU 也是这个原理，一个 CPU 相当于一个高速公路 A，核心数或者线程数就相当于并排可以通行的车道；而多个 CPU 就相当于并排有多条高速公路，而每个高速公路并排有多个车道。\n\n当谈论并发的时候一定要加个单位时间，也就是说单位时间内并发量是多少？离开了单位时间其实是没有意义的。\n\n原则上一个 CPU 只能分配给一个进程，以便运行这个进程。我们通常使用的计算机中只有一个 CPU，也就是说只有一颗心，要让它一心多用同时运行多个进程，就必须使用并发技术。实现并发技术相当复杂，最容易理解的是“时间片轮转进程调度算法”。\n\n综合来说：\n\n## 并发\n\n指应用能够交替执行不同的任务，比如单 CPU 核心下执行多线程并非是同时执行多个任务，如果你开两个线程执行，就是在你几乎不可能察觉到的速度不断去切换这两个任务，已达到\"同时执行效果\"，其实并不是的，只是计算机的速度太快，我们无法察觉到而已.\n\n## 并行\n\n指应用能够同时执行不同的任务，比如吃饭的时候可以边吃饭边打电话，这两件事情可以同时执行。\n\n两者的区别：一个是交替执行，一个是同时执行。\n\n# CPU 时间片轮转机制\n\n时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法，又称 RR 调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。\n\n如果在时间片结束时进程还在运行，则 CPU 将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来，则 CPU 当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。\n\n时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的，包括保存和装入寄存器值及内存映像，更新各种表格和队列等。假如进程切(processwitch)，有时称为上下文切换(context switch)，需要 5ms，再假设时间片设为 20ms，则在做完 20ms 有用的工作之后，CPU 将花费 5ms 来进行进程切换。CPU 时间的 20% 被浪费在了管理开销上了。\n\n为了提高 CPU 效率，我们可以将时间片设为 5000ms。这时浪费的时间只有 0.1%。但考虑到在一个分时系统中，如果有 10 个交互用户几乎同时按下回车键，将发生什么情况？假设所有其他进程都用足它们的时间片的话，最后一个不幸的进程不得不等待 5s 才获得运行机会。多数用户无法忍受一条简短命令要 5s 才能做出响应，同样的问题在一台支持多道程序的个人计算机上也会发生。\n\n结论可以归结如下：时间片设得太短会导致过多的进程切换，降低了 CPU 效率；而设得太长又可能引起对短的交互请求的响应变差。将时间片设为 100ms 通常是一个比较合理的折衷。\n\n# 线程的启动\n\n## 继承自 Thread\n\n```java\nprivate static class UseThread extends Thread {\n   @Override\n   public void run() {\n      super.run();\n      //do my work\n      System.out.println(\"I am extends Thread\");\n   }\n}\n\nUseThread useThread = new UseThread();\nuseThread.start();\n```\n\n## 通过 Runnable 交给 Thread 执行\n\n```java\nprivate static class UseRunnable implements Runnable {\n   @Override\n   public void run() {\n      System.out.println(\"I am implements Runnable\");\n   }\n}\n\nUseRunnable runable = new UseRunnable();\nnew Thread(runable).start();\n```\n\n## 通过 Callable 交给 Thread 执行\n\n```java\nprivate static class UseCallable implements Callable\u003cString\u003e {\n   @Override\n   public String call() throws Exception {\n      System.out.println(\"I am implements Callable\");\n      return \"CallResult\";\n   }\n}\n\nUseCallable callable = new UseCallable();\nFutureTask\u003cString\u003e futureTask = new FutureTask\u003c\u003e(callable);\nnew Thread(futureTask).start();\n//do something\nSystem.out.println(futureTask.get());\n```\n\n## 小结\n\n前面两种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。从 Java 1.5 开始，就提供了 Callable 和 Future 类，通过它们可以在任务执行完毕之后得到任务执行结果。\n\nRunnable 是一个接口，在它里面只声明了一个 run 方法，由于 run 方法返回值为 void 类型，所以在执行完任务之后无法返回任何结果。\n\nCallable 位于 java.util.concurrent 包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做 call，这是一个泛型接口，call 方法返回的类型就是传递进来的 V 类型。\n\nFuture 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过 get 方法获取执行结果，该方法会阻塞直到任务返回结果。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095747.png)\n\nFutureTask 是 Future 接口的实现类：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095800.png)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095802.png)\n\nFutureTask 类实现了 RunnableFuture 接口，而 RunnableFuture 继承了 Runnable 接口和 Future 接口，而 FutureTask 实现了 RunnableFuture 接口。所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。\n\n事实上，FutureTask 是 Future 接口的一个唯一实现类。要 new 一个 FutureTask 的实例，将 Runnable 或者 Callable 对象传入即可。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095805.png)\n\n# 线程的终止\n\n## 被动终止\n\n如果 run 执行完成或者执行过程中抛出了一个未处理的异常则会导致线程终止。\n\n## 手动终止\n\n虽然 Thread 的 API 中提供了 \u003cstrong\u003esuspend()、resume() 和 stop() \u003c/strong\u003e方法，对应线程的暂停、恢复和停止操作 ，但是这些 API 是过期的，也就是不建议使用的。不建议使用的原因主要有：以 suspend() 方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop() 方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为 suspend()、resume() 和 stop() 方法带来的副作用，这些方法才被标注为不建议使用的过期方法。\n\n安全的中止则是其他线程通过调用某个线程 A 的 \u003cstrong\u003einterrupt() \u003c/strong\u003e方法对其进行中断操作， 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程 A 会立即停止自己的工作，同样的 A 线程完全可以不理会这种中断请求。因为 java 里的线程是\u003cstrong\u003e协作式\u003c/strong\u003e的，不是抢占式的。\n\n线程可通过 \u003cstrong\u003eisInterrupted() \u003c/strong\u003e方法检查自身的中断标志位是否被置为 true 来进行响应，也可以调用静态方法\u003cstrong\u003eThread.interrupted() \u003c/strong\u003e来进行判断当前线程是否被中断，不过它会同时将中断标识位改写为 false。\n\n如果一个线程处于了阻塞状态（如线程调用了 thread.sleep、thread.join、thread.wait），则在线程在检查中断标示时如果发现中断标示为 true，则会在这些阻塞方法调用处抛出 InterruptedException 异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为 false。\n\n```java\nprivate static class UseThread extends Thread {\n   @Override\n   public void run() {\n      //while(!isInterrupted()) 不会重置中断状态,一般不会使用\n      while(!Thread.interrupted()) { //会重置中断状态\n         try {\n            System.out.println(\"thread is still running\");\n            Thread.sleep(3000);\n         } catch (InterruptedException e) { //同样会重制中断状态\n            interrupt(); //所以如果不再次中断，则程序不会终止\n            e.printStackTrace();\n         }        \n      }\n   }\n}\n\nThread useThread = new UseThread();\nuseThread.start();\nThread.sleep(800);\nuseThread.interrupt();\n```\n\n不建议自定义一个取消标志位来中止线程的运行。因为 run 方法里\u003cstrong\u003e有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志\u003c/strong\u003e。这种情况下，使用中断会更好，因为，一、一般的阻塞方法，如 sleep 等本身就支持中断的检查，二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。\n\n\u003cstrong\u003e注意：处于死锁状态的线程无法被中断\u003c/strong\u003e\n\n# 线程的状态\n\nJava 中线程的状态分为  6 种：\n\n1. \u003cstrong\u003e初始(NEW)：\u003c/strong\u003e新创建了一个线程对象，但还没有调用 start()方法。\n2. \u003cstrong\u003e运行(RUNNABLE)：\u003c/strong\u003eJava 线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 CPU 的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得 CPU 时间片后变为运行中状态（running）。\n3. \u003cstrong\u003e阻塞(BLOCKED)：\u003c/strong\u003e表示线程阻塞于锁。\n4. \u003cstrong\u003e等待(WAITING)：\u003c/strong\u003e进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。\n5. \u003cstrong\u003e超时等待(TIMED_WAITING)：\u003c/strong\u003e该状态不同于 WAITING，它可以在指定的时间后自行返回。\n6. \u003cstrong\u003e终止(TERMINATED)：\u003c/strong\u003e表示该线程已经执行完毕。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095810.png)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095813.png)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095816.png)\n\n# 线程中的方法\n\n## run 和 start\n\nThread 类是 Java 里对线程概念的抽象，可以这样理解：我们通过 new Thread 其实只是创建出一个 Thread 的实例，还没有操作系统中真正的线程挂起钩来。只有执行了 start 方法后，才实现了真正意义上的启动线程。\n\nstart 方法被调用后会让一个线程进入就绪队列等待分配 cpu，分到 cpu 后才调用 run 方法。\n\nstart 方法不能重复调用。而 run 方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，可以被单独调用。\n\n## yield\n\n使当前线程让出 CPU 占有权，但让出的时间是不可设定的。它会让当前正在运行的线程暂停，但是它不会阻塞线程，它只是让该线程直接转入到就绪状态。也就是 yield 方法只是让当前线程暂停了一下，让系统的线程调度器重新调度一次，所以很可能出现这种情况：当该线程调用了 yield 方法，之后该线程又立马被调度了。\n\n## join\n\n把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。当在某个线程执行过程中，调用其他线程的 join 方法时，调用者将会被阻塞，直到其他线程执行完成为止。比如在线程 B 中调用了线程 A 的 Join 方法，则需要在线程 A 执行完毕后，才会继续执行线程 B。\n\n# 线程间的共享和协作\n\n## 线程间的共享\n\n线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。\n\n### synchronized\n\nJava 支持多个线程同时访问一个对象或者对象的成员变量，关键字 \u003cstrong\u003esynchronized\u003c/strong\u003e 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。\n\n\u003cstrong\u003e对象锁\u003c/strong\u003e\n\n对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的 class 对象上的。\n\n使用对象锁的方式如下：\n\n```java\npublic class ObjectLock {\n    private Object lock = new Object();\n    /**\n     * 锁住非静态变量\n     */\n    public void lockObjectField() throws InterruptedException {\n        synchronized (lock) {\n            System.out.println(Thread.currentThread().getName());\n            Thread.sleep(1000);\n        }\n    }\n    \n    /**\n     * 锁住 this 对象 this 就是当前对象实例\n     */\n    public void lockThis() throws InterruptedException {\n        synchronized (this) {\n            System.out.println(Thread.currentThread().getName());\n            Thread.sleep(1000);\n        }\n    }\n    \n    /**\n     * 直接锁住非静态方法\n     */\n    public synchronized void methodLock() throws InterruptedException {\n        System.out.println(Thread.currentThread().getName());\n        Thread.sleep(1000);\n    }\n    \n    public static void main(String[] args){\n        for (int i = 0; i \u003c 5; i++) {\n            Thread worker = new Thread(new ObjectLockWorker());\n            worker.setName(\"thread-\" + i);\n            worker.start();\n        }\n    }\n    \n    public static class ObjectLockWorker implements Runnable {\n        @Override\n        public void run() {\n            try {\n                ObjectLock objectLock = new ObjectLock();\n                // 方式 1\n                objectLock.lockObjectField();\n                // 方式 2\n                //objectLock.lockThis();\n                // 方式 3\n                //objectLock.methodLock();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n结果为瞬间打印出如下内容：\nthread-3\nthread-0\nthread-4\nthread-1\nthread-2\n```\n\n\u003cstrong\u003e类锁\u003c/strong\u003e\n\n类的对象实例可以有很多个，但是每个类只有一个 class 对象，所以不同对象实例的对象锁是互不干扰的，每个类只有一个类锁。\n\n类锁的使用如下：\n\n```java\npublic class ClassLock {\n    private static Object lock = new Object();\n    /**\n     * 锁住静态变量\n     */\n    public void lockStaticObjectField() throws InterruptedException {\n        synchronized (lock){\n            System.out.println(Thread.currentThread().getName());\n            Thread.sleep(1000);\n        }\n    }\n    \n    /**\n     * 锁住静态方法\n     */\n    public static synchronized void methodLock() throws InterruptedException {\n        System.out.println(Thread.currentThread().getName());\n        Thread.sleep(1000);\n    }\n    \n    /**\n     * 锁住 xxx.class\n     */\n    public void lockClass() throws InterruptedException{\n        synchronized (ClassLock.class){\n            System.out.println(Thread.currentThread().getName());\n            Thread.sleep(1000);\n        }\n    }\n    \n    public static void main(String[] args) {\n        for (int i = 0; i \u003c 5; i++) {\n            Thread worker = new Thread(new ClassLockWorker());\n            worker.setName(\"thread-\" + i);\n            worker.start();\n        }\n    }\n    \n    public static class ClassLockWorker implements Runnable {\n        @Override\n        public void run() {\n            try {\n                ClassLock classLock = new ClassLock();\n                // 方式 1\n                classLock.lockStaticObjectField();\n                // 方式 2\n                //ClassLock.methodLock();\n                // 方式 3\n                //classLock.lockClass();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n结果为依次打印如下内容：\nthread-1\nthread-0\nthread-3\nthread-4\nthread-2\n```\n\n但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的 class 对象。类锁和对象锁之间也是互不干扰的。\n\n### volatile\n\n适合于只有一个线程写，多个线程读的场景，因为它只能确保可见性和有序性，并不保证原子性。\n\n### ThreadLocal\n\n即线程变量，是一个以 ThreadLocal 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 ThreadLocal 对象查询到绑定在这个线程上的一个值，ThreadLocal 往往用来实现变量在线程之间的隔离。\n\nThreadLocal 类接口很简单，只有 4 个方法，我们先来了解一下：\n\n- \u003cstrong\u003epublic void set(Object value) \u003c/strong\u003e\n\n设置当前线程的线程局部变量的值。\n\n- \u003cstrong\u003epublic Object get() \u003c/strong\u003e\n\n该方法返回当前线程所对应的线程局部变量。\n\n- \u003cstrong\u003epublic void remove() \u003c/strong\u003e\n\n将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是 JDK 5.0 新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。\n\n- \u003cstrong\u003eprotected Object initialValue() \u003c/strong\u003e\n\n返回该线程局部变量的初始值，该方法是一个 protected 的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第 1 次调用 get() 或 set(Object) 时才执行，并且仅执行 1 次。ThreadLocal 中的缺省实现直接返回一个 null。\n\n```java\npublic static ThreadLocal\u003cString\u003e res = new ThreadLocal\u003c\u003e();\n```\n\nres 代表一个能够存放 String 类型的 ThreadLocal 对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。\n\n## 线程间的协作\n\n线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在 while 循环中设置不满足的条件，如果条件满足则退出 while 循环，从而完成消费者的工作。却存在如下问题：\n\n1. 难以确保及时性。\n2. 难以降低开销。如果降低睡眠的时间，比如休眠 1 毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。\n\n### wait/notify/notifyAll\n\n\u003cstrong\u003ewait()/wait(long)/wait (long,int)\u003c/strong\u003e\n\n一般是由于某些条件不满足，阻塞当前线程（进入 WAITING 状态），\u003cstrong\u003e让出监视器锁\u003c/strong\u003e，不再参与锁竞争，直到其他线程来通知（告知必要的条件已经满足了），或者直到设定的超时等待时间到了。\n\n\u003cstrong\u003enotify()\u003c/strong\u003e\n\n通知一个在对象上等待的线程，使其从 wait 方法返回，而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入 WAITING 状态。\n\n\u003cstrong\u003enotifyAll()：\u003c/strong\u003e\n\n通知所有等待在该对象上的线程。\n\n### 实现等待/通知机制\n\n指一个线程 A 调用了对象 O 的 wait 方法进入等待状态，而另一个线程 B 调用了对象 O 的 notify 或者 notifyAll 方法，线程 A 收到通知后从对象 O 的 wait 方法返回，进而执行后续操作。上述两个线程通过对象 O 来完成交互，而对象上的 wait 和 notify/notifyAll 的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。\n\n等待方遵循如下原则。\n\n1）获取对象的锁。\n2）如果条件不满足，那么调用对象的 wait 方法，被通知后仍要检查条件。\n3）条件满足则执行对应的逻辑。\n\n```java\nsynchronized(对象) {\n\twhile(条件不满足) {\n\t\t对象.wait();\n\t}\n\t对应逻辑处理\n}\n```\n\n通知方遵循如下原则。\n\n1）获得对象的锁。\n2）改变条件。\n3）通知所有等待在对象上的线程。\n\n```java\nsynchronized(对象) {\n\t改变条件\n\t对象.notifyAll();\n}\n```\n\n在调用 wait 方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait 方法；\n\n调用了 wait 后， 该线程会释放该对象的锁， 然后该线程会被添加到该对象的等待队列中（waiting queue），只要该线程在等待队列中， 就会一直处于阻塞状态，\u003cstrong\u003e不会被调度执行\u003c/strong\u003e。 要注意 wait 方法会强迫线程先进行释放锁操作，所以在调用 wait 时， 该线程必须已经获得锁，否则会抛出异常。\n\n当一个线程调用一个对象的 notify（线程退出调用了 notify 的 synchronized 代码块的时候） 方法时， 调度器会从所有处于该对象等待队列（waiting queue）的线程中取出任意一个线程， 将其添加到入口队列（entry queue）中。然后在入口队列中的多个线程就会竞争对象的锁， 得到锁的线程就可以继续执行。 如果等待队列中（waiting queue）没有线程， notify 方法不会产生任何作用。\n\nnotifyAll 和 notify 工作机制一样， 区别在于 notifyAll 会将等待队列（waiting queue）中所有的线程都添加到入口队列中（entry queue）。\n\n注意：尽可能用 notifyAll，谨慎使用 notify。因为 notify 方法只能唤醒一个线程，而唤醒哪个线程是不确定的，而 notifyAll 方法则可以唤醒所有正在等待的线程。\n\n# 面试题\n\n## \u003cstrong\u003e调用 yield() 、sleep()、wait()、notify() 等方法对锁有何影响？\u003c/strong\u003e\n\n- yield()：让出时间片，不会释放锁。\n- sleep()：线程进入睡眠状态，不会释放锁。且必须定义一个时间，时间到期后会主动恢复。\n- wait()：调动方法之前，必须要持有锁。调用了 wait 方法以后，锁就会被释放，进入锁的等待队列，方法返回后重新拿到锁。需要被中断或者唤醒才能恢复，不能主动恢复。\n- notify()：调动方法之前，必须要持有锁，调用 notify 方法本身不会释放锁的。而是通知等待队列中的某一个线程，同步代码块执行完毕后才会释放锁。\n- notifyAll()：同 notify，有一点不同在于，notifyAll 会发出 n 个信号（n=等待线程数），而 notify 只会发出一个信号，通常情况下，尽量选择 notifyAll。\n- wait 和 sleep 方法都可以让线程阻塞，并且在等待的过程中如果收到中断信号，都可以进行响应（事实上是必须捕获中断异常），并抛出 InterruptedException 异常。\n- wait()方法与 sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的 wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。\n- sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是 sleep()方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。\n\n## 如何实现线程按照顺序执行？\n\n```java\npublic class UseJoin {\n    static class JumpQueue implements Runnable {\n        private Thread thread;//用来插队的线程\n        \n        public JumpQueue(Thread thread) {\n            this.thread = thread;\n        }\n        \n        public void run() {\n           try {\n              System.out.println(thread.getName() + \" will be join before \" + Thread.currentThread().getName());\n            thread.join();\n         } catch (InterruptedException e) {\n            e.printStackTrace();\n         }\n           System.out.println(Thread.currentThread().getName() + \" terminted.\");\n        }\n    }\n    \n    public static void main(String[] args) throws Exception {\n        Thread previous = Thread.currentThread();//现在是主线程\n        for (int i = 0; i \u003c 10; i++) {\n            Thread thread = new Thread(new JumpQueue(previous), String.valueOf(i));\n            thread.start();\n            previous = thread;\n        }\n        SleepTools.second(2);//让主线程休眠2秒\n        System.out.println(Thread.currentThread().getName() + \" terminate.\");\n    }\n}\n```\n\n## 如何实现两个线程交替执行？\n\n```java\npublic class ThreadPrintDemo2 {\n\n  public static void main(String[] args) {\n    final ThreadPrintDemo2 demo2 = new ThreadPrintDemo2();\n    Thread t1 = new Thread(demo2::print1);\n    Thread t2 = new Thread(demo2::print2);\n    t1.start();\n    t2.start();\n  }\n  \n  public synchronized void print2() {\n    for (int i = 1; i \u003c= 100; i += 2) {\n      System.out.println(i);\n      this.notify();\n      try {\n        this.wait();\n        Thread.sleep(100);// 防止打印速度过快导致混乱\n      } catch (InterruptedException e) {\n        // NO\n      }\n    }\n  }\n  \n  public synchronized void print1() {\n    for (int i = 0; i \u003c= 100; i += 2) {\n      System.out.println(i);\n      this.notify();\n      try {\n        this.wait();\n        Thread.sleep(100);// 防止打印速度过快导致混乱\n      } catch (InterruptedException e) {\n        // NO\n      }\n    }\n  }\n}\n```\n\n## 为什么 wait 和 notify/notifyAll 必须在 synchronized 保护的同步代码中使用？\n\n前面提到等待/通知机制的时候提到过，wait/notify 标准用法如下：\n\n```java\nsynchronized(对象) {\n\twhile(条件不满足) {//1\n\t\t对象.wait();//2\n\t}\n\t对应逻辑处理\n}\n\nsynchronized(对象) {\n\t改变条件\n\t对象.notifyAll();\n}\n```\n\n先看 wait 方法，如果没有在 synchronized 代码代码块中，意味着在多线程环境下程序执行到任意位置都可能会发生上下文切换。而 1 和 2 处的操作不是原子的，如果线程 A 在这两处之间发生上下文切换，则有可能进入 while 后，其它线程修改了条件并且发出 notify 通知，但是此时线程 A 是收不到通知的；待上下文切换回来后，A 线程会一直等待其它线程 notify。\n\n这就是所谓的 Lost Wake-Up Problem：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Thread-Base/clipboard_20230323_095828.png)\n\n另外，wait 方法会释放 monitor 锁，这也要求我们必须首先进入到 synchronized 内持有这把锁。\n\n## 为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？\n\n1. 因为 Java 中每个对象都有一把称之为 monitor 监视器的锁，由于每个对象都可以上锁，这就要求在对象头中有一个用来保存锁信息的位置。这个锁是对象级别的，而非线程级别的，wait/notify/notifyAll 也都是锁级别的操作，它们的锁属于对象，所以把它们定义在 Object 类中是最合适，因为 Object 类是所有对象的父类。\n2. 因为如果把 wait/notify/notifyAll 方法定义在 Thread 类中，会带来很大的局限性，比如一个线程可能持有多把锁，以便实现相互配合的复杂逻辑，假设此时 wait 方法定义在 Thread 类中，如何实现让一个线程持有多把锁呢？又如何明确线程等待的是哪把锁呢？既然我们是让当前线程去等待某个对象的锁，自然应该通过操作对象来实现，而不是操作线程。\n","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["Thread","线程协作","面试","Java"]},"/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C-BlockingQueue":{"title":"线程池和 BlockingQueue","content":"# BlockingQueue 阻塞队列\n\n## 队列 \n\n队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。\n\n在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。\n\n## 什么是阻塞队列\n\n`public interface BlockingQueue\u003cE\u003e extends Queue\u003cE\u003e`\n\n- 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。\n- 支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。\n\n阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095000.png)\n\n- \u003cstrong\u003e抛出异常：\u003c/strong\u003e当队列满时，如果再往队列里插入元素，会抛出 IllegalStateException（\"Queuefull\"）异常。当队列空时，从队列里获取元素会抛出 NoSuchElementException 异常。\n- \u003cstrong\u003e返回特殊值：\u003c/strong\u003e当往队列插入元素时，会返回元素是否插入成功，成功返回 true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回 null。\n- \u003cstrong\u003e一直阻塞：\u003c/strong\u003e当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里 take 元素，队列会阻塞住消费者线程，直到队列不为空。\n- \u003cstrong\u003e超时退出：\u003c/strong\u003e当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。\n\n## 常用阻塞队列\n\n### \u003cstrong\u003eArrayBlockingQueue\u003c/strong\u003e\n\n用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列。可在初始化时通过参数设置，默认是非公平的。\n\n所谓公平访问队列是指阻塞的线程可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。\n\n### \u003cstrong\u003eLinkedBlockingQueue\u003c/strong\u003e\n\n用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。\n\n### \u003cstrong\u003ePriorityBlockingQueue\u003c/strong\u003e\n\n支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。\n\n### \u003cstrong\u003eDelayQueue\u003c/strong\u003e\n\n支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。DelayQueue 非常有用，可以将 DelayQueue 运用在\u003cstrong\u003e缓存系统的设计：\u003c/strong\u003e用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。\n\n### \u003cstrong\u003eSynchronousQueue\u003c/strong\u003e\n\n不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。\n\n### \u003cstrong\u003eLinkedTransferQueue\u003c/strong\u003e\n\n多了 tryTransfer 和 transfer 方法。\n\n1. \u003cstrong\u003etransfer\u003c/strong\u003e\u003cstrong\u003e 方法。\u003c/strong\u003e如果当前有消费者正在等待接收元素（消费者使用 take 方法或带时间限制的 poll 方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。\n2. \u003cstrong\u003etryTransfer\u003c/strong\u003e\u003cem\u003e 方法。\u003c/em\u003e tryTransfer 方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回，而 transfer 方法是必须等到消费者消费了才返回。\n\n### \u003cstrong\u003eLinkedBlockingDeque\u003c/strong\u003e\n\n由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。\n\n同时，它还多了 addFirst、addLast、offerFirst、offerLast、peekFirst 和 peekLast 等方法，以 First 单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 JDK 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。在初始化 LinkedBlockingDeque 时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。\n\n\u003cstrong\u003e有界和无界\u003c/strong\u003e\n\n有限队列就是长度有限，满了以后生产者会阻塞，无界队列就是里面能放无数的东西而不会因为队列长度限制被阻塞，当然空间限制来源于系统资源的限制，如果处理不及时，导致队列越来越大越来越大，超出一定的限制致使内存超限，操作系统或者 JVM 会直接杀死进程。\n\n无界也会阻塞，为何？因为阻塞不仅仅体现在生产者放入元素时会阻塞，消费者拿取元素时，如果没有元素，同样也会阻塞。\n\n\u003cstrong\u003eArray 实现和 Linked 实现的区别\u003c/strong\u003e\n\n1. 队列中锁的实现不同。ArrayBlockingQueue 实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue 实现的队列中的锁是分离的，即生产用的是 putLock，消费是 takeLock。\n2. 生产或消费时操作不同。ArrayBlockingQueue 实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；LinkedBlockingQueue 实现的队列中在生产和消费的时候，需要把枚举对象转换为 `Node\u003cE\u003e`进行插入或移除，会影响性能。\n3. 队列大小初始化方式不同。ArrayBlockingQueue 实现的队列中必须指定队列的大小；LinkedBlockingQueue 实现的队列中可以不指定队列的大小，但是默认是 Integer.MAX_VALUE。\n\n# 线程池\n\n## 为什么要用线程池？\n\nJava 中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来三个好处：\n\n1. \u003cstrong\u003e降低资源消耗。\u003c/strong\u003e通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n2. \u003cstrong\u003e提高响应速度。\u003c/strong\u003e当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。如果 T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整 T1,T3 时间的技术，从而提高服务器程序性能的。它把 T1，T3 分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有 T1，T3 的开销了。\n3. \u003cstrong\u003e提高线程的可管理性。\u003c/strong\u003e线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。\n\n## 线程池的创建各个参数含义\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue\u003cRunnable\u003e workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n```\n\n### \u003cstrong\u003ecorePoolSize\u003c/strong\u003e\n\n线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于 corePoolSize；\n\n如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；\n\n如果执行了线程池的 prestartAllCoreThreads() 方法，线程池会提前创建并启动所有核心线程。\n\n### \u003cstrong\u003emaximumPoolSize\u003c/strong\u003e\n\n线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize\n\n### \u003cstrong\u003ekeepAliveTime\u003c/strong\u003e\n\n线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于 corePoolSize 时才有用\n\n### \u003cstrong\u003eTimeUnit\u003c/strong\u003e\n\nkeepAliveTime 的时间单位\n\n### \u003cstrong\u003eworkQueue\u003c/strong\u003e\n\nworkQueue 必须是 BlockingQueue 阻塞队列。当线程池中的线程数超过它的 corePoolSize 的时候，线程会进入阻塞队列进行阻塞等待。通过 workQueue，线程池实现了阻塞功能。\n\n一般来说，我们应该\u003cstrong\u003e尽量使用有界队列\u003c/strong\u003e，因为使用无界队列作为工作队列会对线程池带来如下影响:\n\n1. 当线程池中的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize。\n2. 由于 1，使用无界队列时 maximumPoolSize 将是一个无效参数。\n3. 由于 1 和 2，使用无界队列时 keepAliveTime 将是一个无效参数。\n4. 更重要的，使用无界 queue 可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。\n\n### \u003cstrong\u003ethreadFactory\u003c/strong\u003e\n\n创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。Executors 静态工厂里默认的 threadFactory，线程的命名规则是“pool-数字-thread-数字”。\n\n### \u003cstrong\u003eRejectedExecutionHandler\u003c/strong\u003e\n\n线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了 4 种策略：\n\n1. AbortPolicy：直接抛出异常，默认策略；\n2. CallerRunsPolicy：用调用者所在的线程来执行任务；\n3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；\n4. DiscardPolicy：直接丢弃任务；\n\n当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。\n\n## 线程池的工作机制\n\n```\n1）如果当前运行的线程少于 corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。\n\n2）如果运行的线程等于或多于 corePoolSize，则将任务加入 BlockingQueue。\n\n3）如果无法将任务加入 BlockingQueue（队列已满），则创建新的线程来处理任务。\n\n4）如果创建新线程将使当前运行的线程超出 maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution() 方法。\n```\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095008.png)\n\n## Executor 框架\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095011.png)\n\n### \u003cstrong\u003eExecutor \u003c/strong\u003e\n\n\u003cstrong\u003eExecutor\u003c/strong\u003e\u003cstrong\u003e \u003c/strong\u003e是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的执行分离开来。\n\n### \u003cstrong\u003eExecutorService \u003c/strong\u003e\n\nExecutorService 接口继承了 Executor，在其上做了一些 shutdown()、submit() 的扩展，可以说是真正的线程池接口；\n\n### \u003cstrong\u003eAbstractExecutorService \u003c/strong\u003e\n\nAbstractExecutorService 抽象类实现了 ExecutorService 接口中的大部分方法；\n\n### \u003cstrong\u003eThreadPoolExecutor\u003c/strong\u003e\u003cem\u003e \u003c/em\u003e\n\nThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。\n\n### \u003cstrong\u003eScheduledExecutorService \u003c/strong\u003e\n\nScheduledExecutorService 接口继承了 ExecutorService 接口，提供了带\"周期执行\"功能 ExecutorService；\n\n### \u003cstrong\u003eScheduledThreadPoolExecutor \u003c/strong\u003e\n\nScheduledThreadPoolExecutor 是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor 比 Timer 更灵活，功能更强大。\n\n### \u003cem\u003eForkJoinPool（since 1.7）\u003c/em\u003e\n\nForkJoinPool 是自 JDK 7 起引入的线程池，核心思想是将大的任务拆分成多个小任务（fork），然后在将多个小任务处理汇总到一个结果上（join），非常像 MapReduce 处理原理。同时，它提供基本的线程池功能，支持设置最大并发线程数，支持任务队，支持线程池停止，支持线程池使用情况监控，也是 AbstractExecutorService 的子类，主要引入了“工作窃取”机制，在多 CPU 计算机上处理性能更佳。\n\nForkJoinPool 提供了一个更有效的利用线程的机制，当 ThreadPoolExecutor 还在用单个队列存放任务时，ForkJoinPool 已经分配了与线程数相等的队列；当有任务加入线程池时，会被平均分配到对应的队列上，各线程进行正常工作；当有线程提前完成时，会从队列的末端“窃取”其他线程未执行完的任务。\n\n## \u003cstrong\u003eExecutors 类\u003c/strong\u003e\n\nExcutors 类相当于一个线程池工厂，可以创建不同类型的线程池：\n\n### \u003cem\u003enewFixedThreadPool\u003c/em\u003e\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads){\n    return new ThreadPoolExecutor(nThreads, nThreads, 0L, \n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e());\n}\n\npublic static ExecutorService newFixedThreadPool(int nThreads,     \n            ThreadFactory threadFactory){\n    return new ThreadPoolExecutor(nThreads, nThreads, 0L,   \n        TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003cRunnable\u003e  \n        (), threadFactory);\n}\n```\n\n它的核心线程数和最大线程数是一样的，所以可以把它看作是固定线程数的线程池，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。\n\n### \u003cem\u003enewSingleThreadExecutor\u003c/em\u003e\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue\u003cRunnable\u003e()));\n}\n\npublic static ExecutorService newSingleThreadExecutor(ThreadFactory   \n            threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue\u003cRunnable\u003e(), threadFactory));\n}\n```\n\n它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于\u003cstrong\u003e所有任务都需要按被提交的顺序依次执行\u003c/strong\u003e的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。\n\n### \u003cem\u003enewCachedThreadPoo\u003c/em\u003e\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L,   \n              TimeUnit.SECONDS, new SynchronousQueue\u003cRunnable\u003e());\n}\n\npublic static ExecutorService newCachedThreadPool(ThreadFactory \n            threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L,   \n              TimeUnit.SECONDS, new SynchronousQueue\u003cRunnable\u003e(),\n              threadFactory);\n}\n```\n\n可以称作可缓存线程池，它的特点在于线程数是几乎可以无限增加的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为  0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。\n\n当提交一个任务后，线程池会判断已创建的线程中是否有空闲线程，如果有空闲线程则将任务直接指派给空闲线程，如果没有空闲线程，则新建线程去执行任务，这样就做到了动态地新增线程。\n\n### \u003cem\u003enewScheduledThreadPool\u003c/em\u003e\n\n```java\npublic static ScheduledExecutorService \n        newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPoolExecutor(corePoolSize);\n}\n  \npublic static ScheduledExecutorService newScheduledThreadPool(\n        int corePoolSize, ThreadFactory threadFactory) {\n    return new ScheduledThreadPoolExecutor(corePoolSize,   \n          threadFactory);\n}\n\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue());\n}\n\npublic ScheduledThreadPoolExecutor(int corePoolSize,\n        ThreadFactory threadFactory) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue(), threadFactory);\n}\n```\n\nScheduledExecutorService 有三种方法执行定时任务：\n\n```java\nScheduledExecutorService service = Executors.newScheduledThreadPool(10);\n \nservice.schedule(new Task(), 10, TimeUnit.SECONDS);\n \nservice.scheduleAtFixedRate(new Task(), 10, 10, TimeUnit.SECONDS);\n \nservice.scheduleWithFixedDelay(new Task(), 10, 10, TimeUnit.SECONDS);\n```\n\n\u003cstrong\u003eschedule \u003c/strong\u003e比较简单，表示延迟指定时间后执行一次任务，如果代码中设置参数为 10 秒，也就是 10 秒后执行一次任务后就结束。\n\n\u003cstrong\u003escheduleAtFixedRate\u003c/strong\u003e 表示以固定的频率执行任务，它的第二个参数 initialDelay 表示第一次延时时间，第三个参数 period 表示周期，也就是第一次延时后每次延时多长时间执行一次任务。\n\n\u003cstrong\u003escheduleWithFixedDelay \u003c/strong\u003e与第二种方法类似，也是周期执行任务，区别在于对周期的定义，之前的 scheduleAtFixedRate 是以任务开始的时间为时间起点开始计时，时间到就开始执行第二次任务，而不管任务需要花多久执行；而 scheduleWithFixedDelay 方法以任务结束的时间为下一次循环的时间起点开始计时。\n\n### \u003cem\u003enewSingleThreadScheduledExecutor\u003c/em\u003e\n\n```java\npublic static ScheduledExecutorService \n       newSingleThreadScheduledExecutor() {\n    return new ScheduledThreadPoolExecutor(1);\n}\n\npublic static ScheduledExecutorService \n       newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {\n    return new ScheduledThreadPoolExecutor(1, threadFactory);\n}\n```\n\n它只是 ScheduledThreadPool 的一个特例，内部只有一个线程。它只是将核心线程数设置为了 1。\n\n### 五种线程池参数对比\n\n总结上述的五种线程池，我们以核心线程数、最大线程数，以及线程存活时间三个维度进行对比：\n\n\u003cstrong\u003eFixedThreadPool\u003c/strong\u003e，它的核心线程数和最大线程数都是由构造函数直接传参的，而且它们的值是相等的。重点是使用的队列是容量没有上限的 LinkedBlockingQueue，如果我们对任务的处理速度比较慢，那么随着请求的增多，队列中堆积的任务也会越来越多，最终大量堆积的任务会占用大量内存，并发生 OOM ，也就是 OutOfMemoryError，这几乎会影响到整个程序，会造成很严重的后果。\n\n\u003cstrong\u003eSingleThreadExecutor\u003c/strong\u003e，newSingleThreadExecutor 和 newFixedThreadPool 的原理是一样的，只不过把核心线程数和最大线程数都直接设置成了 1，但是任务队列仍是无界的 LinkedBlockingQueue，所以也会导致同样的问题。\n\n\u003cstrong\u003eCachedThreadPool\u003c/strong\u003e，和前面两种线程池不一样的地方在于任务队列使用的是 SynchronousQueue，SynchronousQueue 本身并不存储任务，而是对任务直接进行转发，这本身是没有问题的，但你会发现构造函数的第二个参数被设置成了 Integer.MAX_VALUE，这个参数的含义是最大线程数，所以由于 CachedThreadPool 并不限制线程的数量，当任务数量特别多的时候，就可能会导致创建非常多的线程，最终超过了操作系统的上限而无法创建新线程，或者导致内存不足。\n\n\u003cstrong\u003eScheduledThreadPool\u003c/strong\u003e  和 \u003cstrong\u003eSingleThreadScheduledExecutor  \u003c/strong\u003e的原理是一样的，它采用的任务队列是 DelayedWorkQueue，这是一个延迟队列，同时也是一个无界队列，所以和 LinkedBlockingQueue 一样，如果队列中存放过多的任务，就可能导致 OOM。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095020.png)\n\n### \u003cem\u003enewWorkStealingPool (since 1.8)\u003c/em\u003e\n\n```java\npublic static ExecutorService newWorkStealingPool() {\n    return new ForkJoinPool\n        (Runtime.getRuntime().availableProcessors(),\n         ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n         null, true);\n}\n\npublic static ExecutorService newWorkStealingPool(int parallelism) {\n    return new ForkJoinPool\n        (parallelism,\n         ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n         null, true);\n}\n\npublic ForkJoinPool(int parallelism,\n                    ForkJoinWorkerThreadFactory factory,\n                    UncaughtExceptionHandler handler,\n                    boolean asyncMode) {\n    this(checkParallelism(parallelism),\n         checkFactory(factory),\n         handler,\n         asyncMode ? FIFO_QUEUE : LIFO_QUEUE,\n         \"ForkJoinPool-\" + nextPoolId() + \"-worker-\");\n    checkPermission();\n}\n```\n\n这个线程池是在 JDK 7 加入的，它的名字 ForkJoin 也描述了它的执行机制，主要用法和之前的线程池是相同的，也是把任务交给线程池去执行，线程池中也有任务队列来存放任务。但是 ForkJoinPool 线程池和之前的线程池有两点非常大的不同之处。第一点它非常适合执行可以产生子任务的任务。\n\n如图所示，我们有一个 Task，这个 Task 可以产生三个子任务，三个子任务并行执行完毕后将结果汇总给 Result，比如说主任务需要执行非常繁重的计算任务，我们就可以把计算拆分成三个部分，这三个部分是互不影响相互独立的，这样就可以利用 CPU 的多核优势，并行计算，然后将结果进行汇总。这里面主要涉及两个步骤，第一步是拆分也就是 Fork，第二步是汇总也就是 Join，到这里你应该已经了解到 ForkJoinPool 线程池名字的由来了。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095024.png)\n\n比如，处理斐波那契数列问题：\n\n```java\nclass Fibonacci extends RecursiveTask\u003cInteger\u003e { \n    int n;\n \n    public Fibonacci(int n) { \n        this.n = n;\n    } \n \n    @Override\n    public Integer compute() { \n        if (n \u003c= 1) { \n            return n;\n        } \n        Fibonacci f1 = new Fibonacci(n - 1);\n        f1.fork();\n        Fibonacci f2 = new Fibonacci(n - 2);\n        f2.fork();\n        return f1.join() + f2.join();\n    } \n }\n\npublic static void main(String[] args) throws ExecutionException, \n            InterruptedException { \n    ForkJoinPool forkJoinPool = new ForkJoinPool();\n    for (int i = 0; i \u003c 10; i++) { \n        ForkJoinTask task = forkJoinPool.submit(new Fibonacci(i));\n        System.out.println(task.get());\n    } \n }\n\n输出内容：\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n```\n\n第二点不同之处在于内部结构，之前的线程池所有的线程共用一个队列，但 ForkJoinPool 线程池中每个线程都有自己独立的任务队列，如图所示。\n\nForkJoinPool 线程池内部除了有一个共用的任务队列之外，每个线程还有一个对应的双端队列 deque，这时一旦线程中的任务被 Fork 分裂了，分裂出来的子任务放入线程自己的 deque 里，而不是放入公共的任务队列中。如果此时有三个子任务放入线程 t1 的 deque 队列中，对于线程 t1 而言获取任务的成本就降低了，可以直接在自己的任务队列中获取而不必去公共队列中争抢也不会发生阻塞（除了后面会讲到的 steal 情况外），减少了线程间的竞争和切换，是非常高效的。\n\n再考虑一种情况，此时线程有多个，而线程 t1 的任务特别繁重，分裂了数十个子任务，但是 t0 此时却无事可做，它自己的 deque 队列为空，这时为了提高效率，t0 就会想办法帮助 t1 执行任务，这就是“work-stealing”的含义。\n\n双端队列 deque 中，线程 t1 获取任务的逻辑是后进先出，也就是 LIFO（Last In Frist Out），而线程 t0 在“steal”偷线程 t1 的 deque 中的任务的逻辑是先进先出，也就是 FIFO（Fast In Frist Out），如下图所示，图中很好的描述了两个线程使用双端队列分别获取任务的情景。你可以看到，使用“work-stealing”算法和双端队列很好地平衡了各线程的负载。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095028.png)\n\n用一张全景图来描述 ForkJoinPool 线程池的内部结构，可以看到 ForkJoinPool 线程池和其他线程池很多地方都是一样的，但重点区别在于它每个线程都有一个自己的双端队列来存储分裂出来的子任务。ForkJoinPool 非常适合用于递归的场景，例如树的遍历、最优路径搜索等场景。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095032.png)\n\n综合以上，Excutors 创建各种线程池对应的适用场景如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Threadpool/clipboard_20230323_095035.png)\n\n## 提交任务\n\n- \u003cstrong\u003eexecute \u003c/strong\u003e方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。\n- \u003cstrong\u003esubmit \u003c/strong\u003e方法用于提交需要返回值的任务。线程池会返回一个 future 类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过 future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，而使用 get(long timeout，TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。\n\n## 关闭线程池\n\n### shutdown()\n\n它可以安全地关闭一个线程池，调用 shutdown 方法之后线程池并不是立刻就被关闭，因为这时线程池中可能还有很多任务正在被执行，或是任务队列中有大量正在等待被执行的任务，调用 shutdown 方法后线程池会\u003cstrong\u003e在执行完正在执行的任务和队列中等待的任务后才彻底关闭\u003c/strong\u003e。但这并不代表 shutdown 操作是没有任何效果的，调用 shutdown 方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。\n\n### isShutdown()\n\n它可以返回 true 或者 false 来判断线程池是否已经开始了关闭工作，也就是是否执行了 shutdown 或者 shutdownNow 方法。这里需要注意，如果调用 isShutdown 方法的返回的\u003cstrong\u003e结果为 true 并不代表线程池此时已经彻底关闭了，这仅仅代表线程池开始了关闭的流程\u003c/strong\u003e，也就是说，此时可能线程池中依然有线程在执行任务，队列里也可能有等待被执行的任务。\n\n### isTerminated()\n\n这个方法可以检测线程池是否真正“终结”了，这不仅代表线程池已关闭，同时代表线程池中的所有任务都已经都执行完毕了。因为刚才说过，调用 shutdown 方法之后，线程池会继续执行里面未完成的任务，不仅包括线程正在执行的任务，还包括正在任务队列中等待的任务。比如此时已经调用了 shutdown 方法，但是有一个线程依然在执行任务，那么此时调用 isShutdown 方法返回的是 true ，而调用 isTerminated 方法返回的便是 false ，因为线程池中还有任务正在在被执行，线程池并没有真正“终结”。\u003cstrong\u003e直到所有任务都执行完毕了，调用 isTerminated 方法才会返回 true\u003c/strong\u003e，这表示线程池已关闭并且线程池内部是空的，所有剩余的任务都执行完毕了。\n\n### awaitTermination()\n\n此方法本身并不是用来关闭线程池的，而是主要用来判断线程池状态的。比如我们给 awaitTermination 方法传入的参数是 10 秒，那么它就会陷入 10 秒钟的等待，直到发生以下三种情况之一：\n\n等待期间（包括进入等待状态之前）线程池已关闭并且所有已提交的任务（包括正在执行的和队列中等待的）都执行完毕，相当于线程池已经“终结”了，方法便会返回 true；\n\n等待超时时间到后，第一种线程池“终结”的情况始终未发生，方法返回 false；\n\n等待期间线程被中断，方法会抛出 InterruptedException 异常。\n\n也就是说，调用 awaitTermination 方法后\u003cstrong\u003e当前线程会尝试等待一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正“终结”了，那么方法就返回 true，否则超时返回 fasle。\u003c/strong\u003e\n\n我们可以根据 awaitTermination 返回的布尔值来判断下一步应该执行的操作。\n\n### shutdownNow()\n\n最后一个方法是 shutdownNow()，也是 5 种方法里功能最强大的，它与第一种 shutdown 方法不同之处在于名字中多了一个单词 Now，也就是表示立刻关闭的意思。在执行 shutdownNow 方法之后，首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务 List 来进行一些补救的操作，例如记录在案并在后期重试。\n\n这里需要注意的是，由于 Java 中不推荐强行停止线程的机制的限制，即便我们调用了 shutdownNow 方法，如果被中断的线程对于中断信号不理不睬，那么依然有可能导致任务不会停止。可见我们在开发中落地最佳实践是很重要的，我们自己编写的线程应当具有响应中断信号的能力，正确停止线程的方法在前面有讲过，应当利用中断信号来协同工作。\n\n在掌握了这 5 种关闭线程池相关的方法之后，就可以根据自己的业务需要，选择合适的方法来停止线程池，比如通常可以用 shutdown 方法来关闭，这样可以让已提交的任务都执行完毕，但是如果情况紧急，那就可以用 shutdownNow 方法来加快线程池“终结”的速度。\n\n合\n\n## 合理地配置线程池\n\n要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。\n\n- 任务的性质：CPU 密集型任务、IO 密集型任务和混合型任务。\n- 任务的优先级：高、中和低。\n- 任务的执行时间：长、中和短。\n- 任务的依赖性：是否依赖其他系统资源，如数据库连接。\n\n性质不同的任务可以用不同规模的线程池分开处理：\n\n1. CPU 密集型任务应配置尽可能小的线程池，如配置 Ncpu + 1 个线程的线程池。比如加密、解密、压缩、计算等。\n2. IO 密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如 2*Ncpu。比如数据库、文件的读写，网络通信等任务等。\n3. 《Java 并发编程实战》的作者 Brain Goetz 推荐的计算方法：\u003cstrong\u003e线程数 = CPU 核心数 *（1+ 平均等待时间/平均工作时间）。\u003c/strong\u003e通过这个公式，我们可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于我们上面的 CPU 密集型任务，线程数就随之减少。太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行压测，监控 JVM 的线程情况以及 CPU 的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。\n4. 混合型的任务，如果可以拆分，将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过 Runtime.getRuntime().availableProcessors() 方法获得当前设备的 CPU 个数。\n5. 优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 来处理。它可以让优先级高的任务先执行。\n6. 执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。\n7. 建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。\n8. 如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。\n\n```java\npublic class FairAndUnfair {\n\n    public static void main(String args[]) {\n        PrintQueue printQueue = new PrintQueue();\n\n\n        Thread thread[] = new Thread[10];\n        for (int i = 0; i \u003c 10; i++) {\n            thread[i] = new Thread(new Job(printQueue), \"Thread \" + i);\n        }\n\n\n        for (int i = 0; i \u003c 10; i++) {\n            thread[i].start();\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\nclass Job implements Runnable {\n\n    private PrintQueue printQueue;\n\n    public Job(PrintQueue printQueue) {\n        this.printQueue = printQueue;\n    }\n\n    @Override\n    public void run() {\n        System.out.printf(\"%s: Going to print a job\\n\", Thread.currentThread().getName());\n        printQueue.printJob(new Object());\n        System.out.printf(\"%s: The document has been printed\\n\", Thread.currentThread().getName());\n    }\n}\n\n\nclass PrintQueue {\n\n    private final Lock queueLock = new ReentrantLock(false);\n\n    public void printJob(Object document) {\n        queueLock.lock();\n\n        try {\n            Long duration = (long) (Math.random() * 10000);\n            System.out.printf(\"%s: PrintQueue: Printing a Job during %d seconds\\n\",\n                    Thread.currentThread().getName(), (duration / 1000));\n            Thread.sleep(duration);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            queueLock.unlock();\n        }\n\n        queueLock.lock();\n        try {\n            Long duration = (long) (Math.random() * 10000);\n            System.out.printf(\"%s: PrintQueue: Printing a Job during %d seconds\\n\",\n                    Thread.currentThread().getName(), (duration / 1000));\n            Thread.sleep(duration);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            queueLock.unlock();\n        }\n    }\n}\n\n```\n","lastmodified":"2023-04-21T14:55:33.037222465Z","tags":["ThreadPool","BlockingQueue","Executor","ExecutorService","Java"]},"/%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86Hash%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86":{"title":"编码、加密、Hash、序列化和字符集","content":"## 加密\n\n在密码学中，加密是将明文信息改变为难以读取的密文内容，使之不可读的过程。只有拥有解密方法的对象，经由解密过程，才能将密文还原为正常可读的内容。理想情况下，只有经授权的人员能够读取密文所要传达的信息。\u003cstrong\u003e加密本身并不能防止信息传输被截取，但加密能防止截取者理解其内容。\u003c/strong\u003e\n\n### 对称加密\n\n#### 原理\n\n通信双方使用同一个密钥，使用加密算法配合上密钥来加密，解密时使用加密过程\n\n的完全逆过程配合密钥来进行解密。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Code%26Hash/clipboard_20230323_030810.png)\n\n#### 经典算法\n\n- DES(56 位密钥，密钥太短而逐渐被弃用)\n- AES(128 位、192 位、256 位密钥， 现在最流行)\n\n#### \u003cstrong\u003e对称加密作用\u003c/strong\u003e\n\n加密通信，防止信息在不安全网络上被截获后，信息被人读取或篡改。\n\n#### \u003cstrong\u003e对称加密(如 \u003c/strong\u003eAES\u003cstrong\u003e)的破解 \u003c/strong\u003e\n\n\u003cem\u003e破解思路\u003c/em\u003e\n\n拿到一组或多组原文-密文对 设法找到一个密钥，这个密钥可以将这些原文-密文对中的原文加密为密文，以 及将密文解密为原文的组合，即为成功破解\n\n\u003cem\u003e反破解\u003c/em\u003e\n\n一种优秀的对称加密算法的标准是，让破解者找不到比穷举法(暴力破解法)更有\n\n效的破解手段，并且穷举法的破解时间足够⻓(例如数千年)。\n\n#### \u003cstrong\u003e对称加密的缺点\u003c/strong\u003e\n\n密钥泄露：不能在不安全网络上传输密钥，一旦密钥泄露则加密通信失败。\n\n### 非对称加密\n\n#### 原理\n\n使用公钥对数据进行加密得到密文;使用私钥对数据进行解密得到原数据。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Code%26Hash/clipboard_20230323_030814.png)\n\n使用非对称加密通信，可以在不可信网络上将双方的公钥传给对方，然后在发消息前分别对消息使用对方的公钥来加密和使用自己的私钥来签名，做到不可信网络上的可靠密钥传播及加密通信。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Code%26Hash/clipboard_20230323_030819.png)\n\n由于私钥和公钥互相可解，因此非对称加密还可以应用于数字签名技术。通常会对原数据 hash 以后对 hash 签名，然后附加在原数据的后面作为签名。这是 为了让数据更小。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Code%26Hash/clipboard_20230323_030822.png)\n\n#### \u003cstrong\u003e经典算法\u003c/strong\u003e\n\n- RSA(可用于加密和签名)\n- DSA(仅用于 签名，但速度更快)\n\n#### \u003cstrong\u003e非对称加密的优缺点\u003c/strong\u003e\n\n- 优点：可以在不安全网络上传输密钥。\n- 缺点：计算复杂，因此性能相比对称加密差很多。\n\n#### \u003cstrong\u003e非对称加密(如 \u003c/strong\u003eRSA\u003cstrong\u003e、\u003c/strong\u003eECDSA\u003cstrong\u003e)的破解 \u003c/strong\u003e\n\n##### \u003cem\u003e破解思路\u003c/em\u003e\n\n和对称加密不同之处在于，非对称加密的公钥很容易获得，因此制造“原文-密文”对是没有困难的事。所以，非对称加密的关键只在于如何找到一个正确的私钥，可以解密所有经过公钥加密过的密文。找到这样的私钥即为成功破解。由于非对称加密的自身特性，怎样通过公钥来推断出私钥通常是一种思路(例如 RSA)，但往往最佳手段依然是穷举法，只是和对称加密破解的区别在于，对称加密破解是不断尝试自己的新密钥是否可以将自己拿到的“原文-密文”对进行加密和解密，而非对称加密时不断尝试自己的新私钥是否和公钥互相可解。\n\n##### \u003cem\u003e反破解\u003c/em\u003e\n\n和对称加密一样，非对称加密算法优秀的标准同样在于，让破解者找不到比穷举法更有效的破解手段，并且穷举法的破解时间足够⻓。\n\n## 编码\n\n把数据从一种形式转换为另一种形式。\n\n### Base64\n\n将二进制数据转换成由 64 个字符组成的字符串的编码算法。\n\n#### 原理\n\n将原数据每 6 位对应成 Base 64 索引表中的一个字符编排成一个字符串(每个字符 8 位)。\n\n#### 用途\n\n1. 将二进制数据扩充了储存和传输途径(例如可以把数据保存到文本文件、可以通过聊天对话框或短信形式发送二进制数据、可以在 URL 中加入简单的二进制数据)。\n2. 普通的字符串在经过 Base64 编码后的结果会变得肉眼不可读，因此可以适用于 一定条件下的防偷窥(较少用)。\n\n#### 缺点\n\n因为自身的原理(6 位变 8 位)，因此每次 Base64 编码之后，数据都会增大约 1/3，所以会影响存储和传输性能。\n\n### \u003cstrong\u003e压缩与解压缩\u003c/strong\u003e\n\n#### \u003cstrong\u003e含义\u003c/strong\u003e\n\n- 压缩：将数据使用更具有存储优势的编码算法进行编码。\n- 解压缩：将压缩数据解码还原成原来的形式，以方便使用。\n\n#### \u003cstrong\u003e目的\u003c/strong\u003e\n\n减小数据占用的存储空间。\n\n#### \u003cstrong\u003e压缩是编码吗?\u003c/strong\u003e\n\n是。所谓编码，即把数据从一种形式转换为另一种形式。压缩过程属于编码过程，\n\n解压缩过程属于解码过程。\n\n#### \u003cstrong\u003e常⻅压缩算法\u003c/strong\u003e\n\nDEFLATE、JPEG、MP3 等。\n\n### \u003cstrong\u003e图片与音频、视频编解码\u003c/strong\u003e\n\n#### \u003cstrong\u003e含义\u003c/strong\u003e\n\n将图像、音频、视频数据通过编码来转换成存档形式(编码)，以及从存档形式转换回来(解码)。\n\n#### \u003cstrong\u003e目的\u003c/strong\u003e\n\n存储和压缩媒体数据(大多数媒体编码算法会压缩数据，但不是全部)。\n\n## \u003cstrong\u003e序列化\u003c/strong\u003e\n\n把数据对象(一般是内存中的，例如 JVM 中的对象)转换成字节序列的过程。对象 在程序内存里的存放形式是散乱的(存放在不同的内存区域、并且由引用进行连 接)，通过序列化可以把内存中的对象转换成一个字节序列，从而使用 byte[] 等形 式进行本地存储或网络传输，在需要的时候重新组装(反序列化)来使用。\n\n### \u003cstrong\u003e目的\u003c/strong\u003e\n\n让内存中的对象可以被储存和传输。\n\n### \u003cstrong\u003e序列化是编码吗?\u003c/strong\u003e\n\n不是，参考编码的定义。\n\n## Hash\n\n### \u003cstrong\u003e定义\u003c/strong\u003e\n\n把任意数据转换成指定大小范围(通常很小，例如 256 字节以内)的数据。\n\n### \u003cstrong\u003e作用\u003c/strong\u003e\n\n相当于从数据中提出摘要信息，因此最主要用途是数字指纹。\n\n### \u003cstrong\u003e用途\u003c/strong\u003e\n\n#### \u003cstrong\u003e唯一性验证\u003c/strong\u003e\n\n例如 Java 中的 hashCode() 方法。把 equals() 方法中的每个用于判断相等的变量都放进 hashCode() 中，一起生成一个尽量不会碰撞的整数即可。\n\n#### \u003cstrong\u003e数据完整性验证\u003c/strong\u003e\n\n从网络上下载文件后，通过比对文件的 Hash 值(例如 MD5、SHA1)，可以确认下 载的文件是否有损坏。如果下载的文件 Hash 值和文件提供方给出的 Hash 值一致， 则证明下载的文件是完好无损的。\n\n#### \u003cstrong\u003e快速查找 \u003c/strong\u003e\n\nHashMap\n\n#### \u003cstrong\u003e隐私保护\u003c/strong\u003e\n\n当重要数据必须暴露的时候，有事可以选择暴露它的 Hash 值(例如 MD5)，以保障原数据的安全。例如网站登录时，可以只保存用户密码的 Hash 值，在每次登录验 证时只需要将输入的密码的 Hash 值和数据库中保存的 Hash 值作比对就好，网站无需知道用户的密码。这样，当网站数据失窃时，用户不会因为自己的密码被盗导致 其他网站的安全也受到威胁。\n\n\u003cstrong\u003e注意：这不属于加密。\u003c/strong\u003e\n\n### Hash \u003cstrong\u003e是编码吗?\u003c/strong\u003e\n\n不是。 Hash 是单向过程，往往是不可逆的，无法进行逆向恢复操作，因此 Hash 不属于编码。\n\n### Hash \u003cstrong\u003e是加密吗?\u003c/strong\u003e\n\n不是。Hash 是单向过程，无法进行逆向回复操作，因此 Hash 不属于加密。(MD5 也不是加密!)\n\n## \u003cstrong\u003e字符集\u003c/strong\u003e\n\n### \u003cstrong\u003e含义\u003c/strong\u003e\n\n一个由整数向现实世界中的文字符号的 Map\n\n### \u003cstrong\u003e分支\u003c/strong\u003e\n\nASCII：128 个字符，1 字节 ISO-8859-1:对 ASCII 进行扩充，1 字节\n\nUnicode：13 万个字符，多字节\n\nUTF-8：Unicode 的编码分支\n\nUTF-16：Unicode 的编码分支\n\nGBK / GB2312 / GB18030：中国自研标准，多字节，字符集 + 编码\n","lastmodified":"2023-04-21T14:55:33.037222465Z","tags":["编码","加密","Hash","序列化","字符集"]},"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84TCPIP-%E5%92%8C-HTTPS":{"title":"计算机网络体系结构、TCP\u0026IP 和 HTTPS","content":"# 为什么需要计算机网络体系结构？\n\n计算机网络是个非常复杂的系统。比如，连接在网络上的两台计算机需要进行通信时，由于计算机网络的复杂性和异质性，需要考虑很多复杂的因素，比如：\n\n1. 这两台计算机之间必须有一条传送数据的通路；\n2. 告诉网络如何识别接收数据的计算机；\n3. 发起通信的计算机必须保证要传送的数据能在这条通路上正确发送和接收；\n4. 对出现的各种差错和意外事故，如数据传送错误、网络中某个节点交换机出现故障等问题，应该有可靠完善的措施保证对方计算机最终能正确收到数据。\n\n计算机网络体系结构标准的制定正是为了解决这些问题，要想完成这种网络通信就必须保证相互通信的这两个计算机系统达成\u003cstrong\u003e高度默契\u003c/strong\u003e。事实上，在网络通信领域，两台计算机(网络设备)之间的通信并不像人与人之间的交流那样自然天然，这种计算机间高度默契的交流(通信) 背后需要十分复杂、完备的网络体系结构作为支撑。那么，用什么方法才能合理地组织网络的结构，以保证其具有结构清晰、设计与实现简化、便于更新和维护、较强的独立性和适应性，从而使网络设备之间具有这种 “高度默契” 呢？答案是分而治之，更进一步地说就是\u003cstrong\u003e分层思想\u003c/strong\u003e。\n\n# 计算机网络体系结构设计基本思想\n\n## 分层思想在日常生活中的应用\n\n在快递系统中，用户和用户之间的通信依赖于下层的服务，但是他们并不需要关心快递、运输等细节，也就是说，寄信者只需将写好的信交给快递员而收信者只需从快递员手中查收信件即可。类似地，快递员也只需要从寄信人手中拿到信件并交给分检员或将信件从分检员手中拿走并交给收信人即可，至于分检员为何要把这份信交给他进行投递(事实上，每个快递员会负责某个片区，分检员根据收信人地址将信件分发给不同的快递员)，他不需要关心也没必要关心。显然，在这个快递系统中，各个角色（用户、快递员…）在功能上相互独立却又能协调合作达成一种 “高度默契”，这在很大程度上得益于分层思想的理念和应用。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031033.png)\n\n## 分层思想的优点\n\n1. 耦合度低(独立性强)。上层只需通过下层为上层提供的接口来使用下层所实现的服务，而不需要关心下层的具体实现。也就是说，下层对上层而言就是具有一定功能的黑箱。\n2. 适应性强。只要每层为上层提供的服务和接口不变，每层的实现细节可以任意改变。\n3. 易于实现和维护。把复杂的系统分解成若干个涉及范围小且功能简单的子单元，从而使得系统结构清晰，实现、调试和维护都变得简单和容易。也就是说，对于设计/开发人员而言，这种方法使设计/开发人员能够专心设计和开发他们所关心的功能模块；对于调试/维护人员而言，这种方法也方便调试/维护人员去处理他们所负责的功能模块。\n\n# 计算机网络体系结构的概念与标准\n\n## 计算机网络体系结构的概念\n\n计算机网络体系结构必须包括三个内容，即分层结构与每层的功能，服务与层间接口和协议。所以，计算机网络体系结构的定义为：\u003cstrong\u003e在计算机网络中，层、层间接口及协议的集合。\u003c/strong\u003e\n\n## 计算机网络体系结构的标准\n\n目前，由国际化标准组织 ISO 制定的网络体系结构国际标准是 OSI 七层模型，但实际中应用最广泛的是 TCP/IP 体系结构。换句话说，OSI 七层模型只是理论上的、官方制定的国际标准，而\u003cstrong\u003eTCP/IP 体系结构才是事实上的国际标准\u003c/strong\u003e。这看起来是不可理喻的，但这却是实际存在的，这是由一些历史原因造成的。OSI 标准的制定者以专家、学者为主，他们缺乏实际经验和商业驱动力，并且 OSI 标准自身运行效率也不怎么好。与此同时，由于 Inernet 在全世界覆盖了相当大的范围，并且占领市场的标准是 TCP/IP 体系结构，因此导致 OSI 标准没有市场背景，也就只是理论上的成果，并没有过多地应用于实践。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031041.png)\n\n# TCP/IP 四层体系结构\n\nTCP/IP 是 Internet 上的标准通信协议集，该协议集由数十个具有层次结构的协议组成，其中 TCP 和 IP 是该协议集中的两个最重要的核心协议。TCP/IP 协议族按层次可分为以下四层：应用层、传输层、网络层和网络接口层，各层对应的 PDU 数据单元的名称如下图所示。\n\n\u003cdiv style=\"text-align: center\"\u003e\u003c/div\u003e\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031045.png)\n\n计算机网络体系结构中，对等层之间交换的信息报文统称为\u003cstrong\u003e协议数据单元（Protocol Data Unit）\u003c/strong\u003e。PDU 由\u003cstrong\u003e协议控制信息（协议头）\u003c/strong\u003e和\u003cstrong\u003e数据（SDU） \u003c/strong\u003e组成。\n\n数据封装过程：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031049.png)\n\n## 应用层\n\n应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务，比如 FTP（文件传输协议）和 DNS（域名系统）服务就是其中两类，HTTP 协议也处于该层。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031057.png)\n\n## 传输层\n\n传输层对上层应用层提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（传输控制协议）和 UDP（用户数据报协议）。其中，TCP 是\u003cstrong\u003e面向连接\u003c/strong\u003e的传输协议，也就是说，其在数据传输之前会建立连接，并把报文分解为多个段进行传输，在目的站再重新装配这些段，必要时重新传输没有收到或错误的，因此它是“可靠”的。而 UDP 是\u003cstrong\u003e无连接\u003c/strong\u003e的传输协议，其在数据传输之前不建立连接，并且对发送的段不进行校验和确认，因此它是“不可靠”的。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031101.png)\n\n## 网络层（网际层）\n\n网络层用来处理在网络上流动的数据包，其中，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。也就是说，网络层主要功能是把数据报通过最佳路径送到目的端，其中，网际层的核心协议——IP，提供了无连接的数据报传输服务(不保证送达，不保序）。\n\n## 网络接口层\n\n网络接口层用来处理连接网络的硬件部分，包括硬件的设备驱动、NIC（Network Interface Card，网卡）及光纤等物理可见部分，还包括连接器等一切传输媒介。也就是说，硬件上的范畴均在链路层的作用范围之内。\n\n# TCP 连接过程\n\n## 三次握手\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031105.png)\n\n1. 客户端发送的 TCP 报文中标志位 SYN 置 1，初始序号 seq=x（随机选择）。Client 进入 SYN_SENT 状态，等待 Server 确认。\n2. 服务器收到数据包后，根据标志位 SYN=1 知道 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，ack=x+1，随机产生一个初始序号 seq=y，并将该数据包发送给 Client 以确认连接请求，Server 进入 SYN_RCVD 状态。\n3. Client 收到确认后，检查 ack 是否为 x+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ack=y+1，并将该数据包发送给 Server。Server 检查 ack 是否为 y+1，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。\n\n## 四次挥手\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031108.png)\n\n1. Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态。\n2. Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为 u + 1（与 SYN 相同，一个 FIN 占用一个序号），Server 进入 CLOSE_WAIT 状态。\n3. Server 发送一个 FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。\n4. Client 收到 FIN 后，Client 进入 TIME_WAIT 状态(主动关闭方才会进入该状态）；接着发送一个 ACK 给 Server，确认序号为 w + 1，Server 进入 CLOSED 状态；Client 进入 TIME_WAIT 状态等待 2 MSL(Maximum Segment Lifetime，最大报文生存时间) 后进入 CLOSED 状态。\n\n## 各个符号的含义\n\nACK、SYN 和 FIN 这些大写的单词表示标志位，其值要么是 1，要么是 0；ack、seq 由小写的单词表示序号。\n\n- 序列号 seq：占 4 个字节，用来标记数据段的顺序，TCP 把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生。给字节编上序号后，就给每一个报文段指派一个序号，序列号 seq 就是这个报文段中的第一个字节的数据编号。\n- 确认号 ack：占 4 个字节，表示\u003cstrong\u003e期待收到对方下一个报文段的第一个数据字节的序号\u003c/strong\u003e；因此当前报文段最后一个字节的编号 +1 即为确认号。\n- 确认 ACK：占 1 位，仅当 ACK=1 时，确认号字段才有效。\u003cstrong\u003eACK 报文不需要回复\u003c/strong\u003e。\n- 同步 SYN：连接建立时用于同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若同意连接，则在响应报文段中使得 SYN=1，ACK=1。因此，SYN=1 表示这是一个连接请求，或连接接受报文。SYN 这个标志位只有在 TCP 建产连接时才会被置 1，握手完成后 SYN 标志位被置 0。\u003cstrong\u003eSYN 报文需要回复\u003c/strong\u003e。\n- 终止 FIN：用来释放一个连接。FIN=1 表示此报文段的发送方的数据已经发送完毕，并要求释放运输连接。\u003cstrong\u003eFIN \u003c/strong\u003e\u003cstrong\u003e报文也需要回复\u003c/strong\u003e。\n\n# HTTPS\n\nHTTP over SSL 的简称，即⼯作在 SSL/TLS 上的 HTTP。服务端和客户端的信息传输都会通过 SSL/TLS 进行加密，所以传输的数据都是加密后的数据。它的工作原理是在客户端和服务器之间利用非堆成加密，协商出⼀套对称加密的密钥，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输。\n\nTLS 的前身是 SSL，SSL 1.0 建立在 SSL 3.0 协议规范之上，是 SSL 3.0 的后续版本。TLS 目前最新版本为 TLS 1.2。TLS 和 SSL 协议理论上属于传输层，在应用层实现。\n\n## 为什么需要 HTTPS？\n\nHTTP 使用明文传输，面临的风险有：\n\n1. 窃听风险：黑客可以获知通信内容；\n2. 黑客可以修改通信内容；\n3. 黑客可以冒充他人身份参与通信。\n\n为此，HTTPS 具有以下特点：\n\n1. 所有信息都是加密传播，第三方无法窃听；\n2. 具有校验机制，一旦被篡改，通信双方会立刻发现；\n3. 配备身份证书，防止身份被冒充。\n\n## SSL/TLS 连接建立的过程\n\nSSL/TLS 通讯同样需要先要进行“握手”，即客户端向服务器端索要并验证公钥，然后通过非对称加密双方协商生成“对话密钥“。“握手”阶段涉及四次通信，需要注意的是，”握手”阶段的所有通信都是明文的。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/TCP%26IP/clipboard_20230323_031114.png)\n\n### \u003cstrong\u003e第一步：客户端发出请求\u003c/strong\u003e\n\n首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello 请求。\n\n在这一步，客户端主要向服务器提供以下信息。\n\n1. 支持的协议版本，比如 TLS 1.0 版。\n2. 一个客户端生成的随机数，稍后用于生成“对话密钥”。\n3. 支持的加密方法，比如 RSA 公钥加密。\n4. 支持的压缩方法。\n\n### \u003cstrong\u003e第二步：服务器回应\u003c/strong\u003e\n\n服务器收到客户端请求后，向客户端发出回应，这叫做 ServerHello。服务器的回应包含以下内容。\n\n1. 确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。\n2. 一个服务器生成的随机数，稍后用于生成“对话密钥”。\n3. 确认使用的加密方法，比如 RSA 公钥加密。\n4. 服务器证书。\n\n除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供“客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供 USB 密钥，里面就包含了一张客户端证书。\n\n### \u003cstrong\u003e第三步：客户端回应\u003c/strong\u003e\n\n客户端收到服务器回应以后，首先验证服务器证书。如果证书不合法\u003cstrong\u003e，\u003c/strong\u003e就会向访问者显示一个警告，由其选择是否还要继续通信。\n\n1）验证域名、有效期等信息是否正确：证书上都有包含这些信息，比较容易完成验证；\n\n2）判断证书来源是否合法：每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；\n\n3）判断证书是否被篡改：需要与 CA 服务器进行校验；\n\n4）判断证书是否已吊销：通过 CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第 3 步中以减少与 CA 服务器的交互，提高验证效率。\n\n如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。\n\n1. 一个随机数。该随机数用服务器公钥加密，防止被窃听。\n2. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的\u003cstrong\u003e所有内容的 hash 值\u003c/strong\u003e，用来供服务器校验。\n\n上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称“pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，用这三个随机数各自生成本次会话所用的“会话密钥”。\n\n### \u003cstrong\u003e第四步：服务器的最后回应\u003c/strong\u003e\n\n服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的“会话密钥”。然后，向客户端最后发送下面信息。\n\n1. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。\n\n至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用“会话密钥”加密内容。\n\n# 面试题\n\n## 为什么需要第三次握手?\n\nTCP 连接是可靠的双工通信，在连接建立阶段必须确认双向通信都是 OK 的。理论上来讲这需要至少四次交互：\n\n1. Client 发送 SYN；\n2. Server 响应 ACK；\n3. Server 发送 SYN；\n4. Client 响应 ACK (如果没有这一步，Server 无法知道 Client 能否收到自己的消息）。\n\n1、2 两步让 Client 知道自己和 Server 之间的双向通信是 OK 的；3、4 两步让 Server 知道自己和 Client 之间的双向通信是 OK 的。实际应用中，2、3 两步合并了，所以最终就只有三次握手。\n\n三次握手还可以解决\u003cstrong\u003e网络中延迟的重复分组问题\u003c/strong\u003e。假设 TC 连接建立过程只有两次握手：\n\n1. Client 发送 SYN\n2. Server 响应 ACK\n\n如果没有第三次握手，出现下面的情况，服务端可能会出现如下问题：\n\n1. Client 发送 SYN；\n2. Client 端超时未收到 Server 的 ACK，重发 SYN；\n3. Server 端收到 Client 重发的 SYN，响应 ACK；\n4. Client 收到 ACK 后，和 Server 正常数据交互，然后关闭连接；\n5. Client 第一次发送的 SYN 并未丢失，而是由于网络延迟，现在才到达 Server 端；\n6. Server 发送 ACK（Server 认为 TCP 连接已建立）；\n7. Client 收到 Server 的 ACK，由于 Client 认为自己并未请求连接，所以会忽略该 ACK（ACK 报文不需要回复）；\n8. 这时 Server 认为连接已经建立，一直等待客户端数据，而客户端却根本不知道有这么一条连接。\n\n## 收到服务器端的连接释放报文段之后，客户端还要继续等待 2MSL 之后才关闭 TCP 连接呢？\n\n- \u003cstrong\u003e为了保证主动关闭方发送的最后一个 ACK 报文能够到达被动关闭方\u003c/strong\u003e。因为这个 ACK 有可能无法到达对端，这样对端会重发 FIN 报文，这时候主动关闭方需要重发 ACK。\n- \u003cstrong\u003e保证本连接的所有报文在网络上消失\u003c/strong\u003e。如果没有这个机制，可能会对新连接产生干扰。举例如下：\n\n  1. A 和 B 正常建立 TCP 连接，数据传输，然后断开连接。但是由于网络传输原因，A 发给 B 的 seq 为 100 的报文滞留在了网络上。\n  2. A 和 B 再次建立连接，所用 IP 和端口与上一步中相同，二者数据传输过程中，B 正好请求 A 发送 seq 为 100 的数据，这时上一步中滞留的报文到达 B，TCP 认为该报文合法，就接收了这个报文。\n\n## 为什么 TCP 释放连接需要四次？\n\nTCP 连接是全双工的，因此每个方向都必须单独进行关闭：当一方完成它的数据发送任务后就发送一个 FIN 来终止这个方向的连接，对端收到后回复一个 ACK 报文，这样双向就需要四次交互。\n\nClient 主动关闭的情况下，Server 收到 Client 的 FIN 报文时，仅仅表示 Client 没有数据发送给 Server 了；但 Server 可能还有数据要发送给 Client，所以 Server 可能并不会立即关闭 SOCKET，而是先回复一个 ACK 报文，告诉 Client“你发的 FIN 报文我收到了”。只有等到 Server 所有的报文都发送完了，才发送 FIN 报文。也就是说，被动关闭方的 ACK 和 FIN 报文多数情况下都是分开发送的，所以需要四次交互。\n","lastmodified":"2023-04-21T14:55:33.037222465Z","tags":["计算机网络","TCP/IP","HTTPS","三次握手","四次挥手"]},"/%E8%AF%8D%E6%80%A7":{"title":"词性","content":"1，及物动词： 字典里词后标有vt. 的就是及物动词。及物动词后一般必须跟有动作的对象（即宾语）。必须加宾语意思才完整的动词，就是及物动词。\n\n2，不及物动词：不及物动词是不需要受词的动词。字典里词后标有vi. 的就是不及物动词。不及物动词后不能直接跟有动作的对象（即宾语）。若要跟宾语，必须先在其后添加上某个介词，如to,of ,at后方可跟上宾语。\n\n3，名词，Nouns (n.) 表示人或事物的名称 box, pen,tree,apple\n\n4，代词，Pronouns (pron.)代替名词、数词、形容词We, this, them,myself\n\n5，形容词， Adjectives(adj.) 用来修饰名词，表示人或事物的特征 good, sad, high, short\n\n6，数词，Numerals(num.)表示数目或顺序 one,two, first\n\n7，动词，Verb (v.) 表示动作或状态 Jump,sing,visit\n\n8，副词，Adverbs（adv.) 修饰动、形、副等词，表示动作特征 there,widely,suddenly\n\n9，冠词，Articles (art.) 用在名词前，帮助说明名词所指的范围 a, an, the\n\n10，介词，Prepositions (prep.) 用在名词或代词前，说明它与别的词的关系 in,on,down,up\n\n11，连词，Conjunctions (conj.) 表示人或事物的名称if,because,but\n\n12，感叹词， Interjections (int.) 代替名词、数词、形容词等 oh,hello,hi,yeah","lastmodified":"2023-04-21T14:55:32.605227307Z","tags":[]},"/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D":{"title":"遍历文件、重命名","content":"```Python\nimport os,re\n\ndef traversal_files1(path):\n    for root, dirs, files in os.walk(path, topdown=False):\n        f = os.path.join(root, name)\n        for name in files:\n            print(f)\n        for name in dirs:\n            print(f)\n\ndef traversal_files(root):\n    for lists in os.listdir(root):\n        f = os.path.join(root, lists)\n        if os.path.isdir(f):\n            #字符串查找\n            if f.find('(更多IT教程-微信634631778)') != -1:\n                print(f)\n                #字符串替换\n                newname  = f.replace('(更多IT教程-微信634631778)', '')\n                print(newname)\n                #文件重命名\n                os.rename(f, newname)\n                traversal_files(newname)\n            else:\n                traversal_files(f)\n        else:\n            #正则表达式匹配\n            pattern = re.compile('(更多IT教程 微信634631778)')\n            if pattern.search(f):\n                print(f)\n                newname  = f.replace('(更多IT教程 微信634631778)', '')\n                print(newname)\n                os.rename(f, newname)\n\nif __name__ == '__main__':\n    path = 'G:\\course\\imooc'\n    # path = '/Users/Jie/Desktop/Course'\n    traversal_files(path)\n```","lastmodified":"2023-04-21T14:55:32.613227217Z","tags":[]},"/%E9%94%81":{"title":"锁","content":"# 锁的分类\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Lock/clipboard_20230323_094809.png)\n\n## 偏向锁/轻量级锁/重量级锁\n\nJava SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6 中，锁一共有 4 种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级但不能降级。\n\n这些状态被记录在对象头中的 mark word 中。\n\n### \u003cstrong\u003e偏向锁\u003c/strong\u003e\n\n如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。\n\n### \u003cem\u003e轻量级锁\u003c/em\u003e\n\nJVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。\n\n### \u003cem\u003e重量级锁\u003c/em\u003e\n\n重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。\n\n### \u003cstrong\u003e对比\u003c/strong\u003e\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Lock/clipboard_20230323_094817.png)\n\n## 可重入锁/非可重入锁\n\n可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。同理，不可重入锁指的是虽然线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。\n\n对于可重入锁而言，最典型的就是 ReentrantLock 了，正如它的名字一样，reentrant 的意思就是可重入，它也是 Lock 接口最主要的一个实现类。synchronized 锁也属于可重入锁。\n\n## 共享锁/独占锁（排他锁）\n\n共享锁指的是我们同一把锁可以被多个线程同时获得；而独占锁（排他锁）指的就是，这把锁只能同时被一个线程获得。读写锁就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。\n\n## 公平锁/非公平锁\n\n### \u003cem\u003e概念\u003c/em\u003e\n\n公平锁之公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。而非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。\n\n那么什么“一定情况下”呢？假设当前线程在请求获取锁的时候，恰巧前一个持有锁的线程释放了这把锁，那么当前申请锁的线程就可以不顾已经等待的线程而选择立刻插队。但是如果当前线程请求的时候，前一个线程并没有在那一时刻释放锁，那么当前线程还是一样会进入等待队列。\n\n### \u003cem\u003e原理\u003c/em\u003e\n\n分析公平和非公平锁的源码，具体看下它们是怎样实现的：\n\n```java\npublic class ReentrantLock implements Lock,   \n        java.io.Serializable {\n    ...\n    //ReentrantLock 类包含一个 Sync 类的成员变量\n    private final Sync sync;\n    ...\n}\n\n//Sync 类的定义\nabstract static class Sync extends AbstractQueuedSynchronizer {...}\n\n//Sync 有公平锁 FairSync 和非公平锁 NonfairSync两个子类\nstatic final class NonfairSync extends Sync {...}\nstatic final class FairSync extends Sync {...}\n\n//公平锁与非公平锁的加锁方法\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (!hasQueuedPredecessors() \u0026\u0026 //只有公平锁在这里判断了队列是否为空\n                compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    } else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc \u003c 0) {\n            throw new Error(\"Maximum lock count exceeded\");\n        }\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取锁时多了一个限制条件：hasQueuedPredecessors() 为 false，这个方法就是判断在等待队列中是否已经有线程在排队了。这也就是公平锁和非公平锁的核心区别。\n\n\u003cstrong\u003e如果是公平锁，那么一旦已经有线程在排队了，当前线程就不再尝试获取锁；对于非公平锁而言，无论是否已经有线程在排队，都会尝试获取一下锁，获取不到的话，再去排队。\u003c/strong\u003e\n\n### \u003cem\u003e对比\u003c/em\u003e\n\n| 类型     | 优点                                               | 缺点                                           |\n| -------- | -------------------------------------------------- | ---------------------------------------------- |\n| 公平锁   | 各线程公平竞争，每个线程等待一段时间后都有机会执行 | 更慢，吞入量更小                               |\n| 非公平锁 | 更快，吞吐量更大                                   | 有可能产生饥饿，某些线程可能始终得不到机会执行 |\n\n## 悲观锁/乐观锁\n\n### 概念\n\n悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。而乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。\n\nJava 中悲观锁的实现包括 synchronized 关键字和 Lock 相关类等，我们以 Lock 接口为例，例如 Lock 的实现类 ReentrantLock，类中的 lock() 等方法就是执行加锁，而 unlock() 方法是执行解锁。处理资源之前必须要先加锁并拿到锁，等到处理完了之后再解开锁，这就是非常典型的悲观锁思想。\n\n乐观锁的典型案例就是原子类，例如 AtomicInteger 在更新数据时，就使用了乐观锁的思想，多个线程可以同时操作同一个原子变量。\n\n### 对比\n\n| 类型   | 优点                                             | 缺点                                                                           | 使用场景                                                                                                       |\n| ------ | ------------------------------------------------ | ------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------- |\n| 乐观锁 | 开销比较锁小                                     | 如果一直拿不到锁，或者并发量大，竞争激烈，导致不停重试，消耗的资源也会越来越多 | 大部分是读取，少部分是修改，或者虽然读写都很多，但是并发并不激烈的场景下，乐观锁不加锁的特点能让性能大幅提高。 |\n| 悲观锁 | 开销固定，就算一直拿不到锁，也不会造成额外的影响 | 操作比较重量级，不能多个线程并行执行，还会有上下文切换等动作造成性能问题       | 并发写入多、临界区代码复杂、竞争激烈等场景，可以避免大量的无用的反复尝试等消耗。                               |\n\n## 自旋锁/非自旋锁\n\n自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。\n\n相反，非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。\n\n## 自旋的利与弊\n\n首先，阻塞和唤醒线程都是需要高昂的开销的，如果同步代码块中的内容不复杂，那么可能转换线程带来的开销比实际业务代码执行的开销还要大。\n\n在很多场景下，同步代码块的内容并不多，所以需要的执行时间也很短，如果仅仅为了这点时间就去切换线程状态，那么其实不如让线程不切换状态，而是让它自旋地尝试获取锁，等待其他线程释放锁，有时只需要稍等一下，就可以避免上下文切换等开销，提高了效率。\n\n用一句话总结自旋锁的好处，那就是自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。\n\n它最大的缺点就在于虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。\n\n### 适用场景\n\n首先，自旋锁适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。\n\n如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。\n\n## 可中断锁/不可中断锁\n\n在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。\n\n# synchronized 实现原理\n\n## 同步代码块\n\n每个 Java 对象都可以用作一个实现同步的锁，这个锁也被称为内置锁或 monitor 锁，获得 monitor 锁的唯一途径就是进入由这个锁保护的同步代码块或同步方法，线程在进入被 synchronized 保护的代码块之前，会自动获取锁，并且无论是正常路径退出，还是通过抛出异常退出，在退出的时候都会自动释放锁。\n\n举个例子，当使用 synchronized 关键字修饰代码块的时候：\n\n```java\npublic class SynTest {\n    public void synBlock() {\n        synchronized (this) {\n            System.out.println(\"abc\");\n        }\n    }\n}\n```\n\n生成的字节码经过反汇编后如下：\n\n```java\npublic void synBlock();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: aload_0\n         1: dup\n         2: astore_1\n         3: monitorenter\n         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         7: ldc           #3                      // String abc\n         9: invokevirtual #4               // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        12: aload_1\n        13: monitorexit\n        14: goto          22\n        17: astore_2\n        18: aload_1\n        19: monitorexit\n        20: aload_2\n        21: athrow\n        22: return\n```\n\n从里面可以看出，synchronized 代码块上多了 monitorenter 和 monitorexit 指令（第 3、13、19 行）。这里有一个 monitorenter，却有两个 monitorexit 指令的原因是，JVM 要保证每个 monitorenter 必须有与之对应的 monitorexit，monitorenter 指令被插入到同步代码块的开始位置，而 monitorexit 需要插入到方法正常结束处和异常处两个地方，这样就可以保证抛异常的情况下也能释放锁。\n\n可以把执行 monitorenter 理解为加锁，执行 monitorexit 理解为释放锁，每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为 0，具体的含义如下：\n\n\u003cstrong\u003emonitorenter\u003c/strong\u003e\n\n执行 monitorenter 的线程尝试获得 monitor 的所有权，会发生以下这三种情况之一：\n\n1. 如果该 monitor 的计数为 0，则线程获得该 monitor 并将其计数设置为 1。然后，该线程就是这个 monitor 的所有者。\n2. 如果线程已经拥有了这个 monitor ，则它将重新进入，并且累加计数。\n3. 如果其他线程已经拥有了这个 monitor，那个这个线程就会被阻塞，直到这个 monitor 的计数变成为 0，代表这个 monitor 已经被释放了，于是当前这个线程就会再次尝试获取这个 monitor。\n\n\u003cstrong\u003emonitorexit\u003c/strong\u003e\n\nmonitorexit 的作用是将 monitor 的计数器减 1，直到减为 0 为止。代表这个 monitor 已经被释放了，已经没有任何线程拥有它了，也就代表着解锁，所以，其他正在等待这个 monitor 的线程，此时便可以再次尝试获取这个 monitor 的所有权。\n\n## 同步方法\n\n从上面可以看出，同步代码块是使用 monitorenter 和 monitorexit 指令实现的。而对于 synchronized 方法，它的实现不太相同。\n\n同步方法使用示例：\n\n```java\npublic synchronized void synMethod() {\n  ...\n}\n```\n\n对应的汇编指令如下：\n\n```java\npublic synchronized void synMethod();\n    descriptor: ()V\n    flags: ACC_PUBLIC, ACC_SYNCHRONIZED\n    Code:\n      stack=0, locals=1, args_size=1\n         0: return\n      LineNumberTable:\n        line 16: 0\n```\n\n对比前面使用 synchronized 代码块生成的汇编指令，可以看出，被 synchronized 修饰的方法会有一个 ACC_SYNCHRONIZED 标志。当某个线程要访问某个方法的时候，会首先检查方法是否有 ACC_SYNCHRONIZED 标志，如果有则需要先获得 monitor 锁，然后才能开始执行方法，方法执行之后再释放 monitor 锁。其他方面， synchronized 方法和刚才的 synchronized 代码块是很类似的，例如这时如果其他线程来请求执行方法，也会因为无法获得 monitor 锁而被阻塞。\n\n# Lock 类\n\n## 简介\n\nLock 接口是 Java 5 引入的，最常见的实现类是 ReentrantLock，可以起到“锁”的作用。\n\n通常情况下，Lock 只允许一个线程来访问这个共享资源。不过有的时候，一些特殊的实现也可允许并发访问，比如 ReadWriteLock 里面的 ReadLock。\n\n## 方法纵览\n\nLock 接口的各个方法，如代码所示。\n\n```java\npublic interface Lock {\n    void lock();\n    void lockInterruptibly() throws InterruptedException;\n    boolean tryLock();\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n    void unlock();\n    Condition newCondition();\n}\n```\n\n### lock()\n\n首先，lock() 是最基础的获取锁的方法。在线程获取锁时如果锁已被其他线程获取，则进行等待，是最初级的获取锁的方法。\n\n对于 Lock 接口而言，获取锁和释放锁都是显式的，不像 synchronized 那样是隐式的，所以 Lock 不会像 synchronized 一样在异常时自动释放锁（synchronized 即使不写对应的代码也可以释放），lock 的加锁和释放锁都必须以代码的形式写出来，所以使用 lock() 时必须由我们自己主动去释放锁，因此最佳实践是执行 lock() 后，首先在 try{} 中操作同步资源，如果有必要就用 catch{} 块捕获异常，然后在 finally{} 中释放锁，以保证发生异常时锁一定被释放，示例代码如下所示。\n\n```java\nLock lock = ...;\nlock.lock();\ntry {\n    //获取到了被本锁保护的资源，处理任务\n    //捕获异常\n} finally {\n    lock.unlock();   //释放锁\n}\n```\n\n一定不要忘记在 finally 中添加 unlock() 方法，以便保障锁的绝对释放。\n\n如果不遵守在 finally 里释放锁的规范，就会让 Lock 变得非常危险，因为你不知道未来什么时候由于异常的发生，导致跳过了 unlock() 语句，使得这个锁永远不能被释放了，其他线程也无法再获得这个锁。\n\n与此同时，lock() 方法不能被中断，这会带来很大的隐患：一旦陷入死锁，lock() 就会陷入永久等待，所以一般我们用 tryLock() 等其他更高级的方法来代替 lock()，下面我们就看一看 tryLock() 方法。\n\n### tryLock()\n\ntryLock() 用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回 true，否则返回 false，代表获取锁失败。相比于 lock()，这样的方法显然功能更强大，我们可以根据是否能获取到锁来决定后续程序的行为。\n\n因为该方法会立即返回，即便在拿不到锁时也不会一直等待，所以通常情况下，我们用 if 语句判断 tryLock() 的返回结果，根据是否获取到锁来执行不同的业务逻辑，典型使用方法如下。\n\n```java\nLock lock = ...;\nif (lock.tryLock()) {\n     try {\n         //处理任务\n     } finally {\n         lock.unlock();   //释放锁\n     } \n} else {\n    //如果不能获取锁，则做其他事情\n}\n```\n\n如果 if 语句返回 false 就会进入 else 语句，代表它暂时不能获取到锁，可以先去做一些其他事情，比如等待几秒钟后重试，或者跳过这个任务，有了这个强大的 tryLock() 方法我们便可以解决死锁问题。\n\n### tryLock(long time, TimeUnit unit)\n\ntryLock() 的重载方法是 tryLock(long time, TimeUnit unit)，这个方法和 tryLock() 很类似，区别在于 tryLock(long time, TimeUnit unit) 方法会有一个超时时间，在拿不到锁时会等待一定的时间，如果在时间期限结束后，还获取不到锁，就会返回 false；如果一开始就获取锁或者等待期间内获取到锁，则返回 true。\n\n这个方法解决了 lock() 方法容易发生死锁的问题，使用 tryLock(long time, TimeUnit unit) 时，在等待了一段指定的超时时间后，线程会主动放弃这把锁的获取，避免永久等待；在等待的期间，也可以随时中断线程，这就避免了死锁的发生。\n\n### lockInterruptibly()\n\n这个方法的作用也是去获取锁，如果这个锁当前是可以获得的，那么这个方法会立刻返回，但是如果这个锁当前是不能获得的（被其他线程持有），那么当前线程便会开始等待，除非它等到了这把锁或者是在等待的过程中被中断了，否则这个线程便会一直在这里执行这行代码。一句话总结就是，除非当前线程在获取锁期间被中断，否则便会一直尝试获取直到获取到为止。\n\n顾名思义，lockInterruptibly() 是可以响应中断的。相比于不能响应中断的 synchronized 锁，lockInterruptibly() 可以让程序更灵活，可以在获取锁的同时，保持对中断的响应。我们可以把这个方法理解为超时时间是无穷长的 tryLock(long time, TimeUnit unit)，因为 tryLock(long time, TimeUnit unit) 和 lockInterruptibly() 都能响应中断，只不过 lockInterruptibly() 永远不会超时。\n\n这个方法本身是会抛出 InterruptedException 的，所以使用的时候，如果不在方法签名声明抛出该异常，那么就要写两个 try 块，如下所示。\n\n```java\npublic void lockInterruptibly() {\n    try {\n        lock.lockInterruptibly();\n        try {\n            System.out.println(\"操作资源\");\n        } finally {\n            lock.unlock();\n        }\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n在这个方法中我们首先执行了 lockInterruptibly() 方法，并且对它进行了 try catch 包装，然后同样假设我们能够获取到这把锁，和之前一样，就必须要使用 try finall 来保障锁的绝对释放。\n\n### unlock()\n\n最后要介绍的方法是 unlock() 方法，是用于解锁的，此方法比较简单，对于 ReentrantLock 而言，执行 unlock() 的时候，内部会把锁的“被持有计数器”减 1，直到减到 0 就代表当前这把锁已经完全释放了，如果减 1 后计数器不为 0，说明这把锁之前被“重入”了，那么锁并没有真正释放，仅仅是减少了持有的次数。\n\n### newCondition()\n\nCondition 接口也提供了类似 Object 的监视器方法，与 Lock 配合可以实现等待/通知模式。\n\n假设线程 1 需要等待某些条件满足后，才能继续运行，这个条件会根据业务场景不同，有不同的可能性，比如等待某个时间点到达或者等待某些任务处理完毕。在这种情况下，可以执行 Condition 的 await 方法，一旦执行了该方法，这个线程就会进入 WAITING 状态。\n\n通常会有另外一个线程，我们把它称作线程 2，它去达成对应的条件，直到这个条件达成之后，那么，线程 2 调用 Condition 的 signal 方法 [或 signalAll 方法]，代表“这个条件已经达成了，之前等待这个条件的线程现在可以苏醒了”。这个时候，JVM 就会找到等待该 Condition 的线程，并予以唤醒，根据调用的是 signal 方法或 signalAll 方法，会唤醒 1 个或所有的线程。于是，线程 1 在此时就会被唤醒，然后它的线程状态又会回到 Runnable 可执行状态。\n\n```java\npublic class ConditionDemo {\n    private ReentrantLock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    void method1() throws InterruptedException {\n        lock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName()+\":条件不满足，开始await\");\n            condition.await();\n            System.out.println(Thread.currentThread().getName()+\":条件满足了，开始执行后续的任务\");\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    void method2() throws InterruptedException {\n        lock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName()+\":需要5秒钟的准备时间\");\n            Thread.sleep(5000);\n            System.out.println(Thread.currentThread().getName()+\":准备工作完成，唤醒其他的线程\");\n            condition.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args)\n                throws InterruptedException {\n        ConditionDemo conditionDemo = new ConditionDemo();\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    conditionDemo.method2();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n        conditionDemo.method1();\n    }\n}\n\n输出结果：\nmain:条件不满足，开始 await\nThread-0:需要 5 秒钟的准备时间\nThread-0:准备工作完成，唤醒其他的线程\nmain:条件满足了，开始执行后续的任务\n```\n\n- \u003cstrong\u003emethod1\u003c/strong\u003e，它代表主线程将要执行的内容，首先获取到锁，打印出“条件不满足，开始 await”，然后调用 condition.await() 方法，直到条件满足之后，则代表这个语句可以继续向下执行了，于是打印出“条件满足了，开始执行后续的任务”，最后会在 finally 中解锁。\n- \u003cstrong\u003emethod2\u003c/strong\u003e，它同样也需要先获得锁，然后打印出“需要 5 秒钟的准备时间”，接着用 sleep 来模拟准备时间；在时间到了之后，则打印出“准备工作完成”，最后调用 condition.signal() 方法，把之前已经等待的线程唤醒。\n\n# 读写锁\n\n在没有读写锁之前，假设使用普通的 ReentrantLock，那么虽然保证了线程安全，但是也浪费了一定的资源，因为如果多个读操作同时进行，其实并没有线程安全问题，可以允许让多个读操作并行，以便提高程序效率。\n\n但是写操作不是线程安全的，如果多个线程同时写，或者在写的同时进行读操作，便会造成线程安全问题。\n\n读写锁就解决了这样的问题，它设定了一套规则，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。\n\n\u003cstrong\u003e使用读写锁时遵守下面的获取规则\u003c/strong\u003e\n\n- 如果有一个线程已经占用了读锁，则此时其他线程如果要申请读锁，可以申请成功。\n- 如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁，因为读写不能同时操作。\n- 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，都必须等待之前的线程释放写锁，同样也因为读写不能同时，并且两个线程不应该同时写。\n\n用一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。也可以总结为：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥）。\n\n## \u003cstrong\u003e使用示例\u003c/strong\u003e\n\nReentrantReadWriteLock 是 ReadWriteLock 的实现类，最主要的有两个方法：readLock() 和 writeLock() 用来获取读锁和写锁。\n\n```java\npublic class ReadWriteLockDemo {\n\n    private static final ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock(false);\n    private static final ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();\n    private static final ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();\n\n    private static void read() {\n        readLock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \"得到读锁，正在读取\");\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            System.out.println(Thread.currentThread().getName() + \"释放读锁\");\n            readLock.unlock();\n        }\n    }\n\n    private static void write() {\n        writeLock.lock();\n        try {\n            System.out.println(Thread.currentThread().getName() + \"得到写锁，正在写入\");\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            System.out.println(Thread.currentThread().getName() + \"释放写锁\");\n            writeLock.unlock();\n        }\n    }\n\n    public static void main(String[] args) \n            throws InterruptedException {\n        new Thread(() -\u003e read()).start();\n        new Thread(() -\u003e read()).start();\n        new Thread(() -\u003e write()).start();\n        new Thread(() -\u003e write()).start();\n    }\n}\n\n输出结果：\nThread-0得到读锁，正在读取\nThread-1得到读锁，正在读取\nThread-0释放读锁\nThread-1释放读锁\nThread-2得到写锁，正在写入\nThread-2释放写锁\nThread-3得到写锁，正在写入\nThread-3释放写锁\n```\n\n可以看出，读锁可以同时被多个线程获得，而写锁不能。\n\n## 适用场景\n\n相比于 ReentrantLock 适用于一般场合，ReadWriteLock 适用于读多写少的情况，合理使用可以进一步提高并发效率。\n\n# JVM 对锁的优化\n\n相比于 JDK 1.5，在 JDK 1.6 中 HotSopt 虚拟机对 synchronized 内置锁的性能进行了很多优化，包括自适应的自旋、锁消除、锁粗化、偏向锁、轻量级锁等。有了这些优化措施后，synchronized 锁的性能得到了大幅提高，下面我们分别介绍这些具体的优化。\n\n## 自适应的自旋锁\n\n在 JDK 1.6 中引入了自适应的自旋锁来解决长时间自旋的问题。自适应意味着自旋的时间不再固定，而是会根据最近自旋尝试的成功率、失败率，以及当前锁的拥有者的状态等多种因素来共同决定。自旋的持续时间是变化的，自旋锁变“聪明”了。比如，如果最近尝试自旋获取某一把锁成功了，那么下一次可能还会继续使用自旋，并且允许自旋更长的时间；但是如果最近自旋获取某一把锁失败了，那么可能会省略掉自旋的过程，以便减少无用的自旋，提高效率。\n\n## 锁消除\n\n经过逃逸分析之后，如果发现某些对象不可能被其他线程访问到，那么就可以把它们当成栈上数据，栈上数据由于只有本线程可以访问，自然是线程安全的，也就无需加锁，所以会把这样的锁给自动去除掉。\n\n## 锁粗化\n\n如果释放了锁，紧接着什么都没做，又重新获取锁，那么其实这种释放和重新获取锁是完全没有必要的，如果我们把同步区域扩大，也就是只在最开始加一次锁，并且在最后直接解锁，那么就可以把中间这些无意义的解锁和加锁的过程消除，相当于是把几个 synchronized 块合并为一个较大的同步块。这样做的好处在于在线程执行这些代码时，就无须频繁申请与释放锁了，这样就减少了性能开销。\n\n## 锁升级\n\n前面说到过，从无锁到偏向锁，再到轻量级锁，最后到重量级锁的升级过程也是 JVM 自动完成的。JVM 默认会优先使用偏向锁，如果有必要的话才逐步升级，这大幅提高了锁的性能。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Concurrent-Lock/clipboard_20230323_094831.png)\n","lastmodified":"2023-04-21T14:55:33.037222465Z","tags":["并发","公平锁","非公平锁","可重入锁","读写锁","synchrionized","Java"]},"/2023-03-15":{"title":"2023-03-15","content":"弄完了同步，牛逼","lastmodified":"2023-04-21T14:55:32.605227307Z","tags":[]},"/2023-03-16":{"title":"2023-03-16","content":"","lastmodified":"2023-04-21T14:55:32.605227307Z","tags":[]},"/2023-03-18":{"title":"2023-03-18","content":"# 2023-03-18\n\n### 今日开发工作\n\n### 今日感想","lastmodified":"2023-04-21T14:55:32.605227307Z","tags":[]},"/2023-03-19":{"title":"2023-03-19","content":"### 今日开发工作\n### 今日感想","lastmodified":"2023-04-21T14:55:32.605227307Z","tags":[]},"/2023-03-20":{"title":"2023-03-20","content":"### 今日开发工作\n### 今日感想\nsadlfjsal \n\nfrom windows\n\n之类主页是[[Home]]","lastmodified":"2023-04-21T14:55:32.605227307Z","tags":[]},"/2023-03-22":{"title":"Troubleshooting and FAQ","content":"\nStill having trouble? Here are a list of common questions and problems people encounter when installing Quartz.\n\nWhile you're here, join our [Discord](https://discord.gg/cRFFHYye7t) :)\n\n### Does Quartz have Latex support?\n\nYes! See [CJK + Latex Support (测试)](notes/CJK%20+%20Latex%20Support%20(测试).md) for a brief demo.\n\n### Can I use \\\u003cObsidian Plugin\\\u003e in Quartz?\n\nUnless it produces direct Markdown output in the file, no. There currently is no way to bundle plugin code with Quartz.\n\nThe easiest way would be to add your own HTML partial that supports the functionality you are looking for.\n\n### My GitHub pages is just showing the README and not Quartz\n\nMake sure you set the source to deploy from `master` (and not `hugo`) using `/ (root)`! See more in the [hosting](/notes/hosting) guide\n\n### Some of my pages have 'January 1, 0001' as the last modified date\n\nThis is a problem caused by `git` treating files as case-insensitive by default and some of your posts probably have capitalized file names. You can turn this off in your Quartz by running this command.\n\n```shell\n# in the root of your Quartz (same folder as config.toml)\ngit config core.ignorecase true\n\n# or globally (not recommended)\ngit config --global core.ignorecase true\n```\n\n### Can I publish only a subset of my pages?\n\nYes! Quartz makes selective publishing really easy. Heres a guide on [excluding pages from being published](notes/ignore%20notes.md).\n\n### Can I host this myself and not on GitHub Pages?\n\nYes! All built files can be found under `/public` in the `master` branch. More details under [hosting](notes/hosting.md).\n\n### `command not found: hugo-obsidian`\n\nMake sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize `hugo-obsidian` as an executable.\n\n```shell\n# Add the following 2 lines to your ~/.bash_profile (~/.zshrc if you are on Mac)\nexport GOPATH=/Users/$USER/go\nexport PATH=$GOPATH/bin:$PATH\n\n# In your current terminal, to reload the session\nsource ~/.bash_profile # again, (~/.zshrc if you are on Mac)\n```\n\n### How come my notes aren't being rendered?\n\nYou probably forgot to include front matter in your Markdown files. You can either setup [Obsidian](notes/obsidian.md) to do this for you or you need to manually define it. More details in [the 'how to edit' guide](notes/editing.md).\n\n### My custom domain isn't working!\n\nWalk through the steps in [the hosting guide](notes/hosting.md) again. Make sure you wait 30 min to 1 hour for changes to take effect.\n\n### How do I setup analytics?\n\nQuartz by default uses [Plausible](https://plausible.io/) for analytics.\n\nIf you would prefer to use Google Analytics, you can follow this [guide in the Hugo documentation](https://gohugo.io/templates/internal/#google-analytics).\n\nAlternatively, you can also import your Google Analytics data into Plausible by [following this guide](https://plausible.io/docs/google-analytics-import).\n\n### How do I change the content on the home page?\n\nTo edit the main home page, open `/content/_index.md`.\n\n### How do I change the colours?\n\nYou can change the theme by editing `assets/custom.scss`. More details on customization and themeing can be found in the [customization guide](notes/config.md).\n\n### How do I add images?\n\nYou can put images anywhere in the `/content` folder.\n\n### My Interactive Graph and Backlinks aren't up to date\n\nBy default, the `linkIndex.json` (which Quartz needs to generate the Interactive Graph and Backlinks) are not regenerated locally. To set that up, see the guide on [local editing](notes/editing.md)\n\n### Can I use React/Vue/some other framework?\n\nNot out of the box. You could probably make it work by editing `/layouts/_default/single.html` but that's not what Quartz is designed to work with. 99% of things you are trying to do with those frameworks you can accomplish perfectly fine using just vanilla HTML/CSS/JS.\n\n## Still Stuck?\n\nQuartz isn't perfect! If you're still having troubles, file an issue in the GitHub repo with as much information as you can reasonably provide. Alternatively, you can message me on [Twitter](https://twitter.com/_jzhao) and I'll try to get back to you as soon as I can.\n\n🐛 [Submit an Issue](https://github.com/jackyzha0/quartz/issues)\n","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":[]},"/2023-03-24":{"title":"2023-03-24","content":"","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":[""]},"/2023-03-27":{"title":"2023-03-27","content":"\nThe nonstop drive to get better even has a term in China’s tech industry: “embroidery.”\ntech industry 科技行业\nterm 学期、术语\n\npredecessor 前身\n\nEverybody works on improving their craft, stitch by stitch\n每个人都致力于提高他们的手艺，一针一针\n\nfirm\n名词-公司, 企业, 厂商\n\n形容词-坚定, 牢固, 坚决\n\n动词-加固, 加强, 弄结实\n\n副词-坚固地, 坚硬地","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":["diary"]},"/2023-04-09":{"title":"2023-04-09","content":"\n1、挂起函数 Continuation 为啥转成 FunctionN\n2、Continuation 的 invoke 方法何时被调用\n3、挂起函数为什么只能被挂起函数调用？\n\t表：因为挂起函数需要 Continuation 环境，普通函数没有提供。用来挂起后恢复\n4、suspendCoroutine -\u003e suspendCoroutineUninterceptedOrReturn\nsuspendCancellableCoroutine -\u003e suspendCoroutineUninterceptedOrReturn\nstartCoroutine -\u003e createCoroutineUnintercepted\n5、挂起其实就是切换线程执行任务，恢复就是把线程切回到调用时的线程\n\n\n```kotlin\npublic actual inline fun \u003cT\u003e (suspend () -\u003e T).startCoroutineUninterceptedOrReturn(  \n\tcompletion: Continuation\u003cT\u003e  \n): Any? = (this as Function1\u003cContinuation\u003cT\u003e, Any?\u003e).invoke(completion)\n\npublic actual inline fun \u003cR, T\u003e (suspend R.() -\u003e T).startCoroutineUninterceptedOrReturn(  \n\treceiver: R,  \n\tcompletion: Continuation\u003cT\u003e  \n): Any? = (this as Function2\u003cR, Continuation\u003cT\u003e, Any?\u003e).invoke(receiver, completion)  \n  \n\ninternal actual inline fun \u003cR, P, T\u003e (suspend R.(P) -\u003e \nT).startCoroutineUninterceptedOrReturn(  \n\treceiver: R,  \n\tparam: P,  \n\tcompletion: Continuation\u003cT\u003e  \n): Any? = (this as Function3\u003cR, P, Continuation\u003cT\u003e, Any?\u003e).invoke(receiver, param, completion)\n\npublic actual fun \u003cT\u003e (suspend () -\u003e T).createCoroutineUnintercepted(  \n\tcompletion: Continuation\u003cT\u003e  \n): Continuation\u003cUnit\u003e {  \n\tval probeCompletion = probeCoroutineCreated(completion)  \n\treturn if (this is BaseContinuationImpl)  \n\t\tcreate(probeCompletion)  \n\telse  \n\t\tcreateCoroutineFromSuspendFunction(probeCompletion) {  \n\t\t\t(this as Function1\u003cContinuation\u003cT\u003e, Any?\u003e).invoke(it)  \n\t\t}  \n}\n\npublic actual fun \u003cR, T\u003e (suspend R.() -\u003e T).createCoroutineUnintercepted(  \n\t\treceiver: R,  completion: Continuation\u003cT\u003e): Continuation\u003cUnit\u003e {  \n\tval probeCompletion = probeCoroutineCreated(completion)  \n\treturn if (this is BaseContinuationImpl)  \n\t\tcreate(receiver, probeCompletion)  \n\telse {  \n\t\tcreateCoroutineFromSuspendFunction(probeCompletion) {  \n\t\t\t(this as Function2\u003cR, Continuation\u003cT\u003e, Any?\u003e).invoke(receiver, it)  \n\t\t}  \n\t}  \n}\n\npublic actual fun \u003cT\u003e Continuation\u003cT\u003e.intercepted(): Continuation\u003cT\u003e =  \n(this as? ContinuationImpl)?.intercepted() ?: this\n\nprivate inline fun \u003cT\u003e createCoroutineFromSuspendFunction(  \n\tcompletion: Continuation\u003cT\u003e,  \n\tcrossinline block: (Continuation\u003cT\u003e) -\u003e Any?  \n): Continuation\u003cUnit\u003e {  \n\tval context = completion.context  \n\t// label == 0 when coroutine is not started yet (initially) or label == 1 when it was  \n\treturn if (context === EmptyCoroutineContext)  \n\t\tobject : RestrictedContinuationImpl(completion as Continuation\u003cAny?\u003e) {  \n\t\t\tprivate var label = 0  \n\t\t\t  \n\t\t\toverride fun invokeSuspend(result: Result\u003cAny?\u003e): Any? =  \n\t\t\twhen (label) {  \n\t\t\t\t0 -\u003e {  \n\t\t\t\t\tlabel = 1  \n\t\t\t\t\tresult.getOrThrow() // Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith  \n\t\t\t\t\tblock(this) // run the block, may return or suspend  \n\t\t\t\t}  \n\t\t\t\t1 -\u003e {  \n\t\t\t\t\tlabel = 2  \n\t\t\t\t\tresult.getOrThrow() // this is the result if the block had suspended  \n\t\t\t\t}  \n\t\t\t\telse -\u003e error(\"This coroutine had already completed\")  \n\t\t\t}  \n\t\t}  \n\telse  \n\t\tobject : ContinuationImpl(completion as Continuation\u003cAny?\u003e, context) {  \n\t\t\tprivate var label = 0  \n\t\t\t  \n\t\t\toverride fun invokeSuspend(result: Result\u003cAny?\u003e): Any? =  \n\t\t\t\twhen (label) {  \n\t\t\t\t\t0 -\u003e {  \n\t\t\t\t\t\tlabel = 1  \n\t\t\t\t\t\tresult.getOrThrow() // Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith  \n\t\t\t\t\t\tblock(this) // run the block, may return or suspend  \n\t\t\t\t\t}  \n\t\t\t\t\t1 -\u003e {  \n\t\t\t\t\t\tlabel = 2  \n\t\t\t\t\t\tresult.getOrThrow() // this is the result if the block had suspended  \n\t\t\t\t}  \n\t\t\telse -\u003e error(\"This coroutine had already completed\")  \n\t\t}  \n\t}  \n}\n```\n\n```kotlin\n@InternalCoroutinesApi\npublic abstract class AbstractCoroutine\u003cin T\u003e(\n    parentContext: CoroutineContext,\n    initParentJob: Boolean,\n    active: Boolean\n) : JobSupport(active), Job, Continuation\u003cT\u003e, CoroutineScope {\n\n    init {\n        /*\n         * Setup parent-child relationship between the parent in the context and the current coroutine.\n         * It may cause this coroutine to become _cancelling_ if the parent is already cancelled.\n         * It is dangerous to install parent-child relationship here if the coroutine class\n         * operates its state from within onCancelled or onCancelling\n         * (with exceptions for rx integrations that can't have any parent)\n         */\n        if (initParentJob) initParentJob(parentContext[Job])\n    }\n\n\t...\n\n}\n```\n\nhttps://www.jianshu.com/p/2659bbe0df16\nhttps://www.jianshu.com/p/2979732fb6fb\nhttps://www.jianshu.com/p/2857993af646\nhttps://www.jianshu.com/p/20418eb50b17\nhttps://www.jianshu.com/p/3a97d87683d5","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":["diary"]},"/2023-04-12":{"title":"2023-04-12","content":"","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":["diary"]},"/ADB-%E5%91%BD%E4%BB%A4":{"title":"ADB 命令","content":"\n# shell\n\nadb shell 常用的命令有 ：\n\n- am（activity manager）\n\n可执行 启动 activity，service，broadcast，杀死进程等操作。\n\n- pm（package manager）\n\n可以执行 安装/卸载 应用，输出 apk 路径等操作。\n\n- dpm（device policy manager）\n\n可以执行设备管理器相关命令，激活设备管理员，设置设备管理器 owner 等。\n\n- screencap （截屏）\n\n使用该命令可以快速截屏并将图片保存至指定路径，截屏过程用户无感知。\n\n# ps\n\nadb shell ps --help\n\n查看帮助\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/ADB/clipboard_20230323_041900.png)\n\n## 常用参数\n\n- -p 后面加 进程 id ，可以显示进程为指定 id 的信息\n\n```apache\nadb shell ps -p 1\n\nUSER            PID   PPID     VSZ    RSS WCHAN            ADDR S NAME                       \nroot              1      0 10782796  4384 0                   0 S init\n```\n\n- -P 后面加 父进程 id，可以显示父进程为指定 id 的信息\n\n```apache\nadb shell ps -P 1\n\nUSER            PID   PPID     VSZ    RSS WCHAN            ADDR S NAME                       \nroot            133      1 10761096  2540 0                   0 S init\nroot            285      1 13495412 127540 0                  0 S zygote64\nroot            286      1 1840080 116252 0                   0 S zygote\n```\n\n- -u 后面加 user 名，可以显示指定 user 的信息\n\n```perl\nadb shell ps -u system\n\nUSER            PID   PPID     VSZ    RSS WCHAN            ADDR S NAME                       \nsystem          164      1 10759476  4296 0                   0 S servicemanager\nsystem          551    285 13891404 262940 0                  0 S system_server\n// 省略...\n```\n\n- -T 将线程信息也显示出来\n\n## 常用属性\n\n使用 `adb shell ps -o HELP` 可以查看 ps 命令可以查看的所有属性信息\n\n```sql\nCommand line field types:\n\n  ARGS    CMDLINE minus initial path     CMD     Thread name (/proc/TID/stat:2)\n  CMDLINE Command line (argv[])          COMM    EXE filename (/proc/PID/exe)\n  COMMAND EXE path (/proc/PID/exe)       NAME    Process name (PID's argv[0])\n\nProcess attribute field types:\n\n  S       Process state:\n      R (running) S (sleeping) D (device I/O) T (stopped)  t (trace stop)\n      X (dead)    Z (zombie)   P (parked)     I (idle)\n      Also between Linux 2.6.33 and 3.13:\n      x (dead)    K (wakekill) W (waking)\n\n  SCH     Scheduling policy (0=other, 1=fifo, 2=rr, 3=batch, 4=iso, 5=idle)\n  STAT    Process state (S) plus:\n      \u003c high priority          N low priority L locked memory\n      s session leader         + foreground   l multithreaded\n  %CPU    Percentage of CPU time used    %MEM    RSS as % of physical memory\n  %VSZ    VSZ as % of physical memory    ADDR    Instruction pointer\n  BIT     32 or 64                       C       Total %CPU used since start\n  CPU     Which processor running on     DIO     Disk I/O\n  DREAD   Data read from disk            DWRITE  Data written to disk\n  ELAPSED Elapsed time since PID start   F       Flags 1=FORKNOEXEC 4=SUPERPRIV\n  GID     Group ID                       GROUP   Group name\n  IO      Data I/O                       LABEL   Security label\n  MAJFL   Major page faults              MINFL   Minor page faults\n  NI      Niceness (static 19 to -20)    PCY     Android scheduling policy\n  PGID    Process Group ID               PID     Process ID\n  PPID    Parent Process ID              PR      Prio Reversed (dyn 39-0, RT)\n  PRI     Priority (dynamic 0 to 139)    PSR     Processor last executed on\n  READ    Data read                      RES     Short RSS\n  RGID    Real (before sgid) Group ID    RGROUP  Real (before sgid) group name\n  RSS     Resident Set Size (DRAM pages) RTPRIO  Realtime priority\n  RUID    Real (before suid) user ID     RUSER   Real (before suid) user name\n  SHR     Shared memory                  STIME   Start time (ISO 8601)\n  SWAP    Swap I/O                       SZ      4k pages to swap out\n  TCNT    Thread count                   TID     Thread ID\n  TIME    CPU time consumed              TIME+   CPU time (high precision)\n  TTY     Controlling terminal           UID     User id\n  USER    User name                      VIRT    Virtual memory size\n  VSZ     Virtual memory size (1k units) WCHAN   Wait location in kernel\n  WRITE   Data written                   \n```\n\n这里列举一些常用的属性\n\n命令行属性：\n\n- NAME 进程名称\n- CMD 线程名\n\n进程属性：\n\n- S 代表着进程状态，其中 R 代表运行中（running），S 代表休眠中（sleeping），X 代表死亡（dead）\n- USER 代表 User 名称\n- PID 进程 id\n- PPID 父进程 id\n- VSZ 进程虚拟地址空间大小\n- PCY Android 系统调度策略\n- TID 线程 id\n\nps 命令默认显示 USER，PID，PPID，VSZ，RSS，WCHAN，ADDR，S，NAME 几个属性\n\n可以使用 adb shell ps -o + 欲显示的属性名，逗号隔开 来自定义输出信息，例如输出 USER,UID,PID,PPID,PGID,PCY,NAME 几个属性，且进程 id 为 285 的进程信息\n\n```apache\nadb shell ps -o USER,UID,PID,PPID,PGID,PCY,NAME  -p 285\n\nUSER           UID    PID   PPID  PGID PCY NAME                       \nroot             0    285      1   285  ta zygote64\n```\n\n# dympsys\n\n## 服务总览\n\ndumpsys service 名称\n\n## 参数查看\n\n- adb shell dumpsys activity -h\n- adb shell dumpsys window -h\n- adb shell dumpsys meminfo -h\n- adb shell dumpsys package -h\n- adb shell dumpsys batteryinfo -h\n\ndumpsys activity containers\n\n直观地查看 Activity 返回栈\n\ndumpsys activity lastanr\n\n查看自开机以来出现的最新的 ANR，即：关机失效，最新的会覆盖上一次\n\ndumpsys activity starter\n\n查看 Activity 的启动者\n\nadb shell dumpsys activity activities | grep mResumedActivity\n\n查看栈顶 Activity\n\nadb shell dumpsys activity top | grep mParent\n\n查看栈顶 activity 的所有 fragment，不过很多时候 activity 中会有一些不可见的 fragment 。例如：用于分发 Lifecycle 的 ReportFragment，Glide 中的空 fragment。因此我们可以使用 `grep` 将其过滤掉\n\n\u003cstrong\u003eadb shell dumpsys meminfo -s [process] \u003c/strong\u003e其中 process 输入 pid 和 applicationId 均可\n\n按比例分摊的内存大小 (Proportional Set Size - \u003cstrong\u003ePSS\u003c/strong\u003e)\n\n应用使用的 \u003cstrong\u003e非共享页数量 + 共享页均匀分摊数量\u003c/strong\u003e（例如，如果三个进程共享 3MB，则每个进程的 PSS 为 1MB）\n\nadb shell dumpsys activity o\n\n查询 OOM 相关的信息\n\nadb shell dumpsys activity p\n\n查看每个进程详细的信息\n\nadb shell am force-stop 包名\n\n强制杀死应用\n","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":["ADB","shell"]},"/About-Atlas":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: tutorial\ntitle: \"About Atlas\"\n---\nAtlas意思是地图集。\n\n单个案例或项目的MOC，考虑直接放在对应文件夹里面，相当于起到一个个文件夹的readme和导览的作用。这里专门放这些MOC的MOC。\n\n围绕本库和obsidian的使用教程、方法和细节，也放到这里，就像是地图的指南针。\n","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":[]},"/Android-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96":{"title":"Android 对容器类的优化","content":"在之前 [HashMap 的源码解析的文章](https://ywue4d2ujm.feishu.cn/docs/doccnWxrCbptIcob6fIMUWVeWfc?app_id=11#S0X9Es) 中可知，HashMap 的一级存储结构是一个初始容量为 16 的数组， 所以当我们创建出一个 HashMap 对象时，即使里面没有任何元素，也要分别一块内存空间给它。而且，在不断的向 HashMap 里 put 数据的过程中，当数据量达到阈值（容量 * 加载因子，加载因子默认为 0.75）时，将会触发 HashMap 扩容流程，扩大后新的容量一定是原来的 2 倍。\n\n假如我们有几十万、几百万条数据，那么 HashMap 要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做 hash 运算，这将对我们的内存空间造成很大消耗和浪费，再加上 HashMap 获取数据是通过遍历 Entry[] 数组来得到对应的元素，在数据量很大时候会比较慢。\n\n所以对于运行在移动设备上的 Android 系统来说，HashMap 的使用会造成比较大的负担。因此在\n\nandroid.util 包中，提供了几个容器类，在某些情况下可以取代 HashMap 以提升性能。\n\n# SparseArray\n\n相比于比 HashMap ，SparseArray 更省内存，并且在某些条件下性能更好，主要是因为它避免了对 key 的自动装箱（int 转为 Integer 类型）。与普通的对象数组不同，它的索引可以包含间隙，因此得名 SparseArray（稀疏数组）。它的内部采用数组来存储 key，并且通过二分查找定位到目标 key，因此在数据量达到数百个时，效率将会降低至少 50% 之于 HashMap。\n\n为了提高性能，在删除某项数据时，SparseArray 并不会马上删除 value 中的内容并且压缩整理 key 数组，而是会把将要删除的数据标记成 \u003cstrong\u003eDELETE\u003c/strong\u003e，后续可以重新用于相同 key 值的数据或者在 gc 操作的时候进行删除。SparseArray 在进行扩容前或者调用 size、indexOfKey 等方法时必须进行 gc 操作。\n\n```java\npublic class SparseArray\u003cE\u003e implements Cloneable {\n    private static final Object DELETED = new Object ();\n    private boolean mGarbage = false;\n    private int [] mKeys;\n    private Object [] mValues;\n\n    public SparseArray () {\n        this(10);\n    }\n\n    public SparseArray (int initialCapacity) {\n        if (initialCapacity == 0) {\n            mKeys = EmptyArray.INT;\n            mValues = EmptyArray.OBJECT;\n        } else {\n            mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);\n            mKeys = new int [mValues.length];\n        }\n        mSize = 0;\n    }\n    \n    ...\n}\n```\n\n它内部则是通过两个数组来进行数据存储的，一个存储 key，另外一个存储 value。\n\n## 添加数据\n\n```typescript\npublic void put(int key, E value) {\n    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);\n\n    if (i \u003e= 0) {\n        mValues[i] = value;\n    } else {\n        i = ~i;\n\n        if (i \u003c mSize \u0026\u0026 mValues[i] == DELETED) {\n            mKeys[i] = key;\n            mValues[i] = value;\n            return;\n        }\n\n        if (mGarbage \u0026\u0026 mSize \u003e= mKeys.length) {\n            gc();\n\n            // Search again because indices may have changed.\n            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);\n        }\n\n        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);\n        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);\n        mSize++;\n    }\n}\n```\n\n## 删除数据\n\n```java\npublic void delete(int key) {\n    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);\n\n    if (i \u003e= 0) {\n        if (mValues[i] != DELETED) {\n            mValues[i] = DELETED;\n            mGarbage = true;\n        }\n    }\n}\n```\n\n## 获取数据\n\n```java\npublic E get(int key) {\n    return get(key, null);\n}\n\npublic E get(int key, E valueIfKeyNotFound) {\n    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);\n\n    if (i \u003c 0 || mValues[i] == DELETED) {\n        return valueIfKeyNotFound;\n    } else {\n        return (E) mValues[i];\n    }\n}\n```\n\n## 特有方法\n\n```java\npublic int keyAt(int index) {\n    if (index \u003e= mSize \u0026\u0026 UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {\n        // The array might be slightly bigger than mSize, in which case, indexing won't fail.\n        // Check if exception should be thrown outside of the critical path.\n        throw new ArrayIndexOutOfBoundsException(index);\n    }\n    if (mGarbage) {\n        gc();\n    }\n\n    return mKeys[index];\n}\n\n\npublic E valueAt(int index) {\n    if (index \u003e= mSize \u0026\u0026 UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {\n        // The array might be slightly bigger than mSize, in which case, indexing won't fail.\n        // Check if exception should be thrown outside of the critical path.\n        throw new ArrayIndexOutOfBoundsException(index);\n    }\n    if (mGarbage) {\n        gc();\n    }\n\n    return (E) mValues[index];\n}\n```\n\n## 垃圾回收\n\n```java\nprivate void gc() {\n    // Log.e(\"SparseArray\", \"gc start with \" + mSize);\n\n    int n = mSize;\n    int o = 0;\n    int[] keys = mKeys;\n    Object[] values = mValues;\n\n    for (int i = 0; i \u003c n; i++) {\n        Object val = values[i];\n\n        if (val != DELETED) {\n            if (i != o) {\n                keys[o] = keys[i];\n                values[o] = val;\n                values[i] = null;\n            }\n\n            o++;\n        }\n    }\n\n    mGarbage = false;\n    mSize = o;\n\n    // Log.e(\"SparseArray\", \"gc end with \" + mSize);\n}\n```\n\n## 小结\n\n优点：\n\n- 避免自动装箱，直接使用数组存储 int 类型的 key\n- 二分查找加快定位 key\n- 删除元素先进行标记，可以重复使用，gc 的时候再进行删除\n\n应用场景：\n\n- key 为 int 类型\n- 数据量不大，最好在千级以内\n\n# ArrayMap\n\nArrayMap 在设计上比 HashMap 更多的考虑了内存的优化，可以理解为以时间换空间的一种优化。它使用了两个数组来存储数据——一个整型数组存储键的 hash 值，另一个对象数组存储键/值对。这样既能避免为每个存入 Map 中的键创建额外的对象，又能更积极的控制这些数据的长度的增加。因为增加长度只需要拷贝数组中的键，而不是重新构建一个哈希表。\n\n它和 SparseArray 一样，也会对 key 使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到 key 相应的 index，然后通过 index 来进行添加、查找、删除等操作。所以，应用场景和 SparseArray 的一样，如果在数据量比较大的情况下，那么它的性能将退化至少 50 %。\n\n```java\npublic final class ArrayMap\u003cK, V\u003e implements Map\u003cK, V\u003e {\n    ...\n\n    int[] mHashes;\n    @UnsupportedAppUsage(maxTargetSdk = 28) // Storage is an implementation detail. Use public key/value API.\n    Object[] mArray;\n    @UnsupportedAppUsage(maxTargetSdk = 28) // Use size()\n    int mSize;\n    \n    ...\n\n    public ArrayMap() {\n        this(0, false);\n    }\n\n    public ArrayMap(int capacity) {\n        this(capacity, false);\n    }\n\n    public ArrayMap(int capacity, boolean identityHashCode) {\n        mIdentityHashCode = identityHashCode;\n\n        // If this is immutable, use the sentinal EMPTY_IMMUTABLE_INTS\n        // instance instead of the usual EmptyArray.INT. The reference\n        // is checked later to see if the array is allowed to grow.\n        if (capacity \u003c 0) {\n            mHashes = EMPTY_IMMUTABLE_INTS;\n            mArray = EmptyArray.OBJECT;\n        } else if (capacity == 0) {\n            mHashes = EmptyArray.INT;\n            mArray = EmptyArray.OBJECT;\n        } else {\n            allocArrays(capacity);\n        }\n        mSize = 0;\n    }\n\n    public ArrayMap(ArrayMap\u003cK, V\u003e map) {\n        this();\n        if (map != null) {\n            putAll(map);\n        }\n    }\n    \n    ...\n}\n```\n\nArrayMap 数据结构：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Android-Container/clipboard_20230323_042030.png)\n\n如上图所示，在 ArrayMap 内部有两个比较重要的数组，一个是 mHashes，另一个是 mArray。\n\n- mHashes 用来存放 key 的 hash 值\n- mArray 用来存储 key 与 value 的值，它是一个 Object 数组\n\n其中这两个数组的索引对应关系是\n\n```java\nmHashes[index] = hash;\nmArray[index\u003c\u003c1] = key;  //等同于 mArray[index * 2] = key;\nmArray[(index\u003c\u003c1)+1] = value; //等同于 mArray[index * 2 + 1] = value;\n```\n\n## 确定元素位置\n\n```java\nint indexOf(Object key, int hash) {\n    final int N = mSize;\n    //快速判断是ArrayMap是否为空,如果符合情况快速跳出\n    if (N == 0) {\n        return ~0;\n    }\n    //二分查找确定索引值\n    int index = ContainerHelpers.binarySearch(mHashes, N, hash);\n\n    // 如果未找到，返回一个index值，可能为后续可能的插入数据使用。\n    if (index \u003c 0) {\n        return index;\n    }\n\n    // 如果确定不仅hashcode相同，也是同一个key，返回找到的索引值。\n    if (key.equals(mArray[index\u003c\u003c1])) {\n        return index;\n    }\n\n    // 如果key的hashcode相同，但不是同一对象，从索引之后再次找\n    int end;\n    for (end = index + 1; end \u003c N \u0026\u0026 mHashes[end] == hash; end++) {\n        if (key.equals(mArray[end \u003c\u003c 1])) return end;\n    }\n\n    // 如果key的hashcode相同，但不是同一对象，从索引之前再次找\n    for (int i = index - 1; i \u003e= 0 \u0026\u0026 mHashes[i] == hash; i--) {\n        if (key.equals(mArray[i \u003c\u003c 1])) return i;\n    }\n    //返回负值，既可以用来表示无法找到匹配的key，也可以用来为后续的插入数据所用。\n    // Key not found -- return negative value indicating where a\n    // new entry for this key should go.  We use the end of the\n    // hash chain to reduce the number of array entries that will\n    // need to be copied when inserting.\n    return ~end;\n}\n```\n\n## 添加数据\n\n键被插入到 objects 的下一个空闲位置。值对象被插入到 mArray 的与对应键相邻的位置。计算出的键的 hashCode 会被插入到 mHashes 数组的下一个空闲位置。\n\n```java\npublic V put(K key, V value) {\n    final int osize = mSize;\n    final int hash;\n    int index;\n    if (key == null) {\n        hash = 0;\n        index = indexOfNull();\n    } else {\n        hash = mIdentityHashCode ? System.identityHashCode(key) : key.hashCode();\n        index = indexOf(key, hash);\n    }\n    if (index \u003e= 0) {\n        index = (index\u003c\u003c1) + 1;\n        final V old = (V)mArray[index];\n        mArray[index] = value;\n        return old;\n    }\n\n    index = ~index;\n    if (osize \u003e= mHashes.length) {\n        final int n = osize \u003e= (BASE_SIZE*2) ? (osize+(osize\u003e\u003e1))\n                : (osize \u003e= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);\n\n        if (DEBUG) Log.d(TAG, \"put: grow from \" + mHashes.length + \" to \" + n);\n\n        final int[] ohashes = mHashes;\n        final Object[] oarray = mArray;\n        allocArrays(n);\n\n        if (CONCURRENT_MODIFICATION_EXCEPTIONS \u0026\u0026 osize != mSize) {\n            throw new ConcurrentModificationException();\n        }\n\n        if (mHashes.length \u003e 0) {\n            if (DEBUG) Log.d(TAG, \"put: copy 0-\" + osize + \" to 0\");\n            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);\n            System.arraycopy(oarray, 0, mArray, 0, oarray.length);\n        }\n\n        freeArrays(ohashes, oarray, osize);\n    }\n\n    if (index \u003c osize) {\n        if (DEBUG) Log.d(TAG, \"put: move \" + index + \"-\" + (osize-index)\n                + \" to \" + (index+1));\n        System.arraycopy(mHashes, index, mHashes, index + 1, osize - index);\n        System.arraycopy(mArray, index \u003c\u003c 1, mArray, (index + 1) \u003c\u003c 1, (mSize - index) \u003c\u003c 1);\n    }\n\n    if (CONCURRENT_MODIFICATION_EXCEPTIONS) {\n        if (osize != mSize || index \u003e= mHashes.length) {\n            throw new ConcurrentModificationException();\n        }\n    }\n    mHashes[index] = hash;\n    mArray[index\u003c\u003c1] = key;\n    mArray[(index\u003c\u003c1)+1] = value;\n    mSize++;\n    return null;\n}\n```\n\n扩容逻辑：\n\n- 首先数组的容量会扩充到 BASE_SIZE\n- 如果 BASE_SIZE 无法容纳，则扩大到 2 * BASE_SIZE\n- 如果 2 * BASE_SIZE 仍然无法容纳，则每次扩容为当前容量的 1.5 倍。\n\n## 删除数据\n\n```java\npublic V remove(Object key) {\n    final int index = indexOfKey(key);\n    if (index \u003e= 0) {\n        return removeAt(index);\n    }\n\n    return null;\n}\n\npublic V removeAt(int index) {\n    if (index \u003e= mSize \u0026\u0026 UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {\n        // The array might be slightly bigger than mSize, in which case, indexing won't fail.\n        // Check if exception should be thrown outside of the critical path.\n        throw new ArrayIndexOutOfBoundsException(index);\n    }\n\n    final Object old = mArray[(index \u003c\u003c 1) + 1];\n    final int osize = mSize;\n    final int nsize;\n    if (osize \u003c= 1) {\n        // Now empty.\n        if (DEBUG) Log.d(TAG, \"remove: shrink from \" + mHashes.length + \" to 0\");\n        final int[] ohashes = mHashes;\n        final Object[] oarray = mArray;\n        mHashes = EmptyArray.INT;\n        mArray = EmptyArray.OBJECT;\n        freeArrays(ohashes, oarray, osize);\n        nsize = 0;\n    } else {\n        nsize = osize - 1;\n        if (mHashes.length \u003e (BASE_SIZE*2) \u0026\u0026 mSize \u003c mHashes.length/3) {\n            // Shrunk enough to reduce size of arrays.  We don't allow it to\n            // shrink smaller than (BASE_SIZE*2) to avoid flapping between\n            // that and BASE_SIZE.\n            final int n = osize \u003e (BASE_SIZE*2) ? (osize + (osize\u003e\u003e1)) : (BASE_SIZE*2);\n\n            if (DEBUG) Log.d(TAG, \"remove: shrink from \" + mHashes.length + \" to \" + n);\n\n            final int[] ohashes = mHashes;\n            final Object[] oarray = mArray;\n            allocArrays(n);\n\n            if (CONCURRENT_MODIFICATION_EXCEPTIONS \u0026\u0026 osize != mSize) {\n                throw new ConcurrentModificationException();\n            }\n\n            if (index \u003e 0) {\n                if (DEBUG) Log.d(TAG, \"remove: copy from 0-\" + index + \" to 0\");\n                System.arraycopy(ohashes, 0, mHashes, 0, index);\n                System.arraycopy(oarray, 0, mArray, 0, index \u003c\u003c 1);\n            }\n            if (index \u003c nsize) {\n                if (DEBUG) Log.d(TAG, \"remove: copy from \" + (index+1) + \"-\" + nsize\n                        + \" to \" + index);\n                System.arraycopy(ohashes, index + 1, mHashes, index, nsize - index);\n                System.arraycopy(oarray, (index + 1) \u003c\u003c 1, mArray, index \u003c\u003c 1,\n                        (nsize - index) \u003c\u003c 1);\n            }\n        } else {\n            if (index \u003c nsize) {\n                if (DEBUG) Log.d(TAG, \"remove: move \" + (index+1) + \"-\" + nsize\n                        + \" to \" + index);\n                System.arraycopy(mHashes, index + 1, mHashes, index, nsize - index);\n                System.arraycopy(mArray, (index + 1) \u003c\u003c 1, mArray, index \u003c\u003c 1,\n                        (nsize - index) \u003c\u003c 1);\n            }\n            mArray[nsize \u003c\u003c 1] = null;\n            mArray[(nsize \u003c\u003c 1) + 1] = null;\n        }\n    }\n    if (CONCURRENT_MODIFICATION_EXCEPTIONS \u0026\u0026 osize != mSize) {\n        throw new ConcurrentModificationException();\n    }\n    mSize = nsize;\n    return (V)old;\n}\n```\n\n- 如果当前 ArrayMap 只有一项数据，则删除操作将 mHashes，mArray 置为空数组，mSize 置为 0\n- 如果当前 ArrayMap 容量过大（大于 BASE_SIZE*2）并且持有的数据量过小（不足 1/3）则降低 ArrayMap 容量，减少内存占用\n- 如果不符合上面的情况，则从 mHashes 删除对应的值，将 mArray 中对应的索引置为 null\n\n## 获取数据\n\n```java\npublic V get(Object key) {\n    final int index = indexOfKey(key);\n    return index \u003e= 0 ? (V)mArray[(index\u003c\u003c1)+1] : null;\n}\n\npublic int indexOfKey(Object key) {\n    return key == null ? indexOfNull()\n            : indexOf(key, mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());\n}\n\nint indexOf(Object key, int hash) {\n    final int N = mSize;\n\n    // Important fast case: if nothing is in here, nothing to look for.\n    if (N == 0) {\n        return ~0;\n    }\n\n    int index = binarySearchHashes(mHashes, N, hash);\n\n    // If the hash code wasn't found, then we have no entry for this key.\n    if (index \u003c 0) {\n        return index;\n    }\n\n    // If the key at the returned index matches, that's what we want.\n    if (key.equals(mArray[index\u003c\u003c1])) {\n        return index;\n    }\n\n    // Search for a matching key after the index.\n    int end;\n    for (end = index + 1; end \u003c N \u0026\u0026 mHashes[end] == hash; end++) {\n        if (key.equals(mArray[end \u003c\u003c 1])) return end;\n    }\n\n    // Search for a matching key before the index.\n    for (int i = index - 1; i \u003e= 0 \u0026\u0026 mHashes[i] == hash; i--) {\n        if (key.equals(mArray[i \u003c\u003c 1])) return i;\n    }\n\n    // Key not found -- return negative value indicating where a\n    // new entry for this key should go.  We use the end of the\n    // hash chain to reduce the number of array entries that will\n    // need to be copied when inserting.\n    return ~end;\n}\n```\n\n## 特有方法\n\n```typescript\npublic K keyAt(int index) {\n    if (index \u003e= mSize \u0026\u0026 UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {\n        // The array might be slightly bigger than mSize, in which case, indexing won't fail.\n        // Check if exception should be thrown outside of the critical path.\n        throw new ArrayIndexOutOfBoundsException(index);\n    }\n    return (K)mArray[index \u003c\u003c 1];\n}\n\n\npublic V valueAt(int index) {\n    if (index \u003e= mSize \u0026\u0026 UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {\n        // The array might be slightly bigger than mSize, in which case, indexing won't fail.\n        // Check if exception should be thrown outside of the critical path.\n        throw new ArrayIndexOutOfBoundsException(index);\n    }\n    return (V)mArray[(index \u003c\u003c 1) + 1];\n}\n```\n\n## 缓存优化\n\nArrayMap 的容量发生变化，正如前面介绍的，有这两种情况：\n\n- put 方法增加数据，扩大容量\n- remove 方法删除数据，减小容量\n\n在这个过程中，会频繁出现多个容量为 BASE_SIZE 和 2 * BASE_SIZE 的 int 数组和 Object 数组。ArrayMap 设计者为了避免创建不必要的对象，减少 GC 的压力。采用了类似 [对象池](https://droidyue.com/blog/2016/12/12/dive-into-object-pool/) 的优化设计。\n\n这其中涉及到几个元素：\n\n- BASE_SIZE 值为 4，与 ArrayMap 容量有密切关系。\n- mBaseCache 用来缓存容量为 BASE_SIZE 的 int 数组和 Object 数组\n- mBaseCacheSize mBaseCache 缓存的数量，避免无限缓存\n- mTwiceBaseCache 用来缓存容量为 BASE_SIZE * 2 的 int 数组和 Object 数组\n- mTwiceBaseCacheSize mTwiceBaseCache 缓存的数量，避免无限缓存\n- CACHE_SIZE 值为 10，用来控制 mBaseCache 与 mTwiceBaseCache 缓存的大小\n\n这其中：\n\n- mBaseCache 的第一个元素保存下一个 m BaseCache，第二个元素保存 mHashes 数组\n- mTwiceBaseCache 和 mBaseCache 一样，只是对应的数组容量不同\n\n具体的缓存数组逻辑的代码：\n\n```java\nprivate static void freeArrays(final int[] hashes, final Object[] array, final int size) {\n    if (hashes.length == (BASE_SIZE*2)) {\n        synchronized (ArrayMap.class) {\n            if (mTwiceBaseCacheSize \u003c CACHE_SIZE) {\n                array[0] = mTwiceBaseCache;\n                array[1] = hashes;\n                for (int i=(size\u003c\u003c1)-1; i\u003e=2; i--) {\n                    array[i] = null;\n                }\n                mTwiceBaseCache = array;\n                mTwiceBaseCacheSize++;\n                if (DEBUG) Log.d(TAG, \"Storing 2x cache \" + array\n                        + \" now have \" + mTwiceBaseCacheSize + \" entries\");\n            }\n        }\n    } else if (hashes.length == BASE_SIZE) {\n        synchronized (ArrayMap.class) {\n            if (mBaseCacheSize \u003c CACHE_SIZE) {\n                array[0] = mBaseCache;\n                array[1] = hashes;\n                for (int i=(size\u003c\u003c1)-1; i\u003e=2; i--) {\n                    array[i] = null;\n                }\n                mBaseCache = array;\n                mBaseCacheSize++;\n                if (DEBUG) Log.d(TAG, \"Storing 1x cache \" + array\n                        + \" now have \" + mBaseCacheSize + \" entries\");\n            }\n        }\n    }\n\n```\n\n具体的利用缓存数组的代码：\n\n```java\nprivate void allocArrays(final int size) {\n    if (mHashes == EMPTY_IMMUTABLE_INTS) {\n        throw new UnsupportedOperationException(\"ArrayMap is immutable\");\n    }\n    if (size == (BASE_SIZE*2)) {\n        synchronized (ArrayMap.class) {\n            if (mTwiceBaseCache != null) {\n                final Object[] array = mTwiceBaseCache;\n                mArray = array;\n                mTwiceBaseCache = (Object[])array[0];\n                mHashes = (int[])array[1];\n                array[0] = array[1] = null;\n                mTwiceBaseCacheSize--;\n                if (DEBUG) Log.d(TAG, \"Retrieving 2x cache \" + mHashes\n                        + \" now have \" + mTwiceBaseCacheSize + \" entries\");\n                return;\n            }\n        }\n    } else if (size == BASE_SIZE) {\n        synchronized (ArrayMap.class) {\n            if (mBaseCache != null) {\n                final Object[] array = mBaseCache;\n                mArray = array;\n                mBaseCache = (Object[])array[0];\n                mHashes = (int[])array[1];\n                array[0] = array[1] = null;\n                mBaseCacheSize--;\n                if (DEBUG) Log.d(TAG, \"Retrieving 1x cache \" + mHashes\n                        + \" now have \" + mBaseCacheSize + \" entries\");\n                return;\n            }\n        }\n    }\n\n    mHashes = new int[size];\n    mArray = new Object[size\u003c\u003c1];\n}\n```\n\n## 小结\n\n优点：\n\n- 二分查找加快定位 key\n- 缓存优化\n\n应用场景：\n\n- 数据结构类型为 Map 类型\n- 数据量不大，最好在千级以内\n\n如果要兼容 aip19 以下版本的话，需要使用 android.support.v4.util.ArrayMap\n\n# 其它\n\n- \u003cstrong\u003eArrayMap\u003cK,V\u003e 替代 HashMap\u003cK,V\u003e\u003c/strong\u003e\n- \u003cstrong\u003eArraySet\u003cK,V\u003e 替代 HashSet\u003cK,V\u003e\u003c/strong\u003e\n- \u003cstrong\u003eSparseArray\u003cV\u003e 替代 HashMap\u003cInteger,V\u003e\u003c/strong\u003e\n- \u003cstrong\u003eSparseBooleanArray 替代 HashMap\u003cInteger,Boolean\u003e\u003c/strong\u003e\n- \u003cstrong\u003eSparseIntArray 替代 HashMap\u003cInteger,Integer\u003e\u003c/strong\u003e\n- \u003cstrong\u003eSparseLongArray 替代 HashMap\u003cInteger,Long\u003e\u003c/strong\u003e\n- \u003cstrong\u003eLongSparseArray\u003cV\u003e 替代 HashMap\u003cLong,V\u003e\u003c/strong\u003e\n","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":["Android","SparseArray","ArrayMap"]},"/Buttons":{"title":"Buttons","content":"```button\nname 灵光乍现\ntype command\naction QuickAdd: CMI\ncolor blue\n```\n^button-idea\n\n\n","lastmodified":"2023-04-21T14:55:32.605227307Z","tags":[]},"/CAS-%E5%92%8C-AQS-%E5%8E%9F%E7%90%86":{"title":"CAS 和 AQS 原理","content":"# CAS\n\n## 介绍\n\nCAS 英文全称是 Compare-And-Swap，中文叫做“比较并交换”，它是一种思想、一种算法。\n\n在大多数处理器的指令中，都会实现 CAS 相关的指令，这一条指令就可以完成“比较并交换”的操作，也正是由于这是一条（而不是多条）CPU 指令，所以 CAS 相关的指令是具备原子性的，这个组合操作在执行期间不会被打断，这样就能保证并发安全。由于这个原子性是由 CPU 保证的，所以无需我们程序员来操心。\n\nCAS 有三个操作数：内存值 V、预期值 A、要修改的值 B。CAS 最核心的思路就是，\u003cstrong\u003e仅当预期值 A 和当前的内存值 V 相同时，才将内存值修改为 B。\u003c/strong\u003e\n\n## \u003cstrong\u003e使用及原理\u003c/strong\u003e\n\n### ConcurrentHashMap\n\n截取 ConcurrentHashMap 部分 putVal 方法的代码，如下所示：\n\n```java\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new   \n                   NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node\u003cK,V\u003e[] tab = table;;) {\n        Node\u003cK,V\u003e f; int n, i, fh;\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        else if ((f = tabAt(tab, i = (n - 1) \u0026 hash)) == null) {\n            if (casTabAt(tab, i, null,\n                         new Node\u003cK,V\u003e(hash, key, value, null)))\n                break; // no lock when adding to empty bin\n        }\n    ...\n}\n\nstatic final \u003cK,V\u003e boolean casTabAt(Node\u003cK,V\u003e[] tab, int i,\n                                    Node\u003cK,V\u003e c, Node\u003cK,V\u003e v) {\n    return U.compareAndSwapObject(tab, ((long)i \u003c\u003c ASHIFT) + ABASE, c, v);\n}\n```\n\n该方法里面只有一行代码，即调用变量 U 的 compareAndSwapObject 的方法，U 是 Unsafe 类型的实例。\n\n### ConcurrentLinkedQueue\n\n接下来看并发容器的第二个案例。非阻塞并发队列 ConcurrentLinkedQueue 的 offer 方法里也有 CAS 的身影，offer 方法的代码如下所示：\n\n```java\npublic boolean offer(E e) {\n    checkNotNull(e);\n    final Node\u003cE\u003e newNode = new Node\u003cE\u003e(e);\n\n    for (Node\u003cE\u003e t = tail, p = t;;) {\n        Node\u003cE\u003e q = p.next;\n        if (q == null) {\n            if (p.casNext(null, newNode)) {\n                if (p != t) \n                    casTail(t, newNode); \n                return true;\n            }\n        }\n        else if (p == q)\n            p = (t != (t = tail)) ? t : head;\n        else\n            p = (p != t \u0026\u0026 t != (t = tail)) ? t : q;\n    }\n}\n\nboolean casNext(Node\u003cE\u003e cmp, Node\u003cE\u003e val) {\n    return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n}\n```\n\n可以看出，在 offer 方法中，有一个 for 循环，这是一个死循环，在第 8 行有一个与 CAS 相关的方法，是 casNext 方法，用于更新节点。那么如果执行 p 的 casNext 方法失败的话，casNext 会返回 false，那么显然代码会继续在 for 循环中进行下一次的尝试。而 casNext 方法中也用到了 UnSafe 类。\n\n### 原子类\n\n在编程领域里，原子性意味着“一组操作要么全都操作成功，要么全都失败，不能只操作成功其中的一部分”。而 java.util.concurrent.atomic 下的类，就是具有原子性的类，可以原子性地执行添加、递增、递减等操作。\n\n原子类的作用和锁有类似之处，是为了保证并发情况下线程安全。不过原子类相比于锁，有一定的优势：\n\n- 粒度更细：原子变量可以把竞争范围缩小到变量级别，通常情况下，锁的粒度都要大于原子变量的粒度。\n- 效率更高：除了高度竞争的情况之外，使用原子类的效率通常会比使用同步互斥锁的效率更高，因为原子类底层利用了 CAS 操作，不会阻塞线程。\n\n原子类一共可以分为以下这 6 类：\n\n| 类型                               | 具体类                                                                         |\n| ---------------------------------- | ------------------------------------------------------------------------------ |\n| Atomic* 基本类型原子类             | AtomicInteger、AtomicLong、AtomicBoolean                                       |\n| Atomic*Array 数组类型原子类        | AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray                      |\n| Atomic*Reference 引用类型原子类    | AtomicReference、AtomicStampedReference、AtomicMarkableReference               |\n| Atomic*FieldUpdater 升级类型原子类 | AtomicIntegerfieldupdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater |\n| Adder 累加器                       | LongAdder、DoubleAdder                                                         |\n| Accumulator 积累器                 | LongAccumulator、DoubleAccumulator                                             |\n\n下面以 AtomicInteger 为例，分析在 Java 中如何利用 CAS 实现原子操作。\n\ngetAndAdd 方法是 AtomicInteger 类的重要方法，这个方法的代码在 Java 1.8 中的实现如下：\n\n```java\npublic final int getAndAdd(int delta) {    \n    return unsafe.getAndAddInt(this, valueOffset, delta);\n}\n```\n\n可以看出，里面再次用到了 Unsafe 这个类，并且调用了 unsafe.getAndAddInt 方法。\n\n### 实现原理\n\n从以上示例可以看出，Unsafe 其实是 CAS 的核心类，并且其核心方法都是由 native 层面来实现的。由于 Java 无法直接访问底层操作系统，而是需要通过 native 方法来实现。不过尽管如此，JVM 还是留了一个后门，Unsafe 类提供了硬件级别的原子操作，可以利用它直接操作内存数据。\n\n看一下 AtomicInteger 的一些重要代码，如下所示：\n\n```java\npublic class AtomicInteger extends Number \n           implements java.io.Serializable {\n   // setup to use Unsafe.compareAndSwapInt for updates\n   private static final Unsafe unsafe = Unsafe.getUnsafe();\n   private static final long valueOffset;\n \n   static {\n       try {\n           valueOffset = unsafe.objectFieldOffset\n               (AtomicInteger.class.getDeclaredField(\"value\"));\n       } catch (Exception ex) { throw new Error(ex); }\n   }\n \n   private volatile int value;\n   public final int get() {return value;}\n   ...\n}\n```\n\n可以看出，在数据定义的部分，首先获取了 Unsafe 实例，并且定义了 valueOffset。接下来 static 代码块会在类加载的时候执行，执行时会调用 Unsafe 的 objectFieldOffset 方法，从而得到当前这个原子类的 value 的偏移量，并且赋给 valueOffset 变量，这样就获取到了 value 的偏移量，它的含义是在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的原值的，这样就能通过 Unsafe 来实现 CAS 了。\n\nvalue 是用 volatile 修饰的，它就是原子类存储的值的变量，由于它被 volatile 修饰，可以保证在多线程之间看到的 value 是同一份，保证了可见性。\n\n接下来继续看 Unsafe 的 getAndAddInt 方法的实现，代码如下：\n\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n   int var5;\n   do {\n       var5 = this.getIntVolatile(var1, var2);\n   } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n   return var5;\n}\n```\n\n首先，它是一个 do-while 循环，所以这是一个死循环，直到满足循环的退出条件时才可以退出。\n\n接下来看 do 后面的这一行代码 var5 = this.getIntVolatile(var1, var2) ，这是个 native 方法，作用就是获取在 var1 中的 var2 偏移处的值。\n\n传入的两个参数，第一个就是当前原子类，第二个就是最开始获取到的 offset，这样一来我们就可以获取到当前内存中偏移量的值，并且保存到 var5 里面。此时 var5 实际上代表当前时刻下的原子类的数值。\n\n现在再来看 while 的退出条件，也就是 compareAndSwapInt 这个方法，它一共传入了 4 个参数，这 4 个参数是 var1、var2、var5、var5 + var4，为了方便理解，我们给它们取了新了变量名，分别 object、offset、expectedValue、newValue，具体含义如下：\n\n- 第一个参数 object 就是将要操作的对象，传入的是 this，也就是 atomicInteger 这个对象本身；\n- 第二个参数是 offset，也就是偏移量，借助它就可以获取到 value 的数值；\n- 第三个参数 expectedValue，代表“期望值”，传入的是刚才获取到的 var5；\n- 而最后一个参数 newValue 是希望修改的数值 ，等于之前取到的数值 var5 再加上 var4，而 var4 就是我们之前所传入的 delta，delta 就是我们希望原子类所改变的数值，比如可以传入 +1，也可以传入 -1。\n\n所以 compareAndSwapInt 方法的作用就是，判断如果现在原子类里 value 的值和之前获取到的 var5 相等的话，那么就把计算出来的 var5 + var4 给更新上去，所以说这行代码就实现了 CAS 的过程。\n\n一旦 CAS 操作成功，就会退出这个 while 循环，但是也有可能操作失败。如果操作失败就意味着在获取到 var5 之后，并且在 CAS 操作之前，value 的数值已经发生变化了，证明有其他线程修改过这个变量。\n\n这样一来，就会再次执行循环体里面的代码，重新获取 var5 的值，也就是获取最新的原子变量的数值，并且再次利用 CAS 去尝试更新，直到更新成功为止，所以这是一个死循环。\n\n总结一下，Unsafe 的 getAndAddInt 方法是通过循环 + CAS 的方式来实现的，在此过程中，它会通过 compareAndSwapInt 方法来尝试更新 value 的值，如果更新失败就重新获取，然后再次尝试更新，直到更新成功。\n\n## CAS 造成的三个问题\n\n### ABA 问题\n\n决定 CAS 是否进行 swap 的判断标准是“当前的值和预期的值是否一致”，如果一致，就认为在此期间这个数值没有发生过变动，这在大多数情况下是没有问题的。\n\n但是在有的业务场景下，我们想确切知道从上一次看到这个值以来到现在，这个值是否发生过变化。例如，这个值假设从 A 变成了 B，再由 B 变回了 A，此时，它不仅可以认为发生了变化，而且变化了两次。\n\n解决 ABA 问题，可以在在变量值自身之外，再添加一个版本号，通过对比版本号来判断值是否变化过。\n\n### 自旋时间过长\n\n由于单次 CAS 不一定能执行成功，所以 CAS 往往是配合着循环来实现的。在高并发场景下有的时候甚至是死循环，不停地进行重试，直到线程竞争不激烈的时候，才能修改成功。\n\n因此要根据实际情况来选择是否使用 CAS，在高并发的场景下，通常 CAS 的效率是不高的。\n\n### 范围不能灵活控制\n\n通常执行 CAS 的时候，是针对某一个而不是多个共享变量的，这个变量可能是 Integer 类型，也有可能是 Long 类型、对象类型等，但是不能针对多个共享变量同时进行 CAS 操作，因为这多个变量之间是独立的，简单的把原子操作组合到一起，并不具备原子性。因此如果想对多个对象同时进行 CAS 操作并想保证线程安全的话，是比较困难的。\n\n有一个解决方案，那就是利用一个新的类，来整合刚才这一组共享变量，这个新的类中的多个成员变量就是刚才的那多个共享变量，然后再利用 atomic 包中的 AtomicReference 来把这个新对象整体进行 CAS 操作，这样就可以保证线程安全。\n\n相比之下，如果使用 synchronized 关键字则会比较方便。\n\n# AQS\n\n## 介绍\n\n队列同步器 AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个 int 类型的 state 变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的 ReentrantLock、Semaphore、CountDownLatch 和 CyclicBarrior 等。\n\n同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系：\n\n锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；\n\n同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。\n\n实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/CAS-AQS/clipboard_20230323_101329.png)\n\n## 使用及原理\n\n如果想使用 AQS 来写一个自己的线程协作工具类，通常而言是分为以下三步，这也是 JDK 里利用 AQS 类的主要步骤：\n\n1. 新建一个自己的线程协作工具类，在内部写一个 Sync 类，该 Sync 类继承 AbstractQueuedSynchronizer，即 AQS；\n2. 想好设计的线程协作工具类的协作逻辑，在 Sync 类里，根据是否是独占，来重写对应的方法。如果是独占，则重写 tryAcquire 和 tryRelease 等方法；如果是非独占，则重写 tryAcquireShared 和 tryReleaseShared 等方法；\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/CAS-AQS/clipboard_20230323_101333.png)\n3. 在自己的线程协作工具类中，实现获取/释放的相关方法，并在里面调用 AQS 对应的方法，如果是独占则调用 acquire 或 release 等方法，非独占则调用 acquireShared 或 releaseShared 或 acquireSharedInterruptibly 等方法。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/CAS-AQS/clipboard_20230323_101337.png)\n\nAQS 最核心的三大部分就是状态（state）、FIFO 等待队列和期望协作工具类去实现的获取）/释放等重要方法。\n\n### state\n\nstate 的含义并不是一成不变的，它会根据具体实现类的作用不同而表示不同的含义。比如说在 Semaphore 中，state 表示的是剩余许可证的数量；在 CountDownLatch 工具类里面，state 表示的是需要“倒数”的数量。他的定义如下：\n\n```java\n/**\n * The synchronization state.\n */\nprivate volatile int state;\n```\n\nstate 的访问方式有三种：\n\n- getState()：获取当前同步状态。\n- setState(int newState)：设置当前同步状态，volatile 保证了它的多线程状态下的可见性。\n- compareAndSetState(int expect, int update)：使用 CAS 设置当前状态，保证状态设置的原子性。\n\n### FIFO 队列\n\n即先进先出队列，这个队列最主要的作用是存储等待的线程。假设很多线程都想要同时抢锁，那么大部分的线程是抢不到的，那怎么去处理这些抢不到锁的线程呢？就得需要有一个队列来存放、管理它们。所以 AQS 的一大功能就是充当线程的“排队管理器”。\n\n当多个线程去竞争同一把锁的时候，就需要用排队机制把那些没能拿到锁的线程串在一起；而当前面的线程释放锁之后，这个管理器就会挑选一个合适的线程来尝试抢刚刚释放的那把锁。所以 AQS 就一直在维护这个队列，并把等待的线程都放到队列里面。\n\n在队列中，分别用 head 和 tail 来表示头节点和尾节点，两者在初始化的时候都指向了一个空节点。头节点可以理解为“当前持有锁的线程”，而在头节点之后的线程就被阻塞了，它们会等待唤醒，唤醒也是由 AQS 负责操作的。\n\n### 获取/释放方法\n\n#### \u003cstrong\u003e获取\u003c/strong\u003e\n\n获取操作通常会依赖 state 变量的值，根据 state 值不同，协作工具类也会有不同的逻辑，并且在获取的时候也经常会阻塞。\n\n比如 ReentrantLock 中的 lock 方法就是其中一个“获取方法”，执行时，如果发现 state 不等于 0 且当前线程不是持有锁的线程，那么就代表这个锁已经被其他线程所持有了。这个时候，当然就获取不到锁，于是就让该线程进入阻塞状态。\n\n再比如，Semaphore 中的 acquire 方法就是其中一个“获取方法”，作用是获取许可证，此时能不能获取到这个许可证也取决于 state 的值。如果 state 值是正数，那么代表还有剩余的许可证，数量足够的话，就可以成功获取；但如果 state 是 0，则代表已经没有更多的空余许可证了，此时这个线程就获取不到许可证，会进入阻塞状态，所以这里同样也是和 state 的值相关的。\n\n再举个例子，CountDownLatch 获取方法就是 await 方法（包含重载方法），作用是“等待，直到倒数结束”。执行 await 的时候会判断 state 的值，如果 state 不等于 0，线程就陷入阻塞状态，直到其他线程执行倒数方法把 state 减为 0，此时就代表现在这个门闩放开了，所以之前阻塞的线程就会被唤醒。\n\n#### \u003cstrong\u003e释放\u003c/strong\u003e\n\n释放方法是站在获取方法的对立面的，通常和刚才的获取方法配合使用。我们刚才讲的获取方法可能会让线程阻塞，比如说获取不到锁就会让线程进入阻塞状态，但是释放方法通常是不会阻塞线程的。\n\n比如在 Semaphore 信号量里面，释放就是 release 方法（包含重载方法），release() 方法的作用是去释放一个许可证，会让 state 加 1；而在 CountDownLatch 里面，释放就是 countDown 方法，作用是倒数一个数，让 state 减 1。所以也可以看出，在不同的实现类里面，他们对于 state 的操作是截然不同的，需要由每一个协作类根据自己的逻辑去具体实现。\n\n### CountDownLatch 的实现\n\n```java\npublic class CountDownLatch {\n\n    public CountDownLatch(int count) {\n        if (count \u003c 0) throw new IllegalArgumentException(\"count \u003c 0\");\n        this.sync = new Sync(count);\n    }\n    \n    public void countDown() {\n        //AQS 类中的方法\n        sync.releaseShared(1);\n    }\n    \n    public void await() throws InterruptedException {\n        //AQS 类中的方法\n        sync.acquireSharedInterruptibly(1);\n    }\n    \n    private final Sync sync;\n   \n    private static final class Sync \n              extends AbstractQueuedSynchronizer {\n        Sync(int count) {\n            setState(count);\n        }\n\n        int getCount() {\n            return getState();\n        }\n\n        protected int tryAcquireShared(int acquires) {\n            return (getState() == 0) ? 1 : -1;\n        }\n\n        protected boolean tryReleaseShared(int releases) {\n            for (;;) {\n                int c = getState();\n                if (c == 0)\n                    return false;\n                int nextc = c-1;\n                if (compareAndSetState(c, nextc))\n                    return nextc == 0;\n            }\n        }\n\n       public final void acquireSharedInterruptibly(int arg) \n              throws InterruptedException {\n           if (Thread.interrupted())\n               throw new InterruptedException();\n           if (tryAcquireShared(arg) \u003c 0)\n               doAcquireSharedInterruptibly(arg);\n       }\n        \n        protected int tryAcquireShared(int acquires) {\n            return (getState() == 0) ? 1 : -1;\n        }\n    }\n    \n}\n```\n","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":["CAS","AQS","原子类","ConcurrentHashMap","并发","锁","面试","Java"]},"/ControlPanel":{"title":"ControlPanel","content":"\u003e [!example]+ 命令按钮\n\u003e `button-idea`\n\u003e \n\n\n\u003e [!example]+ 待办事项\n\u003e- [ ] RecyclerView 分析⏫ \n\u003e- [ ] Fragment 分析\n\u003e- [x] 协程分析\n\u003e- [ ] KMM 学习\n\u003e- [ ] Jetpack 学习\n","lastmodified":"2023-04-21T14:55:32.605227307Z","tags":[]},"/EventBus-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90":{"title":"EventBus 使用及源码解析","content":"\n# 使用\n\n1. 首先引入依赖\n\n```groovy\napply plugin: 'kotlin-kapt'\n\ndependencies {\n    implementation 'org.greenrobot:eventbus:3.2.0'\n    kapt 'org.greenrobot:eventbus-annotation-processor:3.2.0'\n}\n\nkapt {\n    arguments {\n        arg('eventBusIndex', 'com.me.guanpj.myapplication.MyEventBusIndex')\n    }\n}\n```\n\n从在 3.0 版本开始，EventBus 提供了一个 EventBusAnnotationProcessor 注解处理器来在编译期通过读取 @Subscribe 注解，并解析和处理其中所包含的信息，然后生成 Java 类索引来保存订阅者中所有的事件响应函数，这样就比在运行时使用反射来获得订阅者中所有事件响应函数的速度要快。\n\n以下是来自官方对 EventBus 各个版本性能的对比图，可以看到，EventBus 3.x 如果没有使用索引的话性能相较于之前的版本是倒退的。使用索引能让 EventBus 的性能大大增加。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/EventBus/clipboard_20230323_031615.png)\n\n2. 添加混淆规则：\n\n```plain text\n-keepattributes *Annotation*\n-keepclassmembers class * {\n    @org.greenrobot.eventbus.Subscribe \u003cmethods\u003e;\n}\n-keep enum org.greenrobot.eventbus.ThreadMode { *; }\n # And if you use AsyncExecutor:\n-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent {\n    \u003cinit\u003e(java.lang.Throwable);\n}\n```\n\n3. 使用索引文件创建全局 EventBus 实例\n\n经过以上配置，就可以使用生成的 `com.me.guanpj.myapplication.MyEventBusIndex` 创建 EventBus 了。\n\n\u003e 注意：如果项目中没有被 @Subscribe 标记的事件接收方法， 则不会生成索引类。\n\n推荐在 Application 中使用生成的索引创建全局 EventBus 实例：\n\n```kotlin\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        EventBus.builder().addIndex(MyEventBusIndex()).installDefaultEventBus()\n    }\n}\n```\n\n这样后面通过 `EventBus.getDefault()` 获取的 EventBus 实例都是刚才通过索引创建的。\n\n如果既有 Library 的索引，也有 App 的索引，可以在 EventBus 设置过程中一起添加：\n\n```kotlin\nEventBus.builder().addIndex(MyEventBusAppIndex())\n    .addIndex(MyEventBusLibIndex()).build()\n    .installDefaultEventBus()\n```\n\n当然，如果在某些情况下不想使用全局实例，也可以单独生成一个实例：\n\n```kotlin\n\nval eventBus = EventBus.builder()\n    // 事件接收对象是否有层次结构（默认为 true，超类也将被通知）\n    .eventInheritance(true)\n    // 忽略索引文件\n    .ignoreGeneratedIndex(false)\n    // 打印没有订阅消息，默认为 true\n    .logNoSubscriberMessages(true)\n    // 打印订阅异常的消息，默认为 true\n    .logSubscriberExceptions(false)\n    // 设置发送的的事件在没有订阅者的情况时，EventBus是否保持静默，默认为 true\n    .sendNoSubscriberEvent(true)\n    // 发送分发事件的异常，默认为 true\n    .sendSubscriberExceptionEvent(true)\n    //如果 onEvent*** 方法出现异常，是否将此异常分发给订阅者，默认为 false\n    .throwSubscriberException(BuildConfig.DEBUG)\n    // 定义一个线程池用于处理后台线程和异步线程分发事件\n    .executorService(Executors.newSingleThreadExecutor())\n    // 启用严格的方法验证（在 3.0 以前，接收处理事件的方法名必须以 onEvent 开头）\n    // 默认为 false\n    .strictMethodVerification(true)\n    // 为特定时间跳过方法验证，包括方法名、限定符\n    .skipMethodVerificationFor(ButtonEvent::class.java)\n    .build()\neventBus.register(this)\n```\n\n4. 定义事件\n\n新建一个实体类用于事件的传递：\n\n```kotlin\npackage com.me.guanpj.myapplication.event\n\ndata class MessageEvent(val message: String)\n```\n\n5. 发送和接收事件\n\n在需要接收事件的 Activity、Fragment 或者其它地方调用一次 `EventBus.getDefault().register(this)` 进行注册，然后使用 `@Subscribe` 注解标记接收事件的方法，方法参数为一个实体类，或者基本数据类型。\n\n```kotlin\nclass EventBusActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_event)\n\n        EventBus.getDefault().register(this)\n    }\n\n    fun buttonClick(view: android.view.View) {\n        //EventBus.getDefault().post(MessageEvent(\"click\"))\n        EventBus.getDefault().postSticky(MessageEvent(\"click\"))\n    }\n\n    fun jump(view: View) {\n        startActivity(Intent(this, AnotherActivity::class.java))\n    }\n\n    @Subscribe(threadMode = ThreadMode.MAIN, priority = 0)\n    fun onEvent(event : MessageEvent) {\n        Log.e(\"gpj\", \"EventBusActivity onEvent receive msg: ${event.message} in thread: ${Thread.currentThread().name}\")\n    }\n\n    @Subscribe(threadMode = ThreadMode.BACKGROUND, priority = 1)\n    fun onEvent1(event : MessageEvent) {\n        Log.e(\"gpj\", \"EventBusActivity onEvent1 receive msg: ${event.message} in thread: ${Thread.currentThread().name}\")\n    }\n\n    @Subscribe(threadMode = ThreadMode.BACKGROUND, priority = 2)\n    fun onEvent2(event : MessageEvent) {\n        Log.e(\"gpj\", \"EventBusActivity onEvent2 receive msg: ${event.message} in thread: ${Thread.currentThread().name}\")\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        EventBus.getDefault().unregister(this)\n    }\n}\n```\n\n```kotlin\nclass AnotherActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_another)\n\n        EventBus.getDefault().register(this)\n    }\n\n    @Subscribe(threadMode = ThreadMode.MAIN)\n    fun onEvent(event : MessageEvent) {\n        Log.e(\"gpj\", \"AnotherActivity onEvent receive msg: ${event.message} in thread: ${Thread.currentThread().name}\")\n        // 粘性事件不会被消耗，除非手动移除\n        EventBus.getDefault().removeStickyEvent(MessageEvent::class.java)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        EventBus.getDefault().unregister(this)\n    }\n}\n```\n\n每次输出的日志都是一样的：\n\n```plain text\nEventBusActivity onEvent receive msg: click in thread: main\nEventBusActivity onEvent2 receive msg: click in thread: pool-2-thread-1\nEventBusActivity onEvent1 receive msg: click in thread: pool-2-thread-1\n//打开 MainActivity 后\nAnotherActivity receive msg: click in thread: main\n```\n\n# 分析\n\n## 获取 EventBus 实例\n\n不管是用 `EventBus.getDefault()` 还是 `EventBus.builder()` 都能够获取到 EventBus 对象，只不过前者是获取一个全局的单例，后者是使用 builder() 配置出一个新的对象。\n\n```java\npublic class EventBus {\n    ...\n    private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();\n    \n    private final Map\u003cClass\u003c?\u003e, CopyOnWriteArrayList\u003cSubscription\u003e\u003e subscriptionsByEventType;\n    private final Map\u003cObject, List\u003cClass\u003c?\u003e\u003e\u003e typesBySubscriber;\n    private final Map\u003cClass\u003c?\u003e, Object\u003e stickyEvents;\n    ...\n    \n    public static EventBus getDefault() {\n        EventBus instance = defaultInstance;\n        if (instance == null) {\n            synchronized (EventBus.class) {\n                instance = EventBus.defaultInstance;\n                if (instance == null) {\n                    instance = EventBus.defaultInstance = new EventBus();\n                }\n            }\n        }\n        return instance;\n    }\n\n    public static EventBusBuilder builder() {\n        return new EventBusBuilder();\n    }\n\n    public EventBus() {\n        this(DEFAULT_BUILDER);\n    }\n\n    EventBus(EventBusBuilder builder) {\n        logger = builder.getLogger();\n        // 1\n        subscriptionsByEventType = new HashMap\u003c\u003e();\n        // 2\n        typesBySubscriber = new HashMap\u003c\u003e();\n        // 3\n        stickyEvents = new ConcurrentHashMap\u003c\u003e();\n        // 4\n        mainThreadSupport = builder.getMainThreadSupport();\n        mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;\n        backgroundPoster = new BackgroundPoster(this);\n        asyncPoster = new AsyncPoster(this);\n        \n        indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;\n        // 5\n        subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,\n            builder.strictMethodVerification, builder.ignoreGeneratedIndex);\n        logSubscriberExceptions = builder.logSubscriberExceptions;\n        logNoSubscriberMessages = builder.logNoSubscriberMessages;\n        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;\n        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;\n        throwSubscriberException = builder.throwSubscriberException;\n        eventInheritance = builder.eventInheritance;\n        // 6\n        executorService = builder.executorService;\n    }\n    ...\n}\n```\n\n可以看出，两种获取对象的方式都会调用到 `EventBus(EventBusBuilder builder)` 这个构造方法，`getDefault()` 只是最终传入了一个空的 `EventBusBuilder` 对象而已。\n\n在 `EventBus(EventBusBuilder builder)` 构造方法中：\n\n在注释 1 处，创建了一个 subscriptionsByEventType 对象，可以看到它是一个 HashMap，并且其 key 表示 Event 的类型，value 为 `CopyOnWriteArrayList\u003cSubscription\u003e`。这里的 Subscription 是一个订阅信息对象，它里面保存了两个重要的字段，一个是类型为 Object 的 subscriber，该字段即为注册的对象（在 Android 中时通常是 Activity 或着 Fragment 对象）；另一个是类型为 SubscriberMethod 的实例，它就是被 @Subscribe 注解的那个订阅方法，里面保存了一个重要的字段：eventType，它的类型为 `Class\u003c?\u003e`，表示 Event 的类型。\n\n在注释 2 处，新建了一个类型为 HashMap 的 typesBySubscriber 对象，它的 key 为 subscriber 对象， value 为 subscriber 对象中所有的 Event 类型 List，日常使用中仅用于判断某个对象是否注册过。\n\n在注释 3 处新建了一个类型为 ConcurrentHashMap 的 stickyEvents 对象，专用于粘性事件处理的，key 同样为 Event 的类型，value 为当前的事件。\n\n\u003e 普通事件是先注册，然后发送事件才能收到；而粘性事件在发送事件之后再订阅也能收到。并且，粘性事件会保存在内存中，每次进入都会去内存中查找获取最新的粘性事件，除非手动移除事件。\n\n在注释 4 处，新建了三个不同类型的事件发送器：\n\n- mainThreadPoster：主线程事件发送器，通过它的 `mainThreadPoster.enqueue(subscription, event)` 方法可以将订阅信息和对应的事件进行入队，然后通过 handler 去发送一个消息，在 handler 的 `handleMessage()` 中去执行方法。\n- backgroundPoster：后台事件发送器，通过它的 `enqueue()` 将方法加入到后台的一个队列，最后通过线程池去执行，同时它保证任一时间只且仅能有一个任务会被线程池执行。\n- asyncPoster：实现逻辑类似于 backgroundPoster，不同于 backgroundPoster 的保证任一时间只且仅能有一个任务会被线程池执行的特性，asyncPoster 则是异步运行的，可以同时接收多个任务。\n\n再看注释 5 这行代码，这里新建了一个 SubscriberMethodFinder 对象，这是从 EventBus 中抽离出的订阅方法查询的一个对象，在优秀的源码中，我们经常能看到\u003cstrong\u003e组合优于继承\u003c/strong\u003e的这种实现思想。\n\n在注释 6 处，从 builder 中取出了一个默认的线程池对象，它由 \u003cstrong\u003eExecutors 的 newCachedThreadPool() 方法创建，它是一个有则用、无则创建、无数量上限\u003c/strong\u003e的线程池。\n\n## Index 文件分析\n\n### Index 文件概览\n\n生成的索引类如下：\n\n```java\npublic class MyEventBusIndex implements SubscriberInfoIndex {\n    private static final Map\u003cClass\u003c?\u003e, SubscriberInfo\u003e SUBSCRIBER_INDEX;\n\n    static {\n        SUBSCRIBER_INDEX = new HashMap\u003cClass\u003c?\u003e, SubscriberInfo\u003e();\n\n        putIndex(new SimpleSubscriberInfo(com.me.guanpj.myapplication.event.EventBusActivity.class, true,\n                new SubscriberMethodInfo[] {\n            new SubscriberMethodInfo(\"onEvent\", com.me.guanpj.myapplication.event.MessageEvent.class, ThreadMode.MAIN),\n            new SubscriberMethodInfo(\"onEvent1\", com.me.guanpj.myapplication.event.MessageEvent.class,\n                    ThreadMode.BACKGROUND, 1, false),\n            new SubscriberMethodInfo(\"onEvent2\", com.me.guanpj.myapplication.event.MessageEvent.class,\n                    ThreadMode.BACKGROUND, 2, false),\n        }));\n\n        putIndex(new SimpleSubscriberInfo(MainActivity.class, true, new SubscriberMethodInfo[] {\n            new SubscriberMethodInfo(\"onEvent3\", com.me.guanpj.myapplication.event.MessageEvent.class, ThreadMode.MAIN,\n                    3, true),\n        }));\n\n    }\n\n    private static void putIndex(SubscriberInfo info) {\n        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n    }\n\n    @Override\n    public SubscriberInfo getSubscriberInfo(Class\u003c?\u003e subscriberClass) {\n        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n        if (info != null) {\n            return info;\n        } else {\n            return null;\n        }\n    }\n}\n```\n\n### 类介绍\n\n#### SubscriberInfo 继承关系\n\n可以看到，这里新建了一个 Map 集合，用于存放事件订阅类和它们的订阅方法\n\n`SubscriberInfo` 之间的映射。`SubscriberInfo` 的定义如下：\n\n```java\npublic interface SubscriberInfo {\n    Class\u003c?\u003e getSubscriberClass();\n\n    SubscriberMethod[] getSubscriberMethods();\n\n    SubscriberInfo getSuperSubscriberInfo();\n\n    boolean shouldCheckSuperclass();\n}\n```\n\n这里 `SubscriberInfo` 的实现类为 `SimpleSubscriberInfo`，而中间还有一个 `AbstractSubscriberInfo`，它们的定义如下：\n\n```java\npublic abstract class AbstractSubscriberInfo implements SubscriberInfo {\n    private final Class subscriberClass;\n    private final Class\u003c? extends SubscriberInfo\u003e superSubscriberInfoClass;\n    private final boolean shouldCheckSuperclass;\n\n    protected AbstractSubscriberInfo(Class subscriberClass, Class\u003c? extends SubscriberInfo\u003e superSubscriberInfoClass,\n                                     boolean shouldCheckSuperclass) {\n        this.subscriberClass = subscriberClass;\n        this.superSubscriberInfoClass = superSubscriberInfoClass;\n        this.shouldCheckSuperclass = shouldCheckSuperclass;\n    }\n\n    @Override\n    public Class getSubscriberClass() {\n        return subscriberClass;\n    }\n\n    @Override\n    public SubscriberInfo getSuperSubscriberInfo() {\n        if(superSubscriberInfoClass == null) {\n            return null;\n        }\n        try {\n            return superSubscriberInfoClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public boolean shouldCheckSuperclass() {\n        return shouldCheckSuperclass;\n    }\n\n    protected SubscriberMethod createSubscriberMethod(String methodName, Class\u003c?\u003e eventType) {\n        return createSubscriberMethod(methodName, eventType, ThreadMode.POSTING, 0, false);\n    }\n\n    protected SubscriberMethod createSubscriberMethod(String methodName, Class\u003c?\u003e eventType, \n            ThreadMode threadMode) {\n        return createSubscriberMethod(methodName, eventType, threadMode, 0, false);\n    }\n\n    protected SubscriberMethod createSubscriberMethod(String methodName, Class\u003c?\u003e eventType,\n            ThreadMode threadMode,int priority, boolean sticky) {\n        try {\n            Method method = subscriberClass.getDeclaredMethod(methodName, eventType);\n            return new SubscriberMethod(method, eventType, threadMode, priority, sticky);\n        } catch (NoSuchMethodException e) {\n            throw new EventBusException(\"Could not find subscriber method in \" + subscriberClass +\n                    \". Maybe a missing ProGuard rule?\", e);\n        }\n    }\n}\n\npublic class SimpleSubscriberInfo extends AbstractSubscriberInfo {\n\n    private final SubscriberMethodInfo[] methodInfos;\n\n    public SimpleSubscriberInfo(Class subscriberClass, boolean shouldCheckSuperclass, SubscriberMethodInfo[] methodInfos) {\n        super(subscriberClass, null, shouldCheckSuperclass);\n        this.methodInfos = methodInfos;\n    }\n\n    @Override\n    public synchronized SubscriberMethod[] getSubscriberMethods() {\n        int length = methodInfos.length;\n        SubscriberMethod[] methods = new SubscriberMethod[length];\n        for (int i = 0; i \u003c length; i++) {\n            SubscriberMethodInfo info = methodInfos[i];\n            methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode,\n                    info.priority, info.sticky);\n        }\n        return methods;\n    }\n}\n```\n\n#### SubscriberMethod\n\n```java\npublic class SubscriberMethod {\n    final Method method;\n    final ThreadMode threadMode;\n    final Class\u003c?\u003e eventType;\n    final int priority;\n    final boolean sticky;\n    /** Used for efficient comparison */\n    String methodString;\n\n    public SubscriberMethod(Method method, Class\u003c?\u003e eventType, \n            ThreadMode threadMode, int priority, boolean sticky) {\n        this.method = method;\n        this.threadMode = threadMode;\n        this.eventType = eventType;\n        this.priority = priority;\n        this.sticky = sticky;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (other == this) {\n            return true;\n        } else if (other instanceof SubscriberMethod) {\n            checkMethodString();\n            SubscriberMethod otherSubscriberMethod = (SubscriberMethod)other;\n            otherSubscriberMethod.checkMethodString();\n            // Don't use method.equals because of http://code.google.com/p/android/issues/detail?id=7811#c6\n            return methodString.equals(otherSubscriberMethod.methodString);\n        } else {\n            return false;\n        }\n    }\n\n    private synchronized void checkMethodString() {\n        if (methodString == null) {\n            // Method.toString has more overhead, just take relevant parts of the method\n            StringBuilder builder = new StringBuilder(64);\n            builder.append(method.getDeclaringClass().getName());\n            builder.append('#').append(method.getName());\n            builder.append('(').append(eventType.getName());\n            methodString = builder.toString();\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        return method.hashCode();\n    }\n}\n```\n\n#### SubscriberMethodInfo\n\n```java\npublic class SubscriberMethodInfo {\n    final String methodName;\n    final ThreadMode threadMode;\n    final Class\u003c?\u003e eventType;\n    final int priority;\n    final boolean sticky;\n\n    public SubscriberMethodInfo(String methodName, Class\u003c?\u003e eventType, \n            ThreadMode threadMode, int priority, boolean sticky) {\n        this.methodName = methodName;\n        this.threadMode = threadMode;\n        this.eventType = eventType;\n        this.priority = priority;\n        this.sticky = sticky;\n    }\n\n    public SubscriberMethodInfo(String methodName, Class\u003c?\u003e eventType) {\n        this(methodName, eventType, ThreadMode.POSTING, 0, false);\n    }\n\n    public SubscriberMethodInfo(String methodName, Class\u003c?\u003e eventType, ThreadMode threadMode) {\n        this(methodName, eventType, threadMode, 0, false);\n    }\n}\n```\n\n### SubscriberInfo 映射\n\n回到 `MyEventBusIndex` 的 static 代码块，对于每一个调用过 `EventBus.register()` 方法的类，APT（Annotation Processing Tool）都会为它生成一行 `putIndex(...)` 代码，并传入一个新建的 `SimpleSubscriberInfo` 对象。\n\n在 `putIndex()` 方法中会调用传入的 `SimpleSubscriberInfo.getSubscriberClass()` 获取到订阅类的 Class 对象作为 key，同时把自身作为 value 存放进 Map 中。\n\n## register 流程\n\n先看 `EventBus.register` 方法，在分析过程中遇到的字段再回过头来分析。\n\n```java\npublic void register(Object subscriber) {\n    // 获取 subscriber 的 Class 对象\n    Class\u003c?\u003e subscriberClass = subscriber.getClass();\n    // 根据 Class 信息获取到所有加了 @Subscribe 的事件回调方法\n    List\u003cSubscriberMethod\u003e subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n    synchronized (this) {\n        // 遍历各个方法\n        for (SubscriberMethod subscriberMethod : subscriberMethods) {\n            // 执行订阅操作\n            subscribe(subscriber, subscriberMethod);\n        }\n    }\n}\n```\n\n上面的代码可以分为两个部分，2~3 行完成了获取注册对象中加了 `@Subscribe` 的事件回调方法，后面的代码真正完成了注册。\n\n### SubscriberMethodFinder.findSubscriberMethods()\n\n`subscriberMethodFinder` 在 EventBus 创建的时候就已经确定了，它的定义如下：\n\n```java\nclass SubscriberMethodFinder {\n    private static final int BRIDGE = 0x40;\n    private static final int SYNTHETIC = 0x1000;\n\n    private static final int MODIFIERS_IGNORE = Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC;\n    private static final Map\u003cClass\u003c?\u003e, List\u003cSubscriberMethod\u003e\u003e METHOD_CACHE = new ConcurrentHashMap\u003c\u003e();\n\n    private List\u003cSubscriberInfoIndex\u003e subscriberInfoIndexes;\n    private final boolean strictMethodVerification;\n    private final boolean ignoreGeneratedIndex;\n\n    private static final int POOL_SIZE = 4;\n    private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];\n\n    SubscriberMethodFinder(List\u003cSubscriberInfoIndex\u003e subscriberInfoIndexes, boolean strictMethodVerification,\n                           boolean ignoreGeneratedIndex) {\n        this.subscriberInfoIndexes = subscriberInfoIndexes;\n        this.strictMethodVerification = strictMethodVerification;\n        this.ignoreGeneratedIndex = ignoreGeneratedIndex;\n    }\n\n    List\u003cSubscriberMethod\u003e findSubscriberMethods(Class\u003c?\u003e subscriberClass) {\n        List\u003cSubscriberMethod\u003e subscriberMethods = METHOD_CACHE.get(subscriberClass);\n        if (subscriberMethods != null) {\n            return subscriberMethods;\n        }\n\n        if (ignoreGeneratedIndex) {\n            subscriberMethods = findUsingReflection(subscriberClass);\n        } else {\n            subscriberMethods = findUsingInfo(subscriberClass);\n        }\n        if (subscriberMethods.isEmpty()) {\n            throw new EventBusException(\"Subscriber \" + subscriberClass\n                    + \" and its super classes have no public methods with the @Subscribe annotation\");\n        } else {\n            METHOD_CACHE.put(subscriberClass, subscriberMethods);\n            return subscriberMethods;\n        }\n    }\n\n    private List\u003cSubscriberMethod\u003e findUsingInfo(Class\u003c?\u003e subscriberClass) {\n        FindState findState = prepareFindState();\n        findState.initForSubscriber(subscriberClass);\n        while (findState.clazz != null) {\n            findState.subscriberInfo = getSubscriberInfo(findState);\n            if (findState.subscriberInfo != null) {\n                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n                for (SubscriberMethod subscriberMethod : array) {\n                    if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                        findState.subscriberMethods.add(subscriberMethod);\n                    }\n                }\n            } else {\n                findUsingReflectionInSingleClass(findState);\n            }\n            findState.moveToSuperclass();\n        }\n        return getMethodsAndRelease(findState);\n    }\n\n    private List\u003cSubscriberMethod\u003e getMethodsAndRelease(FindState findState) {\n        List\u003cSubscriberMethod\u003e subscriberMethods = new ArrayList\u003c\u003e(findState.subscriberMethods);\n        findState.recycle();\n        synchronized (FIND_STATE_POOL) {\n            for (int i = 0; i \u003c POOL_SIZE; i++) {\n                if (FIND_STATE_POOL[i] == null) {\n                    FIND_STATE_POOL[i] = findState;\n                    break;\n                }\n            }\n        }\n        return subscriberMethods;\n    }\n\n    private FindState prepareFindState() {\n        synchronized (FIND_STATE_POOL) {\n            for (int i = 0; i \u003c POOL_SIZE; i++) {\n                FindState state = FIND_STATE_POOL[i];\n                if (state != null) {\n                    FIND_STATE_POOL[i] = null;\n                    return state;\n                }\n            }\n        }\n        return new FindState();\n    }\n\n    private SubscriberInfo getSubscriberInfo(FindState findState) {\n        if (findState.subscriberInfo != null \u0026\u0026 findState.subscriberInfo.getSuperSubscriberInfo() != null) {\n            SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();\n            if (findState.clazz == superclassInfo.getSubscriberClass()) {\n                return superclassInfo;\n            }\n        }\n        if (subscriberInfoIndexes != null) {\n            for (SubscriberInfoIndex index : subscriberInfoIndexes) {\n                SubscriberInfo info = index.getSubscriberInfo(findState.clazz);\n                if (info != null) {\n                    return info;\n                }\n            }\n        }\n        return null;\n    }\n\n    private List\u003cSubscriberMethod\u003e findUsingReflection(Class\u003c?\u003e subscriberClass) {\n        FindState findState = prepareFindState();\n        findState.initForSubscriber(subscriberClass);\n        while (findState.clazz != null) {\n            findUsingReflectionInSingleClass(findState);\n            findState.moveToSuperclass();\n        }\n        return getMethodsAndRelease(findState);\n    }\n\n    private void findUsingReflectionInSingleClass(FindState findState) {\n        Method[] methods;\n        try {\n            // This is faster than getMethods, especially when subscribers are fat classes like Activities\n            methods = findState.clazz.getDeclaredMethods();\n        } catch (Throwable th) {\n            // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149\n            try {\n                methods = findState.clazz.getMethods();\n            } catch (LinkageError error) { // super class of NoClassDefFoundError to be a bit more broad...\n                String msg = \"Could not inspect methods of \" + findState.clazz.getName();\n                if (ignoreGeneratedIndex) {\n                    msg += \". Please consider using EventBus annotation processor to avoid reflection.\";\n                } else {\n                    msg += \". Please make this class visible to EventBus annotation processor to avoid reflection.\";\n                }\n                throw new EventBusException(msg, error);\n            }\n            findState.skipSuperClasses = true;\n        }\n        for (Method method : methods) {\n            int modifiers = method.getModifiers();\n            if ((modifiers \u0026 Modifier.PUBLIC) != 0 \u0026\u0026 (modifiers \u0026 MODIFIERS_IGNORE) == 0) {\n                Class\u003c?\u003e[] parameterTypes = method.getParameterTypes();\n                if (parameterTypes.length == 1) {\n                    Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);\n                    if (subscribeAnnotation != null) {\n                        Class\u003c?\u003e eventType = parameterTypes[0];\n                        if (findState.checkAdd(method, eventType)) {\n                            ThreadMode threadMode = subscribeAnnotation.threadMode();\n                            findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,\n                                    subscribeAnnotation.priority(), subscribeAnnotation.sticky()));\n                        }\n                    }\n                } else if (strictMethodVerification \u0026\u0026 method.isAnnotationPresent(Subscribe.class)) {\n                    String methodName = method.getDeclaringClass().getName() + \".\" + method.getName();\n                    throw new EventBusException(\"@Subscribe method \" + methodName +\n                            \"must have exactly 1 parameter but has \" + parameterTypes.length);\n                }\n            } else if (strictMethodVerification \u0026\u0026 method.isAnnotationPresent(Subscribe.class)) {\n                String methodName = method.getDeclaringClass().getName() + \".\" + method.getName();\n                throw new EventBusException(methodName +\n                        \" is a illegal @Subscribe method: must be public, non-static, and non-abstract\");\n            }\n        }\n    }\n\n    static void clearCaches() {\n        METHOD_CACHE.clear();\n    }\n\n    static class FindState {\n        final List\u003cSubscriberMethod\u003e subscriberMethods = new ArrayList\u003c\u003e();\n        final Map\u003cClass, Object\u003e anyMethodByEventType = new HashMap\u003c\u003e();\n        final Map\u003cString, Class\u003e subscriberClassByMethodKey = new HashMap\u003c\u003e();\n        final StringBuilder methodKeyBuilder = new StringBuilder(128);\n\n        Class\u003c?\u003e subscriberClass;\n        Class\u003c?\u003e clazz;\n        boolean skipSuperClasses;\n        SubscriberInfo subscriberInfo;\n\n        void initForSubscriber(Class\u003c?\u003e subscriberClass) {\n            this.subscriberClass = clazz = subscriberClass;\n            skipSuperClasses = false;\n            subscriberInfo = null;\n        }\n\n        void recycle() {\n            subscriberMethods.clear();\n            anyMethodByEventType.clear();\n            subscriberClassByMethodKey.clear();\n            methodKeyBuilder.setLength(0);\n            subscriberClass = null;\n            clazz = null;\n            skipSuperClasses = false;\n            subscriberInfo = null;\n        }\n\n        boolean checkAdd(Method method, Class\u003c?\u003e eventType) {\n            // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required.\n            // Usually a subscriber doesn't have methods listening to the same event type.\n            Object existing = anyMethodByEventType.put(eventType, method);\n            if (existing == null) {\n                return true;\n            } else {\n                if (existing instanceof Method) {\n                    if (!checkAddWithMethodSignature((Method) existing, eventType)) {\n                        // Paranoia check\n                        throw new IllegalStateException();\n                    }\n                    // Put any non-Method object to \"consume\" the existing Method\n                    anyMethodByEventType.put(eventType, this);\n                }\n                return checkAddWithMethodSignature(method, eventType);\n            }\n        }\n\n        private boolean checkAddWithMethodSignature(Method method, Class\u003c?\u003e eventType) {\n            methodKeyBuilder.setLength(0);\n            methodKeyBuilder.append(method.getName());\n            methodKeyBuilder.append('\u003e').append(eventType.getName());\n\n            String methodKey = methodKeyBuilder.toString();\n            Class\u003c?\u003e methodClass = method.getDeclaringClass();\n            Class\u003c?\u003e methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);\n            if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) {\n                // Only add if not already found in a sub class\n                return true;\n            } else {\n                // Revert the put, old class is further down the class hierarchy\n                subscriberClassByMethodKey.put(methodKey, methodClassOld);\n                return false;\n            }\n        }\n\n        void moveToSuperclass() {\n            if (skipSuperClasses) {\n                clazz = null;\n            } else {\n                clazz = clazz.getSuperclass();\n                String clazzName = clazz.getName();\n                // Skip system classes, this degrades performance.\n                // Also we might avoid some ClassNotFoundException (see FAQ for background).\n                if (clazzName.startsWith(\"java.\") || clazzName.startsWith(\"javax.\") ||\n                        clazzName.startsWith(\"android.\") || clazzName.startsWith(\"androidx.\")) {\n                    clazz = null;\n                }\n            }\n        }\n    }\n}\n```\n\n在它的构造方法里，`subscriberInfoIndexes` 里面只有注解解释器生成的 `MyEventBusIndex` 对象，其他两个参数都是默认值 false。\n\n先看看 `findSubscriberMethods(subscriberClass)` 是如何完成 `@Subscribe` 方法的解析的：\n\n```java\nList\u003cSubscriberMethod\u003e findSubscriberMethods(Class\u003c?\u003e subscriberClass) {\n    // 1、如果能获取缓存，直接返回\n    List\u003cSubscriberMethod\u003e subscriberMethods = METHOD_CACHE.get(subscriberClass);\n    if (subscriberMethods != null) {\n        return subscriberMethods;\n    }\n\n    // 2、判断是否忽略索引\n    if (ignoreGeneratedIndex) {\n        // 使用反射来获取事件回调方法\n        subscriberMethods = findUsingReflection(subscriberClass);\n    } else {\n        // 尝试从索引文件获取事件回调方法\n        subscriberMethods = findUsingInfo(subscriberClass);\n    }\n    if (subscriberMethods.isEmpty()) {\n        throw new EventBusException(\"Subscriber \" + subscriberClass\n                + \" and its super classes have no public methods with the @Subscribe annotation\");\n    } else {\n        // 3、写入缓存\n        METHOD_CACHE.put(subscriberClass, subscriberMethods);\n        return subscriberMethods;\n    }\n}\n```\n\n注释 1 处是取缓存的操作。页面的生命周期可能会频繁发生变化，因而就可能导致事件的频繁注册、注销，这时候缓存就非常有用了。\n\n注释 2 处，由于 `ignoreGeneratedIndex` 默认为 false，所以这里会执行 `findUsingInfo` 方法来获取订阅类的回调方法。\n\n注释 3 在方法最后返回之前，会进行缓存的更新。\n\n先分析一下 `findUsingInfo` 方法。\n\n#### SubscriberMethodFinder.findUsingInfo()\n\n```java\nprivate List\u003cSubscriberMethod\u003e findUsingInfo(Class\u003c?\u003e subscriberClass) {\n    FindState findState = prepareFindState();\n    findState.initForSubscriber(subscriberClass);\n    // 开启循环\n    while (findState.clazz != null) {\n        // 获取目标方法\n        findState.subscriberInfo = getSubscriberInfo(findState);\n        if (findState.subscriberInfo != null) {\n            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n            for (SubscriberMethod subscriberMethod : array) {\n                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                    findState.subscriberMethods.add(subscriberMethod);\n                }\n            }\n        } else {\n            findUsingReflectionInSingleClass(findState);\n        }\n        // 在父类中查找目标方法\n        findState.moveToSuperclass();\n    }\n    return getMethodsAndRelease(findState);\n}\n```\n\n##### SubscriberMethodFinder.prepareFindState()\n\n```java\nprivate FindState prepareFindState() {\n    synchronized (FIND_STATE_POOL) {\n        for (int i = 0; i \u003c POOL_SIZE; i++) {\n            FindState state = FIND_STATE_POOL[i];\n            if (state != null) {\n                FIND_STATE_POOL[i] = null;\n                return state;\n            }\n        }\n    }\n    return new FindState();\n}\n```\n\n通过 `prepareFindState()` 方法尝试从对象池中获取一个 `FindState` 对象，若对象池中没有可用的对象，则新建一个。\n\n##### FindState.initForSubscriber()\n\n```java\nvoid initForSubscriber(Class\u003c?\u003e subscriberClass) {\n    this.subscriberClass = clazz = subscriberClass;\n    skipSuperClasses = false;\n    subscriberInfo = null;\n}\n```\n\n初始化 `FindState` 对象，使其内部的 `subscriberClass`、`clazz` 都是订阅类，并且注意这时候 `subscriberInfo = null`、`skipSuperClasses = false`。\n\n接着查看 `getSubscriberInfo()` 方法：\n\n##### SubscriberMethodFinder.getSubscriberInfo()\n\n```java\nprivate SubscriberInfo getSubscriberInfo(FindState findState) {\n    if (findState.subscriberInfo != null \u0026\u0026 findState.subscriberInfo.getSuperSubscriberInfo() != null) {\n        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();\n        if (findState.clazz == superclassInfo.getSubscriberClass()) {\n            return superclassInfo;\n        }\n    }\n    if (subscriberInfoIndexes != null) {\n        for (SubscriberInfoIndex index : subscriberInfoIndexes) {\n            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);\n            if (info != null) {\n                return info;\n            }\n        }\n    }\n    return null;\n}\n```\n\n这里首先会通过 FindState 去父类中。。。\n\n但是这里 `findState.subscriberInfo` 是为 null 的，因此不满足条件，接下来会判断 subscriberInfoIndexes（本例中只包含创建 EventBus 对象时传入的 MyEventBusIndex 对象）集合是否为空，如果不为空就会通过 Index 类去查找目标方法。\n\n再次回到 `findUsingInfo()` 方法，可以看到，如果没有找到目标回调方法，也会调用 `findUsingReflectionInSingleClass()` 使用来获取回调方法。因此，`findUsingInfo()` 等于是 `findUsingReflection()` 方法的加强版本。\n\n后面的 while 循环就是从当前的订阅类开始，一直向父类进行循环操作，也就是说，\u003cstrong\u003e这里会解析当前订阅类的父类里面的方法\u003c/strong\u003e。\n\n如果找到目标回调方法，在通过 `findState.checkAdd()` 校验之后，事件回调方法都被加入到了 `findState.subscriberMethods` 中，然后由 `getMethodsAndRelease(findState)` 方法返回。`getMethodsAndRelease()` 方法就是将 `findState.subscriberMethods` 复制了出来，然后回收了 FindState 对象：\n\n```java\nprivate List\u003cSubscriberMethod\u003e getMethodsAndRelease(FindState findState) {\n    // 1\n    List\u003cSubscriberMethod\u003e subscriberMethods = new ArrayList\u003c\u003e(findState.subscriberMethods);\n    // 2\n    findState.recycle();\n    // 3\n    synchronized(FIND_STATE_POOL) {\n        for (int i = 0; i \u003c POOL_SIZE; i++) {\n            if (FIND_STATE_POOL[i] == null) {\n                FIND_STATE_POOL[i] = findState;\n                break;\n            }\n        }\n    }\n    return subscriberMethods;\n}\n```\n\n首先会从 findState 中取出了保存的 subscriberMethods；然后将 findState 里的保存的所有对象进行回收；接着会把把 findState 存储在 FindState 池中方便下一次使用，以提高性能。最后，返回 subscriberMethods。\n\n#### SubscriberMethodFinder.findUsingReflection()\n\n上面就是注解处理器生成的 Index 参与的时候的流程。在这里还是有必要说一下没有 Index 参与时的流程，也就是 `findUsingReflectionInSingleClass()` 方法是如何获取订阅类的回调方法的。\n\n```java\nprivate List\u003cSubscriberMethod\u003e findUsingReflection(Class\u003c?\u003e subscriberClass) {\n    FindState findState = prepareFindState();\n    findState.initForSubscriber(subscriberClass);\n    while (findState.clazz != null) {\n        findUsingReflectionInSingleClass(findState);\n        findState.moveToSuperclass();\n    }\n    return getMethodsAndRelease(findState);\n}\n```\n\n这里同样走到了 `findUsingReflectionInSingleClass()`：\n\n```java\nprivate void findUsingReflectionInSingleClass(FindState findState) {\n    Method[] methods;\n    try {\n        // This is faster than getMethods, especially when subscribers are fat classes like Activities\n        // 获取该类的所有方法，不包括父类\n        methods = findState.clazz.getDeclaredMethods();\n    } catch (Throwable th) {\n        // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149\n        try {\n            // 获取该类以及父类的所有 public 方法，同时指定忽略父类\n            methods = findState.clazz.getMethods();\n        } catch (LinkageError error) { // super class of NoClassDefFoundError to be a bit more broad...\n            String msg = \"Could not inspect methods of \" + findState.clazz.getName();\n            if (ignoreGeneratedIndex) {\n                msg += \". Please consider using EventBus annotation processor to avoid reflection.\";\n            } else {\n                msg += \". Please make this class visible to EventBus annotation processor to avoid reflection.\";\n            }\n            throw new EventBusException(msg, error);\n        }\n        // 标记为跳过父类方法\n        findState.skipSuperClasses = true;\n    }\n    for (Method method : methods) {\n        int modifiers = method.getModifiers();\n        // 判断方法是否是 PUBLIC 且不是 ABSTRACT、STATIC、SYNTHETIC\n        if ((modifiers \u0026 Modifier.PUBLIC) != 0 \u0026\u0026 (modifiers \u0026 MODIFIERS_IGNORE) == 0) {\n            Class\u003c?\u003e[] parameterTypes = method.getParameterTypes();\n            // 判断该方法的参数是不是只有一个\n            if (parameterTypes.length == 1) {\n                // 判断方法是否有 Subscribe 注解\n                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);\n                if (subscribeAnnotation != null) {\n                    // 以上条件都满足后，就进行最后的校验，然后添加到 findState.subscriberMethods 中\n                    Class\u003c?\u003e eventType = parameterTypes[0];\n                    if (findState.checkAdd(method, eventType)) {\n                        ThreadMode threadMode = subscribeAnnotation.threadMode();\n                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,\n                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));\n                    }\n                }\n            } else if (strictMethodVerification \u0026\u0026 method.isAnnotationPresent(Subscribe.class)) {\n                // 方法参数 ！= 1,如果开启了严格验证则抛出异常\n                String methodName = method.getDeclaringClass().getName() + \".\" + method.getName();\n                throw new EventBusException(\"@Subscribe method \" + methodName +\n                        \"must have exactly 1 parameter but has \" + parameterTypes.length);\n            }\n        } else if (strictMethodVerification \u0026\u0026 method.isAnnotationPresent(Subscribe.class)) {\n            // 方法修饰符不合要求，如果开启了严格验证，则抛出异常\n            String methodName = method.getDeclaringClass().getName() + \".\" + method.getName();\n            throw new EventBusException(methodName +\n                    \" is a illegal @Subscribe method: must be public, non-static, and non-abstract\");\n        }\n    }\n}\n```\n\n这个方法大概分为两部分：\n\n1. 首先通过反射的方式获取订阅者类中的所有声明方法，然后在这些方法里面寻找以 `@Subscribe` 作为注解的方法进行处理。\n2. 再经过经过一轮检查，看看 `findState.subscriberMethods` 是否存在，如果没有，将方法名、threadMode、优先级、是否为 sticky 方法等信息封装到 SubscriberMethod 对象中，最后添加到 subscriberMethods 列表中。\n\n从上面方法的分析我们可以看出，订阅类的方法要满足以下条件，才能够顺利的进行注册：\n\n1. 方法必须是 `public` 的，且不能是 `abstract`、`static`、`synthetic` 的\n2. 方法参数必须只有一个\n3. 方法必须带有 `@Subscribe` 注解\n\n### EventBus.subscribe()\n\n上面这些内容就是订阅类回调方法的获取过程了，下面说说回调方法是如何进行注册的。方法为 `EventBus.subscribe()`：\n\n```java\n// Must be called in synchronized block\nprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {\n    // eventType 为回调方法的入参类型，Object 类型\n    Class\u003c?\u003e eventType = subscriberMethod.eventType;\n    // 将订阅者以及订阅方法封装为一个 Subscription 类\n    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);\n    \n    CopyOnWriteArrayList\u003cSubscription\u003e subscriptions = subscriptionsByEventType.get(eventType);\n    if (subscriptions == null) {\n        subscriptions = new CopyOnWriteArrayList\u003c\u003e();\n        // subscriptionsByEventType：以订阅方法的参数为 key，\n        // Subscription 为 value 进行保存\n        subscriptionsByEventType.put(eventType, subscriptions);\n    } else {\n        if (subscriptions.contains(newSubscription)) {\n            throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \"\n                    + eventType);\n        }\n    }\n\n    // 在订阅参数对应的 Subscription 列表中按照订阅方法的优先级进行排序\n    // priority 的数值越高，越在列表的前面；相同 priority 的方法，后来的方法会在后面\n    int size = subscriptions.size();\n    for (int i = 0; i \u003c= size; i++) {\n        if (i == size || subscriberMethod.priority \u003e subscriptions.get(i).subscriberMethod.priority) {\n            subscriptions.add(i, newSubscription);\n            break;\n        }\n    }\n\n    // 从 typesBySubscriber 中获取\n    List\u003cClass\u003c?\u003e\u003e subscribedEvents = typesBySubscriber.get(subscriber);\n    if (subscribedEvents == null) {\n        subscribedEvents = new ArrayList\u003c\u003e();\n        // typesBySubscriber：以订阅者为 key，订阅方法参数为 value 进行保存\n        typesBySubscriber.put(subscriber, subscribedEvents);\n    }\n    subscribedEvents.add(eventType);\n\n    // 如果订阅方法订阅的是粘性事件，则会在注册时接受到此粘性事件\n    if (subscriberMethod.sticky) {\n        if (eventInheritance) {\n            // Existing sticky events of all subclasses of eventType have to be considered.\n            // Note: Iterating over all events may be inefficient with lots of sticky events,\n            // thus data structure should be changed to allow a more efficient lookup\n            // (e.g. an additional map storing sub classes of super classes: Class -\u003e List\u003cClass\u003e).\n            Set\u003cMap.Entry\u003cClass\u003c?\u003e, Object\u003e\u003e entries = stickyEvents.entrySet();\n            for (Map.Entry\u003cClass\u003c?\u003e, Object\u003e entry : entries) {\n                Class\u003c?\u003e candidateEventType = entry.getKey();\n                if (eventType.isAssignableFrom(candidateEventType)) {\n                    Object stickyEvent = entry.getValue();\n                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n                }\n            }\n        } else {\n            Object stickyEvent = stickyEvents.get(eventType);\n            checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n        }\n    }\n}\n```\n\n在上面的方法中，会先将订阅者以及订阅事件包装成为一个 `Subscription` 对象，然后与其他参数一起保存起来，具体为下面两个保存的地方：\n\n- `subscriptionsByEventType`：以订阅事件参数为 key，对应 `Subscription` 对象数组\n- `typesBySubscriber`：以订阅者对象为 key，对应订阅事件参数数组。主要是在 EventBus 的 `isRegister()` 方法中去使用的，用来判断这个 Subscriber 对象 是否已被注册过。\n\n另外，Subscription 对象还会根据 priority 进行排序，具体来说：priority 的数值越高，越在列表的前面；相同 priority 的方法，后来的方法会在后面。\n\n同时我们还可以看出粘性事件的触发机制：\n\n1. 粘性事件发出时，会主动通知所有可以处理的方法，不管方法是否是粘性的\n\n```java\npublic void postSticky(Object event) {\n    synchronized (stickyEvents) {\n        stickyEvents.put(event.getClass(), event);\n    }\n    // Should be posted after it is putted, in case the subscriber wants to remove immediately\n    post(event);\n}\n```\n\n2. 在订阅者进行注册时，如果有可以响应的粘性事件，粘性方法会被触发\n\n```javascript\nif (subscriberMethod.sticky) {\n    if (eventInheritance) {\n        ...\n        for (...) {\n             ...\n            if (...) {\n                Object stickyEvent = entry.getValue();\n                checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n            }\n        }\n    } else {\n        Object stickyEvent = stickyEvents.get(eventType);\n        checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n    }\n}\n```\n\n## post 流程\n\n我们可以调用 `EventBus.post()` 以及 `EventBus.postSticky()` 这两个方法来发送事件，前者是普通事件，后者是粘性事件。\n\n粘性事件的发送比较简单，该方法除了保存了事件之外，还调用了 `post` 方法当做非粘性事件进行了分发。此时，会主动通知所有可以处理的方法，不管方法是否是粘性的：\n\n```java\npublic void postSticky(Object event) {\n    synchronized (stickyEvents) {\n        stickyEvents.put(event.getClass(), event);\n    }\n    // Should be posted after it is putted, in case the subscriber wants to remove immediately\n    post(event);\n}\n```\n\n另外，前面提到过，在订阅者进行注册时，如果有可以响应的粘性事件，粘性方法会被触发。\n\n粘性事件不会被消耗掉，除非手动 remove 掉：\n\n- `removeStickyEvent(Class\u003cT\u003e)`\n- `removeStickyEvent(Object)`\n- `removeAllStickyEvents()`\n\n接下来，我们看看 `EventBus.post()` 是如何触发订阅者的回调事件的。\n\n```java\n/** For ThreadLocal, much faster to set (and get multiple values). */\nfinal static class PostingThreadState {\n    final List\u003cObject\u003e eventQueue = new ArrayList\u003c\u003e();\n    boolean isPosting;\n    boolean isMainThread;\n    Subscription subscription;\n    Object event;\n    boolean canceled;\n}\n\nprivate final ThreadLocal\u003cPostingThreadState\u003e currentPostingThreadState = new ThreadLocal\u003cPostingThreadState\u003e() {\n    @Override\n    protected PostingThreadState initialValue() {\n        return new PostingThreadState();\n    }\n};\n\n/** Posts the given event to the event bus. */\npublic void post(Object event) {\n    PostingThreadState postingState = currentPostingThreadState.get();\n    List\u003cObject\u003e eventQueue = postingState.eventQueue;\n    eventQueue.add(event);\n\n    if (!postingState.isPosting) {\n        postingState.isMainThread = isMainThread();\n        postingState.isPosting = true;\n        if (postingState.canceled) {\n            throw new EventBusException(\"Internal error. Abort state was not reset\");\n        }\n        try {\n            while (!eventQueue.isEmpty()) {\n                postSingleEvent(eventQueue.remove(0), postingState);\n            }\n        } finally {\n            postingState.isPosting = false;\n            postingState.isMainThread = false;\n        }\n    }\n}\n```\n\n首先会调用 `currentPostingThreadState.get()` 获取一个 PostingThreadState 对象， currentPostingThreadState 是一个 ThreadLocal 类型的对象，而 PostingThreadState 中包含了一个 eventQueue 和其他一些标志位。\n\n接着把传入的 event，保存到了当前线程中的一个变量 PostingThreadState 的 eventQueue 事件队列里面，然后开始执行。当在极短时间内多次调用 `post` 方法时，只会将事件添加到队列里面，第 24 行的代码不成立。而在 31-33 行代码里面，会取时间队列的头进行事件分发。最后所有事件处理完成后，标志位复位。\n\n下面我们看看 `postSingleEvent()` 方法，注释都在里面：\n\n```java\nprivate void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n    Class\u003c?\u003e eventClass = event.getClass();\n    boolean subscriptionFound = false;\n    // eventInheritance 表示事件接收类是否有层次结构\n    if (eventInheritance) {\n        // lookupAllEventTypes 方法的作用是查询 class 的父类以及接口\n        // 显然示例中就是一个 Object\n        List\u003cClass\u003c?\u003e\u003e eventTypes = lookupAllEventTypes(eventClass);\n        int countTypes = eventTypes.size();\n        for (int h = 0; h \u003c countTypes; h++) {\n            Class\u003c?\u003e clazz = eventTypes.get(h);\n            // 调用 postSingleEventForEventType 方法\n            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);\n        }\n    } else {\n        // 直接以当前的 eventClass 调用 postSingleEventForEventType 方法\n        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n    }\n    // 最后，当没有订阅者可以处理该事件时，EventBus 会抛出一个 NoSubscriberEvent 事件\n    if (!subscriptionFound) {\n        if (logNoSubscriberMessages) {\n            logger.log(Level.FINE, \"No subscribers registered for event \" + eventClass);\n        }\n        if (sendNoSubscriberEvent \u0026\u0026 eventClass != NoSubscriberEvent.class \u0026\u0026\n                eventClass != SubscriberExceptionEvent.class) {\n            post(new NoSubscriberEvent(this, event));\n        }\n    }\n}\n```\n\nlookupAllEventTypes 方法的作用就是取出 Event 及其父类和接口的 class 列表，当然重复取的话会影响性能，所以它也做了一个 eventTypesCache 的缓存。\n\n接着看看 `postSingleEventForEventType` 方法\n\n```java\nprivate boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class\u003c?\u003e eventClass) {\n    // subscriptions 就是示例中对应订阅方法\n    CopyOnWriteArrayList\u003cSubscription\u003e subscriptions;\n    synchronized (this) {\n        subscriptions = subscriptionsByEventType.get(eventClass);\n    }\n    if (subscriptions != null \u0026\u0026 !subscriptions.isEmpty()) {\n        for (Subscription subscription : subscriptions) {\n            postingState.event = event;\n            postingState.subscription = subscription;\n            boolean aborted = false;\n            try {\n                // 调用 postToSubscription 进行真正的分发\n                postToSubscription(subscription, event, postingState.isMainThread);\n                aborted = postingState.canceled;\n            } finally {\n                postingState.event = null;\n                postingState.subscription = null;\n                postingState.canceled = false;\n            }\n            if (aborted) {\n                break;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n```\n\n首先，根据 Event 类型从 subscriptionsByEventType 中取出对应的 subscriptions 对象，最后调用了 `postToSubscription()` 方法。这里需要注意一个细节，只要 eventClass 可以找到对应的 Subscription，那么该方法就会返回 true，也就是说已经发送给订阅者了。\n\n最后看看 `postToSubscription()` 方法，该方法会根据方法的 threaMode 值，决定在哪如何触发回调方法：\n\n```java\nprivate void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n    switch (subscription.subscriberMethod.threadMode) {\n        case POSTING:\n            invokeSubscriber(subscription, event);\n            break;\n        case MAIN:\n            if (isMainThread) {\n                invokeSubscriber(subscription, event);\n            } else {\n                mainThreadPoster.enqueue(subscription, event);\n            }\n            break;\n        case MAIN_ORDERED:\n            if (mainThreadPoster != null) {\n                mainThreadPoster.enqueue(subscription, event);\n            } else {\n                // temporary: technically not correct as poster not decoupled from subscriber\n                invokeSubscriber(subscription, event);\n            }\n            break;\n        case BACKGROUND:\n            if (isMainThread) {\n                backgroundPoster.enqueue(subscription, event);\n            } else {\n                invokeSubscriber(subscription, event);\n            }\n            break;\n        case ASYNC:\n            asyncPoster.enqueue(subscription, event);\n            break;\n        default:\n            throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode);\n    }\n}\n```\n\n这里面 5 种 ThreadMode，采取的手段也不一样。从该枚举值的定义可以看出，分为 5 种情况，下表就是每种情况的含义：\n\n无论在哪个线程中执行，最后都会调用 `invokeSubscriber` 方法来触发回调任务：\n\n```javascript\nvoid invokeSubscriber(Subscription subscription, Object event) {\n    try {\n        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);\n    } catch (InvocationTargetException e) {\n        handleSubscriberException(subscription, event, e.getCause());\n    } catch (IllegalAccessException e) {\n        throw new IllegalStateException(\"Unexpected exception\", e);\n    }\n}\n```\n\n这里通过反射调用了订阅者的回调方法。至此，事件的发送已经分析完毕。\n\n## unregister 流程\n\n注销过程原理比较简单，就是将注册时保存到 `subscriptionsByEventType`、`typesBySubscriber` 两个集合中的元素删除。\n\n这两个集合在注册过程中分析过：\n\n- `subscriptionsByEventType` 以订阅事件参数为 key，对应 Subscription 对象数组\n- `typesBySubscriber` 以订阅者对象为 key，对应订阅事件参数数组\n\n`EventBus.unregister()` 代码如下：\n\n```java\n/** Unregisters the given subscriber from all event classes. */\npublic synchronized void unregister(Object subscriber) {\n    // 先通过 subscriber 订阅者对象从`typesBySubscriber`中获取订阅事件参数数组\n    List\u003cClass\u003c?\u003e\u003e subscribedTypes = typesBySubscriber.get(subscriber);\n    if (subscribedTypes != null) {\n        // 以订阅事件参数为 key，从`subscriptionsByEventType`中获取到对应的`Subscrition`对象\n        for (Class\u003c?\u003e eventType : subscribedTypes) {\n            unsubscribeByEventType(subscriber, eventType);\n        }\n        typesBySubscriber.remove(subscriber);\n    } else {\n        logger.log(Level.WARNING, \"Subscriber to unregister was not registered before: \" + subscriber.getClass());\n    }\n}\n\n/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */\nprivate void unsubscribeByEventType(Object subscriber, Class\u003c?\u003e eventType) {\n    List\u003cSubscription\u003e subscriptions = subscriptionsByEventType.get(eventType);\n    if (subscriptions != null) {\n        int size = subscriptions.size();\n        for (int i = 0; i \u003c size; i++) {\n            Subscription subscription = subscriptions.get(i);\n            if (subscription.subscriber == subscriber) {\n                subscription.active = false;\n                subscriptions.remove(i);\n                i--;\n                size--;\n            }\n        }\n    }\n}\n```\n\n先通过 subscriber 订阅者对象从 `typesBySubscriber` 中获取订阅事件参数数组；然后以订阅事件参数为 key，从 `subscriptionsByEventType` 中获取到对应的 `Subscrition` 对象。\n\n以上就是 EventBus 的注销过程了。\n\n## 跨进程 EventBus\n\n跨进程 EventBus 的难点在于如何将一个进程中的事件传递到另一个进程中，技术点还是离不来 IPC 的几种常用方式，这里比较实用的是 AIDL 方式。\n\n下面先简单的说一下原理： 1. 弄一个主进程的 Service 作为消息中心，用来向各个进程转发事件 2. 主进程和子进程在初始化的时候都绑定到该 Service 上面，这样就得到了各进程向消息中心 Service 发送消息的通道 3. 在绑定到 Service 后，各个进程向 Service 注册本进程的消息转发器，这样消息中心 Service 就可以对各进程发送消息了，至此 C/S 之间双向的联系通道已经打通\n\n下面分别考虑一下消息的传递，可以分为三种情况讨论。 1. 主进程向子进程的通信：获取主进程 Service 中各个进程（包括主进程自己）的消息转发器，依次转发消息 2. 子进程和主进程的通信：通过初始化绑定到 Service 时获取到的 Service 代理对象，向 Service 发送消息。Service 收到消息后，会向各个进程的消息转发器依次转发消息，这样主进程以及所有子进程都会收到消息 3. 子进程和子进程的通信：先发送到主进程，主进程会进行转发。\n\n注意这里，主进程 Service 持有主进程以及所有子进程的消息转发器，这里不对主进程进行特别处理。此外，所有的事件都会由 Service 进行分发，Service 分发时会对主进程和所有子进程进行分发。\n\n也就是说，如果子进程内部调用了跨进程 EventBus 进行事件分发的话，会在两次 IPC 之后再由改子进程内部的 EventBus 进行触发。这两次 IPC 是：子进程向主进程 Service 发出消息，主进程 Service 接收到消息后向所有进程进行分发。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/EventBus/clipboard_20230323_031638.png)\n\n### 简单实现\n\n文件清单如下：\n\n1. 服务端：IEventBusManager.aidl\n2. 客户端：IEventDispatcher.aidl\n3. 传输的事件：IPCEvent.java、IPCEvent.aidl\n4. 核心类：IPCEventBus.kt\n\n\u003cstrong\u003esrc/main/aidl/xyz/yorek/eventbus/IEventBusManager.aidl\u003c/strong\u003e\n\n```java\n// IEventBusManager.aidl\npackage xyz.yorek.eventbus;\n\nimport xyz.yorek.eventbus.IEventDispatcher;\nimport xyz.yorek.eventbus.IPCEvent;\n\ninterface IEventBusManager {\n    void register(IEventDispatcher dispatcher);\n\n    void unregister(IEventDispatcher dispatcher);\n\n    /** 向主进程发送Event */\n    void postToService(in IPCEvent event);\n}\n```\n\n\u003cstrong\u003esrc/main/aidl/xyz/yorek/eventbus/IEventDispatcher.aidl\u003c/strong\u003e\n\n```java\n// IEventDispatcher.aidl\npackage xyz.yorek.eventbus;\n\nimport xyz.yorek.eventbus.IPCEvent;\n\ninterface IEventDispatcher {\n    /** 接收其他进程发送过来的Event */\n    void dispatch(in IPCEvent event);\n}\n```\n\n\u003cstrong\u003esrc/main/aidl/xyz/yorek/eventbus/IPCEvent.aidl\u003c/strong\u003e\n\n```css\n// IPCEvent.aidl\npackage xyz.yorek.eventbus;\n\nparcelable IPCEvent;\n```\n\n\u003cstrong\u003esrc/main/java/xyz/yorek/eventbus/IPCEvent.java\u003c/strong\u003e\n\n```typescript\npublic class IPCEvent implements Parcelable {\n    public int code;\n    public String msg;\n\n    public IPCEvent() {}\n\n    public IPCEvent(int code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    protected IPCEvent(Parcel in) {\n        this.code = in.readInt();\n        this.msg = in.readString();\n    }\n\n    @Override\n    public String toString() {\n        return \"IPCEvent{\" +\n                \"code=\" + code +\n                \", msg='\" + msg + '\\'' +\n                '}';\n    }\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n    @Override\n    public void writeToParcel(Parcel dest, int flags) {\n        dest.writeInt(this.code);\n        dest.writeString(this.msg);\n    }\n\n    public static final Creator\u003cIPCEvent\u003e CREATOR = new Creator\u003cIPCEvent\u003e() {\n        @Override\n        public IPCEvent createFromParcel(Parcel source) {\n            return new IPCEvent(source);\n        }\n\n        @Override\n        public IPCEvent[] newArray(int size) {\n            return new IPCEvent[size];\n        }\n    };\n}\n```\n\n\u003cstrong\u003esrc/main/java/xyz/yorek/eventbus/IPCEventBus.kt\u003c/strong\u003e\n\n内含一个内部类 `EventBusManagerService`，管理所有进程的事件转发器。\n\n需要注意一下这里面的 `RemoteCallbackList` 的独特用法\n\n```kotlin\nobject IPCEventBus {\n    // 本进程的事件分发器，服务端向本进程客户端发送数据\n    private val mEventDispatcher = object : IEventDispatcher.Stub() {\n        override fun dispatch(event: IPCEvent?) {\n            EventBus.getDefault().post(event)\n        }\n    }\n\n    // 本进程获取的服务端代理，可以向服务端注册事件分发器，还可以发送数据\n    private var mEventBusManagerService: IEventBusManager? = null\n    private val mServiceConnection = object : ServiceConnection {\n        override fun onServiceDisconnected(name: ComponentName?) {\n            mEventBusManagerService = null\n        }\n\n        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n            service ?: return\n            mEventBusManagerService = IEventBusManager.Stub.asInterface(service)\n\n            mEventBusManagerService?.register(mEventDispatcher)\n        }\n    }\n\n    /**\n     * 初始化方法\n     */\n    fun init(context: Application) {\n        this.app = context\n\n        val intent = Intent(app, EventBusManagerService::class.java)\n        app.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE)\n    }\n\n    /**\n     * 销毁方法，进程不需要时调用\n     */\n    fun destory() {\n        if (mEventBusManagerService?.asBinder()?.isBinderAlive == true) {\n            mEventBusManagerService?.unregister(mEventDispatcher)\n            app.unbindService(mServiceConnection)\n        }\n    }\n\n    fun register(any: Any) {\n        EventBus.getDefault().register(any)\n    }\n\n    fun unregister(any: Any) {\n        EventBus.getDefault().unregister(any)\n    }\n\n    /**\n     * 向服务端发送数据，经过服务端转发到各个进程（包括主进程）\n     */\n    fun post(event: IPCEvent?) {\n        mEventBusManagerService?.postToService(event)\n    }\n\n    private lateinit var app: Application\n\n    /**\n     * 服务端\n     */\n    class EventBusManagerService : Service() {\n        // 各个进程的事件分发器\n        private val mDispatchers = RemoteCallbackList\u003cIEventDispatcher\u003e()\n        // 服务端实现\n        private val mEventBusManagerService = object : IEventBusManager.Stub() {\n            override fun register(dispatcher: IEventDispatcher?) {\n                dispatcher ?: return\n                mDispatchers.register(dispatcher)\n            }\n\n            override fun unregister(dispatcher: IEventDispatcher?) {\n                dispatcher ?: return\n                mDispatchers.unregister(dispatcher)\n            }\n\n            override fun postToService(event: IPCEvent?) {\n                dispatchEvent(event)\n            }\n        }\n\n        override fun onBind(intent: Intent?) = mEventBusManagerService\n\n        /**\n         * 分发事件到各个进程\n         */\n        private fun dispatchEvent(event: IPCEvent?) {\n            val n = mDispatchers.beginBroadcast()\n\n            for (i in 0 until n) {\n                val dispatcher = mDispatchers.getBroadcastItem(i)\n                dispatcher.dispatch(event)\n            }\n\n            mDispatchers.finishBroadcast()\n        }\n    }\n}\n```\n\n### 使用示例\n\n我们首先在 AndroidMenifest 中注册一下 `IPCEventBus$EventBusManagerService`；顺便注册一下三个在不同进程的 Activity，方便我们测试：\n\n```html\n\u003c!-- 主进程的Activity --\u003e\n\u003cactivity android:name=\".MainActivity\"\u003e\n    \u003cintent-filter\u003e\n        \u003caction android:name=\"android.intent.action.VIEW\" /\u003e\n        \u003caction android:name=\"android.intent.action.MAIN\" /\u003e\n\n        \u003ccategory android:name=\"android.intent.category.LAUNCHER\" /\u003e\n    \u003c/intent-filter\u003e\n\u003c/activity\u003e\n\u003c!-- 子进程1的Activity --\u003e\n\u003cactivity android:name=\".SecondActivity\" android:process=\":second\" /\u003e\n\u003c!-- 子进程2的Activity --\u003e\n\u003cactivity android:name=\".ThirdActivity\" android:process=\":third\" /\u003e\n\n\u003cservice android:name=\"xyz.yorek.eventbus.IPCEventBus$EventBusManagerService\" /\u003e\n```\n\n上面三个 Activity 引用了同样的布局文件，拥有同样的代码。唯一的区别就是三者的 TAG 不一样，用来区分发出的消息。\n\n下面是 MainActivity 的布局以及代码：\n\n\u003cstrong\u003esrc/main/res/layout/activity_main.xml\u003c/strong\u003e\n\n```xml\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003candroidx.constraintlayout.widget.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\"\u003e\n\n    \u003cButton\n        android:id=\"@+id/btnPost\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"post\"\n        android:onClick=\"post\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" /\u003e\n\n    \u003cButton\n        android:id=\"@+id/btnFirst\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"first\"\n        android:onClick=\"first\"\n        app:layout_constraintTop_toBottomOf=\"@id/btnPost\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toStartOf=\"@+id/btnSecond\"/\u003e\n\n    \u003cButton\n        android:id=\"@+id/btnSecond\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"second\"\n        android:onClick=\"second\"\n        app:layout_constraintTop_toBottomOf=\"@id/btnPost\"\n        app:layout_constraintStart_toEndOf=\"@id/btnFirst\"\n        app:layout_constraintEnd_toStartOf=\"@+id/btnThird\"/\u003e\n\n    \u003cButton\n        android:id=\"@+id/btnThird\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"third\"\n        android:onClick=\"third\"\n        app:layout_constraintTop_toBottomOf=\"@id/btnPost\"\n        app:layout_constraintStart_toEndOf=\"@id/btnSecond\"\n        app:layout_constraintEnd_toEndOf=\"parent\"/\u003e\n\n\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\n```\n\n\u003cstrong\u003eapp/src/main/java/xyz/yorek/eventbus/MainActivity.kt\u003c/strong\u003e\n\n```kotlin\nprivate const val TAG = \"MainActivity\"\n\nclass MainActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        IPCEventBus.init(application)\n        IPCEventBus.register(this)\n\n        setContentView(R.layout.activity_main)\n    }\n\n    override fun onDestroy() {\n        IPCEventBus.unregister(this)\n        super.onDestroy()\n    }\n\n    @Subscribe\n    fun onEventReceived(any: Any?) {\n        Log.e(TAG, \"receive message : $any\")\n    }\n\n    fun post(view: View) {\n        val msg = \"Hello World, from $TAG\"\n        IPCEventBus.post(IPCEvent(1, msg))\n    }\n\n    fun first(view: View) {\n        startActivity(Intent(this, MainActivity::class.java))\n    }\n\n    fun second(view: View) {\n        startActivity(Intent(this, SecondActivity::class.java))\n    }\n\n    fun third(view: View) {\n        startActivity(Intent(this, ThirdActivity::class.java))\n    }\n}\n```\n\n在 MainActivity 中我们 post 一下消息，然后进入 SecondActivity 再次 post，进入 ThirdActivity 后最后一次 post。\n\n各个进程日志如下（按照日志时间顺序）：\n\n```apache\n1569683305.912 31157-31157/xyz.yorek.eventbus E/MainActivity: receive message : IPCEvent{code=1, msg='Hello World, from MainActivity'}\n\n1569683307.622 31157-31169/xyz.yorek.eventbus E/MainActivity: receive message : IPCEvent{code=2, msg='Hello World, from SecondActivity'}\n1569683307.625 31093-31093/xyz.yorek.eventbus:second E/SecondActivity: receive message : IPCEvent{code=2, msg='Hello World, from SecondActivity'}\n\n1569683309.245 31157-31169/xyz.yorek.eventbus E/MainActivity: receive message : IPCEvent{code=3, msg='Hello World, from ThirdActivity'}\n1569683309.245 31210-31210/xyz.yorek.eventbus:third E/ThirdActivity: receive message : IPCEvent{code=3, msg='Hello World, from ThirdActivity'}\n1569683309.246 31093-31246/xyz.yorek.eventbus:second E/SecondActivity: receive message : IPCEvent{code=3, msg='Hello World, from ThirdActivity'}\n```\n\n从上面的日志来看，我们已经完成了跨进程 EventBus 的功能。\n\n下面的日志是一份详细记载了各个事件的日志。从日志的中可以看出：本进程的某线程发出的事件会由同一个线程来触发；其他进程发出的事件，会由本进程 Binder 线程池里面的线程触发。\n\n```apache\n1569683981.405 31484-31484/xyz.yorek.eventbus E/EventBusManagerService: dispatch begin : main\n1569683981.405 31484-31484/xyz.yorek.eventbus E/MainActivity: receive message : main IPCEvent{code=1, msg='Hello World, from MainActivity'}\n1569683981.406 31484-31484/xyz.yorek.eventbus E/EventBusManagerService: dispatch end : main\n1569683981.406 31484-31484/xyz.yorek.eventbus E/MainActivity: post message done : main\n\n1569684013.794 31484-31526/xyz.yorek.eventbus E/EventBusManagerService: dispatch begin : Binder:31484_1\n1569684013.794 31484-31526/xyz.yorek.eventbus E/MainActivity: receive message : Binder:31484_1 IPCEvent{code=2, msg='Hello World, from SecondActivity'}\n1569684013.799 32016-32016/xyz.yorek.eventbus:second E/SecondActivity: receive message : main IPCEvent{code=2, msg='Hello World, from SecondActivity'}\n1569684013.803 31484-31526/xyz.yorek.eventbus E/EventBusManagerService: dispatch end : Binder:31484_1\n1569684013.804 32016-32016/xyz.yorek.eventbus:second E/SecondActivity: post message done : main\n\n1569684035.762 31484-31526/xyz.yorek.eventbus E/EventBusManagerService: dispatch begin : Binder:31484_1\n1569684035.762 31484-31526/xyz.yorek.eventbus E/MainActivity: receive message : Binder:31484_1 IPCEvent{code=3, msg='Hello World, from ThirdActivity'}\n1569684035.764 32063-32063/xyz.yorek.eventbus:third E/ThirdActivity: receive message : main IPCEvent{code=3, msg='Hello World, from ThirdActivity'}\n1569684035.765 31484-31526/xyz.yorek.eventbus E/EventBusManagerService: dispatch end : Binder:31484_1\n1569684035.765 32016-32089/xyz.yorek.eventbus:second E/SecondActivity: receive message : Binder:32016_4 IPCEvent{code=3, msg='Hello World, from ThirdActivity'}\n1569684035.766 32063-32063/xyz.yorek.eventbus:third E/ThirdActivity: post message done : main\n```\n","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":["EventBus","源码解析"]},"/Git":{"title":"Git","content":"\n当我们在git版本库中发现一个问题后，如你在git上对它进行了在线修改，但是没有对本地库进行同步（做到push之前，都先pull下代码，就可以保证本地库和远程库代码一致）。这个时候你再次 push，想把本地库提交到远程git库中，就会出现 push 失败问题：failed to push some refs to。\n\n解决方法：\n只要把远程库同步到本地库即可，使用如下命令：\n`git pull --rebase origin master`\n指令意思就是把远程库中的跟新合并到本地库中（可能存在冲突需要解决），--rebase的作用是取消本地库中刚刚提交的commit，并把他们接到更新后的版本库中。\n \n或者使用如下命令，将commit的代码撤回，然后再git pull：\n`git reset --soft HEAD^`\n\n","lastmodified":"2023-04-21T14:55:33.0252226Z","tags":[""]},"/Glide-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90":{"title":"Glide 加载流程和缓存原理分析","content":"\n# \u003cstrong\u003e加载流程\u003c/strong\u003e\n\nGlide 最普通的用法如下：\n\nGlide.with(this).load(url).into(textView);\n\n以首次加载 url 指向的资源到 textView 对象为例，由于代码实在太过冗长，下面用流程图的方式表示各个环节的执行顺序。\n\n## with\n\nwith 流程的主要职责：\n\n- 创建 RequestManager 对象\n- 初始化各式各样的配置信息（缓存、请求线程池、图片大小和格式等等）以及 Glide 单例对象。\n- 将 Glide 请求和 application/Activity/SupportFragment/Fragment 的生命周期绑定在一起\u003cstrong\u003e，从而实现自动执行请求，暂停操作\u003c/strong\u003e。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-2/clipboard_20230323_034132.png)\n\n```java\npublic class Glide implements ComponentCallbacks2 {\n    ...\n    @NonNull\n    public static RequestManager with(@NonNull Context context) {\n        return getRetriever(context).get(context);\n    }\n\n    @NonNull\n    public static RequestManager with(@NonNull Activity activity) {\n        return getRetriever(activity).get(activity);\n    }\n\n    @NonNull\n    public static RequestManager with(@NonNull FragmentActivity activity) {\n        return getRetriever(activity).get(activity);\n    }\n\n    @NonNull\n    public static RequestManager with(@NonNull Fragment fragment) {\n        return getRetriever(fragment.getActivity()).get(fragment);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Deprecated\n    @NonNull\n    public static RequestManager with(@NonNull android.app.Fragment fragment) {\n        return getRetriever(fragment.getActivity()).get(fragment);\n    }\n\n    @NonNull\n    public static RequestManager with(@NonNull View view) {\n        return getRetriever(view.getContext()).get(view);\n    }\n}\n```\n\n每个重载方法内部都首先调用 getRetriever(@Nullable Context context) 方法获取一个 RequestManagerRetriever 对象，然后调用其 get 方法来返回 RequestManager。\n\n传入 getRetriever 的参数都是 Context，而 RequestManagerRetriever.get 方法传入的参数各不相同，所以生命周期的绑定肯定发生在 get 方法中。把 Glide.with 方法里面的代码分成两部分来分析。\n\n### getRetriever(Context)\n\ngetRetriever(Context) 方法会根据 @GlideModule 注解的类以及 AndroidManifest.xml 文件中 meta-data 配置的 GlideModule 来创建一个 Glide 实例，然后返回该实例的 RequestManagerRetriever。\n\n首先从 getRetriever(Context) 开始：\n\n```java\n@NonNull\nprivate static RequestManagerRetriever getRetriever(@Nullable Context context) {\n  // Context could be null for other reasons (ie the user passes in null), but in practice it will\n  // only occur due to errors with the Fragment lifecycle.\n  Preconditions.checkNotNull(\n      context,\n      \"You cannot start a load on a not yet attached View or a Fragment where getActivity() \"\n          + \"returns null (which usually occurs when getActivity() is called before the Fragment \"\n          + \"is attached or after the Fragment is destroyed).\");\n  return Glide.get(context).getRequestManagerRetriever();\n}\n\n\npublic static Glide get(@NonNull Context context) {\n  if (glide == null) {\n    // 如果有配置 @GlideModule 注解的 Module\n    // 之类会反射构造 kapt 生成的 GeneratedAppGlideModuleImpl 类\n    GeneratedAppGlideModule annotationGeneratedModule =\n        getAnnotationGeneratedGlideModules(context.getApplicationContext());\n    synchronized (Glide.class) {\n      if (glide == null) {\n        checkAndInitializeGlide(context, annotationGeneratedModule);\n      }\n    }\n  }\n\n  return glide;\n}\n\nprivate static void checkAndInitializeGlide(@NonNull Context context) {\n  // In the thread running initGlide(), one or more classes may call Glide.get(context).\n  // Without this check, those calls could trigger infinite recursion.\n  if (isInitializing) {\n    throw new IllegalStateException(\"You cannot call Glide.get() in registerComponents(),\"\n        + \" use the provided Glide instance instead\");\n  }\n  isInitializing = true;\n  initializeGlide(context);\n  isInitializing = false;\n}\n\nprivate static void initializeGlide(@NonNull Context context) {\n  initializeGlide(context, new GlideBuilder());\n}\n\nprivate static void initializeGlide(\n    @NonNull Context context,\n    @NonNull GlideBuilder builder,\n    @Nullable GeneratedAppGlideModule annotationGeneratedModule) {\n  Context applicationContext = context.getApplicationContext();\n  // 如果 GeneratedAppGlideModuleImpl 存在，且允许解析 manifest 文件\n  // 则遍历 manifest 中的 meta-data，解析出所有的 GlideModule 类\n  List\u003ccom.bumptech.glide.module.GlideModule\u003e manifestModules = Collections.emptyList();\n  if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {\n    manifestModules = new ManifestParser(applicationContext).parse();\n  }\n\n  // 根据 Impl 的排除名单，剔除 manifest 中的 GlideModule 类\n  if (annotationGeneratedModule != null\n      \u0026\u0026 !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {\n    Set\u003cClass\u003c?\u003e\u003e excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();\n    Iterator\u003ccom.bumptech.glide.module.GlideModule\u003e iterator = manifestModules.iterator();\n    while (iterator.hasNext()) {\n      com.bumptech.glide.module.GlideModule current = iterator.next();\n      if (!excludedModuleClasses.contains(current.getClass())) {\n        continue;\n      }\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"AppGlideModule excludes manifest GlideModule: \" + current);\n      }\n      iterator.remove();\n    }\n  }\n\n  if (Log.isLoggable(TAG, Log.DEBUG)) {\n    for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) {\n      Log.d(TAG, \"Discovered GlideModule from manifest: \" + glideModule.getClass());\n    }\n  }\n\n  // 如果 Impl 存在，那么设置为该类的 RequestManagerFactory；否则设置为 null\n  RequestManagerRetriever.RequestManagerFactory factory =\n      annotationGeneratedModule != null\n          ? annotationGeneratedModule.getRequestManagerFactory()\n          : null;\n  builder.setRequestManagerFactory(factory);\n  // 依次调用 manifest 中 GlideModule 类的 applyOptions 方法，将配置写到 builder 里\n  for (com.bumptech.glide.module.GlideModule module : manifestModules) {\n    module.applyOptions(applicationContext, builder);\n  }\n  // 写入 Impl 的配置\n  // 也就是说 Impl 配置的优先级更高，如果有冲突的话\n  if (annotationGeneratedModule != null) {\n    annotationGeneratedModule.applyOptions(applicationContext, builder);\n  }\n  // 调用GlideBuilder.build方法创建 Glide\n  Glide glide = builder.build(applicationContext);\n  // 依次调用 manifest 中 GlideModule 类的 registerComponents 方法\n  // 来替换 Glide 的默认配置\n  for (com.bumptech.glide.module.GlideModule module : manifestModules) {\n    try {\n      module.registerComponents(applicationContext, glide, glide.registry);\n    } catch (AbstractMethodError e) {\n      throw new IllegalStateException(\n          \"Attempting to register a Glide v3 module. If you see this, you or one of your\"\n              + \" dependencies may be including Glide v3 even though you're using Glide v4.\"\n              + \" You'll need to find and remove (or update) the offending dependency.\"\n              + \" The v3 module name is: \"\n              + module.getClass().getName(),\n          e);\n    }\n  }\n  // 调用 Impl 中替换 Glide 配置的方法\n  if (annotationGeneratedModule != null) {\n    annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);\n  }\n  // 注册内存管理的回调，因为 Glide 实现了 ComponentCallbacks2 接口\n  applicationContext.registerComponentCallbacks(glide);\n  // 保存 glide 实例到静态变量中\n  Glide.glide = glide;\n}\n```\n\n如果没有在 AndroidManifest 和 @GlideModule 注解中进行过配置，上面的代码可以简化为：\n\n```java\n@SuppressWarnings(\"deprecation\")\nprivate static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) {\n  Context applicationContext = context.getApplicationContext();\n  // 调用 GlideBuilder.build 方法创建 Glide\n  Glide glide = builder.build(applicationContext);\n  // 注册内存管理的回调，因为 Glide 实现了 ComponentCallbacks2 接口\n  applicationContext.registerComponentCallbacks(glide);\n  // 保存 glide 实例到静态变量中\n  Glide.glide = glide;\n}\n```\n\n看一下 GlideBuilder.build 方法：\n\n```java\n@NonNull\nGlide build(@NonNull Context context) {\n  ...\n\n  GlideExperiments experiments = glideExperimentsBuilder.build();\n  RequestManagerRetriever requestManagerRetriever =\n      new RequestManagerRetriever(requestManagerFactory, experiments);\n\n  return new Glide(\n      context,\n      engine,\n      memoryCache,\n      bitmapPool,\n      arrayPool,\n      requestManagerRetriever,\n      connectivityMonitorFactory,\n      logLevel,\n      defaultRequestOptionsFactory,\n      defaultTransitionOptions,\n      defaultRequestListeners,\n      experiments);\n}\n```\n\n这里直接调用了 RequestManagerRetriever 构造器，且传入参数实际上为 null，在 RequestManagerRetriever 的构造器方法中会为此创建一个默认的 DEFAULT_FACTORY：\n\n```java\npublic class RequestManagerRetriever implements Handler.Callback {\n\n  private final Handler handler;\n  private final RequestManagerFactory factory;\n\n\n  public RequestManagerRetriever(\n      @Nullable RequestManagerFactory factory, GlideExperiments experiments) {\n    this.factory = factory != null ? factory : DEFAULT_FACTORY;\n    handler = new Handler(Looper.getMainLooper(), this /* Callback */);\n\n    frameWaiter = buildFrameWaiter(experiments);\n  }\n\n  /**\n   * Used internally to create {@link RequestManager}s.\n   */\n  public interface RequestManagerFactory {\n    @NonNull\n    RequestManager build(\n        @NonNull Glide glide,\n        @NonNull Lifecycle lifecycle,\n        @NonNull RequestManagerTreeNode requestManagerTreeNode,\n        @NonNull Context context);\n  }\n\n  private static final RequestManagerFactory DEFAULT_FACTORY = new RequestManagerFactory() {\n    @NonNull\n    @Override\n    public RequestManager build(@NonNull Glide glide, @NonNull Lifecycle lifecycle,\n        @NonNull RequestManagerTreeNode requestManagerTreeNode, @NonNull Context context) {\n      return new RequestManager(glide, lifecycle, requestManagerTreeNode, context);\n    }\n  };\n}\n```\n\n目前为止，Glide \u003cstrong\u003e单例已经被创建出来了\u003c/strong\u003e，其 RequestManagerRetriever 会作为 getRetriever(Context) 的返回值返回。\n\n接下来回到 Glide.with 方法中，接着执行的是 RequestManagerRetriever.get 方法，该方法根据入参是对生命周期可感的。\n\n### RequestManagerRetriever.get\n\nRequestManagerRetriever.get 方法与 Glide.with 一样，也有很多重载方法：\n\n```java\n@NonNull\nprivate RequestManager getApplicationManager(@NonNull Context context) {\n  // Either an application context or we're on a background thread.\n  if (applicationManager == null) {\n    synchronized (this) {\n      if (applicationManager == null) {\n        // Normally pause/resume is taken care of by the fragment we add to the fragment or\n        // activity. However, in this case since the manager attached to the application will not\n        // receive lifecycle events, we must force the manager to start resumed using\n        // ApplicationLifecycle.\n\n        // TODO(b/27524013): Factor out this Glide.get() call.\n        Glide glide = Glide.get(context.getApplicationContext());\n        applicationManager =\n            factory.build(\n                glide,\n                new ApplicationLifecycle(),\n                new EmptyRequestManagerTreeNode(),\n                context.getApplicationContext());\n      }\n    }\n  }\n\n  return applicationManager;\n}\n\n@NonNull\npublic RequestManager get(@NonNull Context context) {\n  if (context == null) {\n    throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n  } else if (Util.isOnMainThread() \u0026\u0026 !(context instanceof Application)) {\n    if (context instanceof FragmentActivity) {\n      return get((FragmentActivity) context);\n    } else if (context instanceof Activity) {\n      return get((Activity) context);\n    } else if (context instanceof ContextWrapper\n        // Only unwrap a ContextWrapper if the baseContext has a non-null application context.\n        // Context#createPackageContext may return a Context without an Application instance,\n        // in which case a ContextWrapper may be used to attach one.\n        \u0026\u0026 ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) {\n      return get(((ContextWrapper) context).getBaseContext());\n    }\n  }\n\n  return getApplicationManager(context);\n}\n\n@NonNull\npublic RequestManager get(@NonNull FragmentActivity activity) {\n  if (Util.isOnBackgroundThread()) {\n    return get(activity.getApplicationContext());\n  } else {\n    assertNotDestroyed(activity);\n    frameWaiter.registerSelf(activity);\n    FragmentManager fm = activity.getSupportFragmentManager();\n    return supportFragmentGet(activity, fm, /*parentHint=*/ null, isActivityVisible(activity));\n  }\n}\n\n@NonNull\npublic RequestManager get(@NonNull Fragment fragment) {\n  Preconditions.checkNotNull(\n      fragment.getContext(),\n      \"You cannot start a load on a fragment before it is attached or after it is destroyed\");\n  if (Util.isOnBackgroundThread()) {\n    return get(fragment.getContext().getApplicationContext());\n  } else {\n    // In some unusual cases, it's possible to have a Fragment not hosted by an activity. There's\n    // not all that much we can do here. Most apps will be started with a standard activity. If\n    // we manage not to register the first frame waiter for a while, the consequences are not\n    // catastrophic, we'll just use some extra memory.\n    if (fragment.getActivity() != null) {\n      frameWaiter.registerSelf(fragment.getActivity());\n    }\n    FragmentManager fm = fragment.getChildFragmentManager();\n    return supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible());\n  }\n}\n\n@SuppressWarnings(\"deprecation\")\n@NonNull\npublic RequestManager get(@NonNull Activity activity) {\n  if (Util.isOnBackgroundThread()) {\n    return get(activity.getApplicationContext());\n  } else if (activity instanceof FragmentActivity) {\n    return get((FragmentActivity) activity);\n  } else {\n    assertNotDestroyed(activity);\n    frameWaiter.registerSelf(activity);\n    android.app.FragmentManager fm = activity.getFragmentManager();\n    return fragmentGet(activity, fm, /*parentHint=*/ null, isActivityVisible(activity));\n  }\n}\n\n@SuppressWarnings(\"deprecation\")\n@NonNull\npublic RequestManager get(@NonNull View view) {\n  if (Util.isOnBackgroundThread()) {\n    return get(view.getContext().getApplicationContext());\n  }\n\n  Preconditions.checkNotNull(view);\n  Preconditions.checkNotNull(\n      view.getContext(), \"Unable to obtain a request manager for a view without a Context\");\n  Activity activity = findActivity(view.getContext());\n  // The view might be somewhere else, like a service.\n  if (activity == null) {\n    return get(view.getContext().getApplicationContext());\n  }\n\n  // Support Fragments.\n  // Although the user might have non-support Fragments attached to FragmentActivity, searching\n  // for non-support Fragments is so expensive pre O and that should be rare enough that we\n  // prefer to just fall back to the Activity directly.\n  if (activity instanceof FragmentActivity) {\n    Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);\n    return fragment != null ? get(fragment) : get((FragmentActivity) activity);\n  }\n\n  // Standard Fragments.\n  android.app.Fragment fragment = findFragment(view, activity);\n  if (fragment == null) {\n    return get(activity);\n  }\n  return get(fragment);\n}\n```\n\n在这些 get 方法中，\u003cstrong\u003e首先判断当前线程是不是后台线程\u003c/strong\u003e，如果是后台线程那么就会调用 getApplicationManager 方法返回一个 RequestManager：\n\n```java\nGlide glide = Glide.get(context.getApplicationContext());\napplicationManager =\n    factory.build(\n        glide,\n        new ApplicationLifecycle(),\n        new EmptyRequestManagerTreeNode(),\n        context.getApplicationContext());\n```\n\n由于此处 factory 是 DEFAULT_FACTORY，所以 RequestManager 就是下面的值：\n\n```java\nRequestManager(glide,\n        new ApplicationLifecycle(),\n        new EmptyRequestManagerTreeNode(),\n        context.getApplicationContext());\n```\n\n\u003cstrong\u003e如果当前线程不是后台线程\u003c/strong\u003e，get(View) 和 get(Context) 会根据情况调用 get(Fragment) 或 get(FragmentActivity)。其中 get(View) 为了找到一个合适的 Fragment 或 Fallback Activity，内部操作比较多，开销比较大，不要轻易使用。\n\nget(Fragment) 和 get(FragmentActivity) 方法都会调用 supportFragmentGet 方法，只是传入参数不同：\n\n```java\n// FragmentActivity activity\nFragmentManager fm = activity.getSupportFragmentManager();\nsupportFragmentGet(activity, fm, /*parentHint=*/ null, isActivityVisible(activity));\n\n// Fragment fragment\nFragmentManager fm = fragment.getChildFragmentManager();\nsupportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());\n```\n\nGlide 会使用一个加载目标所在的宿主 Activity 或 Fragment 的子 Fragment 来安全保存一个 RequestManager，而 RequestManager 被 Glide 用来开始、停止、管理 Glide 请求。\n\n而 supportFragmentGet 就是创建 / 获取这个 SupportRequestManagerFragment，并返回其持有的 RequestManager 的方法。\n\n```java\n@NonNull\nprivate RequestManager supportFragmentGet(\n    @NonNull Context context,\n    @NonNull FragmentManager fm,\n    @Nullable Fragment parentHint,\n    boolean isParentVisible) {\n  // 获取一个SupportRequestManagerFragment\n  SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint);\n  // 获取里面的RequestManager对象\n  RequestManager requestManager = current.getRequestManager();\n  // 若没有，则创建一个\n  if (requestManager == null) {\n    // TODO(b/27524013): Factor out this Glide.get() call.\n    Glide glide = Glide.get(context);\n    requestManager =\n        factory.build(\n            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);\n    // This is a bit of hack, we're going to start the RequestManager, but not the\n    // corresponding Lifecycle. It's safe to start the RequestManager, but starting the\n    // Lifecycle might trigger memory leaks. See b/154405040\n    if (isParentVisible) {\n      requestManager.onStart();\n    }\n    // 设置到SupportRequestManagerFragment里面，下次就不需要创建了\n    current.setRequestManager(requestManager);\n  }\n  return requestManager;\n}\n\n// 看看Fragment怎么才能高效\n@NonNull\nprivate SupportRequestManagerFragment getSupportRequestManagerFragment(\n    @NonNull final FragmentManager fm, @Nullable Fragment parentHint) {\n  // 已经添加过了，可以直接返回\n  SupportRequestManagerFragment current =\n      (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n  if (current == null) {\n    // 从map中获取，取到也可以返回了\n    current = pendingSupportRequestManagerFragments.get(fm);\n    if (current == null) {\n      // 都没有，那么就创建一个，此时lifecycle默认为ActivityFragmentLifecycle\n      current = new SupportRequestManagerFragment();\n      // 对于fragment来说，此方法会以Activity为host创建另外一个\n      // SupportRequestManagerFragment作为rootRequestManagerFragment\n      // 并会将current加入到rootRequestManagerFragment的\n      // childRequestManagerFragments中\n      // 在RequestManager递归管理请求时会使用到\n      current.setParentFragmentHint(parentHint);\n      // 将刚创建的fragment缓存进map起来\n      pendingSupportRequestManagerFragments.put(fm, current);\n      // 将fragment添加到页面中\n      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n      // 以fm为key从pendingSupportRequestManagerFragments中删除\n      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();\n    }\n  }\n  return current;\n}\n```\n\n在上面的 supportFragmentGet 方法中，成功创建了一个 RequestManager 对象，由于 factory 是 DEFAULT_FACTORY，所以就是下面的值：\n\n```java\nRequestManager(glide,\n  current.getGlideLifecycle(),          // ActivityFragmentLifecycle()\n  current.getRequestManagerTreeNode(),  // SupportFragmentRequestManagerTreeNode()\n  context);\n```\n\n在上一步中 Glide 单例完成了初始化，这一步中成功的创建并返回了一个 RequestManager。Glide.with 已经分析完毕。\n\n### 小结\n\nwith() 方法是为得到一个 RequestManager 对象，从而将 Glide 加载图片周期与 Activity 和 Fragment 进行绑定，进而管理 Glide 加载图片周期。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-2/clipboard_20230323_034143.png)\n\n## \u003cstrong\u003eload\u003c/strong\u003e\n\n由于 .with() 返回的是一个 RequestManager 对象，所以第 2 步中调用的是 RequestManager\n\n类的 load() 方法。而 load() 方法返回的是 RequestBuilder 对象。RequestBuilder 和 RequestOptions 都派生自抽象类 BaseRequestOptions，它们的继承关系如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-2/clipboard_20230323_034149.png)\n\n看一下 RequestManager 的一些方法，首先看 load 的一些重载方法：\n\n```java\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cDrawable\u003e load(@Nullable Bitmap bitmap) {\n  return asDrawable().load(bitmap);\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cDrawable\u003e load(@Nullable Drawable drawable) {\n  return asDrawable().load(drawable);\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cDrawable\u003e load(@Nullable String string) {\n  return asDrawable().load(string);\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cDrawable\u003e load(@Nullable Uri uri) {\n  return asDrawable().load(uri);\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cDrawable\u003e load(@Nullable File file) {\n  return asDrawable().load(file);\n}\n\n@SuppressWarnings(\"deprecation\")\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cDrawable\u003e load(@RawRes @DrawableRes @Nullable Integer resourceId) {\n  return asDrawable().load(resourceId);\n}\n\n@SuppressWarnings(\"deprecation\")\n@CheckResult\n@Override\n@Deprecated\npublic RequestBuilder\u003cDrawable\u003e load(@Nullable URL url) {\n  return asDrawable().load(url);\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cDrawable\u003e load(@Nullable byte[] model) {\n  return asDrawable().load(model);\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cDrawable\u003e load(@Nullable Object model) {\n  return asDrawable().load(model);\n}\n```\n\n在所有的 RequestManager.load 方法中都会先调用 asDrawable() 方法得到一个 RequestBuilder 对象，然后再调用 RequestBuilder.load 方法。\n\n### RequestManager.asXx\n\nasDrawable 方法同其他 as 方法（asGif、asBitmap、asFile）一样，都会先调用 RequestManager.as 方法生成一个 `RequestBuilder\u003cResourceType\u003e` 对象，然后各个 as 方法会附加一些不同的 options：\n\n```java\n@NonNull\n@CheckResult\npublic RequestBuilder\u003cBitmap\u003e asBitmap() {\n  return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);\n}\n\n@NonNull\n@CheckResult\npublic RequestBuilder\u003cGifDrawable\u003e asGif() {\n  return as(GifDrawable.class).apply(DECODE_TYPE_GIF);\n}  \n\n@NonNull\n@CheckResult\npublic RequestBuilder\u003cDrawable\u003e asDrawable() {\n  return as(Drawable.class);\n}\n\n@NonNull\n@CheckResult\npublic RequestBuilder\u003cFile\u003e asFile() {\n  return as(File.class).apply(skipMemoryCacheOf(true));\n}\n\n@NonNull\n@CheckResult\npublic \u003cResourceType\u003e RequestBuilder\u003cResourceType\u003e as(\n    @NonNull Class\u003cResourceType\u003e resourceClass) {\n  return new RequestBuilder\u003c\u003e(glide, this, resourceClass, context);\n}\n```\n\n在 RequestBuilder 的构造器方法方法中将 Drawable.class 这样的入参保存到了 transcodeClass 变量中：\n\n```kotlin\n@SuppressLint(\"CheckResult\")\n@SuppressWarnings(\"PMD.ConstructorCallsOverridableMethod\")\nprotected RequestBuilder(\n    @NonNull Glide glide,\n    RequestManager requestManager,\n    Class\u003cTranscodeType\u003e transcodeClass,\n    Context context) {\n  this.glide = glide;\n  this.requestManager = requestManager;\n  this.transcodeClass = transcodeClass;\n  this.context = context;\n  this.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);\n  this.glideContext = glide.getGlideContext();\n\n  initRequestListeners(requestManager.getDefaultRequestListeners());\n  apply(requestManager.getDefaultRequestOptions());\n}\n```\n\n然后回到之前的 asGif 方法中，看看 apply(DECODE_TYPE_BITMAP) 干了些什么：\n\n```java\n// RequestManager\nprivate static final RequestOptions DECODE_TYPE_GIF \n        = RequestOptions.decodeTypeOf(GifDrawable.class).lock();\n\n@NonNull\n@CheckResult\npublic RequestBuilder\u003cGifDrawable\u003e asGif() {\n  return as(GifDrawable.class).apply(DECODE_TYPE_GIF);\n}\n\n// RequestOptions\n@NonNull\n@CheckResult\npublic static RequestOptions decodeTypeOf(@NonNull Class\u003c?\u003e resourceClass) {\n  return new RequestOptions().decode(resourceClass);\n}\n\n// BaseRequestOptions\n@NonNull\n@CheckResult\npublic T decode(@NonNull Class\u003c?\u003e resourceClass) {\n  if (isAutoCloneEnabled) {\n    return clone().decode(resourceClass);\n  }\n\n  this.resourceClass = Preconditions.checkNotNull(resourceClass);\n  fields |= RESOURCE_CLASS;\n  return selfOrThrowIfLocked();\n}\n\n@NonNull\n@CheckResult\npublic T apply(@NonNull BaseRequestOptions\u003c?\u003e o) {\n  if (isAutoCloneEnabled) {\n    return clone().apply(o);\n  }\n  BaseRequestOptions\u003c?\u003e other = o;\n  ...\n  if (isSet(other.fields, RESOURCE_CLASS)) {\n    resourceClass = other.resourceClass;\n  }\n  ...\n  return selfOrThrowIfLocked();\n}\n\n// RequestBuilder\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cTranscodeType\u003e apply(@NonNull BaseRequestOptions\u003c?\u003e requestOptions) {\n  Preconditions.checkNotNull(requestOptions);\n  return super.apply(requestOptions);\n}\n```\n\n不难发现，apply(DECODE_TYPE_BITMAP) 就是将 BaseRequestOptions.resourceClass 设置为了 GifDrawable.class；对于 asBitmap() 来说，resourceClass 为 Bitmap.class；而对于 asDrawable() 和 asFile() 来说，resourceClass 没有进行过设置，所以为默认值 Object.class。\n\n现在 RequestBuilder 已经由 as 系列方法生成，现在接着会调用 RequestBuilder.load 方法\n\n### RequestBuilder.load\n\nRequestManager.load 方法都会调用对应的 RequestBuilder.load 重载方法；RequestBuilder.load 的各个方法基本上都会直接转发给 loadGeneric 方法，只有少数的方法才会 apply 额外的 options。\n\nloadGeneric 方法也只是保存一下参数而已：\n\n```typescript\n@NonNull\n@CheckResult\n@SuppressWarnings(\"unchecked\")\n@Override\npublic RequestBuilder\u003cTranscodeType\u003e load(@Nullable Object model) {\n  return loadGeneric(model);\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cTranscodeType\u003e load(@Nullable Bitmap bitmap) {\n  return loadGeneric(bitmap)\n      .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cTranscodeType\u003e load(@Nullable Drawable drawable) {\n  return loadGeneric(drawable)\n      .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cTranscodeType\u003e load(@Nullable Uri uri) {\n  return loadGeneric(uri);\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cTranscodeType\u003e load(@Nullable File file) {\n  return loadGeneric(file);\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cTranscodeType\u003e load(@RawRes @DrawableRes @Nullable Integer resourceId) {\n  return loadGeneric(resourceId).apply(signatureOf(ApplicationVersionSignature.obtain(context)));\n}\n\n@Deprecated\n@CheckResult\n@Override\npublic RequestBuilder\u003cTranscodeType\u003e load(@Nullable URL url) {\n  return loadGeneric(url);\n}\n\n@NonNull\n@CheckResult\n@Override\npublic RequestBuilder\u003cTranscodeType\u003e load(@Nullable byte[] model) {\n  RequestBuilder\u003cTranscodeType\u003e result = loadGeneric(model);\n  if (!result.isDiskCacheStrategySet()) {\n      result = result.apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));\n  }\n  if (!result.isSkipMemoryCacheSet()) {\n    result = result.apply(skipMemoryCacheOf(true /*skipMemoryCache*/));\n  }\n  return result;\n}\n\n@NonNull\nprivate RequestBuilder\u003cTranscodeType\u003e loadGeneric(@Nullable Object model) {\n  this.model = model;\n  isModelSet = true;\n  return this;\n}\n```\n\n如上面最后的方法 loadGeneric，这里只是将参数保存在 model 中并设置 isModelSet=true 就完了，\n\n### 小结\n\nload 流程主要给 GlideRequest（RequestManager）设置了要请求的 mode（url），并将 isModelSet 变量设置为 true，表示已设置的状态，最后返回 RequestBuilder。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-2/clipboard_20230323_034156.png)\n\n## into\n\nRequestBuilder.into 有四个重载方法，最终都调用了参数最多的一个：\n\n```typescript\n@NonNull\npublic \u003cY extends Target\u003cTranscodeType\u003e\u003e Y into(@NonNull Y target) {\n  return into(target, /*targetListener=*/ null, Executors.mainThreadExecutor());\n}\n\n@NonNull\n@Synthetic\n\u003cY extends Target\u003cTranscodeType\u003e\u003e Y into(\n    @NonNull Y target,\n    @Nullable RequestListener\u003cTranscodeType\u003e targetListener,\n    Executor callbackExecutor) {\n  return into(target, targetListener, /*options=*/ this, callbackExecutor);\n}\n\nprivate \u003cY extends Target\u003cTranscodeType\u003e\u003e Y into(\n    @NonNull Y target,\n    @Nullable RequestListener\u003cTranscodeType\u003e targetListener,\n    BaseRequestOptions\u003c?\u003e options,\n    Executor callbackExecutor) {\n  Preconditions.checkNotNull(target);\n  if (!isModelSet) {\n    throw new IllegalArgumentException(\"You must call #load() before calling #into()\");\n  }\n\n  Request request = buildRequest(target, targetListener, options, callbackExecutor);\n\n  Request previous = target.getRequest();\n  if (request.isEquivalentTo(previous)\n      \u0026\u0026 !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {\n    // If the request is completed, beginning again will ensure the result is re-delivered,\n    // triggering RequestListeners and Targets. If the request is failed, beginning again will\n    // restart the request, giving it another chance to complete. If the request is already\n    // running, we can let it continue running without interruption.\n    if (!Preconditions.checkNotNull(previous).isRunning()) {\n      // Use the previous request rather than the new one to allow for optimizations like skipping\n      // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions\n      // that are done in the individual Request.\n      previous.begin();\n    }\n    return target;\n  }\n\n  requestManager.clear(target);\n  target.setRequest(request);\n  requestManager.track(target, request);\n\n  return target;\n}\n\n// 最常用的一个重载\n\n@NonNull\npublic ViewTarget\u003cImageView, TranscodeType\u003e into(@NonNull ImageView view) {\n  Util.assertMainThread();\n  Preconditions.checkNotNull(view);\n\n  BaseRequestOptions\u003c?\u003e requestOptions = this;\n  // 若没有指定transform，isTransformationSet()为false\n  // isTransformationAllowed()一般为true，除非主动调用了dontTransform()方法\n  if (!requestOptions.isTransformationSet()\n      \u0026\u0026 requestOptions.isTransformationAllowed()\n      \u0026\u0026 view.getScaleType() != null) {\n    // Clone in this method so that if we use this RequestBuilder to load into a View and then\n    // into a different target, we don't retain the transformation applied based on the previous\n    // View's scale type.\n    // 根据ImageView的ScaleType设置不同的down sample和transform选项\n    switch (view.getScaleType()) {\n      case CENTER_CROP:\n        requestOptions = requestOptions.clone().optionalCenterCrop();\n        break;\n      case CENTER_INSIDE:\n        requestOptions = requestOptions.clone().optionalCenterInside();\n        break;\n      case FIT_CENTER: // 默认值\n      case FIT_START:\n      case FIT_END:\n        requestOptions = requestOptions.clone().optionalFitCenter();\n        break;\n      case FIT_XY:\n        requestOptions = requestOptions.clone().optionalCenterInside();\n        break;\n      case CENTER:\n      case MATRIX:\n      default:\n        // Do nothing.\n    }\n  }\n\n  // 调用上面的重载方法\n  return into(\n      glideContext.buildImageViewTarget(view, transcodeClass),\n      /*targetListener=*/ null,\n      requestOptions,\n      Executors.mainThreadExecutor());\n}\n```\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-2/clipboard_20230323_034202.png)\n\n## \u003cstrong\u003e整体流程\u003c/strong\u003e\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-2/clipboard_20230323_034206.png)\n\n# \u003cstrong\u003e缓存\u003c/strong\u003e\n\n## Glide 缓存机制\n\nGlide 之所以被广泛使用的一个重要原因就是它强大的缓存机制。在 Glide 官方文档中，在 [缓存部分](https://muyangmin.github.io/glide-docs-cn/doc/caching.html) 有如下描述：\n\n默认情况下，Glide 会在开始一个新的图片请求之前检查以下多级的缓存：\n\n1、活动资源 (Active Resources) - 现在是否有另一个 View 正在展示这张图片？\n\n2、内存缓存 (Memory Cache) - 该图片是否最近被加载过并仍存在于内存中？\n\n3、资源类型（Resource） - 该图片是否之前曾被解码、转换并写入过磁盘缓存？\n\n4、数据来源 (Data) - 构建这个图片的资源是否之前曾被写入过文件缓存？\n\n前两步检查图片是否在内存中，如果是则直接返回图片。后两步则检查图片是否在磁盘上，以便快速但异步地返回图片。\n\n如果四个步骤都未能找到图片，则 Glide 会返回到原始资源以取回数据（原始文件，Uri, Url 等）。\n\nGlide 缓存机制的流程图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-2/clipboard_20230323_034424.png)\n\nGlide 的 memory cache 和 disk cache 在 Glide 创建的时候就确定了。代码在 GlideBuilder.build(Context) 方法里面：\n\n```java\n@NonNull\nGlide build(@NonNull Context context) {\n  ...\n  if (memoryCache == null) {\n    memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());\n  }\n  if (diskCacheFactory == null) {\n    diskCacheFactory = new InternalCacheDiskCacheFactory(context);\n  }\n  if (engine == null) {\n    engine = new Engine(memoryCache, diskCacheFactory, ...);\n  }\n  ...\n  return new Glide(context, engine, memoryCache, ...);\n}\n```\n\n如果没有在任何 GlideModule 中进行自定义的话，memoryCache 和 diskCacheFactory 会使用一个默认值，大部分情况下使用这个默认值去实现缓存就可以了。\n\n## \u003cstrong\u003e配置缓存\u003c/strong\u003e\n\n### 磁盘缓存策略\n\nDiskCacheStrategy 可被 diskCacheStrategy() 方法应用到每一个单独的请求。 目前支持的策略允许你阻止加载过程使用或写入磁盘缓存，选择性地仅缓存无修改的原生数据，或仅缓存变换过的缩略图，或是兼而有之。磁盘缓存一共有以下几种策略：\n\n- DiskCacheStrategy.AUTOMATIC：尝试对本地和远程图片使用最佳的策略，它是默认使用的策略。当加载远程数据（比如从 URL 下载）时，仅会存储未被加载过程修改过（比如变换）的原始数据。对于本地数据，则会仅存储变换过的缩略图，因为即使需要再次生成另一个尺寸或类型的图片，取回原始数据也很容易。\n- DiskCacheStrategy.NONE： 表示不缓存任何内容。\n- DiskCacheStrategy.DATA： 表示只缓存原始图片。\n- DiskCacheStrategy.RESOURCE： 表示只缓存转换过后的图片。\n- DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。\n\n\u003cstrong\u003e指定 DiskCacheStrategy :\u003c/strong\u003e\n\n```java\nGlide.with(fragment)\n  .load(url)\n  .diskCacheStrategy(DiskCacheStrategy.ALL)\n  .into(imageView);\n```\n\n### 仅从缓存加载图片\n\n某些情形下，可能希望只要图片不在缓存中则加载直接失败（比如省流量模式？）。如果要达到这种效果，可以在单个请求的基础上使用 onlyRetrieveFromCache 方法：\n\n```java\nGlide.with(fragment)\n  .load(url)\n  .onlyRetrieveFromCache(true)\n  .into(imageView);\n```\n\n这时如果图片在内存缓存或在磁盘缓存中，它会被展示出来。否则只要这个选项被设置为 true ，这次加载会视同失败。\n\n### 跳过缓存\n\n如果你想确保一个特定的请求跳过磁盘和/或内存缓存（\u003cem\u003e比如，图片验证码\u003c/em\u003e），Glide 也提供了一些替代方案。\n\n仅跳过内存缓存，请使用 skipMemoryCache() :\n\n```java\nGlide.with(fragment)\n  .load(url)\n  .skipMemoryCache(true)\n  .into(view);\n```\n\n仅跳过磁盘缓存，请使用 DiskCacheStrategy.NONE :\n\n```java\nGlide.with(fragment)\n  .load(url)\n  .diskCacheStrategy(DiskCacheStrategy.NONE)\n  .into(view);\n```\n\n这两个选项可以同时使用:\n\n```java\nGlide.with(fragment)\n  .load(url)\n  .diskCacheStrategy(DiskCacheStrategy.NONE)\n  .skipMemoryCache(true)\n  .into(view);\n```\n\n虽然提供了这些选项跳过缓存，但不建议这么做。因为从缓存中加载一个图片，要比拉取 - 解码 - 转换成一张新图片的完整流程快得多。\n\n## 活动资源 ActiveResource\n\nActiveResources 在 Engine 的构造器中被创建，它的源码如下：\n\n```java\nfinal class ActiveResources {\n  private final boolean isActiveResourceRetentionAllowed;\n  private final Executor monitorClearedResourcesExecutor;\n  final Map\u003cKey, ResourceWeakReference\u003e activeEngineResources = new HashMap\u003c\u003e();\n  private final ReferenceQueue\u003cEngineResource\u003c?\u003e\u003e resourceReferenceQueue = new ReferenceQueue\u003c\u003e();\n\n  private ResourceListener listener;\n\n  private volatile boolean isShutdown;\n  private volatile DequeuedResourceCallback cb;\n\n  ActiveResources(boolean isActiveResourceRetentionAllowed) {\n    this(\n        isActiveResourceRetentionAllowed,\n        java.util.concurrent.Executors.newSingleThreadExecutor(\n            new ThreadFactory() {\n              @Override\n              public Thread newThread(@NonNull final Runnable r) {\n                return new Thread(\n                    new Runnable() {\n                      @Override\n                      public void run() {\n                        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                        r.run();\n                      }\n                    },\n                    \"glide-active-resources\");\n              }\n            }));\n  }\n\n  ActiveResources(\n      boolean isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) {\n    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;\n    this.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;\n\n    monitorClearedResourcesExecutor.execute(\n        new Runnable() {\n          @Override\n          public void run() {\n            cleanReferenceQueue();\n          }\n        });\n  }\n\n  void setListener(ResourceListener listener) {\n    synchronized (listener) {\n      synchronized (this) {\n        this.listener = listener;\n      }\n    }\n  }\n\n  synchronized void activate(Key key, EngineResource\u003c?\u003e resource) {\n    ResourceWeakReference toPut =\n        new ResourceWeakReference(\n            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);\n\n    ResourceWeakReference removed = activeEngineResources.put(key, toPut);\n    if (removed != null) {\n      removed.reset();\n    }\n  }\n\n  synchronized void deactivate(Key key) {\n    ResourceWeakReference removed = activeEngineResources.remove(key);\n    if (removed != null) {\n      removed.reset();\n    }\n  }\n\n  synchronized EngineResource\u003c?\u003e get(Key key) {\n    ResourceWeakReference activeRef = activeEngineResources.get(key);\n    if (activeRef == null) {\n      return null;\n    }\n\n    EngineResource\u003c?\u003e active = activeRef.get();\n    if (active == null) {\n      cleanupActiveReference(activeRef);\n    }\n    return active;\n  }\n\n  void cleanupActiveReference(@NonNull ResourceWeakReference ref) {\n    synchronized (this) {\n      activeEngineResources.remove(ref.key);\n\n      if (!ref.isCacheable || ref.resource == null) {\n        return;\n      }\n    }\n\n    EngineResource\u003c?\u003e newResource =\n        new EngineResource\u003c\u003e(\n            ref.resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ false, ref.key, listener);\n    listener.onResourceReleased(ref.key, newResource);\n  }\n\n  void cleanReferenceQueue() {\n    while (!isShutdown) {\n      try {\n        ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();\n        cleanupActiveReference(ref);\n\n        DequeuedResourceCallback current = cb;\n        if (current != null) {\n          current.onResourceDequeued();\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n\n  void setDequeuedResourceCallback(DequeuedResourceCallback cb) {\n    this.cb = cb;\n  }\n\n  interface DequeuedResourceCallback {\n    void onResourceDequeued();\n  }\n\n  void shutdown() {\n    isShutdown = true;\n    if (monitorClearedResourcesExecutor instanceof ExecutorService) {\n      ExecutorService service = (ExecutorService) monitorClearedResourcesExecutor;\n      Executors.shutdownAndAwaitTermination(service);\n    }\n  }\n\n  static final class ResourceWeakReference extends WeakReference\u003cEngineResource\u003c?\u003e\u003e {\n    final Key key;\n    final boolean isCacheable;\n    Resource\u003c?\u003e resource;\n    ResourceWeakReference(Key key, EngineResource\u003c?\u003e referent,\n        ReferenceQueue\u003c? super EngineResource\u003c?\u003e\u003e queue,\n        boolean isActiveResourceRetentionAllowed) {\n      super(referent, queue);\n      this.key = Preconditions.checkNotNull(key);\n      this.resource =\n          referent.isMemoryCacheable() \u0026\u0026 isActiveResourceRetentionAllowed\n              ? Preconditions.checkNotNull(referent.getResource())\n              : null;\n      isCacheable = referent.isMemoryCacheable();\n    }\n\n    void reset() {\n      resource = null;\n      clear();\n    }\n  }\n}\n```\n\n先来看 ResourceWeakReference，`extends WeakReference\u003cEngineResource\u003c?\u003e\u003e` 表示它继承自 WeakReference 并且用于保存 EngineResource 类型的引用，此外添加了一个 reset 方法用来清理资源。\n\n构造方法中调用了 super(referent, queue)，这样如果 referent 指向的对象将要被 GC 的时候，referent 就会被放入 queue 中。\n\nActiveResources 初始化时，会启动一个名为“glide-active-resources”的 BACKGROUND 的线程，在该线程中会调用 cleanReferenceQueue() 方法：\n\n```java\nvoid cleanReferenceQueue() {\n    while (!isShutdown) {\n      try {\n        //remove 方法会发生阻塞\n        ResourceWeakReference ref = (ResourceWeakReference) \n            resourceReferenceQueue.remove();\n        //清除资源\n        cleanupActiveReference(ref);\n\n        DequeuedResourceCallback current = cb;\n        if (current != null) {\n          current.onResourceDequeued();\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n```\n\n而 resourceReferenceQueue.remove() 方法会一直尝试从 queue 中获取将要被 GC 的 EngineResource。当发生 GC 时，如果 EngineResource 只 ResourceWeakReference 对象持有，ResourceWeakReference 对象就会被插入到 queue 中，这时在 remove() 方法就能获取到一个 ResourceWeakReference 对象（这是一个典型的生产者 - 消费者模型）。\n\n然后调用 cleanupActiveReference 方法：\n\n```java\nvoid cleanupActiveReference(@NonNull ResourceWeakReference ref) {\n    synchronized (this) {\n      //从集合中移除\n      activeEngineResources.remove(ref.key);\n\n      if (!ref.isCacheable || ref.resource == null) {\n        return;\n      }\n    }\n\n    EngineResource\u003c?\u003e newResource =\n        new EngineResource\u003c\u003e(\n            ref.resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ false, ref.key, listener);\n    //将被 GC 的 EngineResource 回调给 listener\n    listener.onResourceReleased(ref.key, newResource);\n  }\n```\n\n首先会将该对象从集合中移除，然后再将 ResourceWeakReference 对象中的资源取出并回调给 listener，这个 listener 的唯一实现在 Engine 类中，后面还会有地方调用这个方法，这里暂时不进行分析。\n\n该方法除了在此时被调用外，还在 ActiveResources.get(key) 方法中也可能会因为获取到的 resource 为 null 而被调用。\n\n## 内存缓存 MemoryCache\n\nMemoryCache 发生存取操作是在 Engine 中，但是我们看到 MemoryCache 还被放入了 Glide 实例中。这是因为 Glide 实现了 ComponentCallbacks2 接口，在 Glide 创建完成后，实例就注册了该接口。这样在内存紧张的时候，可以通过回调 onTrimMemory 方法通知释放内存。\n\n```java\n@Override\npublic void onTrimMemory(int level) {\n  trimMemory(level);\n}\n\npublic void trimMemory(int level) {\n  // Engine asserts this anyway when removing resources, fail faster and consistently\n  Util.assertMainThread();\n  // Request managers need to be trimmed before the caches and pools, in order for the latter to\n  // have the most benefit.\n  synchronized (managers) {\n    for (RequestManager manager : managers) {\n      manager.onTrimMemory(level);\n    }\n  }\n  // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.\n  memoryCache.trimMemory(level);\n  bitmapPool.trimMemory(level);\n  arrayPool.trimMemory(level);\n}\n```\n\n前面提到过，Glide 初始化的时候如果没有设置过内存缓存方案，则会采用默认实现方案：\n\n```java\nif (memoryCache == null) {\n    memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());\n}\n```\n\nLruResourceCache 继承自 LruCache 类并实现了 MemoryCache 接口，LruCache 使用 LRU（least recently used，即最近最少使用）算法实现的内存淘汰算法，它的核心思想是当缓存对象的数量达到阈值时，会优先删除那些近期最少使用的缓存对象。\n\nLruCache 定义了 LRU 相关的操作，而 MemoryCache 定义的是内存缓存相关的操作。LruResourceCache 源码如下：\n\n```java\npublic class LruResourceCache extends LruCache\u003cKey, Resource\u003c?\u003e\u003e implements MemoryCache {\n  private ResourceRemovedListener listener;\n\n  /**\n   * Constructor for LruResourceCache.\n   *\n   * @param size The maximum size in bytes the in memory cache can use.\n   */\n  public LruResourceCache(long size) {\n    super(size);\n  }\n\n  @Override\n  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {\n    this.listener = listener;\n  }\n\n  @Override\n  protected void onItemEvicted(@NonNull Key key, @Nullable Resource\u003c?\u003e item) {\n    if (listener != null \u0026\u0026 item != null) {\n      listener.onResourceRemoved(item);\n    }\n  }\n\n  @Override\n  protected int getSize(@Nullable Resource\u003c?\u003e item) {\n    if (item == null) {\n      return super.getSize(null);\n    } else {\n      return item.getSize();\n    }\n  }\n\n  @Override\n  public void trimMemory(int level) {\n    if (level \u003e= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {\n      // Entering list of cached background apps\n      // Evict our entire bitmap cache\n      clearMemory();\n    } else if (level \u003e= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN\n        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {\n      // The app's UI is no longer visible, or app is in the foreground but system is running\n      // critically low on memory\n      // Evict oldest half of our bitmap cache\n      trimToSize(getMaxSize() / 2);\n    }\n  }\n}\nLruCache 的源码如下：\npublic class LruCache\u003cT, Y\u003e {\n  private final Map\u003cT, Entry\u003cY\u003e\u003e cache = new LinkedHashMap\u003c\u003e(100, 0.75f, true);\n  private final long initialMaxSize;\n  private long maxSize;\n  private long currentSize;\n\n  public LruCache(long size) {\n    this.initialMaxSize = size;\n    this.maxSize = size;\n  }\n\n  public synchronized void setSizeMultiplier(float multiplier) {\n    if (multiplier \u003c 0) {\n      throw new IllegalArgumentException(\"Multiplier must be \u003e= 0\");\n    }\n    maxSize = Math.round(initialMaxSize * multiplier);\n    evict();\n  }\n\n  protected int getSize(@Nullable Y item) {\n    return 1;\n  }\n\n  protected synchronized int getCount() {\n    return cache.size();\n  }\n\n  protected void onItemEvicted(@NonNull T key, @Nullable Y item) {\n    // optional override\n  }\n\n  public synchronized long getMaxSize() {\n    return maxSize;\n  }\n\n  public synchronized long getCurrentSize() {\n    return currentSize;\n  }\n\n  public synchronized boolean contains(@NonNull T key) {\n    return cache.containsKey(key);\n  }\n\n  @Nullable\n  public synchronized Y get(@NonNull T key) {\n    Entry\u003cY\u003e entry = cache.get(key);\n    return entry != null ? entry.value : null;\n  }\n\n  @Nullable\n  public synchronized Y put(@NonNull T key, @Nullable Y item) {\n    final int itemSize = getSize(item);\n    if (itemSize \u003e= maxSize) {\n      onItemEvicted(key, item);\n      return null;\n    }\n    if (item != null) {\n      currentSize += itemSize;\n    }\n    @Nullable Entry\u003cY\u003e old = cache.put(key, item == null ? null : new Entry\u003c\u003e(item, itemSize));\n    if (old != null) {\n      currentSize -= old.size;\n      if (!old.value.equals(item)) {\n        onItemEvicted(key, old.value);\n      }\n    }\n    evict();\n    return old != null ? old.value : null;\n  }\n\n  @Nullable\n  public synchronized Y remove(@NonNull T key) {\n    Entry\u003cY\u003e entry = cache.remove(key);\n    if (entry == null) {\n      return null;\n    }\n    currentSize -= entry.size;\n    return entry.value;\n  }\n  \n  public void clearMemory() {\n    trimToSize(0);\n  }\n\n  protected synchronized void trimToSize(long size) {\n    Map.Entry\u003cT, Entry\u003cY\u003e\u003e last;\n    Iterator\u003cMap.Entry\u003cT, Entry\u003cY\u003e\u003e\u003e cacheIterator;\n    while (currentSize \u003e size) {\n      //从头开始遍历\n      cacheIterator = cache.entrySet().iterator();\n      //第一个元素\n      last = cacheIterator.next();\n      final Entry\u003cY\u003e toRemove = last.getValue();\n      currentSize -= toRemove.size;\n      final T key = last.getKey();\n      cacheIterator.remove();\n      onItemEvicted(key, toRemove.value);\n    }\n  }\n  \n  private void evict() {\n    trimToSize(maxSize);\n  }\n  \n  @Synthetic\n  static final class Entry\u003cY\u003e {\n    final Y value;\n    final int size;\n    @Synthetic\n    Entry(Y value, int size) {\n      this.value = value;\n      this.size = size;\n    }\n  }\n}\n```\n\nLruCache 内部持有一个 LinkedHashMap 的变量 cache ：\n\n```java\nprivate final Map\u003cT, Entry\u003cY\u003e\u003e cache = \n      new LinkedHashMap\u003c\u003e(100, 0.75f, true);\n```\n\n当第三个参数 accessOrder 为 true 时，表示按照访问顺序排序，每次调用 LinkedHashMap 的 get(key) 或 getOrDefault(key, defaultValue) 方法都会触发 afterNodeAccess(Object) 方法，此方法会将对应的 node 移动到链表的末尾。也就是说 LinkedHashMap 末尾的数据是最近最多使用的。\n\n而 LruCache 清除内存时都会调用 trimToSize(size) 方法时，会从头到尾进行清理，即清理掉最少使用的元素。\n\nLinkedHashMap 主要代码如下：\n\n```java\npublic class LinkedHashMap\u003cK,V\u003e extends HashMap\u003cK,V\u003e implements Map\u003cK,V\u003e {\n    ...\n    public LinkedHashMap(int initialCapacity, \n            float loadFactor, boolean accessOrder) {\n        super(initialCapacity, loadFactor);\n        this.accessOrder = accessOrder;\n    }\n    \n    public V get(Object key) {\n        Node\u003cK,V\u003e e;\n        if ((e = getNode(hash(key), key)) == null)\n            return null;\n        if (accessOrder)\n            afterNodeAccess(e);\n        return e.value;\n    }\n\n    public V getOrDefault(Object key, V defaultValue) {\n       Node\u003cK,V\u003e e;\n       if ((e = getNode(hash(key), key)) == null)\n           return defaultValue;\n       if (accessOrder)\n           afterNodeAccess(e);\n       return e.value;\n    }\n    \n    void afterNodeAccess(Node\u003cK,V\u003e e) { // move node to last\n        LinkedHashMapEntry\u003cK,V\u003e last;\n        if (accessOrder \u0026\u0026 (last = tail) != e) {\n            LinkedHashMapEntry\u003cK,V\u003e p =\n                (LinkedHashMapEntry\u003cK,V\u003e)e, b = p.before, a = p.after;\n            p.after = null;\n            if (b == null)\n                head = a;\n            else\n                b.after = a;\n            if (a != null)\n                a.before = b;\n            else\n                last = b;\n            if (last == null)\n                head = p;\n            else {\n                p.before = last;\n                last.after = p;\n            }\n            tail = p;\n            ++modCount;\n        }\n    }\n    ...\n}\n```\n\n## \u003cstrong\u003e磁盘缓存 DiskCache\u003c/strong\u003e\n\nGlide 初始化时，如果 disCacheFactory 如果没有被指定，则会使用一个默认值，而这个 InternalCacheDiskCacheFactory 就是实现磁盘缓存的入口。\n\n```java\nif (diskCacheFactory == null) {\n    diskCacheFactory = new InternalCacheDiskCacheFactory(context);\n}\n```\n\nInternalCacheDiskCacheFactory 源码如下：\n\n```java\npublic final class InternalCacheDiskCacheFactory extends DiskLruCacheFactory {\n\n  public InternalCacheDiskCacheFactory(Context context) {\n    this(\n        context,\n        DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,\n        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);\n  }\n\n  public InternalCacheDiskCacheFactory(Context context, long diskCacheSize) {\n    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);\n  }\n\n  public InternalCacheDiskCacheFactory(\n      final Context context, final String diskCacheName, long diskCacheSize) {\n    super(\n        new CacheDirectoryGetter() {\n          @Override\n          public File getCacheDirectory() {\n            File cacheDirectory = context.getCacheDir();\n            if (cacheDirectory == null) {\n              return null;\n            }\n            if (diskCacheName != null) {\n              return new File(cacheDirectory, diskCacheName);\n            }\n            return cacheDirectory;\n          }\n        },\n        diskCacheSize);\n  }\n}\n```\n\n它的父类 DiskLruCacheFactory 和 DiskCache 类源码如下：\n\n```java\npublic class DiskLruCacheFactory implements DiskCache.Factory {\n  private final long diskCacheSize;\n  private final CacheDirectoryGetter cacheDirectoryGetter;\n\n  /** Interface called out of UI thread to get the cache folder. */\n  public interface CacheDirectoryGetter {\n    File getCacheDirectory();\n  }\n\n  public DiskLruCacheFactory(final String diskCacheFolder, long diskCacheSize) {\n    this(\n        new CacheDirectoryGetter() {\n          @Override\n          public File getCacheDirectory() {\n            return new File(diskCacheFolder);\n          }\n        },\n        diskCacheSize);\n  }\n\n  public DiskLruCacheFactory(\n      final String diskCacheFolder, final String diskCacheName, long diskCacheSize) {\n    this(\n        new CacheDirectoryGetter() {\n          @Override\n          public File getCacheDirectory() {\n            return new File(diskCacheFolder, diskCacheName);\n          }\n        },\n        diskCacheSize);\n  }\n\n  @SuppressWarnings(\"WeakerAccess\")\n  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, long diskCacheSize) {\n    this.diskCacheSize = diskCacheSize;\n    this.cacheDirectoryGetter = cacheDirectoryGetter;\n  }\n\n  @Override\n  public DiskCache build() {\n    File cacheDir = cacheDirectoryGetter.getCacheDirectory();\n\n    if (cacheDir == null) {\n      return null;\n    }\n\n    if (cacheDir.isDirectory() || cacheDir.mkdirs()) {\n      return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);\n    }\n\n    return null;\n  }\n}\n\npublic interface DiskCache {\n  /** An interface for lazily creating a disk cache. */\n  interface Factory {\n    /** 250 MB of cache. */\n    int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;\n    String DEFAULT_DISK_CACHE_DIR = \"image_manager_disk_cache\";\n    /** Returns a new disk cache, or {@code null} if no disk cache could be created. */\n    @Nullable\n    DiskCache build();\n  }\n  /** An interface to actually write data to a key in the disk cache. */\n  interface Writer {\n    boolean write(@NonNull File file);\n  }\n\n  @Nullable\n  File get(Key key);\n\n  void put(Key key, Writer writer);\n\n  void delete(Key key);\n\n  void clear();\n}\n```\n\nDiskLruCacheFactory.build() 方法会返回一个 DiskLruCacheWrapper 类的实例。回溯到前面 InternalCacheDiskCacheFactory 的创建流程可知，默认创建的 DiskLruCacheWrapper 传入的 diskCacheSize 为 250M 并且 cacheDir 为 \u003cem\u003e/data/data/{package}/cache/image_manager_disk_cache/ \u003c/em\u003e，分别对应缓存大小和目录。\n\n接下来查看 DiskLruCacheWrapper 源码：\n\n```java\npublic class DiskLruCacheWrapper implements DiskCache {\n  private static final String TAG = \"DiskLruCacheWrapper\";\n\n  private static final int APP_VERSION = 1;\n  private static final int VALUE_COUNT = 1;\n  private static DiskLruCacheWrapper wrapper;\n\n  private final SafeKeyGenerator safeKeyGenerator;\n  private final File directory;\n  private final long maxSize;\n  private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();\n  private DiskLruCache diskLruCache;\n\n  ...\n  \n  @SuppressWarnings(\"deprecation\")\n  public static DiskCache create(File directory, long maxSize) {\n    return new DiskLruCacheWrapper(directory, maxSize);\n  }\n\n  @SuppressWarnings({\"WeakerAccess\", \"DeprecatedIsStillUsed\"})\n  protected DiskLruCacheWrapper(File directory, long maxSize) {\n    this.directory = directory;\n    this.maxSize = maxSize;\n    this.safeKeyGenerator = new SafeKeyGenerator();\n  }\n\n  private synchronized DiskLruCache getDiskCache() throws IOException {\n    if (diskLruCache == null) {\n      diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);\n    }\n    return diskLruCache;\n  }\n\n  @Override\n  public File get(Key key) {\n    String safeKey = safeKeyGenerator.getSafeKey(key);\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(TAG, \"Get: Obtained: \" + safeKey + \" for for Key: \" + key);\n    }\n    File result = null;\n    try {\n      final DiskLruCache.Value value = getDiskCache().get(safeKey);\n      if (value != null) {\n        result = value.getFile(0);\n      }\n    } catch (IOException e) {\n      if (Log.isLoggable(TAG, Log.WARN)) {\n        Log.w(TAG, \"Unable to get from disk cache\", e);\n      }\n    }\n    return result;\n  }\n\n  @Override\n  public void put(Key key, Writer writer) {\n    String safeKey = safeKeyGenerator.getSafeKey(key);\n    writeLocker.acquire(safeKey);\n    try {\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        Log.v(TAG, \"Put: Obtained: \" + safeKey + \" for for Key: \" + key);\n      }\n      try {\n        DiskLruCache diskCache = getDiskCache();\n        Value current = diskCache.get(safeKey);\n        if (current != null) {\n          return;\n        }\n\n        DiskLruCache.Editor editor = diskCache.edit(safeKey);\n        if (editor == null) {\n          throw new IllegalStateException(\"Had two simultaneous puts for: \" + safeKey);\n        }\n        try {\n          File file = editor.getFile(0);\n          if (writer.write(file)) {\n            editor.commit();\n          }\n        } finally {\n          editor.abortUnlessCommitted();\n        }\n      } catch (IOException e) {\n        if (Log.isLoggable(TAG, Log.WARN)) {\n          Log.w(TAG, \"Unable to put to disk cache\", e);\n        }\n      }\n    } finally {\n      writeLocker.release(safeKey);\n    }\n  }\n\n  @Override\n  public void delete(Key key) {\n    String safeKey = safeKeyGenerator.getSafeKey(key);\n    try {\n      getDiskCache().remove(safeKey);\n    } catch (IOException e) {\n      if (Log.isLoggable(TAG, Log.WARN)) {\n        Log.w(TAG, \"Unable to delete from disk cache\", e);\n      }\n    }\n  }\n\n  @Override\n  public synchronized void clear() {\n    try {\n      getDiskCache().delete();\n    } catch (IOException e) {\n      if (Log.isLoggable(TAG, Log.WARN)) {\n        Log.w(TAG, \"Unable to clear disk cache or disk cache cleared externally\", e);\n      }\n    } finally {\n      resetDiskCache();\n    }\n  }\n\n  private synchronized void resetDiskCache() {\n    diskLruCache = null;\n  }\n}\n```\n\n该类主要提供了一个生成 Key 的 SafeKeyGenerator 对象以及写锁 DiskCacheWriteLocker。从类名来看这是一个包装类，在代码中也可以看到，它的 get 和 put 方法最终都是通过 DiskLruCache 对象去实现的。\n\n前面提到过，disCacheFactory 对象会被作为参数参与 Engine 的构造，在 Engine 的构造方法中会被包装成为一个 LazyDiskCacheProvider：\n\n```java\nEngine(MemoryCache cache, DiskCache.Factory diskCacheFactory, ...) {\n  this.cache = cache;\n  this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);\n  ...\n}\nLazyDiskCacheProvider 源码如下：\nprivate static class LazyDiskCacheProvider implements DecodeJob.DiskCacheProvider {\n\n  private final DiskCache.Factory factory;\n  private volatile DiskCache diskCache;\n\n  LazyDiskCacheProvider(DiskCache.Factory factory) {\n    this.factory = factory;\n  }\n\n  @VisibleForTesting\n  synchronized void clearDiskCacheIfCreated() {\n    if (diskCache == null) {\n      return;\n    }\n    diskCache.clear();\n  }\n\n  @Override\n  public DiskCache getDiskCache() {\n    if (diskCache == null) {\n      synchronized (this) {\n        if (diskCache == null) {\n          diskCache = factory.build();\n        }\n        if (diskCache == null) {\n          diskCache = new DiskCacheAdapter();\n        }\n      }\n    }\n    return diskCache;\n  }\n}\n```\n\ngetDiskCache() 方法被调用时，会通过 DCL 的方式进而调用 factory 的 build( ) 方法返回一个 DiskCache 作为单例。\n\n以上就是 Glide 缓存的介绍，前面加载流程的分析只是在首次加载图片的时候的流程，并没有涉及到缓存的概念，因此接下来继续在以上 into 流程中重点分析缓存部分的源码。\n\n## 缓存流程\n\n### EngineKey\n\n从之前的分析中可知，整个加载的过程体现在 Engine.load 方法中，该方法注释和代码片段如下：\n\n```java\npublic \u003cR\u003e LoadStatus load(...) {\n  long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;\n\n  EngineKey key =\n      keyFactory.buildKey(\n          model,\n          signature,\n          width,\n          height,\n          transformations,\n          resourceClass,\n          transcodeClass,\n          options);\n\n  EngineResource\u003c?\u003e memoryResource;\n  synchronized (this) {\n    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);\n\n    if (memoryResource == null) {\n      //没有获取到活动资源和 MemoryCache，则启动 Job\n      return waitForExistingOrStartNewJob(...);\n    }\n  }\n\n  // Avoid calling back while holding the engine lock, doing so makes it easier for callers to\n  // deadlock.\n  cb.onResourceReady(\n      memoryResource, DataSource.MEMORY_CACHE, /* isLoadedFromAlternateCacheKey= */ false);\n  return null;\n}\n\n@Nullable\nprivate EngineResource\u003c?\u003e loadFromMemory(\n    EngineKey key, boolean isMemoryCacheable, long startTime) {\n  if (!isMemoryCacheable) {\n    return null;\n  }\n  EngineResource\u003c?\u003e active = loadFromActiveResources(key);\n  if (active != null) {\n    if (VERBOSE_IS_LOGGABLE) {\n      logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n    }\n    return active;\n  }\n  EngineResource\u003c?\u003e cached = loadFromCache(key);\n  if (cached != null) {\n    if (VERBOSE_IS_LOGGABLE) {\n      logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n    }\n    return cached;\n  }\n  return null;\n}\n\n@Nullable\nprivate EngineResource\u003c?\u003e loadFromActiveResources(Key key) {\n  EngineResource\u003c?\u003e active = activeResources.get(key);\n  if (active != null) {\n    active.acquire();\n  }\n  return active;\n}\n\nprivate EngineResource\u003c?\u003e loadFromCache(Key key) {\n  EngineResource\u003c?\u003e cached = getEngineResourceFromCache(key);\n  if (cached != null) {\n    cached.acquire();\n    activeResources.activate(key, cached);\n  }\n  return cached;\n}\n\nprivate EngineResource\u003c?\u003e getEngineResourceFromCache(Key key) {\n  Resource\u003c?\u003e cached = cache.remove(key);\n  final EngineResource\u003c?\u003e result;\n  if (cached == null) {\n    result = null;\n  } else if (cached instanceof EngineResource) {\n    // Save an object allocation if we've cached an EngineResource (the typical case).\n    result = (EngineResource\u003c?\u003e) cached;\n  } else {\n    result =\n        new EngineResource\u003c\u003e(\n            cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);\n  }\n  return result;\n}\n```\n\n从注释和代码中可以看出，首先会根据 key 尝试从 loadFromActiveResources() 方法中获取 ActiveResource，如果能够获取到则直接返回；否则从 loadFromCache() 方法中获取 memory cache；如果仍然没有获取到，最后就交给了 Job 从网络中获取资源。没有意外的话，磁盘缓存也是由 Job 完成的。\n\n只要是缓存，就有 get 和 put 操作，也就离不开 Key，所以先看看从 ActiveResource 和 MemoryCache 中取缓存时的 Key——EngineKey 的组成参数：\n\n| 参数             | 含义                                                                                                                                                                                |\n| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| model            | load 的参数。如：File、Url、Url 等。如果使用自定义的 model, 它需要正确地实现 hashCode() 和 equals()                                                                                 |\n| signature        | BaseRequestOptions 的成员变量，默认会是 EmptySignature.obtain()\u003cbr/\u003e在加载本地 resource 资源时会变成 ApplicationVersionSignature.obtain(context)                                    |\n| width\u003cbr/\u003eheight | 如果没有指定 override(int size)，则为 view 的 size                                                                                                                                  |\n| transformations  | 默认会基于 ImageView 的 scaleType 设置对应的四个 Transformation；\u003cbr/\u003e如果指定了 transform，那么就基于该值进行设置；\u003cbr/\u003e详见 BaseRequestOptions.transform(Transformation, boolean) |\n| resourceClass    | 解码后的资源，如果没有 asBitmap、asGif，一般会是 Object                                                                                                                             |\n| transcodeClass   | 最终要转换成的数据类型，根据 as 方法确定，加载本地 res 或者网络 URL，都会调用 asDrawable，所以为 Drawable                                                                           |\n| options          | 如果没有设置过 transform，此处会根据 ImageView 的 scaleType 默认指定一个 KV                                                                                                         |\n\n再来看 EngineKey 的内部：\n\n```java\nclass EngineKey implements Key {\n  ...\n  @Override\n  public boolean equals(Object o) {\n    if (o instanceof EngineKey) {\n      EngineKey other = (EngineKey) o;\n      return model.equals(other.model)\n          \u0026\u0026 signature.equals(other.signature)\n          \u0026\u0026 height == other.height\n          \u0026\u0026 width == other.width\n          \u0026\u0026 transformations.equals(other.transformations)\n          \u0026\u0026 resourceClass.equals(other.resourceClass)\n          \u0026\u0026 transcodeClass.equals(other.transcodeClass)\n          \u0026\u0026 options.equals(other.options);\n    }\n    return false;\n  }\n  \n  @Override\n  public int hashCode() {\n    if (hashCode == 0) {\n      hashCode = model.hashCode();\n      hashCode = 31 * hashCode + signature.hashCode();\n      hashCode = 31 * hashCode + width;\n      hashCode = 31 * hashCode + height;\n      hashCode = 31 * hashCode + transformations.hashCode();\n      hashCode = 31 * hashCode + resourceClass.hashCode();\n      hashCode = 31 * hashCode + transcodeClass.hashCode();\n      hashCode = 31 * hashCode + options.hashCode();\n    }\n    return hashCode;\n  }\n  ...\n}\n```\n\n可以看到，它的 equals 和 hashCode 方法都是标准的写法，所有成员变量都参与了判断和运算。因此在多次加载同一个 model 的过程中，即使有稍许改动（比如 View 宽高、是否经过变换等），都会导致没有获取内存缓存失败。\n\n### 内存缓存\n\n#### ActiveResource 和 MemoryCache\n\nActiveResource 的 Value 为 ResourceWeakReference，它是 EngineResource 的包装类； MemoryCache 则是直接保存 EngineResource 对象。看看 EngineResource 的内容：\n\n```java\nclass EngineResource\u003cZ\u003e implements Resource\u003cZ\u003e {\n  private final boolean isMemoryCacheable;\n  private final boolean isRecyclable;\n  private final Resource\u003cZ\u003e resource;\n  private final ResourceListener listener;\n  private final Key key;\n\n  private int acquired;\n  private boolean isRecycled;\n\n  interface ResourceListener {\n    void onResourceReleased(Key key, EngineResource\u003c?\u003e resource);\n  }\n\n  EngineResource(\n      Resource\u003cZ\u003e toWrap,\n      boolean isMemoryCacheable,\n      boolean isRecyclable,\n      Key key,\n      ResourceListener listener) {\n    resource = Preconditions.checkNotNull(toWrap);\n    this.isMemoryCacheable = isMemoryCacheable;\n    this.isRecyclable = isRecyclable;\n    this.key = key;\n    this.listener = Preconditions.checkNotNull(listener);\n  }\n\n  Resource\u003cZ\u003e getResource() {\n    return resource;\n  }\n\n  boolean isMemoryCacheable() {\n    return isMemoryCacheable;\n  }\n\n  @NonNull\n  @Override\n  public Class\u003cZ\u003e getResourceClass() {\n    return resource.getResourceClass();\n  }\n\n  @NonNull\n  @Override\n  public Z get() {\n    return resource.get();\n  }\n\n  @Override\n  public int getSize() {\n    return resource.getSize();\n  }\n\n  @Override\n  public synchronized void recycle() {\n    if (acquired \u003e 0) {\n      throw new IllegalStateException(\"Cannot recycle a resource while it is still acquired\");\n    }\n    if (isRecycled) {\n      throw new IllegalStateException(\"Cannot recycle a resource that has already been recycled\");\n    }\n    isRecycled = true;\n    if (isRecyclable) {\n      resource.recycle();\n    }\n  }\n\n  synchronized void acquire() {\n    if (isRecycled) {\n      throw new IllegalStateException(\"Cannot acquire a recycled resource\");\n    }\n    ++acquired;\n  }\n\n  void release() {\n    boolean release = false;\n    synchronized (this) {\n      if (acquired \u003c= 0) {\n        throw new IllegalStateException(\"Cannot release a recycled or not yet acquired resource\");\n      }\n      if (--acquired == 0) {\n        release = true;\n      }\n    }\n    if (release) {\n      listener.onResourceReleased(key, this);\n    }\n  }\n  ...\n}\n```\n\n可以看到，acquire() 方法内部会对一个整型变量 acquired 进行自增操作，这个变量表示该资源被引用的次数，当它大于 0 的时候表示图片正在使用中。相应地，在 release() 方法内部会 acquired 进行自减，并且当变量为 0 的时候，表示没有被任何地方引用，这时会调用 listener.onResourceReleased(key, this) 通知监听器资源已被释放，从而进行后续操作。\n\nacquire() 和 release() 方法在一般情况下外部是不能主动调用的，只有 Glide 框架会在合适的时机下会调用这两个方法。\n\n前面介绍活动资源的时候已经提到过，EngineResource.ResourceListener 唯一实现类为 Engine，来看它的实现内容：\n\n```java\n@Override\npublic void onResourceReleased(Key cacheKey, EngineResource\u003c?\u003e resource) {\n  //从 ActiveResource 中删除\n  activeResources.deactivate(cacheKey);\n  if (resource.isMemoryCacheable()) {\n    //如果开启了缓存则放入 MemoryCache \n    cache.put(cacheKey, resource);\n  } else {\n    resourceRecycler.recycle(resource, /*forceNextFrame=*/ false);\n  }\n}\n```\n\n首先会将缓存图片从活动资源中移除，然后再将它存入 MemoryCache 中。回到刚刚分析的 Engine.load 方法中，再看一次获取 ActiveResource 和 MemoryCache 的方法：\n\n```java\nprivate EngineResource\u003c?\u003e loadFromActiveResources(Key key) {\n  EngineResource\u003c?\u003e active = activeResources.get(key);\n  if (active != null) {\n    active.acquire();\n  }\n  return active;\n}\n\nprivate EngineResource\u003c?\u003e loadFromCache(Key key) {\n  //从 MemoryCache 中移除\n  EngineResource\u003c?\u003e cached = getEngineResourceFromCache(key);\n  if (cached != null) {\n    cached.acquire();\n    //放入 ActiveResource 中\n    activeResources.activate(key, cached);\n  }\n  return cached;\n}\n```\n\n除了从根据 Key 获取到 EngineResource 之外，中间还调用了 active.acquire() 方法。只要命中了缓存，那么该资源的引用计数就会加一。而且，如果命中的是 MemoryCache，那么此资源会被移动到 ActiveResource 中。\n\n结合刚才的分析过程可知，EngineResource 在 ActiveResource 和 MemoryCache 中是互斥存在的。正在使用中的图片使用弱引用（ActiveResource）来进行缓存，不在使用中和被 GC 回收的图片使用 LruCahce（MemoryCache） 来进行缓存。\n\n### 磁盘缓存\n\n#### DecoceJob\n\n回到 Engine.load() 方法中，如果是首次加载资源，那么 ActiveResouce 和 MemoryCache 中必然没有缓存下来，接着会走 waitForExistingOrStartNewJob() 方法：\n\n```java\nprivate \u003cR\u003e LoadStatus waitForExistingOrStartNewJob(...) {\n  ...\n  EngineJob\u003cR\u003e engineJob =\n      engineJobFactory.build(\n          key,\n          isMemoryCacheable,\n          useUnlimitedSourceExecutorPool,\n          useAnimationPool,\n          onlyRetrieveFromCache);\n\n  DecodeJob\u003cR\u003e decodeJob =\n      decodeJobFactory.build(...);\n\n  jobs.put(key, engineJob);\n\n  engineJob.addCallback(cb, callbackExecutor);\n  engineJob.start(decodeJob);\n\n  if (VERBOSE_IS_LOGGABLE) {\n    logWithTimeAndKey(\"Started new load\", startTime, key);\n  }\n  return new LoadStatus(cb, engineJob);\n}\n```\n\nDecoceJob 实现了 Runnable 接口，然后会被 EngineJob.start() 方法提交到对应的线程池中去执行，查看 DecoceJob.run() 方法的调用栈：\n\n```java\n@Override\npublic void run() {\n  ...\n  try {\n    ...\n.    \n    runWrapped();\n  } catch (Throwable t) {\n    ...\n.    \n  } finally {\n    ...\n  }\n}\n\nprivate void runWrapped() {\n  switch (runReason) {\n    case INITIALIZE:\n      stage = getNextStage(Stage.INITIALIZE);\n      currentGenerator = getNextGenerator();\n      runGenerators();\n      break;\n    case SWITCH_TO_SOURCE_SERVICE:\n      runGenerators();\n      break;\n    case DECODE_DATA:\n      decodeFromRetrievedData();\n      break;\n    default:\n      throw new IllegalStateException(\"Unrecognized run reason: \" + runReason);\n  }\n}\n\nprivate Stage getNextStage(Stage current) {\n  switch (current) {\n    case INITIALIZE:\n      return diskCacheStrategy.decodeCachedResource()\n          ? Stage.RESOURCE_CACHE\n          : getNextStage(Stage.RESOURCE_CACHE);\n    case RESOURCE_CACHE:\n      return diskCacheStrategy.decodeCachedData()\n          ? Stage.DATA_CACHE\n          : getNextStage(Stage.DATA_CACHE);\n    case DATA_CACHE:\n      // Skip loading from source if the user opted to only retrieve the resource from cache.\n      return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;\n    case SOURCE:\n    case FINISHED:\n      return Stage.FINISHED;\n    default:\n      throw new IllegalArgumentException(\"Unrecognized stage: \" + current);\n  }\n}\n\nprivate DataFetcherGenerator getNextGenerator() {\n  switch (stage) {\n    case RESOURCE_CACHE:\n      return new ResourceCacheGenerator(decodeHelper, this);\n    case DATA_CACHE:\n      return new DataCacheGenerator(decodeHelper, this);\n    case SOURCE:\n      return new SourceGenerator(decodeHelper, this);\n    case FINISHED:\n      return null;\n    default:\n      throw new IllegalStateException(\"Unrecognized stage: \" + stage);\n  }\n}\n\nprivate void runGenerators() {\n  currentThread = Thread.currentThread();\n  startFetchTime = LogTime.getLogTime();\n  boolean isStarted = false;\n  while (!isCancelled\n      \u0026\u0026 currentGenerator != null\n      \u0026\u0026 !(isStarted = currentGenerator.startNext())) {\n    stage = getNextStage(stage);\n    currentGenerator = getNextGenerator();\n    if (stage == Stage.SOURCE) {\n      reschedule();\n      return;\n    }\n  }\n  // We've run out of stages and generators, give up.\n  if ((stage == Stage.FINISHED || isCancelled) \u0026\u0026 !isStarted) {\n    notifyFailed();\n  }\n  // Otherwise a generator started a new load and we expect to be called back in\n  // onDataFetcherReady.\n}\n```\n\nDecoceJob.run() 中主要调用了 runWrapped() 方法。在此方法中，首次加载时 runReason 为初始化即 RunReason.INITIALIZE 状态 ，又 diskCacheStrategy 默认为 DiskCacheStrategy.AUTOMATIC，且没有设置过 onlyRetrieveFromCache(true)。所以， decode data 的状态依次为 INITIALIZE -\u003e RESOURCE_CACHE -\u003e DATA_CACHE -\u003e SOURCE -\u003e FINISHED。对应的 DataFectcherGenerator 的 list 依次为 ResourceCacheGenerator -\u003e DataCacheGenerator -\u003e SourceGenerator。\n\n在 runGenerators() 方法中会依次调用各个状态生成的 DataFetcherGenerator 的 startNext() 方法尝试 fetch 数据，直到有某个状态的 DataFetcherGenerator.startNext() 方法可以胜任。若状态抵达到了 Stage.FINISHED 或 Job 被取消，且所有状态的 DataFetcherGenerator.startNext() 都无法满足条件，则调用 SingleRequest.onLoadFailed() 进行错误处理。\n\n这里总共有三个 DataFetcherGenerator，依次是：\n\n1. \u003cstrong\u003eResourceCacheGenerator\u003c/strong\u003e：获取采样后、transformed 后资源文件的缓存文件\n2. \u003cstrong\u003eDataCacheGenerator\u003c/strong\u003e：获取原始的没有修改过的资源文件的缓存文件\n3. \u003cstrong\u003eSourceGenerator\u003c/strong\u003e：获取原始源数据，即从网络下载或者从本地资源中加载\n\n#### ResourceCacheKey 和 DataCacheKey\n\n看以看到，ResourceCacheGenerator 和 DataCacheGenerator 分别对应 Resource 和 Data 类型的缓存数据，都属于磁盘缓存的一部分，那么这两种数据的存取规则有什么区别呢？\n\n先看看 ResourceCacheGenerator 中查找缓存时 key 的组成部分：\n\n```java\ncurrentKey =\n    new ResourceCacheKey(\n        helper.getArrayPool(),\n        sourceId,\n        helper.getSignature(),\n        helper.getWidth(),\n        helper.getHeight(),\n        transformation,\n        resourceClass,\n        helper.getOptions());\n```\n\n它的各个参数含义如下：\n\n| 参数                                     | 含义                                                                                                                                             |\n| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| helper.getArrayPool()                    | GlideBuilder.build 时初始化，默认为 LruArrayPool；但不参与 key 的 equals 方法                                                                    |\n| sourceId                                 | 如果请求的是 URL，那么此处会是一个 GlideUrl                                                                                                      |\n| helper.getSignature()                    | BaseRequestOptions 的成员变量，默认会是 EmptySignature.obtain()\u003cbr/\u003e在加载本地 resource 资源时会变成 ApplicationVersionSignature.obtain(context) |\n| helper.getWidth()\u003cbr/\u003ehelper.getHeight() | 如果没有指定 override(int size)，那么将得到 view 的 size                                                                                         |\n| transformation                           | 默认会根据 ImageView 的 scaleType 设置对应的 BitmapTransformation；\u003cbr/\u003e如果指定了 transform，那就是指定的值                                     |\n| resourceClass                            | 可以被编码成的资源类型，比如 BitmapDrawable 等                                                                                                   |\n| helper.getOptions()                      | 如果没有设置过 transform，此处会根据 ImageView 的 scaleType 默认指定一个 KV                                                                      |\n\n在 ResourceCacheKey 中，arrayPool 并没有参与 equals 方法，所以判断两个 ResourceCacheKey 是否相等只需要其他 7 个参数。\n\n然后看看 DataCacheGenerator 中 Key 的组成部分：\n\nKey originalKey = new DataCacheKey(sourceId, helper.getSignature());\n\n它的各个参数含义如下：\n\n| 参数                  | 含义                                                                                                                                             |\n| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| sourceId              | 如果请求的是 URL，那么此处会是一个 GlideUrl                                                                                                      |\n| helper.getSignature() | BaseRequestOptions 的成员变量，默认会是 EmptySignature.obtain()\u003cbr/\u003e在加载本地 resource 资源时会变成 ApplicationVersionSignature.obtain(context) |\n\n在 DataCacheKey 中，仅有的两个变量都参与了 equals 方法。这两个变量就是上面 ResourceCacheKey 中的两个变量。\n\n显然，Data Cache 就是比较原始的数据构成的缓存，而 Resource Cache 是被解码、转换后的 Data Cache，与前面的分析呼应起来了。\n\n#### ResourceCacheGenerator\n\n先来看 ResourceCacheGenerator 的 startNext() 方法：\n\n```java\n@Override\npublic boolean startNext() {\n ...\n while (modelLoaders == null || !hasNextModelLoader()) {\n   ...\n   currentKey =\n       new ResourceCacheKey(// NOPMD AvoidInstantiatingObjectsInLoops\n           helper.getArrayPool(),\n           sourceId,\n           helper.getSignature(),\n           helper.getWidth(),\n           helper.getHeight(),\n           transformation,\n           resourceClass,\n           helper.getOptions());\n   //根据 ResourceCacheKey 获取缓存\n   cacheFile = helper.getDiskCache().get(currentKey);\n   //如果找到了缓存文件，那么循环条件则会为 false，也就退出循环了\n   if (cacheFile != null) {\n     sourceKey = sourceId;\n     modelLoaders = helper.getModelLoaders(cacheFile);\n     modelLoaderIndex = 0;\n   }\n }\n // 如果找到了，hasNextModelLoader() 方法则会为 true，可以执行循环\n // 没有找到缓存文件，则不会进入循环，会直接返回 false\n loadData = null;\n boolean started = false;\n while (!started \u0026\u0026 hasNextModelLoader()) {\n   ModelLoader\u003cFile, ?\u003e modelLoader = modelLoaders.get(modelLoaderIndex++);\n   // 在循环中会依次判断某个 ModelLoader 能不能加载此文件\n   loadData = modelLoader.buildLoadData(cacheFile,\n       helper.getWidth(), helper.getHeight(), helper.getOptions());\n   if (loadData != null \u0026\u0026 helper.hasLoadPath(loadData.fetcher.getDataClass())) {\n     started = true;\n     // 如果某个 ModelLoader 可以，那么就调用其 fetcher 进行加载数据\n     // 加载成功或失败会通知自身\n     loadData.fetcher.loadData(helper.getPriority(), this);\n   }\n }\n return started;\n}\n```\n\n获取缓存的那行代码 helper.getDiskCache().get(currentKey) 将会调用到 DiskLruCacheWrapper.get 方法：\n\n```java\n@Override\npublic File get(Key key) {\n  //生成一个 String 类型的 SafeKey\n  String safeKey = safeKeyGenerator.getSafeKey(key);\n  if (Log.isLoggable(TAG, Log.VERBOSE)) {\n    Log.v(TAG, \"Get: Obtained: \" + safeKey + \" for for Key: \" + key);\n  }\n  File result = null;\n  try {\n    //真正去获取磁盘文件缓存\n    final DiskLruCache.Value value = getDiskCache().get(safeKey);\n    if (value != null) {\n      result = value.getFile(0);\n    }\n  } catch (IOException e) {\n    if (Log.isLoggable(TAG, Log.WARN)) {\n      Log.w(TAG, \"Unable to get from disk cache\", e);\n    }\n  }\n  return result;\n}\n```\n\n首先会使用 Key 映射成一个 String 类型的 safeKey，接着根据这个 safeKey 从 DiskCache 中获取缓存。\n\n回到 ResourceCacheGenerator 中，如果确实有缓存，那么会加载该缓存文件。对于 URL 来说，调用了 ByteBufferFetcher 进行缓存文件的加载，加载成功了返回了一个 ByteBuffer，并调用了 callback 也 就是 ResourceCacheGenerator 的 onDataReady 方法。\n\n```java\n@Override\npublic void onDataReady(Object data) {\n  cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE,\n      currentKey);\n}\n```\n\n然后 ResourceCacheGenerator 又会回调 DecodeJob 的 onDataFetcherReady 方法进行后续的解码操作。\n\n如果没有在 ResourceCacheGenerator 中被 fetch，则会回调 onLoadFailed() 方法：\n\n```java\n@Override\npublic void onLoadFailed(@NonNull Exception e) {\n  cb.onDataFetcherFailed(currentKey, e, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE);\n}\n```\n\n后面 DataCacheGenerator 和 SourceGenerator 的成功回调都会到这里来。\n\n接着回调到 DecodeJob 中继续执行 runGenerators() 方法：\n\n```java\n@Override\npublic void onDataFetcherFailed(\n    Key attemptedKey, Exception e, DataFetcher\u003c?\u003e fetcher, DataSource dataSource) {\n  fetcher.cleanup();\n  GlideException exception = new GlideException(\"Fetching data failed\", e);\n  exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());\n  throwables.add(exception);\n  if (Thread.currentThread() != currentThread) {\n    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;\n    callback.reschedule(this);\n  } else {\n    runGenerators();\n  }\n}\n```\n\n#### DataCacheGenerator\n\nDecodeJob.runGenerators 方法中，继续执行 while 循环将会调用 DataCacheGenerator 的 startNext() 方法：\n\n```java\n@Override\npublic boolean startNext() {\n  while (modelLoaders == null || !hasNextModelLoader()) {\n    sourceIdIndex++;\n    if (sourceIdIndex \u003e= cacheKeys.size()) {\n      return false;\n    }\n    Key sourceId = cacheKeys.get(sourceIdIndex);\n    // PMD.AvoidInstantiatingObjectsInLoops The loop iterates a limited number of times\n    // and the actions it performs are much more expensive than a single allocation.\n    @SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\n    Key originalKey = new DataCacheKey(sourceId, helper.getSignature());\n    cacheFile = helper.getDiskCache().get(originalKey);\n    if (cacheFile != null) {\n      this.sourceKey = sourceId;\n      modelLoaders = helper.getModelLoaders(cacheFile);\n      modelLoaderIndex = 0;\n    }\n  }\n  loadData = null;\n  boolean started = false;\n  while (!started \u0026\u0026 hasNextModelLoader()) {\n    ModelLoader\u003cFile, ?\u003e modelLoader = modelLoaders.get(modelLoaderIndex++);\n    loadData =\n        modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),\n            helper.getOptions());\n    if (loadData != null \u0026\u0026 helper.hasLoadPath(loadData.fetcher.getDataClass())) {\n      started = true;\n      loadData.fetcher.loadData(helper.getPriority(), this);\n    }\n  }\n  return started;\n}\n\nprivate boolean hasNextModelLoader() {\n  return modelLoaderIndex \u003c modelLoaders.size();\n}\n```\n\n过程和 ResourceCacheGenerator 相似，由于获取的是原始的源数据，所以这里的 key 的组成非常简单。\n\n#### SourceGenerator\n\n由于是第一次加载，本地缓存文件肯定是没有的，接着会调用 SourceGenerator 的 startNext() 方法从网络或者本地资源中加载。\n\n```java\nprivate int loadDataListIndex;\n\n@Override\npublic boolean startNext() {\n  // 首次运行 dataToCache 为 null\n  if (dataToCache != null) {\n    Object data = dataToCache;\n    dataToCache = null;\n    cacheData(data);\n  }\n  // 首次运行 sourceCacheGenerator 为 null\n  if (sourceCacheGenerator != null \u0026\u0026 sourceCacheGenerator.startNext()) {\n    return true;\n  }\n  sourceCacheGenerator = null;\n  // 准备加载数据\n  loadData = null;\n  boolean started = false;\n  // 这里直接调用了 DecodeHelper.getLoadData() 方法\n  // 该方法在前面在 ResourceCacheGenerator 中被调用过，且被缓存了下来\n  while (!started \u0026\u0026 hasNextModelLoader()) {\n    loadData = helper.getLoadData().get(loadDataListIndex++);\n    if (loadData != null\n        \u0026\u0026 (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())\n        || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {\n      started = true;\n      //调用 MultiFetcher.loadData，然后用 this 接收回调\n      loadData.fetcher.loadData(helper.getPriority(), this);\n    }\n  }\n  return started;\n}\n\nprivate boolean hasNextModelLoader() {\n  return loadDataListIndex \u003c helper.getLoadData().size();\n}\n```\n\nhelper.getLoadData() 的值在 ResourceCacheGenerator 中就已经被获取并缓存下来了，这是一个 MultiModelLoader 对象生成的 LoadData 对象，LoadData 对象里面有两个 fetcher。\n\n在上面的方法中，会遍历 LoadData list，找出符合条件的 LoadData，然后调用 loadData.fetcher.loadData 加载数据。\n\n在 loadData 不为空的前提下，会判断 Glide 的缓存策略是否可以缓存此数据源，或者是否有加载路径。默认情况下 Glide 的缓存策略是 DiskCacheStrategy.AUTOMATIC，它的 isDataCacheable 实现如下：\n\n```java\n@Override\npublic boolean isDataCacheable(DataSource dataSource) {\n  //DataSource.REMOTE 代表网络资源\n  return dataSource == DataSource.REMOTE;\n}\n```\n\n再看下 loadData.fetcher.getDataSource()：\n\n```java\nstatic class MultiFetcher\u003cData\u003e implements DataFetcher\u003cData\u003e, DataCallback\u003cData\u003e {\n  @NonNull\n  @Override\n  public DataSource getDataSource() {\n    //fetchers 数组保存的两个 DataFetcher 都是 HttpUrlFetcher\n    return fetchers.get(0).getDataSource();\n  }\n}\n\npublic class HttpUrlFetcher implements DataFetcher\u003cInputStream\u003e {\n  @NonNull\n  @Override\n  public DataSource getDataSource() {\n    return DataSource.REMOTE;\n  }\n}\n```\n\n显然，Glide 的缓存策略是可以缓存此数据源的，所以会进行数据加载。接着看看 MultiFetcher.loadData 方法：\n\n```java\nstatic class MultiFetcher\u003cData\u003e implements DataFetcher\u003cData\u003e, DataCallback\u003cData\u003e {\n  private final List\u003cDataFetcher\u003cData\u003e\u003e fetchers;\n  private int currentIndex;\n  private Priority priority;\n  private DataCallback\u003c? super Data\u003e callback;\n  \n  @Override\n  public void loadData(\n      @NonNull Priority priority, @NonNull DataCallback\u003c? super Data\u003e callback) {\n    this.priority = priority;\n    this.callback = callback;\n    exceptions = throwableListPool.acquire();\n    fetchers.get(currentIndex).loadData(priority, this);\n    // If a race occurred where we cancelled the fetcher in cancel() and then called loadData here\n    // immediately after, make sure that we cancel the newly started fetcher. We don't bother\n    // checking cancelled before loadData because it's not required for correctness and would\n    // require an unlikely race to be useful.\n    if (isCancelled) {\n      cancel();\n    }\n  }\n  \n  @Override\n  public void onDataReady(@Nullable Data data) {\n    if (data != null) {\n      callback.onDataReady(data);\n    } else {\n      startNextOrFail();\n    }\n  }\n  \n  @Override\n  public void onLoadFailed(@NonNull Exception e) {\n    Preconditions.checkNotNull(exceptions).add(e);\n    startNextOrFail();\n  }\n  \n  private void startNextOrFail() {\n    if (isCancelled) {\n      return;\n    }\n    if (currentIndex \u003c fetchers.size() - 1) {\n      currentIndex++;\n      loadData(priority, callback);\n    } else {\n      Preconditions.checkNotNull(exceptions);\n      callback.onLoadFailed(new GlideException(\"Fetch failed\", new ArrayList\u003c\u003e(exceptions)));\n    }\n  }\n}\n```\n\n这里面两个 DataFetcher 都是参数相同的 HttpUrlFetcher 实例，我们直接看里面如何从网络加载图片的。\n\n```java\n@Override\npublic void loadData(@NonNull Priority priority,\n    @NonNull DataCallback\u003c? super InputStream\u003e callback) {\n  long startTime = LogTime.getLogTime();\n  try {\n    //获取 InputStream \n    InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());\n    //将结果回调给 MultiFetcher\n    callback.onDataReady(result);\n  } catch (IOException e) {\n    if (Log.isLoggable(TAG, Log.DEBUG)) {\n      Log.d(TAG, \"Failed to load data for url\", e);\n    }\n    callback.onLoadFailed(e);\n  } finally {\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(TAG, \"Finished http url fetcher fetch in \" + LogTime.getElapsedMillis(startTime));\n    }\n  }\n}\n```\n\n这里将请求操作放到了 loadDataWithRedirects() 方法中，然后将请求结果通过回调返回上一层也就是 MultiFetcher.onDataReady() 中。\n\n```java\nprivate InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,\n    Map\u003cString, String\u003e headers) throws IOException {\n  // 检查重定向次数\n  if (redirects \u003e= MAXIMUM_REDIRECTS) {\n    throw new HttpException(\"Too many (\u003e \" + MAXIMUM_REDIRECTS + \") redirects!\");\n  } else {\n    // Comparing the URLs using .equals performs additional network I/O and is generally broken.\n    // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.\n    try {\n      // 检查是不是重定向到自身了\n      if (lastUrl != null \u0026\u0026 url.toURI().equals(lastUrl.toURI())) {\n        throw new HttpException(\"In re-direct loop\");\n      }\n    } catch (URISyntaxException e) {\n      // Do nothing, this is best effort.\n    }\n  }\n  // connectionFactory默认是DefaultHttpUrlConnectionFactory\n  // 其build方法就是调用了url.openConnection()\n  urlConnection = connectionFactory.build(url);\n  for (Map.Entry\u003cString, String\u003e headerEntry : headers.entrySet()) {\n    urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());\n  }\n  urlConnection.setConnectTimeout(timeout);\n  urlConnection.setReadTimeout(timeout);\n  urlConnection.setUseCaches(false);\n  urlConnection.setDoInput(true);\n  // Stop the urlConnection instance of HttpUrlConnection from following redirects so that\n  // redirects will be handled by recursive calls to this method, loadDataWithRedirects.\n  // 禁止HttpUrlConnection自动重定向，重定向功能由本方法自己实现\n  urlConnection.setInstanceFollowRedirects(false);\n  // Connect explicitly to avoid errors in decoders if connection fails.\n  urlConnection.connect();\n  // Set the stream so that it's closed in cleanup to avoid resource leaks. See #2352.\n  stream = urlConnection.getInputStream();\n  if (isCancelled) {\n    return null;\n  }\n  final int statusCode = urlConnection.getResponseCode();\n  if (isHttpOk(statusCode)) {\n    // statusCode=2xx，请求成功\n    return getStreamForSuccessfulRequest(urlConnection);\n  } else if (isHttpRedirect(statusCode)) {\n    // statusCode=3xx，需要重定向\n    String redirectUrlString = urlConnection.getHeaderField(\"Location\");\n    if (TextUtils.isEmpty(redirectUrlString)) {\n      throw new HttpException(\"Received empty or null redirect url\");\n    }\n    URL redirectUrl = new URL(url, redirectUrlString);\n    // Closing the stream specifically is required to avoid leaking ResponseBodys in addition\n    // to disconnecting the url connection below. See #2352.\n    cleanup();\n    return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);\n  } else if (statusCode == INVALID_STATUS_CODE) {\n    // -1 表示不是HTTP响应\n    throw new HttpException(statusCode);\n  } else {\n    // 其他HTTP错误\n    throw new HttpException(urlConnection.getResponseMessage(), statusCode);\n  }\n}\n```\n\n到这一步已经获得网络图片的 InputStream 了，该资源会通过回调经过 MultiFetcher 然后再次回调到 SourceGenerator 中。\n\n```java\n@Override\npublic void onDataReady(Object data) {\n  DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();\n  if (data != null \u0026\u0026 diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) {\n    dataToCache = data;\n    // We might be being called back on someone else's thread. Before doing anything, we should\n    // reschedule to get back onto Glide's thread.\n    cb.reschedule();\n  } else {\n    cb.onDataFetcherReady(loadData.sourceKey, data, loadData.fetcher,\n        loadData.fetcher.getDataSource(), originalKey);\n  }\n}\n\n@Override\npublic void onLoadFailed(@NonNull Exception e) {\n  cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());\n}\n```\n\nonLoadFailed() 方法很简单，直接回调 DecodeJob.onDataFetcherFailed 方法。onDataReady() 方法会首先判 data 能不能缓存，若能缓存则缓存起来，然后调用 DataCacheGenerator 进行加载缓存；若不能缓存，则直接回调 DecodeJob.onDataFetcherReady() 方法通知外界 data 已经准备好了。\n\n获取 DiskCacheStrategy 并判断能不能被缓存的逻辑在 SourceGenerator.startNext() 中出现过，之类显然是可以的。然后将 data 保存到 dataToCache，并调用 cb.reschedule()。\n\ncb.reschedule() 的作用就是将 DecodeJob 提交到 Glide 的 source 线程池中。然后执行 DecodeJob.run() 方法，经过 runWrapped()、 runGenerators() 方法后，又回到了 SourceGenerator.startNext() 方法。\n\n```java\n@Override\npublic boolean startNext() {\n  //首先判断是否有数据待缓存\n  if (dataToCache != null) {\n    Object data = dataToCache;\n    dataToCache = null;\n    cacheData(data);\n  }\n  \n  //刚刚构建了一个 DataCacheGenerator，这里不为空\n  //调用 startNext() 后返回 true\n  if (sourceCacheGenerator != null \u0026\u0026 sourceCacheGenerator.startNext()) {\n    return true;\n  }\n  ...\n}\n\nprivate void cacheData(Object dataToCache) {\n  long startTime = LogTime.getLogTime();\n  try {\n    Encoder\u003cObject\u003e encoder = helper.getSourceEncoder(dataToCache);\n    DataCacheWriter\u003cObject\u003e writer =\n        new DataCacheWriter\u003c\u003e(encoder, dataToCache, helper.getOptions());\n    originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());\n    //缓存 data\n    helper.getDiskCache().put(originalKey, writer);\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(TAG, \"Finished encoding source to cache\"\n          + \", key: \" + originalKey\n          + \", data: \" + dataToCache\n          + \", encoder: \" + encoder\n          + \", duration: \" + LogTime.getElapsedMillis(startTime));\n    }\n  } finally {\n    loadData.fetcher.cleanup();\n  }\n  //构建一个 DataCacheGenerator，传入 this 作为回调\n  sourceCacheGenerator =\n      new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);\n}\n```\n\n在 startNext() 方法的开头，会判断 dataToCache 是否为空，此时显然不为空，所以会调用 cacheData(Object) 方法进行 data 的缓存处理。缓存完毕后，会为该缓存文件生成一个 SourceCacheGenerator。然后在 startNext() 方法中会直接调用该变量进行加载。\n\n由于在构造 DataCacheGenerator 时，指定了 FetcherReadyCallback 为 this，所以这时 DataCacheGenerator 加载结果会由 SourceGenerator 转发给 DecodeJob。\n\n#### DecodeJob.FetcherReadyCallback\n\n先看一下 fetch 失败时干了什么，DecodeJob.onDataFetcherFailed() 方法的实现代码如下：\n\n```java\n@Override\npublic void onDataFetcherFailed(Key attemptedKey, Exception e, DataFetcher\u003c?\u003e fetcher,\n    DataSource dataSource) {\n  fetcher.cleanup();\n  GlideException exception = new GlideException(\"Fetching data failed\", e);\n  exception.setLoggingDetails(attemptedKey, dataSource, fetcher.getDataClass());\n  throwables.add(exception);\n  if (Thread.currentThread() != currentThread) {\n    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;\n    callback.reschedule(this);\n  } else {\n    runGenerators();\n  }\n}\n```\n\n显然，如果 fetch 失败了，如果不在 source 线程中就会回调 EnginJob 的 reschedule() 方法切换到 source 线程，然后重新调用 runGenerators() 方法尝试使用下一个 DataFetcherGenerator 进行加载，一直到没有一个可以加载，这时会调用 notifyFailed() 方法，正式宣告加载失败。\n\n然后再看成功的时候回调的 onDataFetcherReady() 方法：\n\n```java\n@Override\npublic void onDataFetcherReady(Key sourceKey, Object data, DataFetcher\u003c?\u003e fetcher,\n    DataSource dataSource, Key attemptedKey) {\n  this.currentSourceKey = sourceKey;\n  this.currentData = data;\n  this.currentFetcher = fetcher;\n  this.currentDataSource = dataSource;\n  this.currentAttemptingKey = attemptedKey;\n  //判断当前线程是否为 currentThread\n  if (Thread.currentThread() != currentThread) \n    runReason = RunReason.DECODE_DATA;\n    //如果不是，则让 EngineJob 重新调度，最后也会调用 decodeFromRetrievedData\n    callback.reschedule(this);\n  } else {\n    GlideTrace.beginSection(\"DecodeJob.decodeFromRetrievedData\");\n    try {\n      decodeFromRetrievedData();\n    } finally {\n      GlideTrace.endSection();\n    }\n  }\n}\n```\n\n首先会保存传入的参数，然后确认执行线程后调用 decodeFromRetrievedData() 方法进行解码：\n\n```java\nprivate void decodeFromRetrievedData() {\n  if (Log.isLoggable(TAG, Log.VERBOSE)) {\n    logWithTimeAndKey(\"Retrieved data\", startFetchTime,\n        \"data: \" + currentData\n            + \", cache key: \" + currentSourceKey\n            + \", fetcher: \" + currentFetcher);\n  }\n  Resource\u003cR\u003e resource = null;\n  try {\n    resource = decodeFromData(currentFetcher, currentData, currentDataSource);\n  } catch (GlideException e) {\n    e.setLoggingDetails(currentAttemptingKey, currentDataSource);\n    throwables.add(e);\n  }\n  if (resource != null) {\n    notifyEncodeAndRelease(resource, currentDataSource);\n  } else {\n    runGenerators();\n  }\n}\n```\n\n先调用 decodeFromData() 方法进行解码，然后调用 notifyEncodeAndRelease() 方法进行缓存，同时也会通知 EngineJob 资源已经准备好了。\n\ndecodeFromData() 方法调用栈如下：\n\n```java\nprivate \u003cData\u003e Resource\u003cR\u003e decodeFromData(DataFetcher\u003c?\u003e fetcher, Data data,\n    DataSource dataSource) throws GlideException {\n  try {\n    if (data == null) {\n      return null;\n    }\n    long startTime = LogTime.getLogTime();\n    Resource\u003cR\u003e result = decodeFromFetcher(data, dataSource);\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      logWithTimeAndKey(\"Decoded result \" + result, startTime);\n    }\n    return result;\n  } finally {\n    fetcher.cleanup();\n  }\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate \u003cData\u003e Resource\u003cR\u003e decodeFromFetcher(Data data, DataSource dataSource)\n    throws GlideException {\n  LoadPath\u003cData, ?, R\u003e path = decodeHelper.getLoadPath((Class\u003cData\u003e) data.getClass());\n  return runLoadPath(data, dataSource, path);\n}\n\nprivate \u003cData, ResourceType\u003e Resource\u003cR\u003e runLoadPath(Data data, DataSource dataSource,\n    LoadPath\u003cData, ResourceType, R\u003e path) throws GlideException {\n  Options options = getOptionsWithHardwareConfig(dataSource);\n  DataRewinder\u003cData\u003e rewinder = glideContext.getRegistry().getRewinder(data);\n  try {\n    // ResourceType in DecodeCallback below is required for compilation to work with gradle.\n    return path.load(\n        rewinder, options, width, height, new DecodeCallback\u003cResourceType\u003e(dataSource));\n  } finally {\n    rewinder.cleanup();\n  }\n}\n```\n\n`path.load(..., new DecodeCallback\u003cResourceType\u003e(dataSource))` 这行代码中，最后传入了一个 DecodeCallback 回调，该类的回调方法会回调给 DecodeJob 对应的方法：\n\n```java\nprivate final class DecodeCallback\u003cZ\u003e implements DecodePath.DecodeCallback\u003cZ\u003e {\n  private final DataSource dataSource;\n  @Synthetic\n  DecodeCallback(DataSource dataSource) {\n    this.dataSource = dataSource;\n  }\n  \n  @NonNull\n  @Override\n  public Resource\u003cZ\u003e onResourceDecoded(@NonNull Resource\u003cZ\u003e decoded) {\n    return DecodeJob.this.onResourceDecoded(dataSource, decoded);\n  }\n}\n```\n\n然后来看一下 LoadPath.load() 方法的实现：\n\n```java\npublic Resource\u003cTranscode\u003e load(DataRewinder\u003cData\u003e rewinder, @NonNull Options options, int width,\n    int height, DecodePath.DecodeCallback\u003cResourceType\u003e decodeCallback) throws GlideException {\n  List\u003cThrowable\u003e throwables = Preconditions.checkNotNull(listPool.acquire());\n  try {\n    return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);\n  } finally {\n    listPool.release(throwables);\n  }\n}\n\nprivate Resource\u003cTranscode\u003e loadWithExceptionList(DataRewinder\u003cData\u003e rewinder,\n    @NonNull Options options,\n    int width, int height, DecodePath.DecodeCallback\u003cResourceType\u003e decodeCallback,\n    List\u003cThrowable\u003e exceptions) throws GlideException {\n  Resource\u003cTranscode\u003e result = null;\n  //noinspection ForLoopReplaceableByForEach to improve perf\n  for (int i = 0, size = decodePaths.size(); i \u003c size; i++) {\n    DecodePath\u003cData, ResourceType, Transcode\u003e path = decodePaths.get(i);\n    try {\n      result = path.decode(rewinder, width, height, options, decodeCallback);\n    } catch (GlideException e) {\n      exceptions.add(e);\n    }\n    if (result != null) {\n      break;\n    }\n  }\n\n  if (result == null) {\n    throw new GlideException(failureMessage, new ArrayList\u003c\u003e(exceptions));\n  }\n\n  return result;\n}\n```\n\n对于每条 DecodePath，都调用其 decode() 方法，直到有一个 DecodePath 可以 decode 出资源。继续看看 DecodePath.decode() 方法：\n\n```java\npublic Resource\u003cTranscode\u003e decode(DataRewinder\u003cDataType\u003e rewinder, int width, int height,\n    @NonNull Options options, DecodeCallback\u003cResourceType\u003e callback) throws GlideException {\n  Resource\u003cResourceType\u003e decoded = decodeResource(rewinder, width, height, options);\n  Resource\u003cResourceType\u003e transformed = callback.onResourceDecoded(decoded);\n  return transcoder.transcode(transformed, options);\n}\n```\n\n可以看到，这里有三个步骤：\n\n1. 使用 ResourceDecoder List 进行 decode，将原始数据解码成原始图片\n2. 将 decoded 的资源进行 transform\n3. 将 transformed 的资源进行 transcode\n\n首先是 decodeResource() 的过程：\n\n```java\n@NonNull\nprivate Resource\u003cResourceType\u003e decodeResource(DataRewinder\u003cDataType\u003e rewinder, int width,\n    int height, @NonNull Options options) throws GlideException {\n  List\u003cThrowable\u003e exceptions = Preconditions.checkNotNull(listPool.acquire());\n  try {\n    return decodeResourceWithList(rewinder, width, height, options, exceptions);\n  } finally {\n    listPool.release(exceptions);\n  }\n}\n\n@NonNull\nprivate Resource\u003cResourceType\u003e decodeResourceWithList(DataRewinder\u003cDataType\u003e rewinder, int width,\n    int height, @NonNull Options options, List\u003cThrowable\u003e exceptions) throws GlideException {\n  Resource\u003cResourceType\u003e result = null;\n  //noinspection ForLoopReplaceableByForEach to improve perf\n  for (int i = 0, size = decoders.size(); i \u003c size; i++) {\n    //decoders 只有一条，就是 ByteBufferBitmapDecoder\n    ResourceDecoder\u003cDataType, ResourceType\u003e decoder = decoders.get(i);\n    try {\n      //rewinder 自然是 ByteBufferRewind\n      //data 为 ByteBuffer\n      DataType data = rewinder.rewindAndGet();\n      //ByteBufferBitmapDecoder 内部会调用 Downsampler 的 hanldes 方法\n      // 它对任意的 InputStream 和 ByteBuffer 都返回 true\n      if (decoder.handles(data, options)) {\n        //调用 ByteBuffer.position(0) 复位\n        data = rewinder.rewindAndGet();\n        //开始解码\n        result = decoder.decode(data, width, height, options);\n      }\n      // Some decoders throw unexpectedly. If they do, we shouldn't fail the entire load path, but\n      // instead log and continue. See #2406 for an example.\n    } catch (IOException | RuntimeException | OutOfMemoryError e) {\n      if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        Log.v(TAG, \"Failed to decode data for \" + decoder, e);\n      }\n      exceptions.add(e);\n    }\n\n    if (result != null) {\n      break;\n    }\n  }\n\n  if (result == null) {\n    throw new GlideException(failureMessage, new ArrayList\u003c\u003e(exceptions));\n  }\n  return result;\n}\nByteBufferBitmapDecoder.decode() 方法：\n@Override\npublic Resource\u003cBitmap\u003e decode(@NonNull ByteBuffer source, int width, int height,\n    @NonNull Options options)\n    throws IOException {\n  InputStream is = ByteBufferUtil.toStream(source);\n  return downsampler.decode(is, width, height, options);\n}\n```\n\n先将 ByteBuffer 转换成 InputStream，然后调用 Downsampler.decode() 方法进行解码。\n\n这里执行完毕，会将 decode 出来的 Bitmap 包装成为一个 BitmapResource 对象。然后就一直往上返回，返回到 DecodePath.decode 方法中。接下来执行第二行：\n\n```java\nResource\u003cResourceType\u003e transformed = callback.onResourceDecoded(decoded);\n```\n\n这里的 callback 在前面提到过，这会调用 `DecodeJob.onResourceDecoded(DataSource, Resource\u003cZ\u003e)` 方法：\n\n```java\n@Synthetic\n@NonNull\n\u003cZ\u003e Resource\u003cZ\u003e onResourceDecoded(DataSource dataSource,\n    @NonNull Resource\u003cZ\u003e decoded) {\n  @SuppressWarnings(\"unchecked\")\n  Class\u003cZ\u003e resourceSubClass = (Class\u003cZ\u003e) decoded.get().getClass();// Bitmap.class\n  Transformation\u003cZ\u003e appliedTransformation = null;\n  Resource\u003cZ\u003e transformed = decoded;\n  //dataSource为DATA_DISK_CACHE，所以满足条件\n  if (dataSource != DataSource.RESOURCE_DISK_CACHE) {\n    //Bitmap.class对应的正是FitCenter()\n    appliedTransformation = decodeHelper.getTransformation(resourceSubClass);\n    //对decoded资源进行transform\n    transformed = appliedTransformation.transform(glideContext, decoded, width, height);\n  }\n  //TODO: Make this the responsibility of the Transformation.\n  if (!decoded.equals(transformed)) {\n    decoded.recycle();\n  }\n  final EncodeStrategy encodeStrategy;\n  final ResourceEncoder\u003cZ\u003e encoder;\n  //Bitmap有注册对应的BitmapEncoder，所以是available的\n  if (decodeHelper.isResourceEncoderAvailable(transformed)) {\n    //encoder就是BitmapEncoder\n    encoder = decodeHelper.getResultEncoder(transformed);\n    //encodeStrategy为EncodeStrategy.TRANSFORMED\n    encodeStrategy = encoder.getEncodeStrategy(options);\n  } else {\n    encoder = null;\n    encodeStrategy = EncodeStrategy.NONE;\n  }\n  Resource\u003cZ\u003e result = transformed;\n  //isSourceKey显然为true，所以isFromAlternateCacheKey为false，所以就返回了\n  boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);\n  //diskCacheStrategy为AUTOMATIC，该方法返回false\n  if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,\n      encodeStrategy)) {\n    if (encoder == null) {\n      throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());\n    }\n    final Key key;\n    switch (encodeStrategy) {\n      case SOURCE:\n        key = new DataCacheKey(currentSourceKey, signature);\n        break;\n      case TRANSFORMED:\n        key =\n            new ResourceCacheKey(\n                decodeHelper.getArrayPool(),\n                currentSourceKey,\n                signature,\n                width,\n                height,\n                appliedTransformation,\n                resourceSubClass,\n                options);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unknown strategy: \" + encodeStrategy);\n    }\n    LockedResource\u003cZ\u003e lockedResult = LockedResource.obtain(transformed);\n    deferredEncodeManager.init(key, encoder, lockedResult);\n    result = lockedResult;\n  }\n  return result;\n}\n```\n\n当 dataSource != DataSource.RESOURCE_DISK_CACHE 时会进行 transform，这是因为 resource cache 肯定已经经历过 transform 了，所以就不用重新来一遍了。\n\n然后就回到 DecodePath.decode 方法的第三行了：\n\n```java\nreturn transcoder.transcode(transformed, options);\n```\n\n这里的 transcoder 就是 BitmapDrawableTranscoder，该方法返回了一个 LazyBitmapDrawableResource。\n\n至此，resource 已经 decode 完毕。下面一直返回到 DecodeJob.decodeFromRetrievedData() 方法中。下面会调用 notifyEncodeAndRelease() 方法完成后面的事宜。\n\n```java\nprivate void notifyEncodeAndRelease(Resource\u003cR\u003e resource, DataSource dataSource) {\n  // resource是BitmapResource类型，实现了Initializable接口\n  if (resource instanceof Initializable) {\n    // initialize方法调用了bitmap.prepareToDraw()\n    ((Initializable) resource).initialize();\n  }\n  Resource\u003cR\u003e result = resource;\n  LockedResource\u003cR\u003e lockedResource = null;\n  if (deferredEncodeManager.hasResourceToEncode()) {\n    lockedResource = LockedResource.obtain(resource);\n    result = lockedResource;\n  }\n  // 通知回调，资源已经就绪\n  notifyComplete(result, dataSource);\n  stage = Stage.ENCODE;\n  try {\n    // TODO\n    if (deferredEncodeManager.hasResourceToEncode()) {\n      deferredEncodeManager.encode(diskCacheProvider, options);\n    }\n  } finally {\n    // lockedResource为null, skip\n    if (lockedResource != null) {\n      lockedResource.unlock();\n    }\n  }\n  // Call onEncodeComplete outside the finally block so that it's not called if the encode process\n  // throws.\n  // 进行清理工作\n  onEncodeComplete();\n}\n```\n\n重点在于 notifyComplete() 方法，该方法内部会调用 callback.onResourceReady(resource, dataSource) 将结果传递给回调，这里的回调是 EngineJob：\n\n```java\n@Override\npublic void onResourceReady(Resource\u003cR\u003e resource, DataSource dataSource) {\n  synchronized (this) {\n    this.resource = resource;\n    this.dataSource = dataSource;\n  }\n  notifyCallbacksOfResult();\n}\n\nvoid notifyCallbacksOfResult() {\n  ResourceCallbacksAndExecutors copy;\n  Key localKey;\n  EngineResource\u003c?\u003e localResource;\n  synchronized (this) {\n    stateVerifier.throwIfRecycled();\n    if (isCancelled) {\n      // TODO: Seems like we might as well put this in the memory cache instead of just recycling\n      // it since we've gotten this far...\n      resource.recycle();\n      release();\n      return;\n    } else if (cbs.isEmpty()) {\n      throw new IllegalStateException(\"Received a resource without any callbacks to notify\");\n    } else if (hasResource) {\n      throw new IllegalStateException(\"Already have resource\");\n    }\n    // engineResourceFactory默认为EngineResourceFactory\n    // 其build方法就是new一个对应的资源\n    // new EngineResource\u003c\u003e(resource, isMemoryCacheable, /*isRecyclable=*/ true)\n    engineResource = engineResourceFactory.build(resource, isCacheable);\n    // Hold on to resource for duration of our callbacks below so we don't recycle it in the\n    // middle of notifying if it synchronously released by one of the callbacks. Acquire it under\n    // a lock here so that any newly added callback that executes before the next locked section\n    // below can't recycle the resource before we call the callbacks.\n    hasResource = true;\n    copy = cbs.copy();\n    incrementPendingCallbacks(copy.size() + 1);\n\n    localKey = key;\n    localResource = engineResource;\n  }\n\n  // listener就是Engine，该方法会将资源保存到activeResources中\n  listener.onEngineJobComplete(this, localKey, localResource);\n\n  // 这里的ResourceCallbackAndExecutor就是我创建EngineJob和DecodeJob\n  // 并在执行DecodeJob之前添加的回调\n  // entry.executor就是Glide.with.load.into中出现的Executors.mainThreadExecutor()\n  // entry.cb就是SingleRequest\n  for (final ResourceCallbackAndExecutor entry : copy) {\n    entry.executor.execute(new CallResourceReady(entry.cb));\n  }\n  decrementPendingCallbacks();\n}\n```\n\nlistener.onEngineJobComplete() 的代码很简单。\n\n```java\n@Override\npublic synchronized void onEngineJobComplete(\n    EngineJob\u003c?\u003e engineJob, Key key, EngineResource\u003c?\u003e resource) {\n  // A null resource indicates that the load failed, usually due to an exception.\n  if (resource != null) {\n    resource.setResourceListener(key, this);\n\n    if (resource.isCacheable()) {\n      activeResources.activate(key, resource);\n    }\n  }\n\n  jobs.removeIfCurrent(key, engineJob);\n}\n\n@Override\npublic synchronized void onResourceReleased(Key cacheKey, EngineResource\u003c?\u003e resource) {\n  activeResources.deactivate(cacheKey);\n  if (resource.isCacheable()) {\n    cache.put(cacheKey, resource);\n  } else {\n    resourceRecycler.recycle(resource);\n  }\n}\n```\n\n首先会设置资源的回调为自己，这样在资源释放时会通知自己的回调方法，将资源从 active 状态变为 cache 状态，如 onResourceReleased() 方法；然后将资源放入 activeResources 中，资源变为 active 状态；最后将 engineJob 从 Jobs 中移除。\n\n然后看下 entry.executor.execute(new CallResourceReady(entry.cb)) 方法的实现，关注点在 CallResourceReady 上面：\n\n```java\nprivate class CallResourceReady implements Runnable {\n\n    private final ResourceCallback cb;\n\n    CallResourceReady(ResourceCallback cb) {\n      this.cb = cb;\n    }\n\n    @Override\n    public void run() {\n      synchronized (EngineJob.this) {\n        if (cbs.contains(cb)) {\n          // Acquire for this particular callback.\n          engineResource.acquire();\n          callCallbackOnResourceReady(cb);\n          removeCallback(cb);\n        }\n        decrementPendingCallbacks();\n      }\n    }\n  }\n```\n\n首先调用 callCallbackOnResourceReady(cb) 调用 callback，然后调用 removeCallback(cb) 移除 callback。看看 callCallbackOnResourceReady(cb)：\n\n```java\nvoid callCallbackOnResourceReady(ResourceCallback cb) {\n  try {\n    // This is overly broad, some Glide code is actually called here, but it's much\n    // simpler to encapsulate here than to do so at the actual call point in the\n    // Request implementation.\n    cb.onResourceReady(engineResource, dataSource, isLoadedFromAlternateCacheKey);\n  } catch (Throwable t) {\n    throw new CallbackException(t);\n  }\n}\n```\n\n这里就调用了 cb.onResourceReady()，这里说到过 entry.cb 就是 SingleRequest。所以继续看看 SingleRequest.onResourceReady() 方法:\n\n```java\n@Override\npublic synchronized void onResourceReady(Resource\u003c?\u003e resource, DataSource dataSource) {\n  ...\n\n  onResourceReady((Resource\u003cR\u003e) resource, (R) received, dataSource);\n}\n\nprivate synchronized void onResourceReady(Resource\u003cR\u003e resource, R result, DataSource dataSource) {\n  // We must call isFirstReadyResource before setting status.\n  // 由于requestCoordinator为null，所以返回true\n  boolean isFirstResource = isFirstReadyResource();\n  // 将status状态设置为COMPLETE\n  status = Status.COMPLETE;\n  this.resource = resource;\n\n  if (glideContext.getLogLevel() \u003c= Log.DEBUG) {\n    Log.d(GLIDE_TAG, \"Finished loading \" + result.getClass().getSimpleName() + \" from \"\n        + dataSource + \" for \" + model + \" with size [\" + width + \"x\" + height + \"] in \"\n        + LogTime.getElapsedMillis(startTime) + \" ms\");\n  }\n\n  isCallingCallbacks = true;\n  try {\n     // 尝试调用各个listener的onResourceReady回调进行处理\n    boolean anyListenerHandledUpdatingTarget = false;\n    if (requestListeners != null) {\n      for (RequestListener\u003cR\u003e listener : requestListeners) {\n        anyListenerHandledUpdatingTarget |=\n            listener.onResourceReady(result, model, target, dataSource, isFirstResource);\n      }\n    }\n    anyListenerHandledUpdatingTarget |=\n        targetListener != null\n            \u0026\u0026 targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);\n\n    // 如果没有一个回调能够处理，那么自己处理\n    if (!anyListenerHandledUpdatingTarget) {\n      // animationFactory默认为NoTransition.getFactory()，生成的animation为NO_ANIMATION\n      Transition\u003c? super R\u003e animation =\n          animationFactory.build(dataSource, isFirstResource);\n      // target为DrawableImageViewTarget\n      target.onResourceReady(result, animation);\n    }\n  } finally {\n    isCallingCallbacks = false;\n  }\n\n  // 通知requestCoordinator\n  notifyLoadSuccess();\n}\n```\n\n其处理过程和 onLoadFailed() 方法非常类似。\n\nDrawableImageViewTarget 的基类 ImageViewTarget 实现了此方法：\n\n```java\n// ImageViewTarget.java\n@Override\npublic void onResourceReady(@NonNull Z resource, @Nullable Transition\u003c? super Z\u003e transition) {\n  // NO_ANIMATION.transition返回false，所以直接调用setResourceInternal方法\n  if (transition == null || !transition.transition(resource, this)) {\n    setResourceInternal(resource);\n  } else {\n    maybeUpdateAnimatable(resource);\n  }\n}\n\nprivate void setResourceInternal(@Nullable Z resource) {\n  // Order matters here. Set the resource first to make sure that the Drawable has a valid and\n  // non-null Callback before starting it.\n  // 先设置图片\n  setResource(resource);\n  // 然后如果是动画，会执行动画\n  maybeUpdateAnimatable(resource);\n}\n\nprivate void maybeUpdateAnimatable(@Nullable Z resource) {\n  // BitmapDrawable显然不是一个Animatable对象，所以走else分支\n  if (resource instanceof Animatable) {\n    animatable = (Animatable) resource;\n    animatable.start();\n  } else {\n    animatable = null;\n  }\n}\n\n// DrawableImageViewTarget\n@Override\nprotected void setResource(@Nullable Drawable resource) {\n  view.setImageDrawable(resource);\n}\n```\n\nOK，至此网络图片已经通过 view.setImageDrawable(resource) 加载完毕。\n\n最后，回到 DecodeJob.notifyEncodeAndRelease() 方法，notifyComplete() 被调用后，会判断 deferredEncodeManager.hasResourceToEncode()，如果为 true 则会调用 deferredEncodeManager.encode() 方法：\n\n```java\nprivate static class DeferredEncodeManager\u003cZ\u003e {\n  private Key key;\n  private ResourceEncoder\u003cZ\u003e encoder;\n  private LockedResource\u003cZ\u003e toEncode;\n  \n  @Synthetic\n  DeferredEncodeManager() { }\n  \n  // We just need the encoder and resource type to match, which this will enforce.\n  @SuppressWarnings(\"unchecked\")\n  \u003cX\u003e void init(Key key, ResourceEncoder\u003cX\u003e encoder, LockedResource\u003cX\u003e toEncode) {\n    this.key = key;\n    this.encoder = (ResourceEncoder\u003cZ\u003e) encoder;\n    this.toEncode = (LockedResource\u003cZ\u003e) toEncode;\n  }\n  \n  void encode(DiskCacheProvider diskCacheProvider, Options options) {\n    GlideTrace.beginSection(\"DecodeJob.encode\");\n    try {\n      diskCacheProvider.getDiskCache().put(key,\n          new DataCacheWriter\u003c\u003e(encoder, toEncode, options));\n    } finally {\n      toEncode.unlock();\n      GlideTrace.endSection();\n    }\n  }\n  \n  boolean hasResourceToEncode() {\n    return toEncode != null;\n  }\n  \n  void clear() {\n    key = null;\n    encoder = null;\n    toEncode = null;\n  }\n}\n```\n\nDiskLruCacheWrapper 在写入的时候会使用到写锁 DiskCacheWriteLocker，锁对象由对象池创建，写锁 WriteLock 实现是一个重入锁 ReentrantLock，该锁默认是一个不公平锁。\n\n在缓存写入前，会判断 key 对应的 value 存不存在，若存在则放弃写入。缓存的真正写入会由 DataCacheWriter 交给 ByteBufferEncoder 和 StreamEncoder 两个具体类来写入，前者负责将 ByteBuffe 写入到文件，后者负责将 InputStream 写入到文件。\n\n至此，磁盘缓存的读写都已经完毕，剩下的就是内存缓存的两个层次了。回到 DecodeJob.notifyEncodeAndRelease 方法中，经过 notifyComplete、EngineJob.onResourceReady、notifyCallbacksOfResult 方法中。\n\n在该方法中一方面会将原始的 resource 包装成一个 EngineResource，然后通过回调传给 Engine.onEngineJobComplete()，在这里会将资源保持在 ActiveResource 中：\n\n```java\n@Override\npublic synchronized void onEngineJobComplete(\n    EngineJob\u003c?\u003e engineJob, Key key, EngineResource\u003c?\u003e resource) {\n  // A null resource indicates that the load failed, usually due to an exception.\n  if (resource != null) {\n    resource.setResourceListener(key, this);\n    if (resource.isCacheable()) {\n      activeResources.activate(key, resource);\n    }\n  }\n  jobs.removeIfCurrent(key, engineJob);\n}\n```\n\n另一方面会使用 Executors.mainThreadExecutor() 调用 SingleRequest.onResourceReady() 回调进行资源的显示。\n\n在触发回调前后各有一个地方会对 engineResource 进行 acquire() 和 release() 操作。该过程发生在 notifyCallbacksOfResult() 方法的 incrementPendingCallbacks()、decrementPendingCallbacks() 调用中。这一顿操作下来，engineResource 的引用计数应该是 1：\n\n```java\n@Synthetic\nvoid notifyCallbacksOfResult() {\n  ResourceCallbacksAndExecutors copy;\n  Key localKey;\n  EngineResource\u003c?\u003e localResource;\n  \n  synchronized (this) {\n    ...\n    engineResource = engineResourceFactory.build(resource, isCacheable);\n    // Hold on to resource for duration of our callbacks below so we don't recycle it in the\n    // middle of notifying if it synchronously released by one of the callbacks. Acquire it under\n    // a lock here so that any newly added callback that executes before the next locked section\n    // below can't recycle the resource before we call the callbacks.\n    hasResource = true;\n    copy = cbs.copy();\n    incrementPendingCallbacks(copy.size() + 1);\n    localKey = key;\n    localResource = engineResource;\n  }\n  listener.onEngineJobComplete(this, localKey, localResource);\n  for (final ResourceCallbackAndExecutor entry : copy) {\n    entry.executor.execute(new CallResourceReady(entry.cb));\n  }\n  decrementPendingCallbacks();\n}\n\nsynchronized void incrementPendingCallbacks(int count) {\n  ...\n  if (pendingCallbacks.getAndAdd(count) == 0 \u0026\u0026 engineResource != null) {\n    engineResource.acquire();\n  }\n}\n\nsynchronized void decrementPendingCallbacks() {\n  ...\n  int decremented = pendingCallbacks.decrementAndGet();\n  if (decremented == 0) {\n    if (engineResource != null) {\n      engineResource.release();\n    }\n    release();\n  }\n}\n```\n\nengineResource 的引用计数会在 RequestManager.onDestory() 方法中经过 clear()、untrackOrDelegate()、untrack()、RequestTracker.clearRemoveAndRecycle()、clearRemoveAndMaybeRecycle() 方法，调用 SingleRequest.clear() 方法经过 releaseResource()、Engine.release()，进行释放。这样引用计数就为 0 了。\n\n前面在看 EngineResource 的代码时我们知道，一旦引用计数为 0，就会通知 Engine 将此资源从 active 状态变成 memory cache 状态。如果我们再次加载资源时可以从 memory cache 中加载，那么资源又会从 memory cache 状态变成 active 状态。\n\n也就是说，在资源第一次显示后，我们关闭页面，资源会由 active 变成 memory cache；然后我们再次进入页面，加载时会命中 memory cache，从而又变成 active 状态。\n\n本章 Glide 缓存机制的源码内容到此为止了，现在看看文章最开始的流程图，是不是有一点点熟悉的味道。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-2/clipboard_20230323_034514.png)\n\nDecodeJob.onDataFetcherReady 该方法完成两个事情：\n\n1. 将比较原始的 data 数据转变为可以供 ImageView 显示的 resource 数据\n2. 将 resource 数据显示出来\n\n在过程 1 中，将原始 data encode 成 resource 数据后，会调用 DecodeJob.onResourceDecoded 对 resource 数据进行进一步的处理。DecodeJob.onResourceDecoded 首先会对 resource 进行 transform，然后可能会进行磁盘缓存。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-2/clipboard_20230323_034509.png)\n\n# 面试题\n\n内存缓存分两个原因：\n\n1、活动缓存主要是当前正在使用的图片资源。图片资源存放在弱引用中。下面是只用活动缓存的缺点\n\n场景：上下滑动列表，图片会不断创建，当 GC 来临时候，会将当前不使用的图片资源进行回收，由于存放在弱引用中。这样就会导致下次滑动回来还需要加载到内存中。\n\n2、Lru 缓存主要存放：最近被加载过的资源。下面是只用 Lru 的缺点\n\n场景：滑动列表头部头像不动，列表不断滑动，由于 Lru 的机制缓存到达一定大小，可能会将头部图片资源回收。\n\n3、配合使用，两者互斥存在。当资源正在使用的时候放在活动缓存中，当不使用的时候放在 Lru 中（引用为 0 的时候）。so,两者结合性能最佳\n\n磁盘缓存分两个原因：\n1、资源缓存主要是变换后的资源\n2、原始缓存是原始的资源文件\n\n场景：同一张图片，先在 100*100 的 view 上显示，然后在 200*200 的 view 上显示。\n分析：如果不缓存变换后的图，那么每次都需要变换。如果不缓存原图，那么每次都需要重新网络下载原图\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["Glide","源码解析"]},"/Glide-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8":{"title":"Glide 基本使用","content":"\n# 准备\n\n## 添加依赖\n\n```plain text\nimplementation 'com.github.bumptech.glide:glide:4.12.0'\nannotationProcessor 'com.github.bumptech.glide:compiler:4.12.0'\n```\n\n## 添加网路权限\n\n```plain text\n\u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e\n```\n\n## 定义控件\n\n```xml\n\u003candroidx.constraintlayout.widget.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\"\u003e\n\n    \u003cButton\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"load\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        android:onClick=\"load\"/\u003e\n\n    \u003cImageView\n        android:id=\"@+id/image\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:src=\"@mipmap/ic_launcher\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" /\u003e\n\n\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\n```\n\n# 加载图片\n\n添加按钮监听，使用 Glide 加载网路图片：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    ImageView imageView;\n    private String url = \"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.zcool.cn%2Fcommunity%2F01229b55427cae0000019ae90743f7.jpg\u0026refer=http%3A%2F%2Fimg.zcool.cn\u0026app=2002\u0026size=f9999,10000\u0026q=a80\u0026n=0\u0026g=0n\u0026fmt=jpeg?sec=1634203057\u0026t=ddd9257730ce04906923aaa088f0b226\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        imageView = findViewById(R.id.image);\n    }\n\n    public void load(View view) {\n        Glide.with(this).load(url).into(imageView);\n    }\n    \n    @Override\n    protected void onDestroy() {\n      Glide.with(this).clear(imageView);\n      super.onDestroy();\n    }\n}\n```\n\n这样，就是 Glide 最基本的用法。 点击按钮之后，Glide 会把图片加载进 ImageView 中，并在 onDestory 方法中取消 Glide 加载。尽管及时取消不必要的加载是很好的实践，但这并不是必须的操作。实际上，当 Glide.with() 中传入的 Activity 实例销毁时，Glide 会自动取消加载并回收资源。\n\n在 ListView 或 RecyclerView 中加载图片的代码和在单独的 View 中加载完全一样。Glide 已经自动处理了 View 的复用和请求的取消。\n\n## with\n\nGlide.with() 方法有很多重载：\n\n- `with(@NonNull Context context)`\n- `with(@NonNull View view)`\n- `with(@NonNull Activity activity)`\n- `with(@NonNull FragmentActivity activity)`\n- `with(@NonNull Fragment fragment)`\n\n在上面的重载方法中，除了前两个重载方法外，其他三个都有很直观的生命周期；至于前两个，会尝试绑定到 Activity 或 Fragment 上面，如果失败了就会绑定到 Application 级别的生命周期上。\n\nGlide.with() 方法返回的是 RequestManager 实例。\n\n## load\n\nload 方法也有很多重载：\n\n- `load(@Nullable Bitmap bitmap)`\n- `load(@Nullable Drawable drawable)`\n- `load(@Nullable String string)`\n- `load(@Nullable Uri uri)`\n- `load(@Nullable File file)`\n- `load(@RawRes @DrawableRes @Nullable Integer resourceId)`\n- `load(@Nullable byte[] model)`\n- `load(@Nullable Object model)`\n\nRequestManager 除了上面的方法外，还有其他一些有用的方法：\n\n控制方法：\n\n- `isPaused()`\n- `pauseRequests()`\n- `pauseAllRequests()`\n- `pauseRequestsRecursive()`\n- `resumeRequests()`\n- `resumeRequestsRecursive()`\n- `clear(@NonNull View view)`\n- `clear(@Nullable final Target\u003c?\u003e target)`\n\n生命周期方法：\n\n- `onStart()`\n- `onStop()`\n- `onDestroy()`\n\n其他方法：\n\n- `downloadOnly()`\n- `download(@Nullable Object model)`\n- `asBitmap()`\n- `asGif()`\n- `asDrawable()`\n- `asFile()`\n- `as(@NonNull Class\u003cResourceType\u003e resourceClass)`\n\nRequestManager.load() 方法返回了一个 RequestBuilder 对象，调用该对象的 into(@NonNull ImageView view) 方法就完成了 Glide 加载的三步。当然此方法还有一些高级的重载方法，我们后面在说。\n\n此外，上面提到的 RequestManager 的 7 个其他方法也都会返回一个 RequestBuilder 对象，而此时还没有设置要加载的资源，所以 RequestBuilder 也提供了很多 load 方法来设置要加载资源。\n\n# 占位图\n\n占位符类型有三种，分别在三种不同场景使用：\n\n- placeholder\n\nplaceholder 是当请求正在执行时被展示的 Drawables。当请求成功完成时，placehodler 会被请求到的资源替换。如果被请求的资源是从内存中加载出来的，那么 placehodler 不会显示。如果请求失败并且没有设置 error，则 placehodler 将被持续展示。类似地，如果请求的 url/model 为 null，并且 error 和 fallback 都没有设置，那么 placehodler 也会继续显示。\n\n- error\n\nerror 在请求永久性失败时展示。error 同样也在请求的 url/model 为 null，且并没有设置 fallback 时展示。\n\n- fallback\n\nfallback 在请求的 url/model 为 null 时展示。设计 fallback 的主要目的是允许用户指示 null 是否为可接受的正常情况。例如，一个 null 的个人资料 url 可能暗示这个用户没有设置头像，因此应该使用默认头像。然而，null 也可能表明这个元数据根本就是不合法的，或者取不到。\u003cstrong\u003e默认情况下 Glide 将 null 作为错误处理\u003c/strong\u003e，所以可以接受 null 的应用应当显式地设置一个 fallback。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-1/clipboard_20230323_032742.png)\n\n占位图显示逻辑的代码如下：\n\n```java\nprivate synchronized void setErrorPlaceholder() {\n  if (!canNotifyStatusChanged()) {\n    return;\n  }\n\n  Drawable error = null;\n  if (model == null) {\n    error = getFallbackDrawable();\n  }\n  // Either the model isn't null, or there was no fallback drawable set.\n  if (error == null) {\n    error = getErrorDrawable();\n  }\n  // The model isn't null, no fallback drawable was set or no error drawable was set.\n  if (error == null) {\n    error = getPlaceholderDrawable();\n  }\n  target.onLoadFailed(error);\n}\n```\n\n我们准备使用这段代码演示一下。\n\n注意，为了忽略缓存的影响，这里设置了忽略内存缓存 `skipMemoryCache(true)` 并将磁盘缓存策略设置为不缓存 `diskCacheStrategy(DiskCacheStrategy.NONE)`。\n\n```kotlin\nval option = RequestOptions()\n    .placeholder(ColorDrawable(Color.GRAY))\n    .error(ColorDrawable(Color.RED))\n    .fallback(ColorDrawable(Color.CYAN))\n    .skipMemoryCache(true)\n    .diskCacheStrategy(DiskCacheStrategy.NONE)\n\nGlide.with(this)\n    .load(URL)\n    .apply(option)\n    .into(ivGlide)\n```\n\n上面的代码也可以这么写：\n\n```kotlin\nGlide.with(this)\n    .load(URL)\n    .placeholder(ColorDrawable(Color.GRAY))\n    .error(ColorDrawable(Color.RED))\n    .fallback(ColorDrawable(Color.CYAN))\n    .skipMemoryCache(true)\n    .diskCacheStrategy(DiskCacheStrategy.NONE)\n    .into(ivGlide)\n```\n\n使用 RequestOptions() 更方便，因为可以多个 Glide 加载语句共用这些通用设置。\n\n下面展示了正确加载时、加载字符空串时的图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-1/glide-placeholder-success-example.gif)\n\n\u003cdiv style=\"text-align: center\"\u003e\u003cem\u003eGlide 正确加载\u003c/em\u003e\u003c/div\u003e\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-1/glide-error-example.gif)\n\n\u003cdiv style=\"text-align: center\"\u003e\u003cem\u003eGlide 加载空串\u003c/em\u003e\u003c/div\u003e\n\n\u003cstrong\u003e1. 占位符是异步加载的吗？\u003c/strong\u003e\n\nNo。占位符是在主线程从 Android Resources 加载的。我们通常希望占位符比较小且容易被系统资源缓存机制缓存起来。\n\n\u003cstrong\u003e2. 变换是否会被应用到占位符上？\u003c/strong\u003e\n\nNo。Transformation 仅被应用于被请求的资源，而不会对任何占位符使用。\n\n在应用中包含必须在运行时做变换才能使用的图片资源是很不划算的。相反，在应用中包含一个确切符合尺寸和形状要求的资源版本几乎总是一个更好的办法。假如你正在加载圆形图片，你可能希望在你的应用中包含圆形的占位符。另外你也可以考虑自定义一个 View 来剪裁 (clip) 你的占位符，而达到你想要的变换效果。\n\n\u003cstrong\u003e3. 在多个不同的 View 上使用相同的 Drawable 可行么？\u003c/strong\u003e\n\n通常可以，但不是绝对的。任何无状态 (non-stateful ) 的 Drawable（例如 BitmapDrawable）通常都是 ok 的。但是有状态的 Drawable 不一样，在同一时间多个 View 上展示它们通常不是很安全，因为多个 View 会立刻修改 (mutate) Drawable。对于有状态的 Drawable，建议传入一个资源 ID，或者使用 newDrawable() 来给每个请求传入一个新的拷贝。\n\n# 指定图片格式\n\nGlide 支持加载 GIF，Picasso 不支持。而且 Glide 加载 GIF 不需要额外的代码，其内部会判断图片格式。\n\n我们可以直接使用下面的示例代码加载 GIF：\n\n```kotlin\nval option = RequestOptions()\n    .placeholder(ColorDrawable(Color.GRAY))\n    .error(ColorDrawable(Color.RED))\n    .fallback(ColorDrawable(Color.CYAN))\n    .skipMemoryCache(true)\n    .diskCacheStrategy(DiskCacheStrategy.NONE)\n\nGlide.with(this)\n    .load(GIF_URL)\n    .apply(option)\n    .into(ivGlide)\n```\n\n运行结果如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-1/glide-load-gif.gif)\n\n\u003cdiv style=\"text-align: center\"\u003e\u003cem\u003eGlide 加载 GIF\u003c/em\u003e\u003c/div\u003e\n\n现在我们只想加载静态图片，我们可以在 Glide.with 后面追加 asBitmap() 方法实现：\n\n```kotlin\nGlide.with(this)\n    .asBitmap()\n    .load(GIF_URL)\n    .apply(option)\n    .into(ivGlide)\n```\n\n由于调用了 asBitmap() 方法，现在 GIF 图就无法正常播放了，而是会在界面上显示第一帧的图片。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-1/glide-load-gif-with-asbitmap.gif)\n\n\u003cdiv style=\"text-align: center\"\u003e\u003cem\u003eGlide asBitmap 加载 GIF\u003c/em\u003e\u003c/div\u003e\n\n同理，我们在加载普通图片时追加 asGif() 会怎么样呢：\n\n```kotlin\nGlide.with(this)\n    .asGif()\n    .load(URL)\n    .apply(option)\n    .into(ivGlide)\n```\n\n很不幸，显示加载错误图片：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-1/glide-load-url-with-asgif.gif)\n\n\u003cdiv style=\"text-align: center\"\u003e\u003cem\u003eGlide asGif 加载普通图片\u003c/em\u003e\u003c/div\u003e\n\n# 指定图片大小\n\n实际上，使用 Glide 在绝大多数情况下我们都是不需要指定图片大小的。\n\n在学习本节内容之前，你可能还需要先了解一个概念，就是我们平时在加载图片的时候很容易会造成内存浪费。什么叫内存浪费呢？比如说一张图片的尺寸是 1000*1000 像素，但是我们界面上的 ImageView 可能只有 200*200 像素，这个时候如果你不对图片进行任何压缩就直接读取到内存中，这就属于内存浪费了，因为程序中根本就用不到这么高像素的图片。\n\n而使用 Glide，我们就完全不用担心图片内存浪费，甚至是内存溢出的问题。因为 Glide 从来都不会直接将图片的完整尺寸全部加载到内存中，而是用多少加载多少。Glide 会自动判断 ImageView 的大小，然后只将这么大的图片像素加载到内存当中，帮助我们节省内存开支。\n\n也正是因为 Glide 是如此的智能，所以刚才在开始的时候我就说了，在绝大多数情况下我们都是不需要指定图片大小的，因为 Glide 会自动根据 ImageView 的大小来决定图片的大小。\n\n不过，如果你真的有这样的需求，必须给图片指定一个固定的大小，Glide 仍然是支持这个功能的。修改 Glide 加载部分的代码，如下所示：\n\n```kotlin\nGlide.with(this)\n    .load(URL)\n    .apply(option)\n    .override(100)\n    .into(ivGlide)\n```\n\n仍然非常简单，这里使用 override() 方法指定了一个图片的尺寸，也就是说，Glide 现在只会将图片加载成 100*100 像素的尺寸，而不会管你的 ImageView 的大小是多少了。\n\n对比图如下所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-1/clipboard_20230323_033342.png)\n\n\u003cdiv style=\"text-align: center\"\u003e\u003cem\u003eoverride 加载前后对比\u003c/em\u003e\u003c/div\u003e\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["Glide","源码解析"]},"/Glide-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95":{"title":"Glide 高级用法","content":"\n# 回调与监听\n\n## Target\n\n我们都知道，使用 Glide 在界面上加载并展示一张图片只需要一行代码：\n\n```java\nGlide.with(this).load(url).into(imageView);\n```\n\n将 ImageView 的实例传入到 into() 方法当中，Glide 将图片加载完成之后，图片就能显示到 ImageView 上了。这是怎么实现的呢？来看一下 into() 方法的源码：\n\n```java\n@NonNull\npublic ViewTarget\u003cImageView, TranscodeType\u003e into(@NonNull ImageView view) {\n  Util.assertMainThread();\n  Preconditions.checkNotNull(view);\n\n  BaseRequestOptions\u003c?\u003e requestOptions = this;\n  if (!requestOptions.isTransformationSet()\n      \u0026\u0026 requestOptions.isTransformationAllowed()\n      \u0026\u0026 view.getScaleType() != null) {\n    // Clone in this method so that if we use this RequestBuilder to load into a View and then\n    // into a different target, we don't retain the transformation applied based on the previous\n    // View's scale type.\n    switch (view.getScaleType()) {\n      case CENTER_CROP:\n        requestOptions = requestOptions.clone().optionalCenterCrop();\n        break;\n      case CENTER_INSIDE:\n        requestOptions = requestOptions.clone().optionalCenterInside();\n        break;\n      case FIT_CENTER:\n      case FIT_START:\n      case FIT_END:\n        requestOptions = requestOptions.clone().optionalFitCenter();\n        break;\n      case FIT_XY:\n        requestOptions = requestOptions.clone().optionalCenterInside();\n        break;\n      case CENTER:\n      case MATRIX:\n      default:\n        // Do nothing.\n    }\n  }\n\n  return into(\n      glideContext.buildImageViewTarget(view, transcodeClass),\n      /*targetListener=*/ null,\n      requestOptions,\n      Executors.mainThreadExecutor());\n}\n```\n\n可以看到，最后一行代码会调用 glideContext.buildImageViewTarget() 方法构建出一个 Target 对象，然后再把它传入到另一个接收 Target 参数的 into() 方法中。Target 对象则是用来最终展示图片用的，跟进方法 glideContext.buildImageViewTarget：\n\n```java\n@NonNull\npublic \u003cX\u003e ViewTarget\u003cImageView, X\u003e buildImageViewTarget(\n    @NonNull ImageView imageView, @NonNull Class\u003cX\u003e transcodeClass) {\n  return imageViewTargetFactory.buildTarget(imageView, transcodeClass);\n}\n```\n\n继续跟进：\n\n```java\npublic class ImageViewTargetFactory {\n  @NonNull\n  @SuppressWarnings(\"unchecked\")\n  public \u003cZ\u003e ViewTarget\u003cImageView, Z\u003e buildTarget(\n      @NonNull ImageView view, @NonNull Class\u003cZ\u003e clazz) {\n    if (Bitmap.class.equals(clazz)) {\n      return (ViewTarget\u003cImageView, Z\u003e) new BitmapImageViewTarget(view);\n    } else if (Drawable.class.isAssignableFrom(clazz)) {\n      return (ViewTarget\u003cImageView, Z\u003e) new DrawableImageViewTarget(view);\n    } else {\n      throw new IllegalArgumentException(\n          \"Unhandled class: \" + clazz + \", try .as*(Class).transcode(ResourceTranscoder)\");\n    }\n  }\n}\n```\n\n回顾之前的分析流程，在 into(ImageView) 过程中，会将 ImageView 包装成为一个 ViewTarget 类。如果调用过 asBitmap() 方法，那么此处会是 BitmapImageViewTarget，否则都将会是 DrawableImageViewTarget。BitmapImageViewTarget 和 DrawableImageViewTarget 除了 setResource 方法中调用的设置图片的 API 不同外，没有任何区别。\n\nDrawableImageView 的继承链如下：DrawableImageView -\u003e ImageViewTarget -\u003e ViewTarget -\u003e BaseTarget -\u003e Target。\n\n- Target 是一个继承了 LifecycleListener 接口的接口类，该类提供了资源加载过程中的回调操作。\n\n典型的生命周期为 onLoadStarted -\u003e onResourceReady/onLoadFailed -\u003e onLoadCleared，但不保证所有的都是这样。如果资源在内存中或者由于 model 为 null 而加载失败，onLoadStarted 不会被调用。同样，如果 target 不会清除，那么 onLoadCleared 方法也不会被调用。\n\n- BaseTarget 是一个实现了 Target 接口的抽象类。\n\n该类实现了 setRequest(Request)、getRequest() 两个方法，其他方法相当于适配器模式的实现。\n\n- ViewTarget\n\n该类虽然继承了 BaseTarget 类，但其重写了 setRequest(Request)、getRequest() 两个方法，这两个方法会调用 View.setTag 方法将 Request 对象传入。\n\nIn addition, \u003cstrong\u003efor\u003c/strong\u003e ViewTarget\u003cstrong\u003es only\u003c/strong\u003e, you can pass in a new instance to each load or clear call and allow Glide to retrieve information about previous loads from the Views tags\n\nThis will \u003cstrong\u003enot\u003c/strong\u003e work unless your Target extends ViewTarget or implements setRequest() and getRequest() in a way that allows you to retrieve previous requests in new Target instances.\n\n[Cancellation and re-use](http://bumptech.github.io/glide/doc/targets.html#cancellation-and-re-use)\n\n- ImageViewTarget\n\n该类的作用就是在加载的生命周期回调中给 ImageView 设置对应的资源。但由于加载成功后返回的资源可能是 Bitmap 或者 Drawable，所以这个不确定类型的加载由 setResource 抽象方法声明，待子类 BitmapImageViewTarget 和 DrawableImageViewTarget 实现。\n\n- DrawableImageViewTarget\n\n继承了 ImageViewTarget 类，唯一的作用就是实现 setResource(Drawable) 方法。\n\n在了解了 DrawableImageViewTarget 以及相关的类之后，我们看一下其他的 Target。下面是 Glide v4 中出现的所有的 Target：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-3/clipboard_20230323_031827.png)\n\n虽然 Target 很多，但是自定义只需要继承 CustomViewTarget 或者 CustomTarget 就行了。\n\n\u003cstrong\u003e为什么要继承 \u003c/strong\u003eCustomViewTarget \u003cstrong\u003e而不是 \u003c/strong\u003eViewTarget？\nViewTarget 已经被标记为废弃了，建议我们使用 CustomViewTarget。这是因为，如果子类没有实现 ViewTarget.onLoadCleared 方法，将会导致被回收的 bitmap 仍然被 UI 所引用，从而导致崩溃。而 CustomViewTarget.onLoadCleared 方法是 final 类型的，并且提供了一个抽象方法 onResourceCleared 强制我们实现。除此之外，两个类基本没有任何区别。\n\n\u003cstrong\u003e为什么要继承 \u003c/strong\u003eCustomTarget \u003cstrong\u003e而不是 \u003c/strong\u003eSimpleTarget？原因同上。\n\n下面举一个实际例子，在某些场景下，此时我们需要获取到加载成功后的 Bitma p 对象：\n\n```kotlin\nGlide.with(this)\n    .asBitmap()\n    .load(file)\n    .into(object : CustomTarget\u003cBitmap\u003e() {\n        override fun onResourceReady(\n            resource: Bitmap,\n            transition: Transition\u003cin Bitmap\u003e?\n        ) {\n            ivFace.setImageBitmap(resource)\n        }\n\n        override fun onLoadCleared(placeholder: Drawable?) {\n            ivFace.setImageDrawable(placeholder)\n        }\n    })\n```\n\n## RequestBuilder 高级 API\n\n在了解了 Target 之后，我们再看看 RequestBuilder 中高级一点的 API。\n\n下面这些都是 Target 的应用，内部调用的是 **修改过配置** 的 into/submit 方法，但 RequestBuilder.downloadOnly 方法已经被废弃；建议采用 RequestManager 的 downloadOnly() 方法和 into/submit 方法\n\n此外还有还需要注意的一个 API：listener/addListener\n\n### preload\n\n作用：将资源预加载到缓存中\n\npreload 的重载方法如下：\n\n```java\n/**\n  * Preloads the resource into the cache using the given width and height.\n  *\n  * \u003cp\u003e Pre-loading is useful for making sure that resources you are going to to want in the near\n  * future are available quickly. \u003c/p\u003e\n  *\n  * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be\n  *               overridden by\n  *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if\n  *               previously called.\n  * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be\n  *               overridden by\n  *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if\n  *               previously called).\n  * @return A {@link Target} that can be used to cancel the load via\n  * {@link RequestManager#clear(Target)}.\n  * @see com.bumptech.glide.ListPreloader\n  */\n@NonNull\npublic Target\u003cTranscodeType\u003e preload(int width, int height) {\n  final PreloadTarget\u003cTranscodeType\u003e target = PreloadTarget.obtain(requestManager, width, height);\n  return into(target);\n}\n\n/**\n  * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and\n  * height. Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as\n  * the width and height.\n  *\n  * @return A {@link Target} that can be used to cancel the load via\n  * {@link RequestManager#clear(Target)}\n  * @see #preload(int, int)\n  */\n@NonNull\npublic Target\u003cTranscodeType\u003e preload() {\n  return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);\n}\n```\n\n注意，在注释中出现了一个 ListPreload 类，该类是在 ListView 中做 item 预加载的一个工具类，使用方法为 AbsListView#setOnScrollListener(android.widget.AbsListView.OnScrollListener)。该类代码很简单，要点就是在滚动时计算需要预处理的 item。\n\n这么好用，那我要是 RecyclerView 怎么办？Glide 也提供了 RecyclerView 的版本，不过需要添加新的依赖 recyclerview-integration，详情可以查看文档 [INTEGRATION LIBRARIES - RecyclerView](http://bumptech.github.io/glide/int/recyclerview.html)。\n\n我们可以看到，在 preload 的实现中关键点就在于 PreloadTarget 类。该类实现非常简单，就是在 onResourceReady 回调发生后，经过 Handler 中转，最后由构造参数之一的 RequestManager 对象 clear 掉。PreloadTarget 实现代码如下：\n\n```java\n/**\n * A one time use {@link com.bumptech.glide.request.target.Target} class that loads a resource into\n * memory and then clears itself.\n *\n * @param \u003cZ\u003e The type of resource that will be loaded into memory.\n */\npublic final class PreloadTarget\u003cZ\u003e extends SimpleTarget\u003cZ\u003e {\n  private static final int MESSAGE_CLEAR = 1;\n  private static final Handler HANDLER = new Handler(Looper.getMainLooper(), new Callback() {\n    @Override\n    public boolean handleMessage(Message message) {\n      if (message.what == MESSAGE_CLEAR) {\n        ((PreloadTarget\u003c?\u003e) message.obj).clear();\n        return true;\n      }\n      return false;\n    }\n  });\n\n  private final RequestManager requestManager;\n\n  /**\n   * Returns a PreloadTarget.\n   *\n   * @param width  The width in pixels of the desired resource.\n   * @param height The height in pixels of the desired resource.\n   * @param \u003cZ\u003e    The type of the desired resource.\n   */\n  public static \u003cZ\u003e PreloadTarget\u003cZ\u003e obtain(RequestManager requestManager, int width, int height) {\n    return new PreloadTarget\u003c\u003e(requestManager, width, height);\n  }\n\n  private PreloadTarget(RequestManager requestManager, int width, int height) {\n    super(width, height);\n    this.requestManager = requestManager;\n  }\n\n  @Override\n  public void onResourceReady(@NonNull Z resource, @Nullable Transition\u003c? super Z\u003e transition) {\n    HANDLER.obtainMessage(MESSAGE_CLEAR, this).sendToTarget();\n  }\n\n  @SuppressWarnings(\"WeakerAccess\")\n  @Synthetic void clear() {\n    requestManager.clear(this);\n  }\n}\n```\n\n### submit\n\n作用：返回一个 Future 对象，其 get() 方法会阻塞住，所以需要在后台线程中调用\n\nsubmit 的两个重载方法如下：\n\n```java\n/**\n  * Returns a future that can be used to do a blocking get on a background thread.\n  *\n  * \u003cp\u003eThis method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,\n  * since the width and height will be overridden by values passed to {@link\n  * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}\n  * with override values are applied, or whenever you want to retrieve the image in its original\n  * size.\n  *\n  * @see #submit(int, int)\n  * @see #into(Target)\n  */\n@NonNull\npublic FutureTarget\u003cTranscodeType\u003e submit() {\n  return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);\n}\n\n/**\n  * Returns a future that can be used to do a blocking get on a background thread.\n  *\n  * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be\n  *               overridden by\n  *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)} if\n  *               previously called.\n  * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be\n  *               overridden by\n  *               {@link com.bumptech.glide.request.RequestOptions#override(int, int)}} if\n  *               previously called).\n  */\n@NonNull\npublic FutureTarget\u003cTranscodeType\u003e submit(int width, int height) {\n  final RequestFutureTarget\u003cTranscodeType\u003e target = new RequestFutureTarget\u003c\u003e(width, height);\n  return into(target, target, Executors.directExecutor());\n}\n```\n\n由于方法会生成一个 RequestFutureTarget 对象，而其 getSize 的实现就是构造参数。所以，此处的值会覆盖掉 RequestOptions 设置的值。\n\nsubmit 之后生成了一个 RequestFutureTarget 对象，调用该对象的 get 方法可以在资源加载成功后立即获得资源对象，在获得之前会阻塞，所以 get 方法需要在后台线程中执行，否则会报错。\n\nRequestFutureTarget 的示例代码如下：\n\n```java\nFutureTarget\u003cFile\u003e target = null;\nRequestManager requestManager = Glide.with(context);\ntry {\n  target = requestManager\n     .downloadOnly()\n     .load(model)\n     .submit();\n  File downloadedFile = target.get();\n  // ... do something with the file (usually throws IOException)\n} catch (ExecutionException | InterruptedException | IOException e) {\n  // ... bug reporting or recovery\n} finally {\n  // make sure to cancel pending operations and free resources\n  if (target != null) {\n    target.cancel(true); // mayInterruptIfRunning\n  }\n}\n```\n\n### downloadOnly\n\n作用：下载原始的无修改的 data 文件。\n\ndownloadOnly 内部调用的是修改过配置的 into/submit 方法，但 downloadOnly 方法已经被废弃；建议采用 RequestManager 的 downloadOnly() 方法和 into/submit 方法。\n\n实际上 RequestBuilder.downloadOnly 方法与 RequestManager.downloadOnly()、RequestBuilder.into/submit 方法组合没有什么区别。\n\n两处代码如下：\n\n\u003cem\u003eRequestBuilder.downloadOnly\u003c/em\u003e\n\n```java\n@Deprecated\n@CheckResult\npublic \u003cY extends Target\u003cFile\u003e\u003e Y downloadOnly(@NonNull Y target) {\n  return getDownloadOnlyRequest().into(target);\n}\n\n@Deprecated\n@CheckResult\npublic FutureTarget\u003cFile\u003e downloadOnly(int width, int height) {\n  return getDownloadOnlyRequest().submit(width, height);\n}\n\n@NonNull\n@CheckResult\nprotected RequestBuilder\u003cFile\u003e getDownloadOnlyRequest() {\n  return new RequestBuilder\u003c\u003e(File.class, this).apply(DOWNLOAD_ONLY_OPTIONS);\n}\n```\n\n\u003cem\u003eRequestManager.downloadOnly、RequestBuilder.into/submit\u003c/em\u003e\n\n```typescript\n@NonNull\npublic \u003cY extends Target\u003cTranscodeType\u003e\u003e Y into(@NonNull Y target) {\n  return into(target, /*targetListener=*/ null, Executors.mainThreadExecutor());\n}\n\npublic FutureTarget\u003cTranscodeType\u003e submit(int width, int height) {\n  final RequestFutureTarget\u003cTranscodeType\u003e target = new RequestFutureTarget\u003c\u003e(width, height);\n  return into(target, target, Executors.directExecutor());\n}\n\n@NonNull\n@CheckResult\npublic RequestBuilder\u003cFile\u003e downloadOnly() {\n  return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);\n}\n```\n\n所以，这里的 DOWNLOAD_ONLY_OPTIONS 才是 downloadOnly 的精髓，我们看看该变量的值：\n\n```java\nprotected static final RequestOptions DOWNLOAD_ONLY_OPTIONS =\n    new RequestOptions().diskCacheStrategy(DiskCacheStrategy.DATA).priority(Priority.LOW)\n        .skipMemoryCache(true);\n```\n\n果然是下载的是原始的无修改的 data 资源。\n\n### listener/addListener\n\nlistener 与 addListener 不同之处在于，前者只会保留当前的 Listener，而后者会保留之前的 Listener。\n\n```kotlin\n@NonNull\n@CheckResult\n@SuppressWarnings(\"unchecked\")\npublic RequestBuilder\u003cTranscodeType\u003e listener(\n    @Nullable RequestListener\u003cTranscodeType\u003e requestListener) {\n  this.requestListeners = null;\n  return addListener(requestListener);\n}\n\n@NonNull\n@CheckResult\npublic RequestBuilder\u003cTranscodeType\u003e addListener(\n    @Nullable RequestListener\u003cTranscodeType\u003e requestListener) {\n  if (requestListener != null) {\n    if (this.requestListeners == null) {\n      this.requestListeners = new ArrayList\u003c\u003e();\n    }\n    this.requestListeners.add(requestListener);\n  }\n  return this;\n}\n```\n\n这些 listener 会在资源记载失败或者成功的时候被调用，SingleRequest 中关于 requestListeners 的代码：\n\n```java\nprivate synchronized void onResourceReady(Resource\u003cR\u003e resource, R result, DataSource dataSource) {\n  // We must call isFirstReadyResource before setting status.\n  boolean isFirstResource = isFirstReadyResource();\n  status = Status.COMPLETE;\n  this.resource = resource;\n\n  isCallingCallbacks = true;\n  try {\n    boolean anyListenerHandledUpdatingTarget = false;\n    if (requestListeners != null) {\n      for (RequestListener\u003cR\u003e listener : requestListeners) {\n        anyListenerHandledUpdatingTarget |=\n            listener.onResourceReady(result, model, target, dataSource, isFirstResource);\n      }\n    }\n    anyListenerHandledUpdatingTarget |=\n        targetListener != null\n            \u0026\u0026 targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);\n\n    if (!anyListenerHandledUpdatingTarget) {\n      Transition\u003c? super R\u003e animation =\n          animationFactory.build(dataSource, isFirstResource);\n      target.onResourceReady(result, animation);\n    }\n  } finally {\n    isCallingCallbacks = false;\n  }\n\n  notifyLoadSuccess();\n}\n\nprivate synchronized void onLoadFailed(GlideException e, int maxLogLevel) {\n  stateVerifier.throwIfRecycled();\n  e.setOrigin(requestOrigin);\n\n  loadStatus = null;\n  status = Status.FAILED;\n\n  isCallingCallbacks = true;\n  try {\n    //TODO: what if this is a thumbnail request?\n    boolean anyListenerHandledUpdatingTarget = false;\n    if (requestListeners != null) {\n      for (RequestListener\u003cR\u003e listener : requestListeners) {\n        anyListenerHandledUpdatingTarget |=\n            listener.onLoadFailed(e, model, target, isFirstReadyResource());\n      }\n    }\n    anyListenerHandledUpdatingTarget |=\n        targetListener != null\n            \u0026\u0026 targetListener.onLoadFailed(e, model, target, isFirstReadyResource());\n\n    if (!anyListenerHandledUpdatingTarget) {\n      setErrorPlaceholder();\n    }\n  } finally {\n    isCallingCallbacks = false;\n  }\n\n  notifyLoadFailed();\n}\n```\n\n调用逻辑是这样：在 requestListeners 集合、targetListener 中依次调用对应的回调，找到第一个能够处理的 (返回 true)，后面的就不再调用。\n\n同时，如果有一个回调返回了 true，那么资源的对应方法会被拦截：\n\n1. 对于 onResourceReady 方法来说，Target 的 onResourceReady 方法不会被回调\n2. 对于 onLoadFailed 方法来说，setErrorPlaceholder 调用不会调用，即不会显示任何失败的占位符\n\n# Transform\n\n## Transform 行为分析\n\n### 场景还原\n\n布局文件：ImageView 宽高都是 wrap_content\n\n```html\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003candroid.support.constraint.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\u003e\n\n    \u003cImageView\n        android:id=\"@+id/ivGlide\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"/\u003e\n\n    \u003candroid.support.design.widget.FloatingActionButton\n        android:id=\"@+id/fab\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"24dp\"\n        android:src=\"@drawable/btn_camera\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"/\u003e\n\n\u003c/android.support.constraint.ConstraintLayout\u003e\n```\n\n代码：测试的可选项为代码中被注释的两行代码\n\n```kotlin\n...\nimport com.bumptech.glide.request.target.Target as GlideTarget\n\nclass GlideFragment : Fragment() {\n    ...\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        fab.setOnClickListener {\n            load()\n        }\n    }\n\n    private fun load() {\n        Glide.with(this)\n            .load(URL)\n//            .dontTransform()\n//            .override(GlideTarget.SIZE_ORIGINAL, GlideTarget.SIZE_ORIGINAL)\n            .into(ivGlide)\n    }\n\n    companion object {\n        // 540*258  1080/(759-243)-(540/258)=0\n        private const val URL = \"https://www.baidu.com/img/bd_logo1.png\"\n    }\n}\n```\n\n整个例子非常简单，点击一下 FAB 就会调用 load 方法加载网路图片。注意这里 ImageView 的宽高都是 wrap_content。\n\n下面从左至右 4 张图分别对应以下配置开启时的效果（下面分析时会称为例 1、例 2、例 3、例 4）：\n\n1. 直接加载\n2. 只使用 dontTransform\n3. 只使用 override\n4. dontTransform 和 override 同时\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-3/clipboard_20230323_031837.png)\n\n可以很明显的看到，显示的图片也有所差异，ImageView 的宽高有所差异。\n\n如果没有调用 override(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)，ImageView 宽度会是 match_parent 的效果，且如果 dontTransform()，那么高度也是 match_parent 效果。调用了 override 之后会显示的图片的真实尺寸。\n\n带着这个问题，到源码中看看是怎么回事。\n\n### 代码分析\n\n首先 dontTransform() 方法实现在 BaseRequestOptions 文件中，该方法的意思就是不使用任何 transform：\n\n```java\npublic T dontTransform() {\n  if (isAutoCloneEnabled) {\n    return clone().dontTransform();\n  }\n\n  transformations.clear();\n  fields \u0026= ~TRANSFORMATION;\n  isTransformationRequired = false;\n  fields \u0026= ~TRANSFORMATION_REQUIRED;\n  isTransformationAllowed = false;\n  fields |= TRANSFORMATION_ALLOWED;\n  isScaleOnlyOrNoTransform = true;\n  return selfOrThrowIfLocked();\n}\n```\n\n这里首先清空了 transformations，然后设置了一些标志位。这些标志位后面看到再说。然后是 override 方法，该方法的意思是只加载指定宽高的像素的图片，方法实现只是保存了参数，待后面使用：\n\n```kotlin\n@NonNull\n@CheckResult\npublic T override(int width, int height) {\n  if (isAutoCloneEnabled) {\n    return clone().override(width, height);\n  }\n\n  this.overrideWidth = width;\n  this.overrideHeight = height;\n  fields |= OVERRIDE;\n\n  return selfOrThrowIfLocked();\n}\n```\n\n在配置完参数后，调用 into 方法开始加载图片。整个加载流程非常冗长，详情请看前面的分析文章。所以这里只挑选相关的代码，其他的会一笔带过。\n\n先是 RequestBuilder.into(ImageView) 的实现，该方法会默认进行一些 transform 的配置：\n\n```java\n@NonNull\npublic ViewTarget\u003cImageView, TranscodeType\u003e into(@NonNull ImageView view) {\n  Util.assertMainThread();\n  Preconditions.checkNotNull(view);\n\n  BaseRequestOptions\u003c?\u003e requestOptions = this;\n  if (!requestOptions.isTransformationSet()\n      \u0026\u0026 requestOptions.isTransformationAllowed()\n      \u0026\u0026 view.getScaleType() != null) {\n    // Clone in this method so that if we use this RequestBuilder to load into a View and then\n    // into a different target, we don't retain the transformation applied based on the previous\n    // View's scale type.\n    switch (view.getScaleType()) {\n      case CENTER_CROP:\n        requestOptions = requestOptions.clone().optionalCenterCrop();\n        break;\n      case CENTER_INSIDE:\n        requestOptions = requestOptions.clone().optionalCenterInside();\n        break;\n      case FIT_CENTER:\n      case FIT_START:\n      case FIT_END:\n        requestOptions = requestOptions.clone().optionalFitCenter();\n        break;\n      case FIT_XY:\n        requestOptions = requestOptions.clone().optionalCenterInside();\n        break;\n      case CENTER:\n      case MATRIX:\n      default:\n        // Do nothing.\n    }\n  }\n\n  return into(\n      glideContext.buildImageViewTarget(view, transcodeClass),\n      /*targetListener=*/ null,\n      requestOptions,\n      Executors.mainThreadExecutor());\n}\n```\n\n在上面代码第 7 行的判断语句 !requestOptions.isTransformationSet()，判断的是 fields 是否含有标记位 TRANSFORMATION。\n\n第 8 行判断语句 requestOptions.isTransformationAllowed() 判断的是 isTransformationAllowed。\n\n对于这两个判断条件，如果调用了 dontTransform() 方法（例 2、例 4），那么显然条件 1 满足，但是条件 2 就不满足了。否则（例 1、例 3），这两个条件都是满足的，也就意味着 Glide 会有一个默认的 transform。默认的 transform 会根据 ImageView 的 ScaleType 有不同的取值。\n\nScaleType 与默认的 transform 之间关系如下表：\n\n在 ImageView.initImageView() 方法中可以看到，默认的 ScaleType 为 ScaleType.FIT_CENTER。所以，此时 Glide 会默认调用 optionalFitCenter() 方法。\n\n注意，optionalFitCenter() 方法与非 optional 的 fitCenter() 方法的差别在于 isTransformationRequired 参数的值不同。在最后 DecodeHelper.getTransformation(Class) 方法中，如果找不到可用的 transform，且 isTransformationRequired 为 true，就会抛出 IllegalArgumentException。除此之外两者没有别的差别。\n\noptionalFitCenter() 方法会针对四种不同类型的数据产生不同的 transformation：\n\n现在可以开始加载图片了，最开始会调用 SingleRequest.begin 方法，在该方法中会判断需要显示多大尺寸的图片。如果指定了 override(int, int)（例 3、例 4），那么就无需 ViewTarget 参与计算，直接调用 onSizeReady(int, int) 开始下一步；否则（例 1、例 2）就要计算了：\n\n```java\n@Override\npublic synchronized void begin() {\n  if (model == null) {\n    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n      width = overrideWidth;\n      height = overrideHeight;\n    }\n    return;\n  }\n\n  if (status == Status.RUNNING) {\n    throw new IllegalArgumentException(\"Cannot restart a running request\");\n  }\n\n  if (status == Status.COMPLETE) {\n    onResourceReady(resource, DataSource.MEMORY_CACHE);\n    return;\n  }\n\n  // Restarts for requests that are neither complete nor running can be treated as new requests\n  // and can run again from the beginning.\n\n  status = Status.WAITING_FOR_SIZE;\n  if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n    onSizeReady(overrideWidth, overrideHeight);\n  } else {\n    target.getSize(this);\n  }\n\n  if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)\n      \u0026\u0026 canNotifyStatusChanged()) {\n    target.onLoadStarted(getPlaceholderDrawable());\n  }\n}\n```\n\n显然，造成示例中图片尺寸差异的一个原因就是这个第 27 行的 target.getSize(this) 方法了。对应方法的实现在 ViewTarget 中，这个请求会转发给内部的 SizeDeterminer 来完成。看一下 ViewTarget.SizeDeterminer 类：\n\n```java\nstatic final class SizeDeterminer {\n  void getSize(@NonNull SizeReadyCallback cb) {\n    int currentWidth = getTargetWidth();\n    int currentHeight = getTargetHeight();\n    if (isViewStateAndSizeValid(currentWidth, currentHeight)) {\n      cb.onSizeReady(currentWidth, currentHeight);\n      return;\n    }\n    ...\n  }\n\n  private int getTargetHeight() {\n    int verticalPadding = view.getPaddingTop() + view.getPaddingBottom();\n    LayoutParams layoutParams = view.getLayoutParams();\n    int layoutParamSize = layoutParams != null ? layoutParams.height : PENDING_SIZE;\n    return getTargetDimen(view.getHeight(), layoutParamSize, verticalPadding);\n  }\n\n  private int getTargetWidth() {\n    int horizontalPadding = view.getPaddingLeft() + view.getPaddingRight();\n    LayoutParams layoutParams = view.getLayoutParams();\n    int layoutParamSize = layoutParams != null ? layoutParams.width : PENDING_SIZE;\n    return getTargetDimen(view.getWidth(), layoutParamSize, horizontalPadding);\n  }\n}\n```\n\n首先在第 3、4 行调用方法获取 Target 的宽高，由于在本例中宽高都是 WRAP_CONTENT，而且也没有其他的限制，所以最后调用 getTargetDimen 时传入的参数都是一样的 (viewSize=0, paramSize=WRAP_CONTENT=-2, paddingSize=0)。然后，看看 getTargetDimen 方法的实现：\n\n```java\nprivate int getTargetDimen(int viewSize, int paramSize, int paddingSize) {\n  // We consider the View state as valid if the View has non-null layout params and a non-zero\n  // layout params width and height. This is imperfect. We're making an assumption that View\n  // parents will obey their child's layout parameters, which isn't always the case.\n  int adjustedParamSize = paramSize - paddingSize;\n  if (adjustedParamSize \u003e 0) {\n    return adjustedParamSize;\n  }\n\n  // Since we always prefer layout parameters with fixed sizes, even if waitForLayout is true,\n  // we might as well ignore it and just return the layout parameters above if we have them.\n  // Otherwise we should wait for a layout pass before checking the View's dimensions.\n  if (waitForLayout \u0026\u0026 view.isLayoutRequested()) {\n    return PENDING_SIZE;\n  }\n\n  // We also consider the View state valid if the View has a non-zero width and height. This\n  // means that the View has gone through at least one layout pass. It does not mean the Views\n  // width and height are from the current layout pass. For example, if a View is re-used in\n  // RecyclerView or ListView, this width/height may be from an old position. In some cases\n  // the dimensions of the View at the old position may be different than the dimensions of the\n  // View in the new position because the LayoutManager/ViewParent can arbitrarily decide to\n  // change them. Nevertheless, in most cases this should be a reasonable choice.\n  int adjustedViewSize = viewSize - paddingSize;\n  if (adjustedViewSize \u003e 0) {\n    return adjustedViewSize;\n  }\n\n  // Finally we consider the view valid if the layout parameter size is set to wrap_content.\n  // It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a\n  // coherent choice, it's extremely dangerous because original images may be much too large to\n  // fit in memory or so large that only a couple can fit in memory, causing OOMs. If users want\n  // the original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content\n  // may never resolve to a real size unless we load something, we aim for a square whose length\n  // is the largest screen size. That way we're loading something and that something has some\n  // hope of being downsampled to a size that the device can support. We also log a warning that\n  // tries to explain what Glide is doing and why some alternatives are preferable.\n  // Since WRAP_CONTENT is sometimes used as a default layout parameter, we always wait for\n  // layout to complete before using this fallback parameter (ConstraintLayout among others).\n  if (!view.isLayoutRequested() \u0026\u0026 paramSize == LayoutParams.WRAP_CONTENT) {\n    if (Log.isLoggable(TAG, Log.INFO)) {\n      Log.i(TAG, \"Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of\"\n          + \" this device's screen dimensions. If you want to load the original image and are\"\n          + \" ok with the corresponding memory cost and OOMs (depending on the input size), use\"\n          + \" .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set\"\n          + \" layout_width and layout_height to fixed dimension, or use .override() with fixed\"\n          + \" dimensions.\");\n    }\n    return getMaxDisplayLength(view.getContext());\n  }\n\n  // If the layout parameters are \u003c padding, the view size is \u003c padding, or the layout\n  // parameters are set to match_parent or wrap_content and no layout has occurred, we should\n  // wait for layout and repeat.\n  return PENDING_SIZE;\n}\n```\n\n在 getTargetDimen 方法中会通过参数计算 Target 的尺寸，显然这里最后会调用 getMaxDisplayLength(view.getContext()) 来返回 View 的尺寸。至于为什么 wrap_content 时会这样做，在注释中说的很清楚了，主要是考虑到加载的资源的不确定性，万一是一个大图片就直接 OOM 了。而且 Glide 会打印出 log 告诉我们一些解决方法，如果我们不满意这种处理方式。\n\ngetMaxDisplayLength(Context) 会返回 Display size 宽高的较大者：\n\n```java\n// Use the maximum to avoid depending on the device's current orientation.\nprivate static int getMaxDisplayLength(@NonNull Context context) {\n  if (maxDisplayLength == null) {\n    WindowManager windowManager =\n        (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n    Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();\n    Point displayDimensions = new Point();\n    display.getSize(displayDimensions);\n    maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);\n  }\n  return maxDisplayLength;\n}\n```\n\n显然，在示例中，最后获取到的宽高都是一样的，在竖屏状态下会是 Display 的高。\n\n\u003cstrong\u003eDisplay#getSize 与 Display#getRealSize 的区别？\u003c/strong\u003e\n\nDisplay#getRealSize 返回的是屏幕真实的尺寸；而 Display#getSize 返回的是“可用”的屏幕尺寸，常见的情况是，有 NavigationBar 就会等于 RealSize 减去 NavigationBar 的高度。\n\n获取到了 Target 的尺寸之后，会调用 isViewStateAndSizeValid 方法检查是否 OK：OK 就调用 SingleRequest.onSizeReady 方法进入下一步了；否则会给 ViewTree 添加 OnPreDrawListener 监听器，在 onPreDraw 方法回调中再次获取一下尺寸。\n\n在经过一系列操作，加载到原始数据之后，会现在 DecodePath.decode 中对原始 data 进行 decode，这样就得到了 Bitmap，但是过程中涉及到 Bitmap 尺寸的操作。具体经过 ByteBufferBitmapDecoder 到 Downsampler#decodeFromWrappedStreams 方法中。里面绝大多数都是计算，这里拿例 1 来描述计算过程：\n\n1. 获取 Bitmap 的宽高：sourceWidth=540,sourceHeight=258；获取 Target 的宽高：targetWidth=targetHeight=1776\n2. 调用 calculateScaling 方法计算 inSampleSize、inTargetDensity、inDensity 等一系列参数，这里会用到 DownsampleStrategy.FitCenter 类，该对象在前面 optionalFitCenter() 过程保存的 KV 表格中提到过。其 getScaleFactor 方法实现就是取 target 宽高 / source 宽高的较小者，也就是 3.288889，该值由 inTargetDensity/inDensity 保存。\n3. 最后计算 expectedWidth=round(540*3.288889)=1776，expectedHeight=round(258*3.288889)=849，并从 BitmapPool 中获取这么一个宽高的 Bitmap 设置给 Options.inBitmap\n4. 再次进行解码，解码完毕后获得的图片就是 1776x849 大小的图片了。\n\n如果是 dontTransform（例 2），DownsampleStrategy 会是默认值 DownsampleStrategy.CenterOutside。其 getScaleFactor 方法实现就是取 target 宽高 / source 宽高的较大者，也就是 6.883721。因此最后解码完毕的图片大小为 3717x1776。\n\n如果是 override 过的（例 3、例 4），由于不需要缩放，所以返回的就是原始大小的图片。\n\n在 decode 完毕后，会回到 DecodeJob.onResourceDecoded 方法中接着进行 transform 操作：\n\n```java\n@Synthetic\n@NonNull\n\u003cZ\u003e Resource\u003cZ\u003e onResourceDecoded(DataSource dataSource,\n    @NonNull Resource\u003cZ\u003e decoded) {\n  @SuppressWarnings(\"unchecked\")\n  Class\u003cZ\u003e resourceSubClass = (Class\u003cZ\u003e) decoded.get().getClass();\n  Transformation\u003cZ\u003e appliedTransformation = null;\n  Resource\u003cZ\u003e transformed = decoded;\n  if (dataSource != DataSource.RESOURCE_DISK_CACHE) {\n    appliedTransformation = decodeHelper.getTransformation(resourceSubClass);\n    transformed = appliedTransformation.transform(glideContext, decoded, width, height);\n  }\n  ...\n}\n```\n\n在这里首先判断是不是 DataSource.RESOURCE_DISK_CACHE，如果不是才需要进行 transform。\n\n\u003cstrong\u003eBut, why?\u003c/strong\u003e Glide 中很重要的概念——resource 和 data：差别在于 resource 是已经 transform 过了的，即 transform(data)=resource。所以，我们知道 resource 已经经过 transform 过了，自然就不再需要。\n\n对于调用过 dontTransform() 方法的例子（例 2、例 4）来说，decodeHelper.getTransformation 返回的是一个 UnitTransformation，其 transform 没有干任何有意义的事情，也就是说不进行 transform。\n\n对于普通的 Glide 加载请求（例 1、例 3）来说，一个 URL 已经经过一系列 Registry 的变换，到这里就变成 了 Bitmap.class，所以在第 11 行调用的是 `FitCenter().transform(Context, Resource\u003cBitmap\u003e, int, int )` 方法。而 FitCenter 又是 BitmapTransformation 的子类，所以先看看 BitmapTransformation：\n\n```java\npublic abstract class BitmapTransformation implements Transformation\u003cBitmap\u003e {\n\n  @NonNull\n  @Override\n  public final Resource\u003cBitmap\u003e transform(\n      @NonNull Context context, @NonNull Resource\u003cBitmap\u003e resource, int outWidth, int outHeight) {\n    if (!Util.isValidDimensions(outWidth, outHeight)) {\n      throw new IllegalArgumentException(\n          \"Cannot apply transformation on width: \" + outWidth + \" or height: \" + outHeight\n              + \" less than or equal to zero and not Target.SIZE_ORIGINAL\");\n    }\n    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();\n    Bitmap toTransform = resource.get();\n    int targetWidth = outWidth == Target.SIZE_ORIGINAL ? toTransform.getWidth() : outWidth;\n    int targetHeight = outHeight == Target.SIZE_ORIGINAL ? toTransform.getHeight() : outHeight;\n    Bitmap transformed = transform(bitmapPool, toTransform, targetWidth, targetHeight);\n\n    final Resource\u003cBitmap\u003e result;\n    if (toTransform.equals(transformed)) {\n      result = resource;\n    } else {\n      result = BitmapResource.obtain(transformed, bitmapPool);\n    }\n    return result;\n  }\n\n  protected abstract Bitmap transform(\n      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight);\n}\n```\n\n首先做 sanity check，然后获取 targetWidth、targetHeight。如果指定了 override(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)，这里会是图片的真实尺寸，否则就是 Target 的尺寸了。\n\n然后调用抽象方法进行 transform 操作，并返回 transform 后的结果。显然，transform 抽象方法就是子类需要实现的了，所以看看 FitCenter 的方法：\n\n```java\npublic class FitCenter extends BitmapTransformation {\n  private static final String ID = \"com.bumptech.glide.load.resource.bitmap.FitCenter\";\n  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);\n\n  @Override\n  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,\n      int outHeight) {\n    return TransformationUtils.fitCenter(pool, toTransform, outWidth, outHeight);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    return o instanceof FitCenter;\n  }\n\n  @Override\n  public int hashCode() {\n    return ID.hashCode();\n  }\n\n  @Override\n  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {\n    messageDigest.update(ID_BYTES);\n  }\n}\n```\n\n可以看到 FitCenter.transform 方法直接调用了 TransformationUtils 的 fitCenter 方法。除此之外，需要注意一下 equals、hashCode、updateDiskCacheKey 方法，这三个方法要重写的原因是因为 transform 会作为 key 的组成部分，参与到 key 的比较、缓存读写时 safeKey 生成，具体内容可以参考之前分析的文章。\n\n至于 TransformationUtils 类，该类里面有很多处理图片的静态方法，内置的几种 BitmapTransformation 都是调用该工具类里面对应的方法来完成 transform 功能的。这里只看 fitCenter 方法：\n\n```java\npublic static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int width,\n    int height) {\n  if (inBitmap.getWidth() == width \u0026\u0026 inBitmap.getHeight() == height) {\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(TAG, \"requested target size matches input, returning input\");\n    }\n    return inBitmap;\n  }\n  final float widthPercentage = width / (float) inBitmap.getWidth();\n  final float heightPercentage = height / (float) inBitmap.getHeight();\n  final float minPercentage = Math.min(widthPercentage, heightPercentage);\n\n  // Round here in case we've decoded exactly the image we want, but take the floor below to\n  // avoid a line of garbage or blank pixels in images.\n  int targetWidth = Math.round(minPercentage * inBitmap.getWidth());\n  int targetHeight = Math.round(minPercentage * inBitmap.getHeight());\n\n  if (inBitmap.getWidth() == targetWidth \u0026\u0026 inBitmap.getHeight() == targetHeight) {\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n      Log.v(TAG, \"adjusted target size matches input, returning input\");\n    }\n    return inBitmap;\n  }\n\n  // Take the floor of the target width/height, not round. If the matrix\n  // passed into drawBitmap rounds differently, we want to slightly\n  // overdraw, not underdraw, to avoid artifacts from bitmap reuse.\n  targetWidth = (int) (minPercentage * inBitmap.getWidth());\n  targetHeight = (int) (minPercentage * inBitmap.getHeight());\n\n  Bitmap.Config config = getNonNullConfig(inBitmap);\n  Bitmap toReuse = pool.get(targetWidth, targetHeight, config);\n\n  // We don't add or remove alpha, so keep the alpha setting of the Bitmap we were given.\n  TransformationUtils.setAlpha(inBitmap, toReuse);\n\n  if (Log.isLoggable(TAG, Log.VERBOSE)) {\n    Log.v(TAG, \"request: \" + width + \"x\" + height);\n    Log.v(TAG, \"toFit:   \" + inBitmap.getWidth() + \"x\" + inBitmap.getHeight());\n    Log.v(TAG, \"toReuse: \" + toReuse.getWidth() + \"x\" + toReuse.getHeight());\n    Log.v(TAG, \"minPct:   \" + minPercentage);\n  }\n\n  Matrix matrix = new Matrix();\n  matrix.setScale(minPercentage, minPercentage);\n  applyMatrix(inBitmap, toReuse, matrix);\n\n  return toReuse;\n}\n```\n\n该方法最开始会检查尺寸是否需要进行缩放，对于 override(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)（例 3）来说，显然是不需要的，所以就直接返回了。\n\n否则，对于例 1 来说，需要继续执行后面的代码显示合适的图片。由于 Bitmap 的宽高在 encode 过程中计算出来了，为 1776x849，而传入的 width、height 为 1776，显然 minPercentage 会取 widthPercentage，也就意味着会按照屏幕的宽度进行缩放。但 widthPercentage 为 1，所以导致第 18 行的判断条件为 true，因此直接返回了图片。\n\n后面就是纯粹的展示问题了，在 DrawableImageViewTarget.setResource 方法中会将上面的图片设置到 ImageView 中，此时 ImageView 宽高都是 0，resource 的宽高为 1776x849。下面怎么显示就是 ImageView 决 定的了。\n\n下面对四个例子做一个小结：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-3/clipboard_20230323_031849.png)\n\n各例子之所以表现各不一样，其原因就在于 decode 出来的图片的尺寸不一致，而使用 wrap_content 宽高的 ImageView 加载这些图片，就会造成这些效果。\n\n## Glide 自带的 Transformation\n\n在上一节遇到的 FitCenter、CenterOutside 这两个 BitmapTransformation 都是 Glide 自带的，除了这两个外还有其他四个自带的。这些 BitmapTransformation 的名称和作用如下：\n\n- CenterInside：如果图片的尺小于等于 target，图片保持不变；否则会调用 fitCenter。\n- FitCenter：等比缩放，使得图片的一条边和 target 相同，另外一边小于给定的 target。\n- CenterCrop：首先缩放图片，使图片的宽和给定的宽相等，且图片的高大于给定的高。或者高相等，图片的宽大于给定的宽。然后 crop，使较大的一边的像素和给定的相同。这种缩放最终效果显然不是等比缩放。\n- Rotate：旋转 Bitmap\n- RoundedCorners：圆角，单位是 pixel\n- CircleCrop：圆形\n\n前面三个我们非常熟悉了，和 ImageView 的 ScaleType 有对应关系，所以下面的示例用来演示一下后面的三个 Transformation。\n\n布局文件很简单，一个参照的 ImageView + 三个显示对应效果的 ImageView:\n\n```xml\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003candroid.support.constraint.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\u003e\n\n    \u003candroid.support.constraint.Guideline\n        android:id=\"@+id/guideline\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"0dp\"\n        app:layout_constraintGuide_percent=\"0.5\"\n        android:orientation=\"vertical\"/\u003e\n\n    \u003cImageView\n        android:id=\"@+id/ivGlide1\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"@id/guideline\"\n        app:layout_constraintTop_toTopOf=\"parent\"/\u003e\n\n    \u003cImageView\n        android:id=\"@+id/ivGlide2\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintStart_toStartOf=\"@id/guideline\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\"/\u003e\n\n    \u003cImageView\n        android:id=\"@+id/ivGlide3\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"@id/guideline\"\n        app:layout_constraintTop_toBottomOf=\"@id/ivGlide1\"/\u003e\n\n    \u003cImageView\n        android:id=\"@+id/ivGlide4\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        app:layout_constraintStart_toStartOf=\"@id/guideline\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintTop_toBottomOf=\"@id/ivGlide2\"/\u003e\n\n    \u003candroid.support.design.widget.FloatingActionButton\n        android:id=\"@+id/fab\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_margin=\"24dp\"\n        android:src=\"@drawable/btn_camera\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"/\u003e\n\n\u003c/android.support.constraint.ConstraintLayout\u003e\n```\n\n源文件也比较简单：\n\n```kotlin\n// private const val URL = \"http://cn.bing.com/az/hprichbg/rb/Dongdaemun_ZH-CN10736487148_1920x1080.jpg\"\n\nGlide.with(this)\n    .load(URL)\n    .into(ivGlide1)\n\nGlide.with(this)\n    .load(URL)\n    .transform(FitCenter(), Rotate(180))\n    .into(ivGlide2)\n\nGlide.with(this)\n    .load(URL)\n    .transform(MultiTransformation(FitCenter(), RoundedCorners(303 ushr 1)))\n    .into(ivGlide3)\n\nGlide.with(this)\n    .load(URL)\n    .transform(CircleCrop())\n    .into(ivGlide4)\n```\n\nRotate、RoundedCorners、CircleCrop 效果图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Glide-3/clipboard_20230323_031855.png)\n\n看完图后，这三个 Transformation 的特点一目了然了。注意上面第 2、3 个加载时，因为 ImageView 高度为 wrap_content，所以需要加上 FitCenter，使 Bitmap 的宽高达到我们的预期（图片宽高为 1920*1080，ImageView 宽度为 540，因此高度为 (540/1920*1080=303.75，转为 int 后为 303)），然后在此基础上进行圆角或圆形处理。\n\nGlide 使用 map 保存 transformation，所以调用多个 transform 方法，只有最后一个才会生效。如果我们想要使用多个 transformation，可以使用 MultiTransformation 类或者 `transforms(Transformation\u003cBitmap\u003e...)` 以及 `transform(Transformation\u003cBitmap\u003e...)` 方法。\n\n## 自定义 BitmapTransformation\n\n如果我们想 transform Bitmap，继承 BitmapTransformation 是最好的方式了。BitmapTransformation 为我们处理了一些基础的东西，例如，如果 Transformation 返回了一个新的 Bitmap， BitmapTransformation 将负责提取和回收原始的 Bitmap。\n\n下面是一个简单的实现：\n\n```java\npublic class FillSpace extends BitmapTransformation {\n    private static final String ID = \"com.bumptech.glide.transformations.FillSpace\";\n    private static final String ID_BYTES = ID.getBytes(STRING_CHARSET_NAME);\n\n    @Override\n    public Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {\n        if (toTransform.getWidth() == outWidth \u0026\u0026 toTransform.getHeight() == outHeight) {\n            return toTransform;\n        }\n\n        return Bitmap.createScaledBitmap(toTransform, outWidth, outHeight, /*filter=*/ true);\n    }\n\n    @Override\n    public void equals(Object o) {\n      return o instanceof FillSpace;\n    }\n\n    @Override\n    public int hashCode() {\n      return ID.hashCode();\n    }\n\n    @Override\n    public void updateDiskCacheKey(MessageDigest messageDigest)\n        throws UnsupportedEncodingException {\n      messageDigest.update(ID_BYTES);\n    }\n}\n```\n\n上面的例子虽然简单，但是包含了必须实现的方法：\n\n1. transform 是该类存在的意义，作用不言而喻。\n2. 第一个参数 pool，这个是 Glide 中的一个 Bitmap 缓存池，用于对 Bitmap 对象进行重用，否则每次图片变换都重新创建 Bitmap 对象将会非常消耗内存。\n3. 第二个参数 toTransform，这个是原始图片的 Bitmap 对象，我们就是要对它来进行图片变换。\n4. 第三和第四个参数比较简单，分别代表图片变换后的宽度和高度，其实也就是 override() 方法中传入的宽和高的值了。\n5. equals、hashCode、updateDiskCacheKey 三个方法必须实现，因为磁盘缓存和内存缓存都需要这个。详情可以看之前的分析文章。\n\n此外，如果自定义的 BitmapTransformation 有构造参数，那么 equals、hashCode、updateDiskCacheKey 三个方法也需要对构造参数做处理。比如 RoundedCorners：\n\n```java\npublic final class RoundedCorners extends BitmapTransformation {\n  private static final String ID = \"com.bumptech.glide.load.resource.bitmap.RoundedCorners\";\n  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);\n\n  private final int roundingRadius;\n\n  /**\n   * @param roundingRadius the corner radius (in device-specific pixels).\n   * @throws IllegalArgumentException if rounding radius is 0 or less.\n   */\n  public RoundedCorners(int roundingRadius) {\n    Preconditions.checkArgument(roundingRadius \u003e 0, \"roundingRadius must be greater than 0.\");\n    this.roundingRadius = roundingRadius;\n  }\n\n  @Override\n  protected Bitmap transform(\n      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {\n    return TransformationUtils.roundedCorners(pool, toTransform, roundingRadius);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o instanceof RoundedCorners) {\n      RoundedCorners other = (RoundedCorners) o;\n      return roundingRadius == other.roundingRadius;\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    return Util.hashCode(ID.hashCode(),\n        Util.hashCode(roundingRadius));\n  }\n\n  @Override\n  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {\n    messageDigest.update(ID_BYTES);\n\n    byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();\n    messageDigest.update(radiusData);\n  }\n}\n```\n\n# AppGlideModule\n\nGlide 之所以强大，另外一个重要的功能就是可以自定义模块，自定义模块功能可以将更改 Glide 配置，替换 Glide 组件等操作独立出来，使得我们能轻松地对 Glide 的各种配置进行自定义，并且又和 Glide 的图片加载逻辑没有任何交集，这也是一种低耦合编程方式的体现。\n\n需要注意的是，更改 Glide 默认配置应该关注是否会造成性能倒退。\n\n## 使用\n\n首先，使用 kapt 将 compiler 引入到项目中：\n\n```groovy\napply plugin: 'kotlin-kapt'\n\ndependencies {\n  implementation 'com.github.bumptech.glide:glide:4.12.0'\n  kapt 'com.github.bumptech.glide:compiler:4.12.0'\n}\n```\n\n并且在你的 `proguard.cfg` 中 keep 住你的 AppGlideModule 实现：\n\n```plain text\n-keep public class  extends com.bumptech.glide.module.AppGlideModule\n-keep class com.bumptech.glide.GeneratedAppGlideModuleImpl\n```\n\n接着，新建一个类继承自 AppGlideModule：\n\n```kotlin\n@GlideModule\nclass MyAppGlideModule : AppGlideModule() {\n    override fun applyOptions(context: Context, builder: GlideBuilder) {\n    }\n\n    override fun isManifestParsingEnabled() = super.isManifestParsingEnabled()\n\n    override fun registerComponents(context: Context, glide: Glide, registry: Registry) {\n    }\n}\n```\n\n可以看到，一共有三个方法可以进行重写，它们分别代表什么呢？\n\n### applyOptions\n\napplyOptions 方法主要用于更改 Glide 默认配置，比如修改硬盘缓存路径、设置 Bitmap 的解码格式、设置 LRUCahce 大小甚至使用自定义 LRUCahce 实现或者自定义磁盘缓存实现等。下面将罗列一些常用的配置选项。\n\n#### \u003cstrong\u003e内存缓存（MemoryCache）\u003c/strong\u003e\n\nGlide 使用 LruResourceCache 作为 MemoryCache 接口的一个默认实现，使用固定大小的内存和 LRU 算法。LruResourceCache 的大小由 Glide 的 MemorySizeCalculator 类来决定，这个类主要关注设备的内存类型，设备 RAM 大小，以及屏幕分辨率。\n\n使用 applyOptions(Context, GlideBuilder) 方法配置 MemorySizeCalculator 可以自定义 MemoryCache 的大小：\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    val calculator = MemorySizeCalculator.Builder(context)\n        .setMemoryCacheScreens(2f)\n        .build()\n    builder.setMemoryCache(LruResourceCache(calculator.memoryCacheSize.toLong()))\n}\n```\n\n也可以直接覆写缓存大小：\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    val memoryCacheSizeBytes = 1024 * 1024 * 20 // 20mb\n    builder.setMemoryCache(LruResourceCache(memoryCacheSizeBytes.toLong()))\n}\n```\n\n甚至可以提供自己的 MemoryCache 实现：\n\n```scala\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    builder.setMemoryCache(YourAppMemoryCacheImpl())\n}\n```\n\n#### \u003cstrong\u003eBitmapPool\u003c/strong\u003e\n\nGlide 使用 LruBitmapPool 作为默认的 BitmapPool 。LruBitmapPool 是一个内存中的固定大小的 BitmapPool，使用 LRU 算法清理。默认大小基于设备的分辨率和密度，同时也考虑内存类和 isLowRamDevice 的返回值。具体的计算通过 Glide 的 MemorySizeCalculator 来完成，与 Glide 的 MemoryCache 的大小检测方法相似。\n\n可以在 AppGlideModule 中定制 BitmapPool 的尺寸，使用 applyOptions(Context, GlideBuilder) 方法并配置 MemorySizeCalculator:\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    val calculator = MemorySizeCalculator.Builder(context)\n        .setBitmapPoolScreens(3f)\n        .build()\n    builder.setBitmapPool(LruBitmapPool(calculator.bitmapPoolSize.toLong()))\n}\n```\n\n也可以直接复写这个池的大小：\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    val bitmapPoolSizeBytes = 1024 * 1024 * 30 // 30mb\n    builder.setBitmapPool(LruBitmapPool(bitmapPoolSizeBytes.toLong()))\n}\n```\n\n当然也可以提供 BitmapPool 的完全自定义实现：\n\n```scala\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    builder.setBitmapPool(YourAppBitmapPoolImpl())\n}\n```\n\n#### \u003cstrong\u003e磁盘缓存（DiskCache）\u003c/strong\u003e\n\nGlide 使用 DiskLruCacheWrapper 作为默认的 磁盘缓存 。 DiskLruCacheWrapper 是一个使用 LRU 算法的固定大小的磁盘缓存。默认磁盘大小为 250 MB ，位置是在应用的缓存文件夹中的一个特定目录（\u003cem\u003e/data/data/{package}/cache/image_manager_disk_cache/\u003c/em\u003e） 。\n\n假如使用 Glide 展示图片内容是公开的，那么应用可以将这个缓存位置改到外部存储：\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    builder.setDiskCache(ExternalPreferredCacheDiskCacheFactory(context))\n}\n```\n\n无论使用内部或外部磁盘缓存，应用程序都可以改变磁盘缓存的大小：\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    val diskCacheSizeBytes = 1024 * 1024 * 100;  //100 MB\n    builder.setDiskCache(ExternalPreferredCacheDiskCacheFactory(context,\n         diskCacheSizeBytes.toLong()))\n}\n```\n\n还可以自己命名外存或内存上的缓存文件夹：\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    val diskCacheSizeBytes = 1024 * 1024 * 100;  //100 MB\n    builder.setDiskCache(InternalCacheDiskCacheFactory(context, \n        cacheFolderName, diskCacheSizeBytes.toLong()))\n}\n```\n\n此外，还可以自定义 DiskCache 接口的实现，并提供自己的 DiskCache.Factory 来创建缓存。Glide 使用一个工厂接口来在后台线程中打开磁盘缓存 ，这样方便缓存做诸如检查路径存在性等的 IO 操作而不用触发严格模式（StrictMode） 。\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    builder.setDiskCache(DiskCache.Factory { YourAppCustomDiskCache() })\n}\n```\n\n#### \u003cstrong\u003e默认请求选项（DefaultRequestOptions）\u003c/strong\u003e\n\n虽然 RequestOptions\u003cstrong\u003e \u003c/strong\u003e通常由每个请求单独指定，也可以通过 AppGlideModule 应用一个 RequestOptions 的集合以作用于每次请求，比如设置 Bitmap 的解码格式为 RGB_565 (默认为 ARGB_8888)：\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    builder.setDefaultRequestOptions(\n        RequestOptions()\n            .format(DecodeFormat.PREFER_RGB_565)\n            .disallowHardwareConfig()\n    )\n}\n```\n\n一旦创建了新的请求，这些选项将通过 GlideBuilder 中的 setDefaultRequestOptions 被应用上。因此，任何单独请求里应用的选项将覆盖 GlideBuilder 里设置的冲突选项。\n\n类似地，RequestManagers 允许你为这个特定的 RequestManager 启动的所有加载请求设置默认的 RequestOptions。 因为每个 Activity 和 Fragment 都拥有自己的 RequestManager，你可以使用 RequestManager 的 applyDefaultRequestOptions 方法来设置默认的 RequestOption，并仅作用于一个特定的 Activity 或 Fragment：\n\n```kotlin\nGlide.with(fragment)\n    .applyDefaultRequestOptions(\n        RequestOptions()\n            .format(DecodeFormat.PREFER_RGB_565)\n            .disallowHardwareConfig()\n    )\n```\n\nRequestManager 还有一个 setDefaultRequestOptions 方法，可以完全替换掉之前设置的任意的默认 RequestOptions，无论它是通过 AppGlideModule 的 [GlideBuilder] 还是 RequestManager。使用 [setDefaultRequestOptions] 要小心，因为很容易意外覆盖掉其他地方设置的重要默认选项。 通常 applyDefaultRequestOptions 更安全，使用起来更直观。\n\n#### \u003cstrong\u003e未捕获异常策略 (UncaughtThrowableStrategy)\u003c/strong\u003e\n\n在加载图片时假如发生了一个异常 (例如, OOM), Glide 将会使用一个 GlideExecutor.UncaughtThrowableStrategy 。\n\n默认策略是将异常打印到设备的 LogCat 中。 这个策略从 Glide 4.2.0 起将可被定制。 你可以传入一个 DiskCacheExecutor 和 / 或一个 SourceExecutor：\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    val myUncaughtThrowableStrategy = UncaughtThrowableStrategy.LOG\n    builder.setDiskCacheExecutor(GlideExecutor.newDiskCacheBuilder()\n        .setUncaughtThrowableStrategy { myUncaughtThrowableStrategy }\n        .build())\n    builder.setSourceExecutor(GlideExecutor.newSourceBuilder()\n        .setUncaughtThrowableStrategy { myUncaughtThrowableStrategy }\n        .build())\n}\n```\n\n#### \u003cstrong\u003e日志级别（LogLevel ）\u003c/strong\u003e\n\n可以使用 setLogLevel (结合 Android 的 Log 定义的值) 来获取格式化日志的子集，包括请求失败时的日志行。通常来说 Log.VERBOSE 粒度太细，而 Log.ERROR 又会让日志更趋向静默。\n\n```kotlin\noverride fun applyOptions(context: Context, builder: GlideBuilder) {\n    builder.setLogLevel(Log.DEBUG)\n}\n```\n\n所有的配置选项如下\n\n| 方法                                | 作用 |\n| ----------------------------------- | ---- |\n| setBitmapPool                       |      |\n| setArrayPool                        |      |\n| setMemoryCache                      |      |\n| setDiskCache                        |      |\n| setResizeExecutor                   |      |\n| setSourceExecutor                   |      |\n| setDiskCacheExecutor                |      |\n| setAnimationExecutor                |      |\n| setDefaultRequestOptions            |      |\n| setDefaultTransitionOptions         |      |\n| setMemorySizeCalculator             |      |\n| setConnectivityMonitorFactory       |      |\n| setLogLevel                         |      |\n| setIsActiveResourceRetentionAllowed |      |\n| addGlobalRequestListener            |      |\n| setLogRequestOrigins                |      |\n| setImageDecoderEnabledForBitmaps    |      |\n\n### isManifestParsingEnabled\n\n在 Glide v3 中，使用自定义模块需要在 AndroidManifest.xml 文件中通过 meta-data 进行配置：\n\n```xml\n\u003capplication\n    ...\u003e\n\n    \u003cmeta-data\n        android:name=\"xxx.xxx.MyGlideModule\"\n        android:value=\"GlideModule\" /\u003e\n\n    \u003cactivity ... /\u003e\n\u003c/application\u003e\n```\n\nMyGlideModule 代码如下：\n\n```kotlin\nclass MyGlideModule : GlideModule {\n   override fun applyOptions(context: Context, builder: GlideBuilder) {\n       ...\n   }\n   \n   override fun registerComponents(context: Context, glide: Glide, registry: Registry) {\n       ...\n   }\n}\n```\n\n为了维持对 Glide v3 的 GlideModules 的向后兼容性，Glide 仍然会解析应用程序和所有被包含的库中的 AndroidManifest.xml 文件，并包含在这些清单中列出的旧 GlideModules 模块类。\n\n如果你已经迁移到 Glide v4 的 AppGlideModule 和 LibraryGlideModule ，你可以完全禁用清单解析。这样可以改善 Glide 的初始启动时间，并避免尝试解析元数据时的一些潜在问题。要禁用清单解析，可以在 AppGlideModule 实现中复写 isManifestParsingEnabled() 方法：\n\n```kotlin\noverride fun isManifestParsingEnabled() = false\n```\n\n### registerComponents\n\n应用程序和库都可以注册很多组件来扩展 Glide 的功能。可用的组件包括：\n\n1. ModelLoader, 用于加载自定义的 Model(Url, Uri,任意的 POJO ) 和 Data(InputStreams, FileDescriptors)。\n2. ResourceDecoder, 用于对新的 Resources(Drawables, Bitmaps) 或新的 Data 类型 (InputStreams, FileDescriptors) 进行解码。\n3. Encoder, 用于向 Glide 的磁盘缓存写 Data (InputStreams, FileDesciptors)。\n4. ResourceTranscoder，用于在不同的资源类型之间做转换，例如，从 BitmapResource 转换为 DrawableResource 。\n5. ResourceEncoder，用于向 Glide 的磁盘缓存写 Resources(BitmapResource, DrawableResource)。\n\n组件通过 Registry 类来注册。例如，添加一个 ModelLoader ，使其能从自定义的 Model 对象中创建一个 InputStream ：\n\n```kotlin\noverride fun registerComponents(context: Context, glide: Glide, registry: Registry) {\n    registry.append(Photo::class.java, InputStream::class.java, Factory())\n}\n```\n\n在一个 GlideModule 里可以注册很多组件。ModelLoader 和 ResourceDecoder 对于同样的参数类型还可以有多种实现。\n\n在前文的分析中知道了，Glide 加载网络图片默认使用的是 HttpUrlConnection，如果想把这个位置的实现替换成 OkHttp3 或者 Volley 实现可以吗？显然是可以的，而且官方也提供了这个功能：\n\n- [OkHttp3](http://bumptech.github.io/glide/int/okhttp3.html)\n- [Volley](http://bumptech.github.io/glide/int/volley.html)\n\n以 OkHttp3 为例，用起来很简单，只需要集成一个 library 即可，非常符合 Glide 的风格。build.gradle 的配置如下：\n\n```groovy\nimplementation \"com.github.bumptech.glide:okhttp3-integration:4.12.0\"\n```\n\n首先找到里面的 @GlideModule 修饰的类，而且应该是一个 LibraryGlideModule 类：\n\n```scala\n@GlideModule\npublic final class OkHttpLibraryGlideModule extends LibraryGlideModule {\n  @Override\n  public void registerComponents(@NonNull Context context, @NonNull Glide glide,\n      @NonNull Registry registry) {\n    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());\n  }\n}\n```\n\n此外，里面还发现了一个实现了 com.bumptech.glide.module.GlideModule 接口的废弃类 OkHttpGlideModule：\n\n```java\n@Deprecated\npublic class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {\n  @Override\n  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {\n    // Do nothing.\n  }\n\n  @Override\n  public void registerComponents(Context context, Glide glide, Registry registry) {\n    registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());\n  }\n}\n```\n\n由于我们使用的 Glide 版本为 4.x，使用了上面的 OkHttpLibraryGlideModule 并且无需在 AndroidManifest.xml 中配置，自然也用不到这个类。\n\n回到 OkHttpLibraryGlideModule 类中，看看 registerComponents 方法的实现：\n\n```java\nregistry.replace(GlideUrl.class, InputStream.class,\n     new OkHttpUrlLoader.Factory());\n```\n\n对于此项，Glide 的默认配置中有如下代码：\n\n```java\n.append(GlideUrl.class, InputStream.class, \n        new HttpGlideUrlLoader.Factory())\n```\n\n所以可以理解为，原本交给 HttpGlideUrlLoader.Factory() 处理的任务会交给 OkHttpUrlLoader.Factory() 处理。\n\n\u003cstrong\u003eOkHttpUrlLoader\u003c/strong\u003e 源码如下：\n\n```java\npublic class OkHttpUrlLoader implements ModelLoader\u003cGlideUrl, InputStream\u003e {\n\n  private final Call.Factory client;\n\n  // Public API.\n  @SuppressWarnings(\"WeakerAccess\")\n  public OkHttpUrlLoader(@NonNull Call.Factory client) {\n    this.client = client;\n  }\n\n  @Override\n  public boolean handles(@NonNull GlideUrl url) {\n    return true;\n  }\n\n  @Override\n  public LoadData\u003cInputStream\u003e buildLoadData(\n      @NonNull GlideUrl model, int width, int height, @NonNull Options options) {\n    return new LoadData\u003c\u003e(model, new OkHttpStreamFetcher(client, model));\n  }\n\n  /** The default factory for {@link OkHttpUrlLoader}s. */\n  // Public API.\n  @SuppressWarnings(\"WeakerAccess\")\n  public static class Factory implements ModelLoaderFactory\u003cGlideUrl, InputStream\u003e {\n    private static volatile Call.Factory internalClient;\n    private final Call.Factory client;\n\n    private static Call.Factory getInternalClient() {\n      if (internalClient == null) {\n        synchronized (Factory.class) {\n          if (internalClient == null) {\n            internalClient = new OkHttpClient();\n          }\n        }\n      }\n      return internalClient;\n    }\n\n    /** Constructor for a new Factory that runs requests using a static singleton client. */\n    public Factory() {\n      this(getInternalClient());\n    }\n\n    /**\n     * Constructor for a new Factory that runs requests using given client.\n     *\n     * @param client this is typically an instance of {@code OkHttpClient}.\n     */\n    public Factory(@NonNull Call.Factory client) {\n      this.client = client;\n    }\n\n    @NonNull\n    @Override\n    public ModelLoader\u003cGlideUrl, InputStream\u003e build(MultiModelLoaderFactory multiFactory) {\n      return new OkHttpUrlLoader(client);\n    }\n\n    @Override\n    public void teardown() {\n      // Do nothing, this instance doesn't own the client.\n    }\n  }\n}\n```\n\n可以看到，OkHttpUrlLoader.Factory 的无参构造器会使用 DCL 单例模式创建一个 OkHttpClient() 对象，其 build 方法会返回一个 new OkHttpUrlLoader(client)。\n\nOkHttpUrlLoader.buildLoadData 方法会返回一个 fetcher 为 \u003cstrong\u003eOkHttpStreamFetcher\u003c/strong\u003e 的 LoadData。当需要进行加载的时候，会调用 fetcher 的 loadData 方法：\n\n```java\n@Override\npublic void loadData(@NonNull Priority priority,\n    @NonNull final DataCallback\u003c? super InputStream\u003e callback) {\n    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());\n    for (Map.Entry\u003cString, String\u003e headerEntry : url.getHeaders().entrySet()) {\n        String key = headerEntry.getKey();\n        requestBuilder.addHeader(key, headerEntry.getValue());\n    }\n    Request request = requestBuilder.build();\n    this.callback = callback;\n\n    call = client.newCall(request);\n    call.enqueue(this);\n}\n\n@Override\npublic void onFailure(@NonNull Call call, @NonNull IOException e) {\n    if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"OkHttp failed to obtain result\", e);\n    }\n\n    callback.onLoadFailed(e);\n}\n\n@Override\npublic void onResponse(@NonNull Call call, @NonNull Response response) {\n    responseBody = response.body();\n    if (response.isSuccessful()) {\n        long contentLength = Preconditions.checkNotNull(responseBody).contentLength();\n        stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);\n        callback.onDataReady(stream);\n    } else {\n        callback.onLoadFailed(new HttpException(response.message(), response.code()));\n    }\n}\n```\n\nOkHttpStreamFetcher 的实现比 HttpUrlFetcher 简单多了，而且看起来也没有什么难度。\n\n如果我们想使用 App 现有的 OkHttpClient 而不是默认创建一个新的，我们可以先 @Excludes 掉 OkHttpLibraryGlideModule；然后在 replace 的同时，在 OkHttpUrlLoader.Factory(Call.Factory) 构造时注入现有的 OkHttpClient：\n\n```kotlin\n@GlideModule\n@Excludes(value = [OkHttpLibraryGlideModule::class, MyLibraryGlideModule::class, MyGlideModule::class])\nclass MyAppGlideModule : AppGlideModule() {\n    override fun applyOptions(context: Context, builder: GlideBuilder) {\n        builder.setDiskCache(ExternalPreferredCacheDiskCacheFactory(context))\n    }\n\n    override fun registerComponents(context: Context, glide: Glide, registry: Registry) {\n        val okHttpClient = OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(30, TimeUnit.SECONDS)\n            .writeTimeout(30, TimeUnit.SECONDS)\n            .addNetworkInterceptor(\n                HttpLoggingInterceptor {\n                    Log.i(\"MyAppGlideModule\", it)\n                }.apply {\n                    level = HttpLoggingInterceptor.Level.BODY\n                }\n            ).build()\n\n        registry.replace(GlideUrl::class.java, InputStream::class.java,\n             OkHttpUrlLoader.Factory(okHttpClient))\n    }\n}\n```\n\n## 原理\n\n### Glide 初始化流程分析\n\n之前在分析 [Glide 加载流程](https://ywue4d2ujm.feishu.cn/docs/doccnY69t6P4JXuanj2oz8GBp5g) 的文章中已经知道，with 方法调用过程中会调用到 Glide.get(context) 方法生成并返回全局 Glide 单例：\n\n```java\npublic static Glide get(@NonNull Context context) {\n  if (glide == null) {\n    // 如果有配置 @GlideModule 注解的 Module\n    // 这里会反射构造 kapt 生成的 GeneratedAppGlideModuleImpl 类\n    GeneratedAppGlideModule annotationGeneratedModule =\n        getAnnotationGeneratedGlideModules(context.getApplicationContext());\n    synchronized (Glide.class) {\n      if (glide == null) {\n        checkAndInitializeGlide(context, annotationGeneratedModule);\n      }\n    }\n  }\n\n  return glide;\n}\n\n\n@GuardedBy(\"Glide.class\")\nprivate static void checkAndInitializeGlide(@NonNull Context context, @Nullable GeneratedAppGlideModule generatedAppGlideModule) {\n    if (isInitializing) {\n        throw new IllegalStateException(\"You cannot call Glide.get() in registerComponents(), use the provided Glide instance instead\");\n    } else {\n        isInitializing = true;\n        initializeGlide(context, generatedAppGlideModule);\n        isInitializing = false;\n    }\n}\n\nprivate static void initializeGlide(@NonNull Context context) {\n  initializeGlide(context, new GlideBuilder());\n}\n\nprivate static void initializeGlide(\n    @NonNull Context context,\n    @NonNull GlideBuilder builder,\n    @Nullable GeneratedAppGlideModule annotationGeneratedModule) {\n  Context applicationContext = context.getApplicationContext();\n  // 如果 GeneratedAppGlideModuleImpl 存在，且允许解析 manifest 文件\n  // 则遍历 manifest 中的 meta-data，解析出所有的 GlideModule 类\n  List\u003ccom.bumptech.glide.module.GlideModule\u003e manifestModules = Collections.emptyList();\n  if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) {\n    manifestModules = new ManifestParser(applicationContext).parse();\n  }\n\n  // 根据 Impl 的排除名单，剔除 manifest 中的 GlideModule 类\n  if (annotationGeneratedModule != null\n      \u0026\u0026 !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) {\n    Set\u003cClass\u003c?\u003e\u003e excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses();\n    Iterator\u003ccom.bumptech.glide.module.GlideModule\u003e iterator = manifestModules.iterator();\n    while (iterator.hasNext()) {\n      com.bumptech.glide.module.GlideModule current = iterator.next();\n      if (!excludedModuleClasses.contains(current.getClass())) {\n        continue;\n      }\n      if (Log.isLoggable(TAG, Log.DEBUG)) {\n        Log.d(TAG, \"AppGlideModule excludes manifest GlideModule: \" + current);\n      }\n      iterator.remove();\n    }\n  }\n\n  if (Log.isLoggable(TAG, Log.DEBUG)) {\n    for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) {\n      Log.d(TAG, \"Discovered GlideModule from manifest: \" + glideModule.getClass());\n    }\n  }\n\n  // 如果 Impl 存在，那么设置为该类的 RequestManagerFactory；否则设置为 null\n  RequestManagerRetriever.RequestManagerFactory factory =\n      annotationGeneratedModule != null\n          ? annotationGeneratedModule.getRequestManagerFactory()\n          : null;\n  builder.setRequestManagerFactory(factory);\n  // 依次调用 manifest 中 GlideModule 类的 applyOptions 方法，将配置写到 builder 里\n  for (com.bumptech.glide.module.GlideModule module : manifestModules) {\n    module.applyOptions(applicationContext, builder);\n  }\n  // 写入 Impl 的配置\n  // 也就是说 Impl 配置的优先级更高，如果有冲突的话\n  if (annotationGeneratedModule != null) {\n    annotationGeneratedModule.applyOptions(applicationContext, builder);\n  }\n  // 调用GlideBuilder.build方法创建 Glide\n  Glide glide = builder.build(applicationContext);\n  // 依次调用 manifest 中 GlideModule 类的 registerComponents 方法\n  // 来替换 Glide 的默认配置\n  for (com.bumptech.glide.module.GlideModule module : manifestModules) {\n    try {\n      module.registerComponents(applicationContext, glide, glide.registry);\n    } catch (AbstractMethodError e) {\n      throw new IllegalStateException(\n          \"Attempting to register a Glide v3 module. If you see this, you or one of your\"\n              + \" dependencies may be including Glide v3 even though you're using Glide v4.\"\n              + \" You'll need to find and remove (or update) the offending dependency.\"\n              + \" The v3 module name is: \"\n              + module.getClass().getName(),\n          e);\n    }\n  }\n  // 调用 Impl 中替换 Glide 配置的方法\n  if (annotationGeneratedModule != null) {\n    annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);\n  }\n  // 注册内存管理的回调，因为 Glide 实现了 ComponentCallbacks2 接口\n  applicationContext.registerComponentCallbacks(glide);\n  // 保存 glide 实例到静态变量中\n  Glide.glide = glide;\n}\n```\n\n可以看到，这里首先会调用 getAnnotationGeneratedGlideModules() 方法反射构造出注解处理器生成的 GeneratedAppGlideModuleImpl 对象。\n\n接着，Glide 的创建（line 84）发生在 applyOptions 之后，registerComponents 之前。也好理解，因为 applyOptions 是更改配置，肯定是初始化时就要确定的；而 registerComponents 针对的运行时的功能扩展，而且需要调用 Glide 对象的方法，所以在 Glide 创建之后调用。\n\n看看 GlideBuilder.build 方法：\n\n```java\n@NonNull\nGlide build(@NonNull Context context) {\n  if (sourceExecutor == null) {\n    sourceExecutor = GlideExecutor.newSourceExecutor();\n  }\n\n  if (diskCacheExecutor == null) {\n    diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();\n  }\n\n  if (animationExecutor == null) {\n    animationExecutor = GlideExecutor.newAnimationExecutor();\n  }\n\n  if (memorySizeCalculator == null) {\n    memorySizeCalculator = new MemorySizeCalculator.Builder(context).build();\n  }\n\n  if (connectivityMonitorFactory == null) {\n    connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();\n  }\n\n  if (bitmapPool == null) {\n    int size = memorySizeCalculator.getBitmapPoolSize();\n    if (size \u003e 0) {\n      bitmapPool = new LruBitmapPool(size);\n    } else {\n      bitmapPool = new BitmapPoolAdapter();\n    }\n  }\n\n  if (arrayPool == null) {\n    arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());\n  }\n\n  if (memoryCache == null) {\n    memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());\n  }\n\n  if (diskCacheFactory == null) {\n    diskCacheFactory = new InternalCacheDiskCacheFactory(context);\n  }\n\n  if (engine == null) {\n    engine =\n        new Engine(\n            memoryCache,\n            diskCacheFactory,\n            diskCacheExecutor,\n            sourceExecutor,\n            GlideExecutor.newUnlimitedSourceExecutor(),\n            animationExecutor,\n            isActiveResourceRetentionAllowed);\n  }\n\n  if (defaultRequestListeners == null) {\n    defaultRequestListeners = Collections.emptyList();\n  } else {\n    defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);\n  }\n\n  GlideExperiments experiments = glideExperimentsBuilder.build();\n  RequestManagerRetriever requestManagerRetriever =\n      new RequestManagerRetriever(requestManagerFactory, experiments);\n\n  return new Glide(\n      context,\n      engine,\n      memoryCache,\n      bitmapPool,\n      arrayPool,\n      requestManagerRetriever,\n      connectivityMonitorFactory,\n      logLevel,\n      defaultRequestOptionsFactory,\n      defaultTransitionOptions,\n      defaultRequestListeners,\n      experiments);\n}\n```\n\n可以看到，build 方法基本对每一个参数都进行了 null 判断，如果为 null 则使用默认的参数。那么，这些参数什么时候不为空呢？当在 AppliesOptions 接口的实现（即前面所说的 applyOptions 方法）中通过传入参数 GlideBuilder 设置后，这里 build 时就不会为 null 了。\n\n比如，前面举例的通过 GlideBuilder.setDiskCache 来将 diskCacheFactory 设置为我们指定的值，从而将磁盘缓存位置切换到 externalCacheDir 中。\n\n```kotlin\n@GlideModule\nclass MyAppGlideModule : AppGlideModule() {\n    override fun applyOptions(context: Context, builder: GlideBuilder) {\n        builder.setDiskCache(ExternalPreferredCacheDiskCacheFactory(context))\n    }\n}\n```\n\n### kapt 生成文件过程分析\n\n为了更好地理解 Glide 中 annotation processor 的作用，这里分别实现 AppGlideModule、LibraryGlideModule 以及 GlideModule ：\n\n```kotlin\n@GlideModule\n@Excludes(value = [MyGlideModule::class])\nclass MyAppGlideModule : AppGlideModule()\n\n@GlideModule\nclass MyLibraryGlideModule : LibraryGlideModule()\n\nclass MyGlideModule : GlideModule {\n    override fun applyOptions(context: Context, builder: GlideBuilder) {}\n\n    override fun registerComponents(context: Context, glide: Glide, registry: Registry) {}\n}\n```\n\n在 AndroidManifest 文件中配置好 MyGlideModule 之后，我们先 rebuild 一下，看一下生成的 GeneratedAppGlideModuleImpl 文件：\n\n```java\n@SuppressWarnings(\"deprecation\")\nfinal class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule {\n  private final MyAppGlideModule appGlideModule;\n\n  public GeneratedAppGlideModuleImpl(Context context) {\n    appGlideModule = new MyAppGlideModule();\n    if (Log.isLoggable(\"Glide\", Log.DEBUG)) {\n      Log.d(\"Glide\", \"Discovered AppGlideModule from annotation: com.me.guanpj.myapplication.MyAppGlideModule\");\n      Log.d(\"Glide\", \"Discovered LibraryGlideModule from annotation: com.me.guanpj.myapplication.MyLibraryGlideModule\");\n    }\n  }\n\n  @Override\n  public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) {\n    appGlideModule.applyOptions(context, builder);\n  }\n\n  @Override\n  public void registerComponents(@NonNull Context context, @NonNull Glide glide,\n      @NonNull Registry registry) {\n    new MyLibraryGlideModule().registerComponents(context, glide, registry);\n    appGlideModule.registerComponents(context, glide, registry);\n  }\n\n  @Override\n  public boolean isManifestParsingEnabled() {\n    return appGlideModule.isManifestParsingEnabled();\n  }\n\n  @Override\n  @NonNull\n  public Set\u003cClass\u003c?\u003e\u003e getExcludedModuleClasses() {\n    Set\u003cClass\u003c?\u003e\u003e excludedClasses = new HashSet\u003cClass\u003c?\u003e\u003e();\n    excludedClasses.add(com.me.guanpj.myapplication.MyGlideModule.class);\n    return excludedClasses;\n  }\n\n  @Override\n  @NonNull\n  GeneratedRequestManagerFactory getRequestManagerFactory() {\n    return new GeneratedRequestManagerFactory();\n  }\n}\n```\n\n代码很简单，属于 AppGlideModule 的三个方法基本都调用了 MyAppGlideModule 的三个配置方法。在此基础上，每个 LibraryGlideModule 的 registerComponents 方法都会在 GeneratedAppGlideModuleImpl.registerComponents 方法中被调用。\n\n另外，我们关注一下最后两个方法，这两个方法都是基类 GeneratedAppGlideModule 额外提供了的，代码如下所示：\n\n```java\nabstract class GeneratedAppGlideModule extends AppGlideModule {\n  /**\n   * This method can be removed when manifest parsing is no longer supported.\n   */\n  @NonNull\n  abstract Set\u003cClass\u003c?\u003e\u003e getExcludedModuleClasses();\n\n  @Nullable\n  RequestManagerRetriever.RequestManagerFactory getRequestManagerFactory() {\n    return null;\n  }\n}\n```\n\ngetRequestManagerFactory 在子类的实现是固定的，就是 return new GeneratedRequestManagerFactory()。\n\n#### @Excludes\n\nGeneratedAppGlideModuleImpl.getExcludedModuleClasses() 的实现，与 @Excludes 注解有关，使用该注解可以让 Glide 忽略指定的 GlideModule 或 LibraryGlideModule。@Excludes 注解只能用在 AppGlideModules 上，下面的例子将会让 Glide 忽略掉 MyLibraryGlideModule、MyGlideModule 的配置：\n\n```scala\n@GlideModule\n@Excludes(value = [MyLibraryGlideModule::class, MyGlideModule::class])\nclass MyAppGlideModule : AppGlideModule()\n```\n\n此时 rebuild 之后，生成的 GeneratedAppGlideModuleImpl 文件的相关方法如下：\n\n```typescript\n@Override\npublic void registerComponents(@NonNull Context context, @NonNull Glide glide,\n    @NonNull Registry registry) {\n    // 注意，没有new MyLibraryGlideModule().registerComponents(context, glide, registry);了\n    appGlideModule.registerComponents(context, glide, registry);\n}\n\n@Override\n@NonNull\npublic Set\u003cClass\u003c?\u003e\u003e getExcludedModuleClasses() {\n    Set\u003cClass\u003c?\u003e\u003e excludedClasses = new HashSet\u003cClass\u003c?\u003e\u003e();\n    excludedClasses.add(com.me.guanpj.myapplication.MyGlideModule.class);\n    excludedClasses.add(com.me.guanpj.myapplication. MyLibraryGlideModule.class);\n    return excludedClasses;\n}\n```\n\n然后在 Glide 初始化的时候，在方法返回结果 set 里面的 GlideModule 将会从集合中移除。\n\n#### @GlideExtension\n\n@GlideExtension 注解修饰的类可以扩展 Glide 的 API。该类必须是工具类的形式，里面的方法必须都是静态的，除了私有的空实现的构造器。\n\nApplication 可以实现多个 @GlideExtension 注解类，Library 也可以实现任意数量的 @GlideExtension 注解类。Glide 在编译时，一旦发现一个 AppGlideModule，所有可用的 GlideExtension 都会合并，并生成单个的 API 文件。任何冲突都会导致 Glide 注解生成器的编译错误。\n\nGlideExtension 注解类可以定义两种扩展方法：\n\n1. @GlideOption——为 RequestOptions 添加自定义的配置，扩展 RequestOptions 的静态方法。常见作用有：\n2. 定义在整个应用程序中经常使用的一组选项\n3. 添加新选项，通常与 Glide 的 com.bumptech.glide.load.Option 一起使用。\n4. @GlideType——为新资源类型（GIFs、SVG 等）添加支持，扩展 RequestManager 的静态方法\n\n下面的示例来自于官方文档 GlideExtension 的示例：\n\n```kotlin\n@GlideExtension\nobject MyAppExtension {\n    // Size of mini thumb in pixels.\n    private const val MINI_THUMB_SIZE = 100\n\n    private val DECODE_TYPE_GIF = RequestOptions.decodeTypeOf(GifDrawable::class.java).lock()\n\n    @GlideOption\n    @JvmStatic\n    fun miniThumb(options: BaseRequestOptions\u003c*\u003e): BaseRequestOptions\u003c*\u003e {\n        return options\n            .fitCenter()\n            .override(MINI_THUMB_SIZE)\n    }\n\n    @GlideType(GifDrawable::class)\n    @JvmStatic\n    fun asGifTest(requestBuilder: RequestBuilder\u003cGifDrawable\u003e): RequestBuilder\u003cGifDrawable\u003e {\n        return requestBuilder\n            .transition(DrawableTransitionOptions())\n            .apply(DECODE_TYPE_GIF)\n    }\n}\n```\n\n这里为 RequestOptions 扩展了 miniThumb 方法，为 RequestManager 扩展了 asGifTest 方法。所以我们可以这样使用：\n\n```kotlin\nGlideApp.with(this)\n    .asGifTest()\n    .load(URL)\n    .miniThumb()\n    .into(ivGlide1)\n```\n\n注意这里使用的不再是 Glide，而是 GlideApp。GlideApp 是专门用来处理这种扩展 API 的。\n\n在 Glide 初始化的时候，会将 GeneratedAppGlideModuleImpl.getRequestManagerFactory() 方法返回的 GeneratedRequestManagerFactory 作为 requestManagerFactory 参数，这样创建 RequestManager 时都会调用 GeneratedRequestManagerFactory.build 方法生成 GlideRequests。\n\n\u003cstrong\u003eGlideRequests\u003c/strong\u003e 继承至 RequestManager，里面包含了 @GlideType 注解修饰的 API：\n\n```java\npublic class GlideRequests extends RequestManager {\n  public GlideRequests(@NonNull Glide glide, @NonNull Lifecycle lifecycle,\n                       @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) {\n    super(glide, lifecycle, treeNode, context);\n  }\n  ...\n  /**\n   * @see MyAppExtension#asGifTest(RequestBuilder)\n   */\n  @NonNull\n  @CheckResult\n  public GlideRequest\u003cGifDrawable\u003e asGifTest() {\n    return (GlideRequest\u003cGifDrawable\u003e) MyAppExtension.asGifTest(this.as(GifDrawable.class));\n  }\n  ...\n}\n```\n\n\u003cstrong\u003eGlideRequest（注意没有 s）\u003c/strong\u003e 则继承至 RequestBuilder，包含了 @GlideOption 提供的 API：\n\n```scala\npublic class GlideRequest\u003cTranscodeType\u003e extends RequestBuilder\u003cTranscodeType\u003e implements Cloneable {\n  /**\n   * @see MyAppExtension#miniThumb(BaseRequestOptions)\n   */\n  @SuppressWarnings(\"unchecked\")\n  @CheckResult\n  @NonNull\n  public GlideRequest\u003cTranscodeType\u003e miniThumb() {\n    return (GlideRequest\u003cTranscodeType\u003e) MyAppExtension.miniThumb(this);\n  }\n}\n```\n\n此外，如果需要使用到 RequestOptions，要使用 Generated API 生成的 GlideOptions。\n\n总的来说，如果想使用 Generated API，注意一下三个类的关系\n\n- RequestManager -\u003e GlideRequests\n- RequestBuilder -\u003e GlideRequest\n- RequestOptions -\u003e GlideOptions\n\n## 实战分析","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["Glide","源码解析"]},"/HTTP-%E5%9F%BA%E7%A1%80":{"title":"HTTP 基础","content":"# 什么是 HTTP ？\n\nHypertext Transfer Protocol，超文本传输协议，和 HTML (Hypertext Markup Language 超文本标记语言) 一起诞生，用于在网络上请求和传输 HTML 内容。\n\n超文本，即「扩展型文本」，指的是 HTML 中可以有链向别的文本的链接 (hyperlink)。\n\n# HTTP 报文格式\n\n请求报文格式：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Http/clipboard_20230323_031410.png)\n\n响应报文格式：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Http/clipboard_20230323_031414.png)\n\n# Request Method \u003cstrong\u003e请求方法 \u003c/strong\u003e\n\n## GET\n\n- 用于获取资源\n- 对服务器数据不进行修改\n- 不发送 Body\n\n```plain text\nGET  /users/1  HTTP/1.1\nHost: api.github.com\n```\n\n对应 Retrofit 的代码：\n\n```java\n@GET(\"/users/{id}\")\nCall\u003cUser\u003e getUser(@Path(\"id\") String id, \n                  @Query(\"gender\") String gender);\n```\n\n## POST\n\n- 用于增加或修改资源\n- 发送给服务器的内容写在 Body 里面\n\n```plain text\nPOST  /users  HTTP/1.1\nHost: api.github.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 13\nname=guanpj\u0026gender=male\n```\n\n对应 Retrofit 的代码：\n\n```java\n@FormUrlEncoded\n@POST(\"/users\")\nCall\u003cUser\u003e addUser(@Field(\"name\") String name, \n                  @Field(\"gender\") String gender);\n```\n\n## PUT\n\n- 用于修改资源\n- 发送给服务器的内容写在 Body 里面\n\n```plain text\nPUT  /users/1  HTTP/1.1\nHost: api.github.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 13\ngender=female\n```\n\n对应 Retrofit 的代码：\n\n```java\n@FormUrlEncoded\n@PUT(\"/users/{id}\")\nCall\u003cUser\u003e updateGender(@Path(\"id\") String id,\n                        @Field(\"gender\") String gender);\n```\n\n## DELETE\n\n- 用于删除资源\n- 不发送 Body\n\n```plain text\nDELETE  /users/1  HTTP/1.1\nHost: api.github.com\n```\n\n对应 Retrofit 的代码：\n\n```java\n@DELETE(\"/users/{id}\")\nCall\u003cUser\u003e getUser(@Path(\"id\") String id,\n                  @Query(\"gender\") String gender);\n```\n\n## HEAD\n\n- 和 GET 使用方法完全相同\n- 和 GET 唯一区别在于，返回的响应中没有 Body\n\n# Status Code \u003cstrong\u003e状态码\u003c/strong\u003e\n\n三位数字，用于对响应结果做出类型化描述(如「获取成功」「内容未找到」)。\n\n- 1xx:临时性消息。如:100 (继续发送)、101(正在切换协议)\n- 2xx:成功。最典型的是 200(OK)、201(创建成功)。\n- 3xx:重定向。如 301(永久移动)、302(暂时移动)、304(内容未改变)。\n- 4xx:客户端错误。如 400(客户端请求错误)、401(认证失败)、403(被禁 止)、404(找不到内容)。\n- 5xx:服务器错误。如 500(服务器内部错误)。\n\n# Header \u003cstrong\u003e首部\u003c/strong\u003e\n\n作用：HTTP 消息的 metadata（即原数据）。\n\n## Host\n\n目标主机。注意:不是在网络上用于寻址的，而是在目标服务器上用于定位子服务\n\n器的。\n\n## Content-Type\n\n指定 Body 的类型。主要有四类:\n\n### text/html\n\n请求 Web ⻚面是返回响应的类型，Body 中返回 html 文本。格式如下:\n\n```plain text\nHTTP/1.1 200 OK\nContent-Type: text/html; charset=utf-8\nContent-Length: 853\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"utf-8\"\u003e\n......\n```\n\n### x-www-form-urlencoded\n\nWeb ⻚面纯文本表单的提交方式。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Http/clipboard_20230323_031421.png)\n\n格式如下:\n\n```plain text\nPOST  /users  HTTP/1.1\nHost: api.github.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 27\nname=guanpj\u0026gender=male\n```\n\n对应 Retrofit 的代码：\n\n```java\n@FormUrlEncoded\n@POST(\"/users\")\nCall\u003cUser\u003e addUser(@Field(\"name\") String name,\n@Field(\"gender\") String gender);\n```\n\n### multipart/form-data\n\nWeb ⻚面含有二进制文件时的提交方式。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Http/clipboard_20230323_031424.png)\n\n格式如下:\n\n```plain text\nPOST  /users  HTTP/1.1\nHost: guanpj.me.com\nContent-Type: multipart/form-data; boundary=----\nWebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Length: 2382\n------WebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"name\"\nguanpj\n------WebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"avatar\";\nfilename=\"avatar.jpg\"\nContent-Type: image/jpeg\nJFIFHHvOwX9jximQrWa......\n------WebKitFormBoundary7MA4YWxkTrZu0gW--\n```\n\n对应 Retrofit 的代码:\n\n```java\n@Multipart\n@POST(\"/users\")\nCall\u003cUser\u003e addUser(@Part(\"name\") RequestBody name,\n@Part(\"avatar\") RequestBody avatar);\n...\nRequestBody namePart =\nRequestBody.create(MediaType.parse(\"text/plain\"), nameStr);\nRequestBody avatarPart =\nRequestBody.create(MediaType.parse(\"image/jpeg\"), avatarFile);\napi.addUser(namePart, avatarPart);\n```\n\n### application/json , image/jpeg , application/zip ...\n\n单项内容(文本或非文本都可以)，用于 Web Api 的响应或者 POST / PUT 的请求\n\n\u003cstrong\u003e请求中提交 JSON\u003c/strong\u003e\n\n```plain text\nPOST /users HTTP/1.1\nHost: hencoder.com\nContent-Type: application/json; charset=utf-8\nContent-Length: 38\n{\"name\":\"guanpj\",\"gender\":\"male\"}\n```\n\n对应 Retrofit 的代码:\n\n```java\n@POST(\"/users\")\nCall\u003cUser\u003e addUser(@Body(\"user\") User user);\n...\n// 需要使用 JSON 相关的 Converter \napi.addUser(user);\n```\n\n\u003cstrong\u003e响应中返回 JSON\u003c/strong\u003e\n\n```plain text\nHTTP/1.1 200 OK\ncontent-type: application/json; charset=utf-8\ncontent-length: 234\n[{\"login\":\"mojombo\",\"id\":1,\"node_id\":\"MDQ6VXNl\ncjE=\",\"avatar_url\":\"https://avatars0.githubuse\nrcontent.com/u/1?v=4\",\"gravat......\n```\n\n\u003cstrong\u003e请求中提交二进制内容\u003c/strong\u003e\n\n```plain text\nPOST /user/1/avatar HTTP/1.1\nHost: hencoder.com\nContent-Type: image/jpeg\nContent-Length: 1575\nJFIFHH9......\n```\n\n对应 Retrofit 的代码:\n\n```java\n@POST(\"users/{id}/avatar\")\nCall\u003cUser\u003e updateAvatar(@Path(\"id\") String id, @Body\nRequestBody avatar);\n...\nRequestBody avatarBody =\nRequestBody.create(MediaType.parse(\"image/jpeg\"),\navatarFile);\napi.updateAvatar(id, avatarBody)\n```\n\n\u003cstrong\u003e响应中返回二进制内容\u003c/strong\u003e\n\n```plain text\nHTTP/1.1 200 OK\ncontent-type: image/jpeg\ncontent-length: 1575\nJFIFHH9......\nContent-Length\n```\n\n指定 Body 的⻓度(字节)。\n\n## Transfer: chunked (\u003cstrong\u003e分块传输编码\u003c/strong\u003e)\n\n用于当响应发起时，内容⻓度还没能确定的情况下。和 Content-Length 不同时使 用。用途是尽早给出响应，减少用户等待。\n\n格式：\n\n```plain text\nHTTP/1.1 200 OK\nContent-Type: text/html\nTransfer-Encoding: chunked\n4\nChun\n9\nked Trans\n12\nfer Encoding\n0\nLocation\n```\n\n指定重定向的目标 URL。\n\n## User-Agent\n\n用户代理，即是谁实际发送请求、接受响应的，例如手机浏览器、某款手机 App。\n\n## Range / Accept-Range\n\n按范围取数据。\n\n- `Accept-Range: bytes`： 响应报文中出现，表示服务器支持按字节来取范围数据；\n- `Range: bytes=\u003cstart\u003e-\u003cend\u003e`： 请求报文中出现，表示要取哪段数据；\n- `Content-Range:\u003cstart\u003e-\u003cend\u003e/total`： 响应报文中出现，表示发送的是哪段 数据。\n\n作用：断点续传、多线程下载。\n\n## \u003cstrong\u003e其他 \u003c/strong\u003eHeaders\n\n- Accept：客户端能接受的数据类型。如 text/html\n- Accept-Charset：客户端接受的字符集。如 utf-8。\n- Accept-Encoding：客户端接受的压缩编码类型。如 gzip。\n- Content-Encoding：压缩类型。如 gzip。\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["计算机网络","报文","HTTPS"]},"/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90":{"title":"HashMap 源码解析","content":"# 前言  \n  \nHashMap 是 Java 中最常用 K-V 容器，使用哈希值来确定元素存储的位置，HashMap 对 Entry 进行了扩展（Node），使其形成以链表或者树的形式存储在 HashMap 的容器里。  \n  \n在 Java 8 之前和之后，HashMap 的实现有较大的不同，因此对于 put 流程、扩容机制等主要过程分析将会采用两个版本进行对比。  \n  \n# 成员变量  \n  \nHashMap 成员变量和构造方法声明如下（Java 7 和 8 大致相同，以下为 Java 8 版本）：  \n  \n```java  \npublic class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e  \n  \n    implements Map\u003cK,V\u003e, Cloneable, Serializable {  \n\n    // 初始容量 16  \n    static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16  \n  \n    // 最大容量，该数组最大值为2^31一次方。  \n    static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30;  \n  \n    // 默认的加载因子，如果构造的时候不传则为 0.75  \n    static final float DEFAULT_LOAD_FACTOR = 0.75f;  \n  \n    // @1.8：数组某个位置下的 node 链表转化为红黑树对该链表的最小长度要求  \n    static final int TREEIFY_THRESHOLD = 8;  \n  \n    // @1.8：当一个反树化的阈值，当这个 node 长度减少到该值就会从树转化成链表  \n    static final int UNTREEIFY_THRESHOLD = 6;  \n  \n    // @1.8：数组某个位置下的 node 链表转化为红黑树对元素个数的最小要求  \n    static final int MIN_TREEIFY_CAPACITY = 64;  \n  \n    // 具体存放数据的数组  \n    transient Node\u003cK,V\u003e[] table;  \n  \n    // entrySet，一个存放 k-v 缓冲区  \n    transient Set\u003cMap.Entry\u003cK,V\u003e\u003e entrySet;  \n  \n    // 存放键值对的个数。  \n    transient int size;  \n  \n    // 记录更改 map 结构次数(添加、删除、扩容？)  \n    transient int modCount;  \n  \n    // 临界值，当实际大小(容量*填充因子)超过临界值时，会进行扩容  \n  \n    int threshold;  \n  \n    // 填充因子  \n    final float loadFactor;  \n  \n    // 指定初始容量  \n    public HashMap(int initialCapacity) {  \n        this(initialCapacity, DEFAULT_LOAD_FACTOR);  \n    }  \n\n    // 默认构造函数  \n    public HashMap() {  \n        // 默认 threshold 在首次 put 时才复制，Java 7 则是调用  \n        // this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR)  \n        this.loadFactor = DEFAULT_LOAD_FACTOR;   \n    }  \n\n    // 包含另一个 Map  \n    public HashMap(Map\u003c? extends K, ? extends V\u003e m) {  \n        this.loadFactor = DEFAULT_LOAD_FACTOR;  \n  \n        putMapEntries(m, false);  \n    }  \n\n    // 指定初始容量和填充因子  \n    public HashMap(int initialCapacity, float loadFactor) {  \n        if (initialCapacity \u003c 0) // 容量不能为负数  \n  \n            throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);  \n  \n        // 当容量大于 2^31 就取最大值 1\u003c\u003c30;   \n  \n        if (initialCapacity \u003e MAXIMUM_CAPACITY)  \n  \n            initialCapacity = MAXIMUM_CAPACITY;  \n  \n        if (loadFactor \u003c= 0 || Float.isNaN(loadFactor))  \n  \n            throw new IllegalArgumentException(\"Illegal load factor: \"                + loadFactor);  \n  \n        this.loadFactor = loadFactor;  \n  \n        // tableSizeFor 保证了数组长度一定是 2 的幂次方，是大于等于    initialCapacity 最接近的值。  \n        // 这里使用 threshold 暂时保存计算后的 initialCapacity 值  \n        this.threshold = tableSizeFor(initialCapacity);  \n  \n    }  \n    ...  \n}  \n```  \n  \n# 数据结构  \n  \nJava 7 采用数组 + 链表方式进行存储，元素类型为 Entry：  \n  \n```java  \nstatic class Entry\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {  \n  \n    final K key;  \n  \n    V value;  \n  \n    Entry\u003cK,V\u003e next;  \n  \n    int hash;  \n\n    ...  \n}  \n```  \n  \n元素的存储结构如下：  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_035018.png)\nJava 8 开始，采用数组 + 链表 + 红黑树方式进行存储，元素类型为 Node 和 TreeNode：  \n  \n```java  \nstatic class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {  \n  \n    final int hash;  \n  \n    final K key;  \n  \n    V value;  \n  \n    Node\u003cK,V\u003e next;  \n\n    ...  \n}  \n  \n  \n  \nstatic final class TreeNode\u003cK,V\u003e extends LinkedHashMap.Entry\u003cK,V\u003e {  \n  \n    TreeNode\u003cK,V\u003e parent;  // red-black tree links  \n  \n    TreeNode\u003cK,V\u003e left;  \n  \n    TreeNode\u003cK,V\u003e right;  \n  \n    TreeNode\u003cK,V\u003e prev;    // needed to unlink next upon deletion  \n  \n    boolean red;  \n    \n    ...  \n}  \n```  \n  \n元素的存储结构如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_041741.png)\n\n# put 流程分析  \n  \n## Java 7 put 流程  \n  \n### 代码分析  \n  \nJava 7 put 流程主要方法源码如下：  \n  \n```java  \npublic V put(K key, V value)  \n    if (table == EMPTY_TABLE) {  \n        // 初始化 table  \n        inflateTable(threshold);  \n    }  \n  \n    if (key == null) {  \n        // 在 table[0] 处插入 key 为 null 元素并返回  \n        return putForNullKey(value);  \n    }  \n  \n    // 先进行一次 hash 计算     \n    int hash = hash(key);  \n  \n    // 根据 hash 值计算 table 下标  \n    int i = indexFor(hash, table.length);  \n  \n    // 遍历 table[i] 处的链表  \n    for (Entry\u003cK,V\u003e e = table[i]; e != null; e = e.next) {  \n        Object k;  \n        // hash 一样且 key 相等或者 equals 方法返回 true 才进行替换  \n        if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) {  \n            V oldValue = e.value;  \n  \n            e.value = value;  \n  \n            e.recordAccess(this);  \n  \n            return oldValue;  \n        }  \n    }  \n    // 出循环意味着 table[i] 这条链表没有此元素  \n    // 更新 modCount  \n    modCount++;  \n    // 插入新元素  \n    addEntry(hash, key, value, i);  \n  \n    return null;  \n}  \n  \nprivate void inflateTable(int toSize) {  \n    // 获取大于  \n    int capacity = roundUpToPowerOf2(toSize);  \n    // 重新计算阈值  \n    threshold = (int) Math.min(capacity * loadFactor,   \n            MAXIMUM_CAPACITY + 1);  \n  \n    // 创建数组  \n    table = new Entry[capacity];  \n  \n    // 根据配置判断是否初始化 hashSeed  \n    initHashSeedAsNeeded(capacity);  \n}  \n  \nprivate V putForNullKey(V value) {  \n    // 最多循环一次，因为这个位置最多只有一个元素  \n    for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) {  \n        // key 为 null 直接替换  \n        if (e.key == null) {  \n            V oldValue = e.value;  \n            e.value = value;  \n            e.recordAccess(this);  \n  \n            return oldValue;  \n        }  \n    }  \n  \n    // 更新 modCount  \n    modCount++;  \n  \n    // 在 table[0] 处插入元素  \n    addEntry(0, null, value, 0);  \n  \n    return null;  \n}  \n  \nvoid addEntry(int hash, K key, V value, int bucketIndex) {  \n    // 元素数量达到临界值且 table[bucketIndex] 位置不为空才进行扩容  \n    if ((size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])) {  \n        // 两倍容量  \n        resize(2 * table.length);  \n  \n        // 重新计算 hash  \n        hash = (null != key) ? hash(key) : 0;  \n  \n        // 重新确定数组下标  \n        bucketIndex = indexFor(hash, table.length);  \n    }\n    // 创建并插入新元素  \n    createEntry(hash, key, value, bucketIndex);  \n}  \n  \n// 在链表头部插入新元素  \nvoid createEntry(int hash, K key, V value, int bucketIndex) {  \n    // 保存原头结点  \n    Entry\u003cK,V\u003e e = table[bucketIndex];  \n    // 创建新元素、把 next 指向头节点，并替换原来 bucketIndex 位置的链表  \n    table[bucketIndex] = new Entry\u003c\u003e(hash, key, value, e);  \n    // 元素数量++  \n    size++；  \n}  \n```  \n  \n### 流程图示  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040358.png)\n## Java 8 put 流程  \n  \n### 代码分析  \n  \nJava 8 put 流程主要方法源码如下：  \n  \n```java  \npublic V put(K key, V value) {  \n      // onlyIfAbsent 默认为 false，即元素存在时进行替换  \n    return putVal(hash(key), key, value, false, true);  \n}  \n  \nfinal V putVal(int hash, K key, V value,   \n          boolean onlyIfAbsent, boolean evict) {  \n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i;  \n  \n    // table 未初始化或者长度为 0，进行扩容  \n    if ((tab = table) == null || (n = tab.length) == 0)  \n        n = (tab = resize()).length;  \n  \n    // (n - 1) \u0026 hash 确定元素存放位置，位置为空则直接放入该位置  \n    if ((p = tab[i = (n - 1) \u0026 hash]) == null)  \n        tab[i] = newNode(hash, key, value, null);  \n  \n    // 数组对应位置已经存在元素  \n    else {  \n        Node\u003cK,V\u003e e; K k;  \n  \n        // 比较数组中第一个元素  \n        if (p.hash == hash \u0026\u0026  \n            ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n  \n                // 将第一个元素赋值给 e  \n                e = p;  \n        // 是否为红黑树结点  \n        else if (p instanceof TreeNode)  \n            // 放入树中  \n            e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab,   \n                        hash, key, value);  \n        // 链表结点  \n        else {  \n            // 遍历链表  \n            for (int binCount = 0; ; ++binCount) {  \n                // 到达链表的尾部，说明没有找到相等的 key  \n                if ((e = p.next) == null) {  \n                    // 在尾部插入新结点  \n                    p.next = newNode(hash, key, value, null);  \n  \n                    // 判断结点数量是否达到阈值(TREEIFY_THRESHOLD 默认为 8)  \n                    if (binCount \u003e= TREEIFY_THRESHOLD - 1) {  \n                        // 根据数组长度决定是否树化  \n                        treeifyBin(tab, hash);  \n                    }  \n  \n                    // 跳出循环  \n                    break;  \n                }  \n  \n                // 判断链表中结点的 key 值是否与插入的 key 相等  \n                if (e.hash == hash \u0026\u0026  \n                    ((k = e.key) == key ||   \n                          (key != null \u0026\u0026 key.equals(k))))  \n                    // key 相等，跳出循环，此时 e 就是目标结点  \n                    break;  \n  \n                // 与前面的 e = p.next 组合遍历链表  \n                p = e;  \n            }  \n        }  \n  \n        // 找到 key 值相等的目标结点  \n        if (e != null) {  \n  \n            V oldValue = e.value;  \n  \n            // onlyIfAbsent 为 false 或者目标接点值为 null  \n            if (!onlyIfAbsent || oldValue == null)  \n  \n                //用新值替换旧值  \n                e.value = value;  \n  \n            // 空实现，用于访问后回调给子类，如 LinkedHashMap  \n            afterNodeAccess(e);  \n  \n            // 返回旧值  \n            return oldValue;  \n        }  \n    }  \n  \n    // 结构修改，更新 modCount  \n    ++modCount;  \n  \n    // 实际大小大于阈值则扩容  \n    if (++size \u003e threshold)  \n        resize();  \n  \n    // 插入后回调  \n    afterNodeInsertion(evict);  \n  \n    return null;  \n}  \n```  \n  \n#### 流程图示  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040522.png)\n# hash 计算与元素位置确定  \n  \n## Java 7  \n  \n```java  \nint hash = hash(key);  \n  \nint i = indexFor(hash, table.length);  \n  \nfinal int hash(Object k) {  \n  \n    // 默认为 0，初始化方法见后文  \n    int h = hashSeed;  \n  \n    // 如果 hashSeed 不为零且 key 是 String 类型  \n    if (0 != h \u0026\u0026 k instanceof String) {  \n        // 返回特定 hash 值  \n        return sun.misc.Hashing.stringHash32((String) k);  \n    }  \n  \n    h ^= k.hashCode();  \n  \n    // 多次异或  \n    h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12);  \n  \n    return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4);  \n}  \n  \nstatic int indexFor(int h, int length) {  \n    // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";  \n    return h \u0026 (length-1);  \n}  \n```  \n  \n## Java 8  \n  \n```java  \npublic V put(K key, V value) {  \n    return putVal(hash(key), key, value, false, true);  \n}  \n\nstatic final int hash(Object key) {  \n    int h;  \n  \n    // 让高 16 位和低 16 位异或  \n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16);  \n}  \n\np = tab[index = (n - 1) \u0026 hash]；  \n```  \n  \n# 扩容流程  \n  \n扩容过程涉及到 rehash、复制数据等操作，非常消耗性能。  \n  \n和扩容相关的全局变量及其含义：  \n  \n| 全局变量   | 含义                                                                                                                                                                                                                                                                                                                                                                                                      |  \n| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |  \n| capacity   | table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。                                                                                                                                                                                                                                                                                                                               |  \n| size       | 存放键值对数量。                                                                                                                                                                                                                                                                                                                                                                                          |  \n| threshold  | size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。threshold = (int) (capacity * loadFactor)                                                                                                                                                                                                                                                                                                   |  \n| loadFactor | 填充因子，table 能够使用的比例。loadFactor 能够控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。\u003cbr/\u003eloadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。 |  \n  \n## Java 7 扩容流程  \n  \n### 代码分析  \n  \nJava 7 的 resize 方法相关代码：  \n  \n```java  \nvoid resize(int newCapacity) {  \n    Entry[] oldTable = table;  \n  \n    // 记录旧容量  \n    int oldCapacity = oldTable.length;  \n  \n    // 如果容量已达到上限，则扩容阈值设置成不可能达到的最大值，即后续不再扩容  \n    if (oldCapacity == MAXIMUM_CAPACITY) {  \n        threshold = Integer.MAX_VALUE;  \n  \n        return;  \n    }  \n  \n    // 根据新容量创建出新数组  \n    Entry[] newTable = new Entry[newCapacity];  \n  \n    // 将旧数组的节点转移到新数组  \n    transfer(newTable, initHashSeedAsNeeded(newCapacity));  \n  \n    // 新旧易主  \n    table = newTable;  \n  \n    // 根据新容量重新确定新阈值  \n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);  \n}  \n \n// 从配置中获取是否启用备用 hash，用于减少字符串 hash 冲突  \nfinal boolean initHashSeedAsNeeded(int capacity) {  \n    // 是否已经启用备用 hash  \n    boolean currentAltHashing = hashSeed != 0;  \n  \n    // 虚拟机已经启动且数组容量大于 ALTERNATIVE_HASHING_THRESHOLD  \n    boolean useAltHashing = sun.misc.VM.isBooted() \u0026\u0026  \n            (capacity \u003e= Holder.ALTERNATIVE_HASHING_THRESHOLD);  \n  \n    // 异或操作判断是否切换  \n    boolean switching = currentAltHashing ^ useAltHashing;  \n    if (switching) {  \n        // useAltHashing 为 true 则 hashSeed 初始化为也给随机 hash 值  \n        hashSeed = useAltHashing  \n            ? sun.misc.Hashing.randomHashSeed(this)  \n            : 0;  \n    }  \n    return switching;  \n}  \n\nvoid transfer(Entry[] newTable, boolean rehash) {  \n    int newCapacity = newTable.length;  \n  \n    // 遍历旧数组  \n    for (Entry\u003cK,V\u003e e : table) {  \n        // 遍历数组上的链表  \n        while(null != e) {  \n            // 记录下一个位置  \n            Entry\u003cK,V\u003e next = e.next;  \n  \n            // 判断是否重新计算 hash 值  \n            if (rehash) {  \n  \n                e.hash = null == e.key ? 0 : hash(e.key);  \n  \n            }  \n  \n            // 根据新容量重新计算位置  \n            int i = indexFor(e.hash, newCapacity);  \n  \n            // 按旧链表的正序遍历链表、在新链表的头部依次插入  \n            // 因此扩容后可能出现逆序  \n            e.next = newTable[i];  \n  \n            newTable[i] = e;  \n  \n            e = next;  \n        }  \n    }  \n}  \n```  \n  \n### 扩容流程在多线程环境下的隐患  \n  \n在 resize 扩容过程中，在将旧数组上的数据转移到新数组上时，转移数据操作是按旧链表的正序遍历链表、在新链表的头部依次插入的。在多线程的环境下，由于这些操作不具有原子性和内存可见性，转移数据、扩容后，容易出现环形链表的情况。  \n  \n## Java 8 扩容流程  \n  \n### 代码分析  \n  \nJava 8 中的 resize 和 treeifyBin 方法：  \n  \n```java  \nfinal void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) {  \n    int n, index; Node\u003cK,V\u003e e;  \n    // 如果数组为空或者数组长度小于 64，则进行扩容  \n    if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY)  \n        resize();  \n    // 根据 hash 获取数组下标，该位置有值再进行树化  \n    else if ((e = tab[index = (n - 1) \u0026 hash]) != null) {  \n        TreeNode\u003cK,V\u003e hd = null, tl = null;  \n        // 遍历链表  \n        do {  \n            // Node 节点转换成 TreeNode 节点  \n            TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null);  \n  \n            if (tl == null)  \n                hd = p;  \n            else {  \n                p.prev = tl;  \n  \n                tl.next = p;  \n            }  \n  \n            tl = p;  \n        } while ((e = e.next) != null);  \n        \n        if ((tab[index] = hd) != null)  \n            hd.treeify(tab);  \n    }  \n}  \n\nfinal Node\u003cK,V\u003e[] resize() {  \n  \n    Node\u003cK,V\u003e[] oldTab = table;  \n  \n    int oldCap = (oldTab == null) ? 0 : oldTab.length;  \n  \n    int oldThr = threshold;  \n  \n    int newCap, newThr = 0;  \n  \n    if (oldCap \u003e 0) {  \n        // 超过最大值后续不再扩容  \n        if (oldCap \u003e= MAXIMUM_CAPACITY) {  \n            threshold = Integer.MAX_VALUE;  \n            return oldTab;  \n        }  \n  \n        // 否则扩充为原来的2倍  \n        else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 oldCap \u003e= DEFAULT_INITIAL_CAPACITY)  \n            newThr = oldThr \u003c\u003c 1; // double threshold  \n    }  \n  \n    else if (oldThr \u003e 0) // initial capacity was placed in threshold  \n        newCap = oldThr;  \n    else {  \n        // signifies using defaults  \n        newCap = DEFAULT_INITIAL_CAPACITY;  \n  \n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  \n    }  \n  \n    // 计算新的 resize 上限  \n  \n    if (newThr == 0) {  \n        float ft = (float)newCap * loadFactor;  \n        newThr = (newCap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);  \n    }  \n  \n    threshold = newThr;  \n  \n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})  \n  \n    Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap];  \n  \n    table = newTab;  \n\n    if (oldTab != null) {  \n        // 旧数组迁移至新数组  \n        for (int j = 0; j \u003c oldCap; ++j) {  \n            Node\u003cK,V\u003e e;  \n            if ((e = oldTab[j]) != null) {  \n                oldTab[j] = null;  \n                if (e.next == null)  \n                    newTab[e.hash \u0026 (newCap - 1)] = e;  \n                else if (e instanceof TreeNode)  \n                    ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap);  \n                else {  \n                    Node\u003cK,V\u003e loHead = null, loTail = null;  \n                    Node\u003cK,V\u003e hiHead = null, hiTail = null;  \n                    Node\u003cK,V\u003e next;  \n                    do {  \n                        next = e.next;  \n                        // 原索引  \n                        if ((e.hash \u0026 oldCap) == 0) {  \n                            if (loTail == null)  \n                                loHead = e;  \n                            else  \n                                loTail.next = e;  \n                            loTail = e;  \n                        }  \n  \n                        // 原索引+oldCap  \n                        else {  \n                            if (hiTail == null)  \n                                hiHead = e;  \n                            else  \n                                hiTail.next = e;  \n                            hiTail = e;  \n                        }  \n                    } while ((e = next) != null);  \n  \n                    // 原索引元素放到新数组中  \n                    if (loTail != null) {  \n                        loTail.next = null;  \n                        newTab[j] = loHead;  \n                    }  \n  \n                    // 原索引 +oldCap 元素放到新数组中  \n                    if (hiTail != null) {  \n                        hiTail.next = null;  \n                        newTab[j + oldCap] = hiHead;  \n                    }  \n                }  \n            }  \n        }  \n    }  \n    return newTab;  \n}  \n```  \n  \nresize 方法中的前半段，关于 newCap 和 newThr 的计算过程，简化后如下：  \n  \n```java  \nif (oldCap \u003e 0) {  \n    // 嵌套条件分支  \n    if (oldCap \u003e= MAXIMUM_CAPACITY) {...}  \n    else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026  \n                 oldCap \u003e= DEFAULT_INITIAL_CAPACITY) {...}  \n}   \nelse if (oldThr \u003e 0) {...}  \n  \nelse {...}  \n```  \n  \n这些判断分别对应以下几种条件：  \n  \n| 条件                       | 覆盖情况                            | 备注                                                                                                                         |  \n| -------------------------- | ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |  \n| oldCap \u003e 0                 | 桶数组 table 已经被初始化           |                                                                                                                              |  \n| oldThr \u003e 0                 | threshold \u003e 0，且桶数组未被初始化   | 调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况，此种情况下 newCap = oldThr，newThr 在第二个条件分支中算出 |  \n| oldCap == 0 \u0026\u0026 oldThr == 0 | 桶数组未被初始化，且 threshold 为 0 | 调用 HashMap() 构造方法会产生这种情况。                                                                                      |  \n  \noldCap \u003e 0 时表示 table 数组已经被初始化过，这时需要再次计算容量和阈值：  \n  \n| 条件                        | 覆盖情况                                      | 备注                                                      |  \n| --------------------------- | --------------------------------------------- | --------------------------------------------------------- |  \n| oldCap \u003e= 230               | 桶数组容量大于或等于最大桶容量 230            | 后续不再扩容                                              |  \n| newCap \u003c 230 \u0026\u0026 oldCap \u003e 16 | 新桶数组容量小于最大值，且旧桶数组容量大于 16 | 该种情况下新阈值 newThr = oldThr \u003c\u003c 1，移位可能会导致溢出 |  \n  \nresize 方法后续过程中可以看出，Java 8 转移数据操作是按旧链表的正序遍历链表、在新链表的尾部依次插入的，所以不会出现链表 逆序、倒置的情况，故不容易出现环形链表的情况。但仍然还是线程不安全，因为没有加同步锁保护。  \n  \n## 扩容流程对比  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040805.png)\n# get 流程分析  \n  \n## Java 7\n  \n```java  \npublic V get(Object key) {  \n    if (key == null)  \n        return getForNullKey();  \n    Entry\u003cK,V\u003e entry = getEntry(key);  \n    return null == entry ? null : entry.getValue();  \n}  \n  \nprivate V getForNullKey() {  \n    if (size == 0) {  \n        return null;  \n    }  \n  \n    // 下标为 0 处获取 key 为 null 的元素  \n    for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) {  \n        if (e.key == null)  \n            return e.value;  \n    }  \n    return null;  \n}  \n\nfinal Entry\u003cK,V\u003e getEntry(Object key) {  \n    if (size == 0) {  \n        return null;  \n    }  \n  \n    int hash = (key == null) ? 0 : hash(key);  \n    for (Entry\u003cK,V\u003e e = table[indexFor(hash, table.length)];  \n             e != null; e = e.next) {  \n        Object k;  \n        if (e.hash == hash \u0026\u0026  \n            ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n            return e;  \n    }  \n    return null;  \n}  \n```  \n  \n## Java 8\n  \n```java  \npublic V get(Object key) {  \n    Node\u003cK,V\u003e e;  \n    return (e = getNode(hash(key), key)) == null ? null : e.value;  \n}  \n\nfinal Node\u003cK,V\u003e getNode(int hash, Object key) {  \n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n; K k;  \n    if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026  \n        (first = tab[(n - 1) \u0026 hash]) != null) {  \n        // 先判断 tab[index] 中的第一个元素  \n        if (first.hash == hash \u0026\u0026 // always check first node  \n            ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n            return first;  \n        if ((e = first.next) != null) {  \n            // 结点为红黑树则使用 TreeNode 的方法获取  \n            if (first instanceof TreeNode)  \n                return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key);  \n            do { //否则遍历链表  \n                if (e.hash == hash \u0026\u0026  \n                    ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n                    return e;  \n            } while ((e = e.next) != null);  \n        }  \n    }  \n    return null;  \n}  \n```  \n  \n遍历方式  \n  \n```java  \nMap\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e() {{  \n    put(\"a\", 10);  \n    put(\"b\", 20);  \n}};  \n  \n// 方式一：迭代 entrySet  \n  \nfor (Map.Entry\u003cString, Integer\u003e entry : map.entrySet()) {  \n    String key = entry.getKey();  \n    int value = entry.getValue();  \n}  \n\n// 方式二：单独迭代 keySet 或 values  \n// 迭代键  \nfor (String key : map.keySet()) {  \n    System.out.println(\"Key = \" + key);  \n}  \n  \n// 迭代值  \nfor (Integer value : map.values()) {  \n    System.out.println(\"Value = \" + value);  \n}  \n\n// 方式三：使用 iterator  \n  \nIterator\u003cMap.Entry\u003cString, Integer\u003e\u003e entries =         \n          map.entrySet().iterator();  \n  \nwhile (entries.hasNext()) {  \n    Map.Entry\u003cString, Integer\u003e entry = entries.next();  \n    String key = entry.getKey();  \n    int value = entry.getValue();  \n}  \n\n// 方式四：Lambda 表达式  \nmap.forEach((k, v) -\u003e System.out.println(\"key: \" + k + \" value:\" + v));  \n```  \n  \n# 面试题  \n  \n## 为什么 HashMap 数组长度为 2 的幂次方？  \n  \n如果数组中 hash 冲突太过频繁，某些位置的元素形成过长的链表，就会导致数据存取效率过低，因此要使元素均匀地分布在数组中，hash 碰撞就不能太频繁。而 hash 值范围为 -2147483648 到 2147483647，如果用如此长的数组来进行存放加上合理 hash 映射确实可以使 hash 碰撞降到很低的水平，但这明显是不现实的。  \n  \n因此这个 hash 值是不能直接使用的，首先需要进行二次 hash 使得结果更加随机，这时理论上可以使用 hash % length 得到一个不小于数组长度 length 的 index 值，这样不但能避免产生数组越界，并且可以使元素均匀分布，事实上很多 hash 算法都是采用该方法。但是在计算机中，% 取模运算比位 \u0026 运算的效率要低得多，而当 length 为 2 的幂次方时，hash % length 刚好等于 hash \u0026 (length - 1) ，从而能够将 % 运算转换成 \u0026 运算，更加快速地得到 index 值。  \n  \n因此采用 2 的幂次方作为数组的长度的好处是：使元素均匀分部以降低 hash 冲突的基础上，大大加快了计算元素所在数组位置的速度。  \n  \n## hash 冲突有哪些解决方法？HashMap 是怎样解决的？  \n  \n1. 二次 hash，通过高 16 位与低 16 位异或运算，使得结果更加随机；  \n2. 拉链地址法，将 hash 值相同的元素串成一个链表或者转为红黑树。  \n  \n## HashMap 会造成哪些安全问题？怎么解决？  \n  \n如前面文章所述，在 Java 7 中，HashMap 在扩容的时候是通过遍历旧数组，然后在新数组中使用头插法进行转移元素的。这在单线程环境中是没有问题的，但是到了多线程环境下，由于 JMM 的特性，会以一定的概率形成环形链表的情况。在 Java 8 中这个问题通过使用尾插法得到解决，但是多线程下很多操作仍然会导致线程安全问题，比如多个线程 put 后某些元素丢失等。因此多线程环境下要保证线程安全，可以使用 ConcurentHashMap 代替 HashMap。  \n  \n## 使用对象作为 HashMap 的 key 应该注意什么？  \n  \n应当重写对象的 hashCode() 和 equals() 方法。如前面代码所示，HashMap 在 put 一个元素的时候，会调用此元素的 key 值的 hashCode 方法确定元素存放位置，并且会调用 hashCode 和 equals 方法判断元素是否相等。因此如果没有重写这两个方法，或者方法重写的时候没有遵守规则，HashMap 通过 put 存入一组元素后，再通过此元素的 key 值去 get 对象的时候就有可能出现跟预期结果不一致的情况。  \n  \n在重写 equals 方法的时候，需要遵守下面的通用约定：  \n  \n- \u003cstrong\u003e自反性\u003c/strong\u003e：对于任何非空引用 x，x.equals(x) 必须返回 true；  \n- \u003cstrong\u003e对称性\u003c/strong\u003e：对于任何非空引用 x 和 y，如果且仅当 y.equals(x) 返回 true 时 x.equals(y) 必须返回 true；  \n- \u003cstrong\u003e传递性\u003c/strong\u003e：对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 必须返回 true；  \n- \u003cstrong\u003e一致性\u003c/strong\u003e：对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 x.equals(y) 的多次调用必须始终返回 true 或始终返回 false；  \n- \u003cstrong\u003e非空性\u003c/strong\u003e：对于任何非空引用 x，x.equals(null) 必须返回 false。  \n  \n\u003cstrong\u003e重写 hashCode 方法的大致方式（非强制）：\u003c/strong\u003e  \n  \n1. 把某个非零常数值，比如说 31（最好是素数，考虑到 HashMap 源码中的异或操作），保存在一个叫 result 的 int 类型的变量中。  \n2. 对于对象中每一个关键域 f（值 equals 方法中考虑的每一个域），完成以下步骤：  \n3. 为该域计算 int 类型的散列码 c:  \n  \n```  \n1. 如果该域是 boolean 类型，则计算 (f?0:1)  \n  \n2. 如果该域是 byte、char、short 或者 int 类型，则计算 (int)f  \n  \n3. 如果该域是 float 类型，则计算 Float.floatToIntBits(f)  \n  \n4. 如果该域是 long 类型，则计算 (int)(f ^ (f\u003e\u003e\u003e32))  \n  \n5. 如果该域是double类型，则计算 Double.doubleToLongBits(f) 得到一个 long 类型的值，然后按照步骤 4，对该 long 型值计算散列值  \n  \n6. 如果该域是一个对象引用，并且该类的 equals 方法通过递归调用 equals 的方式来比较这个域，则同样对这个对象递归调用 hashCode 方法。  \n  \n7. 如果该域是一个数组，则把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤下面的做法把这些散列值组合起来。  \n```  \n  \n2. 按照下面的公式，把步骤 1 中计算得到的散列码 c 组合到 result 中：result = 31 x result+c。  \n3. 返回 result。  \n4. 写完 hashCode 方法之后，确认是否相等的实例具有相等的散列码。如果不是的话，找出原因，并修改。  \n  \n样例：  \n```java  \npublic class Student {  \n  \n    private String name;  \n  \n    private int age;  \n  \n    private Grades grades;  \n  \n    public Student(String name, int age, Grades grades) {  \n        this.name = name;  \n        this.age = age;  \n        this.grades = grades;  \n    }  \n\n    @Override  \n    public int hashCode() {  \n        final int prime = 31;  \n        int result = 1;  \n        \n        result = prime * result + age;  \n        result = prime * result +  \n                ((name == null) ? 0 : name.hashCode());  \n        result = prime * result +  \n                (grades == null ? 0 : grades.hashCode());  \n  \n        return result;  \n    }  \n  \n    @Override  \n    public boolean equals(Object obj) {  \n        if (this == obj) return true;  \n  \n        if (obj == null || getClass() != obj.getClass()) return false;  \n  \n        Student other = (Student) obj;  \n  \n        if (age != other.age) return false;  \n  \n        if (name != null ? !name.equals(other.name) :   \n              other.name != null) return false;  \n  \n        if (grades != null ? !grades.equals(other.grades) :           \n              other.grades != null) return false;  \n  \n        return true;  \n    }  \n}  \n```","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["HashMap","源码解析","Java"]},"/IO":{"title":"IO","content":"","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["Java","IO"]},"/Index-for-Atlases":{"title":"Untitled Page","content":"---\ndate created: 2022-06-22\ndate modified: 2022-08-20\ntags: dataview\ntitle: \"Index for Atlases\"\n---\n```dataviewjs\n// 获取当前文件所在的文件夹\nconst currentFolder = dv.current().file.folder\n// 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息\nconst groups =  dv.pages(`\"${currentFolder}\"`).groupBy(p =\u003e p.file.folder)\nfor (let group of groups) {\n\tdv.header(4, group.key);\n\tdv.table([\"Name\",\"标签\",\"入链\", \"创建日期\", \"修改日期\"],\n\t\tgroup.rows\n\t\t\t.sort(k =\u003e k.file.name, 'asc')\n\t\t\t.map(k =\u003e [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday]))\n}\n```\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":[]},"/JVM-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6":{"title":"JVM 中的对象和垃圾回收","content":"# 虚拟机中的对象\n\n了解了 JVM 运行时数据区域之后，大致明白了 JVM 内存模型的概况，对内存中的存放内容也有了初步了解。更进一步地，如果要了解内存中的数据的创建过程、在内存中如何布局、以及访问方式等，就必须要把范围限定到具体的虚拟机类型和集中在某一个内存区域上才有意义。下面以最常用的 HotSpot 虚拟机和最常用的内存区域 Java 堆为例，深入探索对象分配、布局和访问过程。\n\n## 对象的创建\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123009.png)\n\n虚拟机遇到一条 new 指令时，首先检查是否被类加载器加载，如果没有，则必须先执行相应的类加载过程。类加载就是把 class 加载到 JVM 的运行时数据区的过程。\n\n### \u003cstrong\u003e1、检查加载\u003c/strong\u003e\n\n首先检查这个指令的参数是否能在常量池中定位到一个类的\u003cstrong\u003e符号引用\u003c/strong\u003e（以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。\n\n### \u003cstrong\u003e2、分配内存\u003c/strong\u003e\n\n如果上一步检查加载成功，接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。\n\n分配内存主要有两种方式\n\n#### \u003cstrong\u003e指针碰撞\u003c/strong\u003e\n\n如果 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“\u003cstrong\u003e指针碰撞\u003c/strong\u003e”。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123013.png)\n\n#### \u003cstrong\u003e空闲列表\u003c/strong\u003e\n\n如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“\u003cstrong\u003e空闲列表\u003c/strong\u003e”。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123019.png)\n\n选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n\n如果是 Serial、ParNew 等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞的方式，既简单又高效。\n\n如果是使用 CMS 这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。\n\n#### \u003cstrong\u003e内存分配的并发安全问题\u003c/strong\u003e\n\n除如何划分可用空间之外，还有另外一个需要考虑的问题是：对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的。\n\n解决方案有以下两种：\n\n\u003cstrong\u003eCAS 机制\u003c/strong\u003e\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123025.png)\n\n对分配内存空间的动作进行同步处理，虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。虽然这种方式解决了并发问题，但是我们不难发现，这种方式增加了复杂度，降低了内存的分配的功效性。\n\n\u003cstrong\u003e分配缓冲\u003c/strong\u003e\n\n另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer, 简称 TLAB）。JVM 在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个 Buffer，如果需要分配内存，就在自己的 Buffer 上分配，这样就不存在竞争的情况，可以大大提升分配效率，当 Buffer 容量不够的时候，再重新从 Eden 区域申请一块继续使用。\n\nTLAB 的目的是在为新对象分配内存空间时，让每个 Java 应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。\n\nTLAB 只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个 TLAB 用满（分配指针 top 撞上分配极限 end 时），就新申请一个 TLAB。\n\n分配缓冲较 CAS 机制少了比较、预处理，失败重试步骤，极其高效，所以我们一般使用 TLAB 方式，JVM 默认也是此方式。要禁用 TLAB，需指定 -XX:-UseTLAB。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123030.png)\n\n### \u003cstrong\u003e3、内存空间初始化\u003c/strong\u003e\n\n内存分配完成后，虚拟机需要将分配到的内存空间（不包括对相投）都初始化为零值（如 int 值为 0，boolean 值为 false 等等）。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n\n\u003cstrong\u003e注意：此过程没有调用构造方法！\u003c/strong\u003e\n\n### \u003cstrong\u003e4、设置\u003c/strong\u003e\n\n接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes 在 Java hotspot VM 内部表示为类元数据）、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头之中。\n\n### \u003cstrong\u003e5、对象初始化\u003c/strong\u003e\n\n在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但从 Java 程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行 new 指令之后会接着把对象按照程序员的意愿进行初始化(构造方法)，这样一个真正可用的对象才算完全产生出来。\n\n## 对象内存布局\n\n在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。\n\n对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。\n\n对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。\n\n如果对象是一个 Java 数组，那么在对象头中还有一块用于记录数组长度的数据。\n\n第三部分对齐填充并不是必须的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot 的自动内存管理系统要求对对象的大小必须是 8 字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。数据对齐的作用就是\u003cstrong\u003e方便进行垃圾回收\u003c/strong\u003e。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123035.png)\n\n## 对象访问定位\n\n建立对象是为了使用对象，我们的 Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。\n\n### \u003cstrong\u003e句柄\u003c/strong\u003e\n\nJava 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123040.png)\n\n- \u003cstrong\u003e优点：\u003c/strong\u003ereference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改.\n- \u003cstrong\u003e缺点：\u003c/strong\u003e需要在堆中维护一个句柄池，而且由于中间多了个句柄池引用过程也多了一个步骤，执行效率受到影响。\n\n### \u003cstrong\u003e直接指针\u003c/strong\u003e\n\n如果使用直接指针访问， reference 中存储的直接就是对象地址。\n\n这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。\n\n使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123100.png)\n\n对 HotSpot 而言，它是使用直接指针访问方式进行对象访问的。\n\n# 垃圾收集\n\n## 判断对象存活\n\n在堆里面存放着几乎所有的对象实例，垃圾回收器在对进行回收前，要做的事情就是确定这些对象中哪些还是“存活”着，哪些已经“死去”（死去代表着不可能再被任何途径使用得对象了）。JVM 中有两种算法判断对象的存活。\n\n### 引用计数法\n\n在对象中添加一个引用计数器，每当有一个地方引用他时，计数器的值就加一；当引用失效时，计数器的值就减一，任何时刻计数器为零的对象就是不可能再被使用的。\n\n优点：原理简单、判断效率高\n\n缺点：必须要配合大量的额外处理才能保证正确的工作，如单纯的引用计数法很难解决对象之间相互循环引用的问题。\n\n主流的 Java 虚拟机没有采用引用计数法管理内存。\n\n### 引用链法（可达性分析法）\n\n#### 可达性分析\n\n通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为 “引用链”（Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的说法就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。\n\n主流的商用程序（Java、C#）的内存管理子系统都是通过可达性（Reachability Analysis）分析算法来判断对象是否存活。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123106.png)\n\n#### GC Roots 分类\n\n作为 GC Roots 的对象包括下面几种（重点是前面 4 种）：\n\n\u003cstrong\u003e1、虚拟机栈（栈帧中的本地变量表）中引用的对象。比如各个现场被调用方法堆栈中使用到的参数、局部变量、临时变量等。\u003c/strong\u003e\n\n\u003cstrong\u003e2、方法区中类静态属性引用的对象。比如 Java 类的引用类型静态变量。\u003c/strong\u003e\n\n\u003cstrong\u003e3、方法区中常量引用的对象。比如字符串常量池里的引用。\u003c/strong\u003e\n\n\u003cstrong\u003e4、本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。\u003c/strong\u003e\n\n5、JVM 的内部引用（class 对象、异常对象 NullPointException、OutofMemoryError，系统类加载器）。\n\n6、所有被同步锁（synchronized）持有的对象。\n\n7、JVM 内部的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。\n\n8、JVM 实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收只回收部分代的对象，这个后续会细讲，先大致了解概念）。\n\n#### 决定对象是否死亡\n\n- 可达性分析仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡\n- 当在可达性分析 中判断不可达的对象，只是“被判刑”= 还没真正死亡\n- 不可达对象会被放在”即将回收“的集合里\n- 要判断一个对象真正死亡，还需要经历两个阶段：\n\n##### \u003cstrong\u003e第一次标记 \u0026 筛选\u003c/strong\u003e\n\n如果一个对象在可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。如果对象没有覆盖 finalize() 方法或者 finalize() 方法已被虚拟机调用过，那么虚拟机都将视为“没有必要执行”，这时对象将被继续留在“即将回收”集合。\n\n##### \u003cstrong\u003e第二次标记 \u0026 筛选\u003c/strong\u003e\n\n如果这个对象被判断为有必要执行 finalize() 方法，那么该对象就会被放到 F-Queue 中，稍后收集器将对 F-Queue 中的对象进行小规模标记。在执行 finalize() 过程中，如果对象重新与引用链上的任意一个对象建立关系，那么第二次标记的时候就会被移除“即将回收”的集合。\n\n经过上面两次标记 \u0026 筛选，仍然留在“即将回收”集合里的对象将会在 GC 到来的时候被回收。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123112.png)\n\n\u003cstrong\u003e尽量不要依赖 finalize，因为这个方法太不可靠，在生产中很难控制方法的执行或者对象的调用顺序。可以忽略 finalize 方法，因为在 finalize 方法能做的工作，Java 中有更好的方式，比如 try-finally。\u003c/strong\u003e\n\n## 引用类型\n\nJava 中一共有四种引用，分别为强引用、弱引用、软引用和虚引用。\n\n### \u003cstrong\u003e强引用\u003c/strong\u003e\n\n一般的 Object obj = new Object() 就属于强引用。在任何情况下，只要有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n### \u003cstrong\u003e软引用 SoftReference\u003c/strong\u003e\n\n如果内存空间足够，垃圾回收器就不会回收它，\u003cstrong\u003e如果内存空间不足了，就会回收这些对象的内存\u003c/strong\u003e。只要垃圾回收器没有回收它，该对象就可以被程序使用。\n\n软引用可用来实现内存敏感的高速缓存。例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。\n\n### \u003cstrong\u003e弱引用 WeakReference\u003c/strong\u003e\n\n弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，\u003cstrong\u003e不管当前内存空间足够与否，都会回收它的内存\u003c/strong\u003e。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n\n\u003cstrong\u003e注意：\u003c/strong\u003e软引用和弱引用可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。\n\n实际运用（WeakHashMap、ThreadLocal）\n\n### \u003cstrong\u003e虚引用 PhantomReference\u003c/strong\u003e\n\n幽灵引用，最弱（随时会被回收掉）。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。唯一的作用就是垃圾回收的时候收到一个通知，可以用来监控垃圾回收器是否正常工作。\n\n## 垃圾收集算法\n\n#### 分代收集理论\n\n当前虚拟机的垃圾收集器大多数都采用分代收集的理论进行设计，分代收集名为理论，实质事一套符合大多数程序运行实际情况的经验法则，，它建立在两个分代假说之上：\n\n1. 弱分代假说：绝大多数对象都是朝生夕灭的。\n2. 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。\n\n这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（即熬过垃圾收集过程的次数）分配到不同区域中存储。\n\n在 Java 堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型划分；也才能够针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出“标记 - 复制算法”“标记 - 清除算法”和“标记 - 整理算法”等针对性的垃圾收集算法。\n\n一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123124.png)\n\n- 新生代：复制算法。每次收集都会有大量对象死去，复制算法只需要付出少量对象的复制成本就可以完成每次垃圾收集。当年轻代中的 Eden 区分配满的时候，就会触发年轻代的 GC（Minor GC）。具体过程如下：\n\n  - 在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区（From 区）；\n  - Eden 区再次 GC，这时会采用复制算法，将 Eden 和 From 区一起清理。存活的对象会被复制到 To 区；接下来，只需要清空 From 区就可以了。\n  - 所以在这个过程中，总会有一个 Survivor 分区是空置的。Eden、From、To 的默认比例是 8:1:1，所以只会造成 10% 的空间浪费。\n- 老年代：标记 - 清除或者标记 - 整理算法。老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保。对象进入老年代有多个途径：\n\n（1）提升（Promotion）\n\n每当发生一次 Minor GC，存活下来的对象年龄（对象头中纪录）都会加 1。直到达到一定的阈值，就会把这些“老年”对象给提升到老年代。\n\n这些对象如果变的不可达，直到老年代发生 GC 的时候，才会被清理掉。\n\n这个阈值，可以通过参数 ‐XX:+MaxTenuringThreshold 进行配置，最大值是 15，因为它是用 4bit 存储的。\n\n（2）空间分配担保\n\nGC 过程每次存活的对象，都会放入其中一个 Survivor 区，这个区域默认的比例是 10%。但是无法保证每次存活的对象都小于 10%，当 Survivor 空间不够，就需要依赖其他内存（指老年代）进行分配担保。这个时候，对象也会直接在老年代上分配。\n\n（3）大对象直接在老年代分配\n\n超出某个大小的对象将直接在老年代分配。这个值是通过参数 -XX:PretenureSizeThreshold 进行配置的。默认为 0，意思是全部首选 Eden 区进行分配。\n\n（4）动态对象年龄判定\n\n有的垃圾回收算法，并不要求 age 必须达到 15 才能晋升到老年代，它会使用一些动态的计算方法。比如，从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 将作为新的阈值，年龄大于此阈值的对象直接进入老年代。\n\n#### 垃圾回收类型介绍\n\n- 部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：\n\n  - 新生代收集（Minor GC/Young GC）：目标只是新生代的垃圾收集。\n  - 老年代收集（Major GC/Old GC）：目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独回收老年代的行为。\n  - 混合收集（Mixed GC）：指目标是收集整个新生代及老年代的垃圾收集。目前只有 G1 收集器有这种行为。\n- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。\n\n#### 标记 - 清除\n\n在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。\n\n在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。\n\n在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123130.png)\n\n不足：\n\n- 标记和清除过程效率都不高；\n- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。\n\n#### 标记 - 复制\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123135.png)\n\n将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。\n\n主要不足是只使用了内存的一半空间。\n\n现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间（分别叫做 From 和 To，也可以叫做 Survivor0 和 Survivor1 ），每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。\n\nHotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。\n\n#### 标记 - 整理\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_1231340.png)\n\n标记的过程与“标记 - 清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n优点:\n\n- 不会产生内存碎片\n\n不足:\n\n- 需要移动大量对象，处理效率比较低。\n\n## 经典垃圾收集器\n\n如果说垃圾收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。《Java 虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器都有可能会有很大的差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123145.png)\n\n以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。它们之间涉及到的某些概念，在谈论垃圾收集器的上下文语境中，可以有如下理解：\n\n- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；\n- 串行（Serial）：串行指的是垃圾收集器与用户程序交替执行，意味着在执行垃圾收集的时候需要停顿用户程序；\n- 并行（Parallel） ：指的是多条垃圾收集线程并行工作，默认用户线程仍然处于等待状态。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。\n- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（不一定是并行，可能会交替执行）。用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。\n\n#### Serial 收集器\n\nSerial 翻译为串行，也就是说它以串行的方式执行。\n\n它是单线程的收集器，只会使用一个线程进行垃圾收集工作。它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123150.png)\n\n\u003cstrong\u003e优点\u003c/strong\u003e\n简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。\n\n\u003cstrong\u003e缺点\u003c/strong\u003e\n进行垃圾收集工作的时候必须暂停其他所有的工作线程（Stop The World），直到收集结束。\n\n#### ParNew 收集器\n\n它是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123155.png)\n\n#### Parallel Scavenge 收集器\n\n与 ParNew 一样是多线程收集器。其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。\n\n停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验；而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。\n\n缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。\n\n#### Serial Old 收集器\n\n是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用，同样也是一个单线程收集器，使用“标记-整理”算法。如果用在 Server 场景下，它有两大用途：\n\n- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。\n- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。\n\n#### Parallel Old 收集器\n\nParallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。\n\n#### CMS 收集器\n\nCMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。它是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\n\n从名字中的 Mark Sweep 这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n\n- 初始标记： \u003cstrong\u003e暂停所有的其他线程\u003c/strong\u003e，并记录下\u003cstrong\u003e与 GC root 直接相连\u003c/strong\u003e的对象，速度很快。\n- 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n- 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段也需要\u003cstrong\u003e暂停所有的其他线程\u003c/strong\u003e。但停顿时间一般会比初始标记阶段的时间稍长，而又远远比并发标记阶段时间短。\n- 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123203.png)\n\n在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。\n\n从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：\n\n- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。\n- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将\u003cstrong\u003e临时启用 Serial Old 来替代 CMS\u003c/strong\u003e。\n- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。\n\n#### G1 收集器\n\nG1 (Garbage-First) 是一款\u003cstrong\u003e面向服务器\u003c/strong\u003e的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。\n\n堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。它把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。\n\n每一个 Region 都可以根据需要，扮演新生代的 Eden、Survivor 和老年代空间，G1 能够对扮演不同觉得的 Region 采用不同的策略区处理。Region 中还有一类特殊的 Humongous（巨大的） 区域，专门用来储存大对象。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123208.png)\n\nG1 收集器的运作大致分为以下几个步骤：\n\n- 初始标记\n- 并发标记\n- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。\n- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123216.png)\n\nG1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\n\nG1 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：\n\n- 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。\n- 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\n- 空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。\n- 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。\n\n| 收集器            | 收集对象/算法                      | 收集器类型      | 说明                                                                                                                           | 适用场景                                                                                                     |\n| ----------------- | ---------------------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ |\n| Serial            | 新生代/复制                        | 单线程          |                                                                                                                                | 简单高效；\u003cbr/\u003e适合内存不大的情况；\u003cbr/\u003eClient 场景下的默认新生代收集器。                                    |\n| ParNew            | 新生代/复制                        | 并行\u003cbr/\u003e多线程 | 是 Serial 收集器的多线程版本                                                                                                   | Server 场景下默认的新生代收集器；\u003cbr/\u003e搭配 CMS 垃圾回收器的首选。                                            |\n| Parallel Scavenge | 新生代/复制                        | 并行\u003cbr/\u003e多线程 | 类似 ParNew，更加关注吞吐量，达到一个可控制的吞吐量；                                                                          | Server 场景多 CPU 机器上的默认收集器，主要适合后台运算不需要太多交互的任务；                                 |\n| Serial Old        | 老年代/标记整理                    | 单线程          |                                                                                                                                | Client 模式下虚拟机使用                                                                                      |\n| Parallel Old      | 老年代/标记整理                    | 并行\u003cbr/\u003e多线程 | Parallel Scavenge 收集器的老年代版本，为了配合 Parallel Scavenge 的面向吞吐量的特性而开发的对应组合；                          | 在注重吞吐量以及 CPU 资源敏感的场合采用                                                                      |\n| CMS               | 老年代/标记清除                    | 并行\u003cbr/\u003e并发   | 尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：\u003cbr/\u003e1.内存碎片\u003cbr/\u003e2.需要更多 cpu 资源\u003cbr/\u003e3.浮动垃圾问题，需要更大的堆空间 | 重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者 B/S 系统。互联网后端目前 CMS 是主流的垃圾回收器。 |\n| G1                | 新生代和老年代/标记整理 + 化整为零 | 并行\u003cbr/\u003e并发   | JDK 1.7 才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势；             | 面向服务端应用的垃圾回收器，目标为取代 CMS。                                                                 |\n\n# 内存分配与 GC 策略\n\n## 1. 对象优先在 Eden 分配\n\n大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。\n\n## 2. 大对象直接进入老年代\n\n大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。\n\n经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。\n\n-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。\n\n## 3. 长期存活的对象进入老年代\n\n为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。\n\n-XX:MaxTenuringThreshold 用来定义年龄的阈值。\n\n## 4. 动态对象年龄判定\n\n虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。\n\n## 5. 空间分配担保\n\n在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。\n\n如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123223.png)\n\n## Full GC 的触发条件\n\n对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：\n\n### 1. 调用 System.gc()\n\n只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。\n\n### 2. 老年代空间不足\n\n老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。\n\n为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。\n\n### 3. 空间分配担保失败\n\n使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。\n\n### 4. 永久代空间不足（JDK 1.8 之前）\n\n在 JDK 1.8 之前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。\n\n当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。\n\n为避免以上原因引起的 Full GC，可采用的方法为\u003cstrong\u003e增大永久代空间\u003c/strong\u003e或\u003cstrong\u003e转为使用 CMS 收集器\u003c/strong\u003e。\n\n### 5. Concurrent Mode Failure\n\n执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123229.png)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-GC/clipboard_20230323_123234.png)\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["JVM","垃圾回收","GC","Java"]},"/JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F":{"title":"JVM 内存区域","content":"# 简介\n\n## 什么是 JVM？\n\nJava 虚拟机（Java Virtual Machine，简称 JVM），它能识别 .class 后缀的字节码文件（Java bytecode），并且能够解析它的指令，最终调用操作系统上的函数以完成指定操作。\n\n## 为什么需要 JVM？\n\nJava 程序使用 javac 编译成 .class 文件之后，还需要使用 Java 命令去主动执行它，操作系统并不认识这些 .class 文件，JVM 则充当了翻译官的角色。JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120503.png)\n\n从图中可以看到，有了 JVM 这个抽象层之后，Java 就可以实现跨平台了。JVM 只需要保证能够正确执行 .class 文件，就可以运行在诸如 Linux、Windows、MacOS 等平台上了。\n\nJVM 解释的是类似于汇编语言的字节码，需要一个抽象的运行时环境。同时，这个虚拟环境也需要解决字节码加载、自动垃圾回收、并发等一系列问题。JVM 其实是一个规范，定义了 .class 文件的结构、加载机制、数据存储、运行时栈等诸多内容，最常用的 JVM 实现就是 Hotspot。\n\n一个 Java 程序，首先经过 javac 编译成 .class 文件，然后 JVM 将其加载到 `元数据` 区，执行引擎将会通过 `混合模式` 执行这些字节码。执行时，会翻译成操作系统相关的函数。JVM 作为 .class 文件的黑盒存在，输入字节码，调用操作系统函数。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120537.png)\n## JVM、JRE 和 JDK 三者关系\n\nJVM 只是一个翻译官，它负责把字节码翻译成机器码，但是需要注意，JVM 不会自己生成代码，需要大家编写代码，同时需要很多依赖类库，这个时候就需要用到 JRE。\n\nJRE 除了包含 JVM 之外，提供了很多的类库（就是我们说的 jar 包，它可以提供一些即插即用的功能，比如读取或者操作文件，连接网络，使用 I/O 等等之类的）这些东西就是 JRE 提供的基础类库。JVM 标准加上实现的一大堆基础类库，就组成了 Java 的运行时环境，也就是我们常说的 JRE（Java Runtime Environment）。有了 JRE 之后，Java 程序便可以运行来了。\n\n但对于程序员来说，JRE 还不够。还需要编译代码、调试代码、打包代码，有时候还需要反编译代码等等。因此需要使用 JDK，除了 JRE 之外，JDK 还提供了一些非常好用的小工具，比如 javac（编译代码）、java、jar （打包代码）、javap（反编译 \u003c 反汇编 \u003e）等。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120708.png)\n\n# JVM 运行时数据区\n\n相对于 C 和 C++ 的手动内存管理和复杂难以理解的指针等特性，Java 引以为豪的就是它的自动内存管理机制，这使得 Java 程序写起来方便得多。然而这种呼之即来挥之即去的内存申请和释放方式，自然也有它的代价。为了管理这些快速的内存申请释放操作，就必须引入一个池子来延迟这些内存区域的回收操作。另外，Java 程序的数据结构是非常丰富的，比如有静态成员变量、动态成员变量、区域变量、短小紧凑的对象声明和庞大复杂的内存申请等等。这么多不同的数据结构，到底是在什么地方存储的，它们之间又是怎么进行交互的呢？这就有了内存区域划分的概念，如图：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120716.png)\n\nJVM 内存区域划分如图所示，从图中我们可以看出：\n\n- JVM 堆中的数据是共享的，是占用内存最大的一块区域。\n- 可以执行字节码的模块叫作执行引擎。\n- 执行引擎在线程切换时依靠的就是程序计数器来进行恢复。\n- JVM 的内存划分与多线程是息息相关的。程序中运行时用到的栈，以及本地方法栈，它们的维度都是线程。\n- 本地内存包含元数据区和一些直接内存。\n\n![](static/boxcnFXQjU3d0urFc9C5qGM6ISd.png)\n\n## 程序计数器\n\n程序计数器（Program Counter Register）是一块较小的内存空间，由于 JVM 可以并发执行线程，因此会存在线程之间的切换，而这个时候就程序计数器会记录下当前程序执行到的位置，以便在其他线程执行完毕后，恢复现场继续执行。\n\nJVM 会为每个线程分配一个程序计数器，与线程的生命周期相同。\n\n如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行虚拟机字节码指令的地址。如果正在执行的是 Native 本地方法，计数器的值则为空。\n\n\u003cstrong\u003e程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。\u003c/strong\u003e\n\n## 虚拟机栈\n\n虚拟机栈描述的是 Java 方法执行的内存模型：\n\n每个方法在执行的同时都会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n\n虚拟机栈是每个线程独有的，随着线程的创建而存在，线程结束而死亡。\n\n在虚拟机栈内存不够的时候会 OutOfMemoryError，在线程运行中需要更大的虚拟机栈时会出现 StackOverFlowError。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120721.png)\n\n从上图可以看出，虚拟机栈包含很多\u003cstrong\u003e栈帧\u003c/strong\u003e，每个方法执行的同时会创建一个栈帧，栈帧又存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。\n\n### 虚拟机栈运行的原理\n\n- JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循\"先进后出\"的原则。\n- 每一次函数调用都会有一个对应的栈帧被压入虚拟机栈中，每一个函数调用结束后，都会有一个栈帧被弹出。\n- 在一条活动的线程中，一个时间点上，只会有一个数据的栈帧。即只有当前正在执行的方法的栈帧是有效的。这个栈帧称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。\n- 执行引擎运行的所有字节码指令只针对当前的栈帧进行操作。\n- 如果该方法调用了其他方法，对应新的栈帧会创建处理，放在栈的顶部，成为新的当前栈。\n- 不同线程中所包含的栈帧是不允许相互作用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。\n- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的返回结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，是的前一个栈帧重新成为当前栈帧。\n- Java 方法有两种返回方式：return 语句和抛出异常，不管哪种返回方式都会导致栈帧被弹出。\n\n### 局部变量表\n\n局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和 returnAdress 类型（指向了一条字节码指令的地址）。\n\n### 操作数栈\n\n主要用于\u003cstrong\u003e保存计算过程的中间结果\u003c/strong\u003e，同时作为计算过程中\u003cstrong\u003e临时的存储空间\u003c/strong\u003e。\n\n当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。\n\n操作数栈、局部变量表和程序计数器的工作过程：\n\n![](static/boxcnIP1LPtHC6Df6FWYsQDun3z.png)\n\n### 动态连接\n\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。\n\n方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪一个方法)，这也是 Java 强大的扩展能力，在运行期间才能确定目标方法的\u003cstrong\u003e直接引用\u003c/strong\u003e。\n\n所有\u003cstrong\u003e方法调用中的目标方法\u003c/strong\u003e在 Class 文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。\n\n在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池中。比如：描述一个方法调用另外的其他方法时，就是通过常量池中指向方法的引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120904.png)\n\n下面从字节码的角度分析动态连接的过程：\n\n```java\npublic class DynamicLinkingTest {\n    int num = 10;\n    public void methodA() {\n        System.out.println(\"methodA...\");\n    }\n    public void method() {\n        System.out.println(\"methodB...\");\n        methodA();\n        num++;\n    }\n}\n```\n\n上面代码反编译以后可以看到如下指令：\n\n```java\n Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokevirtual #2                  // Method a:()V\n         4: return\n```\n\ninvokevirtual 后面的 #2 符号引用对应的就是运行时常量池中的直接引用。\n\n#2 对应了方法引用，#3，#17……最终对应到 methodA：\n\n```java\nConstant pool:\n   #1 = Methodref          #4.#16         // java/lang/Object.\"\u003cinit\u003e\":()V\n   #2 = Methodref          #3.#17         // com/suanfa/jvm/OperandStackTest.a:()V\n   #3 = Class              #18            // com/suanfa/jvm/OperandStackTest\n   #4 = Class              #19            // java/lang/Object\n   #5 = Utf8               \u003cinit\u003e\n   #6 = Utf8               ()V\n   #7 = Utf8               Code\n   #8 = Utf8               LineNumberTable\n   #9 = Utf8               LocalVariableTable\n  #10 = Utf8               this\n  #11 = Utf8               Lcom/suanfa/jvm/OperandStackTest;\n  #12 = Utf8               a\n  #13 = Utf8               b\n  #14 = Utf8               SourceFile\n  #15 = Utf8               OperandStackTest.java\n  #16 = NameAndType        #5:#6          // \"\u003cinit\u003e\":()V\n  #17 = NameAndType        #12:#6         // a:()V\n  #18 = Utf8               com/suanfa/jvm/OperandStackTest\n  #19 = Utf8               java/lang/Object\n```\n\n#### \u003cstrong\u003e方法调用\u003c/strong\u003e\n\n在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。\n\n1. 静态链接、早期绑定：当一个字节码文件别装入 JVM 内部，如果被调用的目标方法在编译器可知，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。对应的方法绑定机制为\u003cstrong\u003e早期绑定\u003c/strong\u003e。\n2. 动态链接、晚期绑定：如果方法被调用的时候在编译期无法确定下来，就是说，只能在运行时将调用方法的符号引用转换为直接引用，引用这种引用转换过程具备动态性，因此称之为动态链接。对应的方法绑定机制为\u003cstrong\u003e晚期绑定\u003c/strong\u003e。\n\n#### \u003cstrong\u003e虚方法与非虚方法\u003c/strong\u003e\n\n- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称之为非虚方法。\n- 静态变量、私有方法、final 方法、实例构造器、父类方法都是非虚方法。\n- 其它方法称之为虚方法。\n\n##### 普通调用指令\n\n- invokestatic ：静态方法，解析阶段确定唯一方法版本\n- invokespecial ：调用`\u003cinit\u003e`方法、私有方法以及父类方法，解析阶段确定唯一方法版本\n- invokevirtual ：调用所有虚方法\n- invokeinterface ：调用接口方法\n\n##### 动态调用指令\n\n- invokedynamic ： 动态解析所需要调用的方法，然后执行。invokedynamic 指令是在 Java 7 中增加的，为了实现动态类型语言支持而做的一种改进，但在 Java 7 中并没有提供直接生成的 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具才能够生成 invokedynamic 指令。直到 JDK 8 的 Lambda 表达式的出现，invokedynamic 指令在 Java 中才有了直接生成的方式。\n\n前四条指令固化在虚拟机的内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定版本。其中 invokevirtual 和 invokestatic 指令调用的方法称为非虚方法，其余的（final 修饰除外）称为虚方法。\n\n下面以具体实例展示以上介绍的各种调用指令：\n\n```java\n/**\n * 解析调用中非虚方法、虚方法的测试\n */\nclass Father {\n    public Father(){\n        System.out.println(\"Father 默认构造器\");\n    }\n\n    public static void showStatic(String s){\n        System.out.println(\"Father show static \" + s);\n    }\n\n    public final void showFinal(){\n        System.out.println(\"Father show final\");\n    }\n\n    public void showCommon(){\n        System.out.println(\"Father show common\");\n    }\n\n}\n\npublic class Son extends Father{\n    public Son(){\n        super();\n    }\n\n    public Son(int age){\n        this();\n    }\n\n    public static void main(String[] args) {\n        Son son = new Son();\n        son.show();\n    }\n\n    //不是重写的父类方法，因为静态方法不能被重写\n    public static void showStatic(String s) {\n        System.out.println(\"Son show static \" + s);\n    }\n\n    private void showPrivate(String s) {\n        System.out.println(\"Son show private \" + s);\n    }\n\n    public void show() {\n        //invokestatic\n        showStatic(\"大头儿子\");\n        //invokestatic\n        super.showStatic(\"大头儿子\");\n        //invokespecial\n        showPrivate(\"hello!\");\n        //invokespecial\n        super.showCommon();\n        //invokevirtual 因为此方法声明有final，不能被子类重写\n        //所以也认为该方法是非虚方法\n        showFinal();\n        //虚方法如下\n        //invokevirtual\n        //没有显式加super，被认为是虚方法，因为子类可能重写showCommon\n        showCommon();\n        info();\n\n        MethodInterface in = null;\n        //invokeinterface  \n        //不确定接口实现类是哪一个 需要重写\n        in.methodA();\n        //invokedynamic\n        lambda(()-\u003e {\n          \n        });\n    }\n\n    public void info(){\n\n    }\n    \n    public void lambda(MethodInterface interface) {\n        methodInterface.methodA();\n    }\n\n}\n\ninterface MethodInterface {\n    void methodA();\n}\n```\n\n### 方法出口\n\n指方法返回地址，是存放调用该方法的程序计数器的值。\n\n方法返回分为正常返回和异常退出。无论何种退出情况，都将返回至方法当前被调用的位置，这样程序才能继续执行。\n\n本质上，方法的退出就是当前栈帧出栈的过程。此时需要回复上层方法的局部变量表、操作数栈、将返回值压入调用者的栈帧的操作数栈、设置程序计数器的值等，让调用者方法继续执行下去。正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值。\n\n### 本地方法栈\n\nJava 虚拟机栈是用来为 Java 方法服务，相应地，本地方法栈则是用来为 native 方法服务的，可以认为是通过 JNI (Java Native Interface) 直接调用本地 C/C++ 库，不受 JVM 控制。需要注意的是，HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一了。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120910.png)\n\n本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 异常。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_120920.png)\n\n## 堆\n\n堆是 JVM 上最大的内存区域，我们申请的\u003cstrong\u003e几乎所有的对象\u003c/strong\u003e，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。\n\n一个对象创建的时候，决定是堆上分配还是在栈上分配，和两个方面有关：对象的类型和在 Java 类中存在的位置。\n\n- 对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。\n- 对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况。由于每个线程拥有一个虚拟机栈，当在方法体内声明了基本数据类型的对象，就会在栈上直接分配。其他情况，则都是在堆上分配。\n\n堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。\n\n随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。由于对象的大小不一，在长时间运行后，堆空间会被许多细小的碎片占满，造成空间浪费。所以，仅仅销毁对象是不够的，还需要堆空间整理。\n\n现在的虚拟机（包括 HotSpot）都是采用分代回收算法。在分代回收的思想中， 把堆分为：新生代 + 老年代 + 永久代（Java 1.8 之前的方法区的实现方式）； 新生代又分为 Eden + From Survivor + To Survivor 区。几乎所有的 Java 对象都在 Eden 区被 new 出来的。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121108.png)\n\n在 Hotspot 中，Eden、 From 和 To 区空间大小默认比例是 8：1：1。\n\n也可以使用 -XX:SurvivorRatio 调整这个空间比例，比如 -XX:SruvivorRatio=8。\n\n## 方法区\n\n方法区（Method Area）与 Java 堆一样，是所有\u003cstrong\u003e线程共享\u003c/strong\u003e的内存区域。\n\n方法区用于存储已经被虚拟机加载的类信息（即加载类、接口、枚举、注解时需要的信息，包括版本、field、方法、接口等信息）、final 常量、静态变量、编译器即时编译的代码等。\n\n方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。\n\n### 版本演进\n\nJava 8 之前，许多 Java 程序员都习惯在 HotSpot 虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或者将两者混为一谈。本质上这两者是不等价的，因为仅仅是当时的 HotSpot 虚拟机设计团队把垃圾收集器的分代设计思想扩展到方法区，或者说使用永久代来实现方法区而已，这样使得 Hotspot 的垃圾收集器能够像管理 Java 堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机（如 JRockit 和 J9）来说是不存在永久代的概念的，因为《Java 虚拟机规范》对方法区的实现要求比较宽松。\n\n在 Java 6 的时候 Hotspot 开发团队就有放弃永久代，逐步改为采用本地内存来实现方法区的计划了。到了 Java 7，Hotspot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆里；而从 Java 8 开始，则放弃了永久代的概念，改用与 JRockit 和 J9 一样在本地内存中实现的元空间（MetaSpace）来代替，并把之前永久代剩余的内容（运行时常量池和其他类信息等）全部移动到元空间中\n\nJava 7 之前：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121115.png)\n\nJava 7:\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121121.png)\n\nJava 8 开始：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121132.png)\n\n### 采用元空间替代永久代实现方法区的优点\n\n1. 字符串存在永久代中，容易出现性能问题和内存溢出。\n2. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。而元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制。\n3. 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。\n4. 将 HotSpot 与 JRockit 合二为一。\n\n### 方法区中的内容\n\n#### \u003cstrong\u003e类型信息\u003c/strong\u003e\n\n对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：\n\n1. 这个类型的完整有效名称（即包名.类名）\n2. 这个类型直接父类的完整有效名（对于 interface 或是 java. lang.Object，都没有父类）\n3. 这个类型的修饰符（public、 abstract、 final 的某个子集）\n4. 这个类型直接接口的一个延续列表\n\n#### \u003cstrong\u003e域（Field）信息\u003c/strong\u003e\n\nJVM 必须在方法区中保存类型的所有域的相关信息以及域的生命顺序。\n\n域的相关信息包括：域名称、域类型、域修饰符（pubic、private、protected、static、final、volatile、transient 的某个子集）。\n\n#### \u003cstrong\u003e方法（method）信息\u003c/strong\u003e\n\nJVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：\n\n1. 方法名称。\n2. 方法的返回类型（或 void）\n3. 方法参数的数量和类型（按顺序）\n4. 方法的修饰符（public、private、protected、static、final、synchronized、native、abstract 的一个子集）\n5. 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）\n6. 异常表（abstract 和 native 方法除外），每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。\n\n#### \u003cstrong\u003e静态变量（static 变量）\u003c/strong\u003e\n\n1. 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。\n2. 类变量被类的所有实例所共享，即使没有类实例你也可以访问它。\n\n#### \u003cstrong\u003e全局常量（static final 变量）\u003c/strong\u003e\n\n与 non-final 的类变量的处理方法则不同，每个全局常量在编译的时候就被分配了。\n\n```java\npublic static int count = 1;\npublic static final int number = 2;\n```\n\n反编译后就可以看到如下代码：\n\n```java\npublic static int count;\n    descriptor: I\n    flags: ACC_PUBLIC, ACC_STATIC\n\npublic static final int number;\n    descriptor: I\n    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL\n    ConstantValue: int 2\n```\n\n## 直接内存\n\n直接内存并不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。它是处于 Java 堆外的、直接向内存申请的系统内存区间。\n\n直接内存源自 NIO，通过存在堆外内存的 DirectByteBuffer 操作 Native 本地内存。通常，访问直接内存的速度会优于 Java 堆内存，即读写性能高。因此出于性能考虑，读写频繁的场合可能考虑使用直接内存。因此 Java 的 NIO 库使用直接内存进行数据缓冲器。\n\n直接内存也可能导致 OOM，由于它处于 Java 堆外，因此它的大小不会直接受限于 -Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统给出的最大内存。可以通过 -XX:MaxDirectMemorySize 设置它的大小，默认与堆的最大值 -Xmx 参数值一致。\n\n直接内存的缺点是分配回收成本较高、不受 JVM 内存回收管理。\n\n# 常量池和 String\n\n## 常量池概念\n\n### 静态常量池\n\n一个有效的 Class 文件中除了包含了类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息就是\u003cstrong\u003e常量池（Constant Pool）\u003c/strong\u003e，用于存放编译期生成的各种\u003cstrong\u003e字面量（Literal）\u003c/strong\u003e和\u003cstrong\u003e对类型、域和方法的符号引用（Symbolic References）\u003c/strong\u003e。\n\n### 运行时常量池\n\n运行时常量池是方法区中的一部分。Class 文件中静态常量池的内容将在类加载后存放到方法区的运行时常量池中。也就是说，每个 Class 都有一个静态常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。\n\n运行时常量池相对于 Class 文件常量池的一个重要特征就是它具备动态性。运行期间也可以将新产生的常量放入常量池中，典型的实现方式就是 String 类的 intern() 方法。\n\n### 字符串常量池\n\n字符串的分配和其他的对象分配一样，需要耗费高昂的时间和空间为代价，如果需要大量频繁的创建字符串，会极大程度地影响程序的性能，因此 JVM 为了提高性能和减少内存开销引入了字符串常量池的概念。\n\n#### 特点\n\n字符串常量池中是不会存储相同的字符串的。\n\n字符串常量池（String Pool）由 StringTable 类实现，它是一个固定大小的 Hashtable。因此，如果 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长会直接造成调用 String.intern 时性能大幅度下降。\n\n```java\npublic class StringTable extends sun.jvm.hotspot.utilities.Hashtable {\n    ...\n}\n```\n\nJDK6、7 中，StringTable 默认是 1009，所以如果常量池中的字符串过多就会导致效率下降很快，此时可以通过参数进行调整。\n\nJDK8 开始，StringTable 默认是 60013，也可以通过参数进行调整，但限制最小长度不低于 1009。\n\nStringTable 存储的不是 String 对象的内容，而是一个个 HashtableEntry，HashtableEntry 里面的 value 指向的才是 String 对象一般我们说一个字符串进入了字符串常量池其实是说在这个 StringTable 中保存了对它的引用；反之，如果说没有在其中就是说 StringTable 中没有对它的引用。\n\n#### 字符串常量池位置变化\n\n字符串常量池自 Java 7 开始从永久代移动到堆中。因为永久代的回收频率很低，在 Full GC 的时候才会触发，而 Full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了 StringTable 回收效率不高。而开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。因此，只有放到堆里才能及时回收这部分内存。\n\n## String\n\n无论是服务端还是 Android 客户端开发，String 对象无疑是用得最多的数据类型之一，String 类的代码简化后有如下内容：\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    \n    ...\n}\n```\n\n实际上，value[] 数组才是真正存放字符串的容器。\n\n### String 对象的内存分配\n\n以下使用 String 对象最常用的两种方式，下面进行深入分析。\n\n#### 通过字面量赋值创建\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = \"xyz\";\n        ...\n    }\n}\n```\n\n这段代码执行后（假如 main 线程还存活），内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121313png)\n\n执行 String s = \"xyz\" 时，首先会在字符串常量池中查找（遍历 StringTable 逐个获取 HashtableEntry 对象，判断 HashtableEntry 的 value 是否 equals(\"xyz\")），看能不能找到“xyz”\u003cstrong\u003e字符串的引用\u003c/strong\u003e，如果字符串常量池中找不到这个引用，则：\n\n1. 创建一个 String 对象和 char 数组对象；\n2. 将创建的 String 对象封装成 HashtableEntry，作为 StringTable 的 value 进行存储；\n3. 返回创建的 String 对象。\n\n如果能找到这个引用：\n\n- 直接返回找到引用对应的 String 对象。\n\n#### 通过 new 关键字创建\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s = new String(\"xyz\");\n        ...\n    }\n}\n```\n\n这段代码执行后（假如 main 线程还存活），内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121321.png)\n\n执行 String s = new String(\"xyz\") 时，首先会在字符串常量池中查找，看能不能找到“xyz”\u003cstrong\u003e字符串对应对象的引用\u003c/strong\u003e，如果字符串常量池中找不到这个引用，则：\n\n1. 创建一个 String 对象和 char 数组对象；\n2. 将创建的 String 对象封装成 HashtableEntry，作为 StringTable 的 value 进行存储；\n3. new String(\"xyz\") 会在堆区又创建一个 String 对象，char 数组直接指向创建好的 char 数组对象。\n\n如果能找到这个引用：\n\n- new String(\"xyz\") 会在堆区创建一个对象，char 数组直接指向已经存在的 char 数组对象。\n\n#### 对比\n\n对于 String s = \"xyz\" 这种形式创建字符串对象，如果字符串常量池中能找到，不会创建 String 对象；如果如果字符串常量池中找不到，创建一个 String 对象。\n\n对于 String s = new String(\"xyz\") 这种形式创建字符串对象，如果字符串常量池中能找到，创建一个 String 对象；如果如果字符串常量池中找不到，创建两个 String 对象。\n\n所以，在日常开发中，能用 String s = \"xyz\" 尽量不用 String s = new String(\"xyz\")，因为可以少创建一个对象，节省一部分空间。\n\n事实上，运行程序用到 Test 类的时候，Test.class 文件的信息会被解析到内存的方法区里，例子中的“xyz”作为字面量，它的一个引用会被存到在堆中的字符串常量池里。而“xyz”本体还是和所有对象一样，创建在堆中的 Eden 区，但因为一直有一个引用驻留在字符串常量池，所以不会被 GC 清理掉。这个对象“xyz”会生存到整个线程结束。主线程中的 s 变量这时候都还没有被创建，但“xyz”的实例已经在堆里了，对它的引用也已经在字符串常量池里了。\n\n有了前面的基础，再来分析下面代码：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s1 = new String(\"xyz\");\n        String s2 = \"xyz\";\n        System.out.println(s1 == s2);\n        System.out.println(s1.equals(s2));\n        ...\n    }\n}\n输出结果：\nfalse\ntrue\n```\n\n这段代码执行后（假如 main 线程还存活），内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121328.png)\n\n很明显，s1 和 s2 指向的是不同的对象。而 equals 方法比较的真正的 char 数据，并且从图中可以看出 s1 和 s2 最终指向的都是同一个 char 数组对象，所以 s1.equals(s2) 等于 true。关于它们是否指向同一个数组，下图也可以证实：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121334.png)\n\n#### 通过字符串拼接创建\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        String s1 = \"aa\";\n        String s2 = \"bb\";\n        String str0 = new String(\"aa\") + new String(\"bb\");\n        String str1 = s1 + s2;\n        String str2 = \"aabb\";\n        String str3 = \"aa\" + \"bb\";\n        System.out.println(str0 == str1);\n        System.out.println(str1 == str2);\n        System.out.println(str2 == str3);\n        ...\n    }\n}\n输出结果：\nfalse\nfalse\ntrue\n```\n\n首先，对于 str3 来说，编译期会优化成 “aabb”，因此只有它与 str2 是同一个对象。\n\n对于 str0 和 str1 来说，会被编译器会优化成 new StringBuilder().append(\"aa\").append(\"bb\").toString();\n\nStringBuilder 里面的 append 方法就是对 char 数组进行操作，查看 StringBuilder 的 toString 方法：\n\n```java\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    /**\n     * The value is used for character storage.\n     */\n    char[] value;\n    \n    ...\n\n    @Override\n    public String toString() {\n        // Create a copy, don't share the array\n        return new String(value, 0, count);\n    }\n    \n    ...\n}\n```\n\n再看 String 的这个构造方法：\n\n```java\npublic String(char value[], int offset, int count) {\n    if (offset \u003c 0) {\n        throw new StringIndexOutOfBoundsException(offset);\n    }\n    if (count \u003c= 0) {\n        if (count \u003c 0) {\n            throw new StringIndexOutOfBoundsException(count);\n        }\n        if (offset \u003c= value.length) {\n            this.value = \"\".value;\n            return;\n        }\n    }\n    // Note: offset or count might be near -1\u003e\u003e\u003e1.\n    if (offset \u003e value.length - count) {\n        throw new StringIndexOutOfBoundsException(offset + count);\n    }\n    this.value = Arrays.copyOfRange(value, offset, offset+count);\n}\n```\n\n它关键做了如下操作：\n\n- 根据参数\u003cstrong\u003e复制一份\u003c/strong\u003e char 数组对象。\n- 创建一个 String 对象，String 对象的 value 指向复制的 char 数组对象。\n\n也就是说 str1 指向的 String 对象的 value 值直接指向了一个已经存在的数组，而且没有驻留到字符串常量池，而 str2 指向的对象驻留到字符串常量池里面去了。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121345.png)\n\n因此 str0、str1 和 str2 都是指向不同的对象，并且分别指向不同的 char 数组对象。下图再次验证：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121351.png)\n\n### String.intern() 方法\n\n上面说到，调用 StringBuilder 的 toString 方法创建的 String 对象是不会驻留到字符串常量池的，那还有没有办法将这个对象驻留到字符串常量池呢？有的，这就是 String.intern 方法的作用。\n\n以这段代码为例：\n\n```java\nString s1 = \"aa\";\nString s2 = \"bb\";\nString str = s1 + s2;\nstr.intern();\n```\n\n在执行 str.intern() 之前，内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121400.png)\n\n在执行 str.intern();之后，内存布局如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-Memory/clipboard_20230323_121406.png)\n\nintern 方法就是创建了一个 HashtableEntry 对象，并把 value 指向 String 对象，然后把 HashtableEntry 通过 hash 定位存到对应的字符串成常量池中。当然，前提是字符串常量池中原来没有对应的 HashtableEntry。如果字符串常量池中已经有对应的 HashtableEntry，则返回 HashtableEntry 的 value，即它所对应 String 对象的地址。\n\n#### 版本区别\n\nJDK6 中，将字符串对象尝试放入字符串常量池中：\n\n如果字符串常量池中有，则不会放入，并返回已有的字符串常量池中的对象。\n\n如果没有，会把此对象复制一份，返回字符串池常量池，并返回字符串常量池的地址。\n\nJDK7 开始，将字符串对象尝试放入字符串池常量池中：\n\n如果字符串常量池中有，则不会放入，并返回已有的字符串常量池中的对象。\n\n如果没有，会把对象的引用地址复制一份，放入字符串常量池中，并返回字符串常量池中的引用地址。\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["JVM","内存区域","内存布局","Java"]},"/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B":{"title":"JVM 字节码指令简介","content":"Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码）以及跟随其后的零至多个代表此操作所需的参数（操作数）构成。\n\n在 Java 虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。比如， iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在 Class 文件中它们必须拥有各自独立的操作码。\n\n编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展为相应的 int 类型数据。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的对 int 类型作为运算类型来进行的。\n\n### 加载和存储指令\n\n加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。这些指令如下：\n\n- 将一个局部变量加载到操作栈:iload、iload_、lload、lload_、fload、fload_、dload、dload_、aload、aload_\n- 将一个数值从操作数栈存储到局部变量表:istore、istore_、lstore、lstore_、fstore、fstore_、dstore、dstore_、astore、astore_\n- 将一个常量加载到操作数栈:bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_、lconst_、fconst_、dconst_\n- 扩充局部变量表的访问索引的指令:wide\n\n### 运算指令\n\n算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。\n\n- 加法指令:iadd、ladd、fadd、dadd\n- 减法指令:isub、lsub、fsub、dsub\n- 乘法指令:imul、lmul、fmul、dmul\n- 除法指令:idiv、ldiv、fdiv、ddiv\n- 求余指令:irem、lrem、frem、drem\n- 取反指令:ineg、lneg、fneg、dneg\n- 位移指令:ishl、ishr、iushr、lshl、lshr、lushr\n- 按位或指令:ior、lor ·按位与指令:iand、land\n- 按位异或指令:ixor、lxor ·局部变量自增指令:iinc\n- 比较指令:dcmp g、dcmp l、fcmp g、fcmp l、lcmp\n\n### 类型转换指令\n\n类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码的显示类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。\n\nJava 虚拟机直接支持以下数值类型的宽化类型转换：\n\n- int 类型到 long、float 或者 double 类型\n- long 类型到 float、double 类型\n- float 类型到 double 类型\n\n相对的，处理窄化类型转换时，就必须显示地使用转换指令来完成：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l 和 d2f\n\n在将 int 或 long 类型窄化转换为整数类型 T 的时候，转换过程仅仅是简单丢弃除最低位 N 字节以外的内容，N 是类型 T 的数据类型长度，这将可能导致转换结果与输入值有不同的正负号（把前面的符号位给舍去了）。\n\n### 对象创建与访问指令\n\n虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素。\n\n- 创建类实例的指令:new\n- 创建数组的指令:new array 、anew array 、mult ianew array\n- 访问类字段(static 字段，或者称为类变量)和实例字段(非 static 字段，或者称为实例变量)的 指令:getfield、putfield、getstatic、putstatic\n- 把一个数组元素加载到操作数栈的指令:baload、caload、saload、iaload、laload、faload、 daload、aaload\n- 将一个操作数栈的值储存到数组元素中的指令:bastore、castore、sastore、iastore、fastore、 dastore、aastore\n- 取数组长度的指令:array lengt h - 检查类实例类型的指令:inst anceof、checkcast\n\n### 操作数栈管理指令\n\n如同操作一个普通数据结构中的堆栈那样，Java 虚拟机提供了一些用于直接操作操作数栈的指令：\n\n- 将操作数栈的栈顶一个或两个元素出栈:p op 、p op 2\n- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶:dup 、dup 2、dup _x1、 dup 2_x1、dup _x2、dup 2_x2\n- 将栈最顶端的两个数值互换:swap\n\n### 控制转移指令\n\n控制转移指令可以让 Java 虚拟机有条件或无条件地从指定位置指令(而不是控制转移指令)的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改 PC 寄存器的值。\n\n- 条件分支:ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq 和 if_acmpne\n- 复合条件分支:tableswitch、lookupswitch\n- 无条件分支:goto、goto_w、jsr、jsr_w、ret\n\n与前面的算术运算的规则一致，对于 boolean、byte、char 和 short 类型的条件分支比较操作，都使用 int 类型的比较指令完成，而对于 long、float 和 double 类型的条件分支比较操作，则会先执行相应类型的比较运算指令，预算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。因此，各种类型的比较最终都会转换为 int 类型的比较操作。\n\n### 方法调用和返回指令\n\n方法调用：分派、执行过程。\n\n- invokevirt ual 指令:用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)， 这也是 Java 语言中最常见的方法分派方式。\n- invokeinterface 指令:用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找 出适合的方法进行调用。\n- invokespecial 指令:用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和 父类方法。\n- invokestatic 指令:用于调用类静态方法(static 方法)。\n- invokedynamic 指令:用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。前面 四条调用指令的分派逻辑都固化在 Java 虚拟机内部，用户无法改变，而 invokedy namic 指令的分派逻辑 是由用户所设定的引导方法决定的。\n\n方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、dreturn 和 areturn，另外还有一条 return 指令供声明为 void 的方法、实例初始化方法、类和接口的类初始化方法使用。\n\n### 异常处理指令\n\n在 Java 程序中显式抛出异常的操作(throw 语句)都由 athrow 指令来实现，除了用 throw 语句显式抛出异常的情况之外，《Java 虚拟机规范》还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状态时自动抛出。例如整数运算中，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出 ArithmeticException 异常。\n\n而在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（很久之前曾经使用 jsr 和 ret 指令来实现，现在已经不用了），而是采用异常表来完成。\n\n### 10. 同步指令\n\nJava 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来实现的。\n\n方法级的同步是隐式的，无法通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否被声明为同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。\n\n同步一段指令集序列通常是由 Java 语言中的 synchronized 语句块来表示，Java 虚拟机的指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义，正确实现 synchronized 关键字需要 javac 编译器与 Java 虚拟机两者共同协作支持。\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["JVM","字节码","Java"]},"/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90":{"title":"JVM 字节码结构分析","content":"# 概述\n\n提到字节码，首先想到的就是 Java，Java 之所以可以“一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class 文件）供 JVM 使用。\n\n​其实不止是 Java，其他很多编程语言如 Scala、Kotlin 和 Groovy 等都是运行在 JVM 的语言，因此它们对应的编译器也能够生成 .class 字节码。\n\n源代码中的各种变量，关键字和运算符号的语义最终都会编译成多条字节码命令。而字节码命令所能提供的语义描述能力是要明显强于 Java 本身的，所以有其他一些同样基于 JVM 的语言能提供许多 Java 所不支持的语言特性。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124332.png)\n\n在 Java 中一般是用 javac 命令编译源代码为字节码文件，一个 .java 文件从编译到运行的示例如下。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124336.png)\n\nJVM 的指令由一个字节长度的操作码（opcode）和紧随其后的可选的操作数（operand）构成。“字节码”这个名字的由来也是因为操作码的长度用一个字节表示。\n\n`\u003copcode\u003e [\u003coperand1\u003e, \u003coperand2\u003e]`\n\n比如将整型常量 100 压栈到栈顶的指令是 “bipush 100”，其中 bipush 就是操作码，100 就是操作数。\n\n因为操作码长度只有 1 个字节长度，这使得编译后的字节码文件非常小巧紧凑，但同时也直接限制了整个 JVM 操作码指令集的数量最多只能有 256 个，目前已经使用了 200+。\n\n大部分字节码指令都包含了所要操作的类型信息。比如 “ireturn” 用于返回一个 int 类型的数据，“dreturn” 用于返回一个 double 类型的的数据，“freturn” 指令用于返回一个 float 类型的数据，这种方式也使得字节码实际的指令类型远小于 200 个。\n\n字节码使用大端序（Big-Endian）表示，即高位在前，低位在后的方式，比如字节码 “getfield 00 02”，表示的是 “getfiled 0x00\u003c\u003c8 | 0x02（getfield #2)”。\n\n字节码并不是某种虚拟 CPU 的机器码，而是一种介于源码和机器码中间的一种抽象表示方法，不过字节码通过 JIT（Just in time）技术可以被进一步编译成机器码。\n\n# 字节码结构\n\n根据 Java 虚拟机规范，Class 文件通过 \u003cstrong\u003eClassFile\u003c/strong\u003e 定义，有点类似 C 语言的结构体。\n\nClassFile 的结构如下：\n\n```plain text\nClassFile {\n    u4             magic; //魔数\n    u2             minor_version;//小版本号\n    u2             major_version;//大版本号\n    u2             constant_pool_count;//常量数量\n    cp_info        constant_pool[constant_pool_count-1];//常量池\n    u2             access_flags;//类访问标记\n    u2             this_class;//当前类\n    u2             super_class;//父类\n    u2             interfaces_count;//接口数量\n    u2             interfaces[interfaces_count];//接口表\n    u2             fields_count;//字段数量\n    field_info     fields[fields_count];//字段表\n    u2             methods_count;//方法数量\n    method_info    methods[methods_count];//方法表\n    u2             attributes_count;//属性数量\n    attribute_info attributes[attributes_count];//属性表\n}\n```\n\n可以看出，class 文件由下面十个部分组成：\n\n- 魔数（Magic Number）\n- 版本号（Minor\u0026Major Version）\n- 常量池（Constant Pool）\n- 类访问标记(Access Flags)\n- 类索引（This Class）\n- 超类索引（Super Class）\n- 接口表索引（Interfaces）\n- 字段表（Fields）\n- 方法表（Methods）\n- 属性表（Attributes）\n\n它们的按照以下顺序进行排放：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124342.png)\n\n《Optimizing Java》的作者编了一句顺口溜帮忙记住上面这十部分：\"My Very Cute Animal Turns Savage In Full Moon Areas.\"\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124346.png)\n\n以下面这个类为例：\n\n```java\npublic class ByteCodeDemo {\n   private int a = 1;\n\n   public int add() {\n      int b = 2;\n      int c = a + b;\n      System.out.println(c);\n      return c;\n   }\n}\n```\n\n编译生成的字节码如下：\n\n```plain text\n➜  Test hexdump ByteCodeDemo.class\n0000000 ca fe ba be 00 00 00 34 00 24 0a 00 06 00 16 09\n0000010 00 05 00 17 09 00 18 00 19 0a 00 1a 00 1b 07 00\n0000020 1c 07 00 1d 01 00 01 61 01 00 01 49 01 00 06 3c\n0000030 69 6e 69 74 3e 01 00 03 28 29 56 01 00 04 43 6f\n0000040 64 65 01 00 0f 4c 69 6e 65 4e 75 6d 62 65 72 54\n0000050 61 62 6c 65 01 00 12 4c 6f 63 61 6c 56 61 72 69\n0000060 61 62 6c 65 54 61 62 6c 65 01 00 04 74 68 69 73\n0000070 01 00 0e 4c 42 79 74 65 43 6f 64 65 44 65 6d 6f\n0000080 3b 01 00 03 61 64 64 01 00 03 28 29 49 01 00 01\n0000090 62 01 00 01 63 01 00 0a 53 6f 75 72 63 65 46 69\n00000a0 6c 65 01 00 11 42 79 74 65 43 6f 64 65 44 65 6d\n00000b0 6f 2e 6a 61 76 61 0c 00 09 00 0a 0c 00 07 00 08\n00000c0 07 00 1e 0c 00 1f 00 20 07 00 21 0c 00 22 00 23\n00000d0 01 00 0c 42 79 74 65 43 6f 64 65 44 65 6d 6f 01\n00000e0 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65\n00000f0 63 74 01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 53\n0000100 79 73 74 65 6d 01 00 03 6f 75 74 01 00 15 4c 6a\n0000110 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65\n0000120 61 6d 3b 01 00 13 6a 61 76 61 2f 69 6f 2f 50 72\n0000130 69 6e 74 53 74 72 65 61 6d 01 00 07 70 72 69 6e\n0000140 74 6c 6e 01 00 04 28 49 29 56 00 21 00 05 00 06\n0000150 00 00 00 01 00 02 00 07 00 08 00 00 00 02 00 01\n0000160 00 09 00 0a 00 01 00 0b 00 00 00 38 00 02 00 01\n0000170 00 00 00 0a 2a b7 00 01 2a 04 b5 00 02 b1 00 00\n0000180 00 02 00 0c 00 00 00 0a 00 02 00 00 00 01 00 04\n0000190 00 02 00 0d 00 00 00 0c 00 01 00 00 00 0a 00 0e\n00001a0 00 0f 00 00 00 01 00 10 00 11 00 01 00 0b 00 00\n00001b0 00 5c 00 02 00 03 00 00 00 12 05 3c 2a b4 00 02\n00001c0 1b 60 3d b2 00 03 1c b6 00 04 1c ac 00 00 00 02\n00001d0 00 0c 00 00 00 12 00 04 00 00 00 05 00 02 00 06\n00001e0 00 09 00 07 00 10 00 08 00 0d 00 00 00 20 00 03\n00001f0 00 00 00 12 00 0e 00 0f 00 00 00 02 00 10 00 12\n0000200 00 08 00 01 00 09 00 09 00 13 00 08 00 02 00 01\n0000210 00 14 00 00 00 02 00 15\n0000218\n```\n\n通过反编译后可得到如下信息：\n\n```plain text\n➜  Test javap -v ByteCodeDemo\nClassfile /Users/Jie/IdeaProjects/Test/out/production/Test/ByteCodeDemo.class\n  Last modified 2021年8月30日; size 536 bytes\n  MD5 checksum aa05281ffe821ab9f1e1c192a69a5688\n  Compiled from \"ByteCodeDemo.java\"\npublic class ByteCodeDemo\n  minor version: 0\n  major version: 52\n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER\n  this_class: #5                          // ByteCodeDemo\n  super_class: #6                         // java/lang/Object\n  interfaces: 0, fields: 1, methods: 2, attributes: 1\nConstant pool:\n   #1 = Methodref          #6.#22    // java/lang/Object.\"\u003cinit\u003e\":()V\n   #2 = Fieldref           #5.#23    // ByteCodeDemo.a:I\n   #3 = Fieldref           #24.#25   // java/lang/System.out:Ljava/io/PrintStream;\n   #4 = Methodref          #26.#27   // java/io/PrintStream.println:(I)V\n   #5 = Class              #28       // ByteCodeDemo\n   #6 = Class              #29       // java/lang/Object\n   #7 = Utf8               a\n   #8 = Utf8               I\n   #9 = Utf8               \u003cinit\u003e\n  #10 = Utf8               ()V\n  #11 = Utf8               Code\n  #12 = Utf8               LineNumberTable\n  #13 = Utf8               LocalVariableTable\n  #14 = Utf8               this\n  #15 = Utf8               LByteCodeDemo;\n  #16 = Utf8               add\n  #17 = Utf8               ()I\n  #18 = Utf8               b\n  #19 = Utf8               c\n  #20 = Utf8               SourceFile\n  #21 = Utf8               ByteCodeDemo.java\n  #22 = NameAndType        #9:#10         // \"\u003cinit\u003e\":()V\n  #23 = NameAndType        #7:#8          // a:I\n  #24 = Class              #30            // java/lang/System\n  #25 = NameAndType        #31:#32        // out:Ljava/io/PrintStream;\n  #26 = Class              #33            // java/io/PrintStream\n  #27 = NameAndType        #34:#35        // println:(I)V\n  #28 = Utf8               ByteCodeDemo\n  #29 = Utf8               java/lang/Object\n  #30 = Utf8               java/lang/System\n  #31 = Utf8               out\n  #32 = Utf8               Ljava/io/PrintStream;\n  #33 = Utf8               java/io/PrintStream\n  #34 = Utf8               println\n  #35 = Utf8               (I)V\n{\n  public ByteCodeDemo();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1  // Method java/lang/Object.\"\u003cinit\u003e\":()V\n         4: aload_0\n         5: iconst_1\n         6: putfield      #2  // Field a:I\n         9: return\n      LineNumberTable:\n        line 1: 0\n        line 2: 4\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      10     0  this   LByteCodeDemo;\n\n  public int add();\n    descriptor: ()I\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: iconst_2\n         1: istore_1\n         2: aload_0\n         3: getfield      #2 // Field a:I\n         6: iload_1\n         7: iadd\n         8: istore_2\n         9: getstatic     #3 // Field java/lang/System.out:Ljava/io/PrintStream;\n        12: iload_2\n        13: invokevirtual #4 // Method java/io/PrintStream.println:(I)V\n        16: iload_2\n        17: ireturn\n      LineNumberTable:\n        line 5: 0\n        line 6: 2\n        line 7: 9\n        line 8: 16\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      18     0  this   LByteCodeDemo;\n            2      16     1     b   I\n            9       9     2     c   I\n}\nSourceFile: \"ByteCodeDemo.java\"\n```\n\n反编译的过程将看似毫无规律的十六进制数字还原出了更直观易懂的信息，可见字节码的生成必然遵循着某个固定而特殊的规律，下面将一一对它们进行解析。\n\n## 魔数（Magic Number）\n\n.class 文件的头四个字节称为魔数（Magic Number），可以看到 .class 的魔数为 0xCAFEBABE。很多文件都以魔数来进行文件类型的区分，比如 PDF 文件的魔数是 %PDF-(16 进制 0x255044462D)，png 文件的魔数是\\x89PNG（0x89504E47）。文件格式的制定者可以自由的选择魔数值，只要魔数值还没有被广泛的采用过且不会引起混淆即可。\n\n魔数放在文件开头，JVM 可以根据文件的开头来判断这个文件是否可能是一个 .class 文件，如果是，才会继续进行之后的操作。\n\n## 版本号（Minor \u0026 Major Version）\n\n版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。上面示例中版本号对应的字节码为“00 00 00 34”，次版本号转化为十进制为 0，主版本号转化为十进制为 52，对应的主版本号为 1.8，所以编译该文件的 Java 版本号为 1.8.0（每次 Java 发布大版本时，主版本号加 1）。\n\n## 常量池（Constant Pool）\n\n紧接着主版本号之后的字节为常量池入口。常量池整体上分为两部分：常量池计数器（存储常量池大小计数）以及常量池数据区（存储常量池项），如下图所示。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124353.png)\n\n### 常量池计数器（constant_pool_count）\n\n由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。本文示例中的代码常量池计数对应的字节码为“00 24”，将十六进制的 24 转化为十进制值为 36，排除掉下标“0”，也就是说，这个类文件中共有 35 个常量。\n\n### 常量池数据区（constant_pool[constant_pool_count-1]）\n\n常量池项中存储两类常量：字面量与符号引用。字面量如声明为 Final 的常量值和文本字符串等，符号引用分为类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。\n\n数据区是由（constant_pool_count-1）个 cp_info 结构组成，一个 cp_info 结构对应一个常量。\n\n目前在字节码中共有 14 种类型的 cp_info（如下图所示），每种类型的结构都是固定的。\n\n| 类型                             | 标志（tag） | 描述                 |\n| -------------------------------- | ----------- | -------------------- |\n| CONSTANT_utf8_info               | 1           | UTF-8 编码的字符串   |\n| CONSTANT_Integer_info            | 3           | 整形字面量           |\n| CONSTANT_Float_info              | 4           | 浮点型字面量         |\n| CONSTANT_Long_info               | ５          | 长整型字面量         |\n| CONSTANT_Double_info             | ６          | 双精度浮点型字面量   |\n| CONSTANT_Class_info              | ７          | 类或接口的符号引用   |\n| CONSTANT_String_info             | ８          | 字符串类型字面量     |\n| CONSTANT_Fieldref_info           | ９          | 字段的符号引用       |\n| CONSTANT_Methodref_info          | 10          | 类中方法的符号引用   |\n| CONSTANT_InterfaceMethodref_info | 11          | 接口中方法的符号引用 |\n| CONSTANT_NameAndType_info        | 12          | 字段或方法的符号引用 |\n| CONSTANT_MothodType_info         | 16          | 方法类型             |\n| CONSTANT_MethodHandle_info       | 15          | 方法句柄             |\n| CONSTANT_InvokeDynamic_info      | 18          | 动态方法调用点       |\n\n具体以 CONSTANT_utf8_info 为例，它的结构如下图所示。首先一个字节“tag”，它的值取自上图中对应项的 Tag，由于它的类型是 utf8_info，所以值为“01”。接下来两个字节标识该字符串的长度 Length，然后 Length 个字节为这个字符串具体的值。\n\n从前文示例中的字节码摘取一个 cp_info 结构，如下图所示。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124358.png)\n\n将它翻译过来后，其含义为：该常量类型为 utf8 字符串，长度为一字节，数据为“a”。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124404.png)\n\n下面来逐一详细介绍这些常量池项。\n\n#### CONSTANT_Utf8_info\n\nCONSTANT_Utf8_info 存储的是经过 MUTF-8(modified UTF-8) 编码的字符串，结构如下:\n\n```plain text\nCONSTANT_Utf8_info {\n    u1 tag;\n    u2 length;\n    u1 bytes[length];\n}\n```\n\n它由三部分构成：\n\n1. 第一部分 tag 值为固定为 1\n2. 第二部分 length 表示字符串的长度\n3. 第三部分是采用 MUTF-8 编码的长度为 length 的字节数组\n\n如果要存储的字符串是\"hello\"，存储结构如下图所示\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124834.png)\n\nMUTF-8 编码与标准的 UTF-8 编码大部分情况下是相同的，但也有一些细微的区别，比如在 MUTF-8 里空字符(\"\\u0000\")用两个字节 0xC080 表示，而在标准的 UTF-8 编码里的表述方式为 0x00，还有一些其它的差异这里不做深入的展开。\n\n#### CONSTANT_Integer_info 和 CONSTANT_Float_info\n\n这两种结构分别用来表示 int 和 float 类型的常量，这两种类型的结构很类似，都用四个字节来表示具体的数值常量，它们的结构定义如下：\n\n```plain text\nCONSTANT_Integer_info {\n    u1 tag;\n    u4 bytes;\n}\nCONSTANT_Float_info {\n    u1 tag;\n    u4 bytes;\n}\n```\n\n以整型常量 18(0x12) 为例，它在常量池中的布局结构如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124910.png)\n\nJava 语言规范还定义了 boolean、byte、short 和 char 类型的变量，在常量池中都会被当做 int 来处理，比如用代码定义了下面的常量：\n\n```plain text\npublic class MyConstantTest {\n    public final boolean bool = true; //  1(0x01)\n    public final char c = 'A';        // 65(0x41)\n    public final byte b = 66;         // 66(0x42)\n    public final short s = 67;        // 67(0x43)\n    public final int i = 68;          // 68(0x44)\n}\n```\n\n编译生成的 class 文件如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124929.png)\n\n#### CONSTANT_Long_info 和 CONSTANT_Double_info\n\n这两种结构分别用来表示 long 和 double 类型的常量，这两个结构类似，都用 8 个字节表示具体的常量数值。它们的结构如下：\n\n```plain text\nCONSTANT_Long_info {\n    u1 tag;\n    u4 high_bytes;\n    u4 low_bytes;\n}\n\nCONSTANT_Double_info {\n    u1 tag;\n    u4 high_bytes;\n    u4 low_bytes;\n}\n```\n\n对应的结构如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_124949.png)\n\n以下面的代码为例\n\n```plain text\npublic class HelloWorldMain {\n    public final long a = Long.MAX_VALUE; \n}\n```\n\njavap 输出的常量池信息如下：\n\n```plain text\nConstant pool:\n   #1 = Methodref          #7.#17         // java/lang/Object.\"\u003cinit\u003e\":()V\n   #2 = Class              #18            // java/lang/Long\n   #3 = Long               9223372036854775807l\n   #5 = Fieldref           #6.#19         // HelloWorldMain.a:J\n```\n\n前面提到过，CONSTANT_Long_info 和 CONSTANT_Double_info 占用两个常量池位置，可以看到常量 a 占用了 #3 和 #4 两个位置，下一个常量从索引值 5 开始。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125043.png)\n\n#### CONSTANT_Class_info\n\nCONSTANT_Class_info 结构用来表示类或接口，它的结构如下：\n\n```plain text\nCONSTANT_Class_info {\n    u1 tag;\n    u2 name_index;\n}\n```\n\n它由两部分组成，第一个字节是 tag，值为 7，tag 后面的两个字节 name_index 是一个常量池索引，指向类型为 CONSTANT_Utf8_info 常量，这个字符串存储的是类或接口的全限定名。如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125114.png)\n\n#### CONSTANT_String_info\n\nCONSTANT_String_info 用来表示 java.lang.String 类型的常量对象，同样由两部分构成：\n\n```plain text\nCONSTANT_String_info {\n    u1 tag;\n    u2 string_index;\n}\n```\n\n第一个字节是 tag，值为 8，tag 后面的两个字节是一个叫 string_index 的索引值，指向常量池中的 CONSTANT_Utf8_info，这个 CONSTANT_Utf8_info 中存储的才是真正的字符串常量。\n\n以下面的代码为例：\n\n```java\npublic class HelloWorldMain {\n    private String a = \"hello\";\n}\n```\n\nCONSTANT_String_info 的存储布局方式为：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125138.png)\n\n#### CONSTANT_Fieldref_info、CONSTANT_Methodref_info 和 CONSTANT_InterfaceMethodref_info\n\n这三种常量类型结构比较类似\n\n```plain text\nCONSTANT_Fieldref_info {\n    u1 tag;\n    u2 class_index;\n    u2 name_and_type_index;\n}\n\nCONSTANT_Methodref_info {\n    u1 tag;\n    u2 class_index;\n    u2 name_and_type_index;\n}\n\nCONSTANT_InterfaceMethodref_info {\n    u1 tag;\n    u2 class_index;\n    u2 name_and_type_index;\n}\n```\n\n下面以 CONSTANT_Methodref_info 为例来介绍如何描述一个方法。\n\n方法 = 方法所属的类 + 方法名 + 方法参数和返回值描述符\n\n这就是 CONSTANT_Methodref_info 的作用，它表示类中方法的符号引用\n\n它由三部分构成\n\n- 第一部分也是 tag，值为 10\n- 第二个部分是 class_index，是一个指向 CONSTANT_Class_info 的常量池索引值\n- 第三部分是 name_and_type_index，是一个指向 CONSTANT_NameAndType_info 的常量池索引值，表示方法的参数类型和返回值的签名\n\n```java\npublic class HelloWorldMain {\n    public static void main(String[] args) {\n        new HelloWorldMain().testMethod(1, \"hi\");\n    }\n    public void testMethod(int id, String name) {\n    }\n}\n```\n\nConstant pool:\n\n```plain text\n   #2 = Class              #18            // HelloWorldMain\n   #5 = Methodref          #2.#20         // HelloWorldMain.testMethod:(ILjava/lang/String;)V\n  #20 = NameAndType        #13:#14        // testMethod:(ILjava/lang/String;)V\n```\n\n结构布局示意图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125200.png)\n\n#### CONSTANT_NameAndType_info\n\nCONSTANT_NameAndType_info 结构用来表示字段或者方法，格式如下：\n\n```plain text\nCONSTANT_NameAndType_info {\n    u1 tag;\n    u2 name_index;\n    u2 descriptor_index;\n}\n```\n\n它由三部分组成：\n\n- tag : 值为 12\n- name_index : 指向常量池中的 CONSTANT_Utf8_info，存储的是字段名或者方法名\n- descriptor_index : 也是指向常量池中的 CONSTANT_Utf8_info，存储的是字段描述符或者方法描述符\n\n以下面的方法为例：\n\n```java\npublic void testMethod(int id, String name) {\n}\n```\n\nCONSTANT_NameAndType_info 的结构布局示意图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125221.png)\n\n#### CONSTANT_MethodType_info、CONSTANT_MethodHandle_info 和 CONSTANT_InvokeDynamic_info\n\n从 JDK1.7 开始，为了更好的支持动态语言调用，新增了以上 3 种常量池类型。\n\n以 CONSTANT_InvokeDynamic_info 为例，它主要为 invokedynamic 指令提供启动引导方法，它由三部分构成：\n\n```plain text\nCONSTANT_InvokeDynamic_info {\n    u1 tag;\n    u2 bootstrap_method_attr_index;\n    u2 name_and_type_index;\n}\n```\n\n- tag：值为 18\n- bootstrap_method_attr_index：指向引导方法表 bootstrap_methods[] 数组的索引\n- name_and_type_index：指向索引类常量池里 CONSTANT_NameAndType_info，表示方法描述符\n\n比如下面的的代码：\n\n```java\npublic void foo() {\n    new Thread (()-\u003e {\n        System.out.println(\"hello\");\n    }).start();\n}\n```\n\njavap 输出的常量池的部分如下：\n\n```plain text\nConstant pool:\n   #3 = InvokeDynamic      #0:#25         // #0:run:()Ljava/lang/Runnable;\n   ...\n  #25 = NameAndType        #37:#38        // run:()Ljava/lang/Runnable;\n\nBootstrapMethods:\n  0: #22 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #23 ()V\n      #24 invokestatic HelloWorldMain.lambda$foo$0:()V\n      #23 ()V\n```\n\n整体的结构如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125251.png)\n\n## 类访问标记(Access Flags)\n\n常量池之后存储的是访问标记（Access flags），用来标识一个类是是不是 final、abstract 等，由两个字节表示总共可以有 16 个标记位可供使用，目前只使用了其中的 8 个。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125310.png)\n\n具体的标记位含义如下\n\n| Flag Name      | Value | Interpretation                         |\n| -------------- | ----- | -------------------------------------- |\n| ACC_PUBLIC     | 1     | 标识是否是 public                      |\n| ACC_FINAL      | 10    | 标识是否是 final                       |\n| ACC_SUPER      | 20    | 已经不用了                             |\n| ACC_INTERFACE  | 200   | 标识是类还是接口                       |\n| ACC_ABSTRACT   | 400   | 标识是否是 abstract                    |\n| ACC_SYNTHETIC  | 1000  | 编译器自动生成，不是用户源代码编译生成 |\n| ACC_ANNOTATION | 2000  | 标识是否是注解类                       |\n| ACC_ENUM       | 4000  | 标识是否是枚举类                       |\n\nJVM 并没有穷举所有的访问标志，而是使用按位或操作来进行描述的，比如某个类的修饰符为 Public Final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010=0x0011。\n\n## 类索引（This Class）、超类索引（Super Class）和接口表索引（Interfaces）\n\n这三个部分用来确定类的继承关系，this_class 表示类索引，super_name 表示父类索引，interfaces 表示类或者接口的直接父接口。以 this_class 为例，它是一个两字节组成，执行常量池。\n\n以下面代码为例：\n\n```java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World\");\n    }\n}\n```\n\nthis_class 为 0x0005，指向常量池中下标为 5 的元素，这个元素是由两部分组成，第一部分是类型，这里是 Class 表示是一个类，第二部分是指向常量池下标 21 的元素，这个元素是字符串 \"HelloWorldMain\"。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125327.png)\n\nsuper_class 和 interfaces 的原理与之类似。\n\n## 字段表（Fields）\n\n### 字段表概述\n\n紧随接口索引表之后的是字段表（Fields），类中定义的字段会被存储到这个集合中，包括类中定义的静态和非静态的字段，不包括方法内部定义的变量。\n\n结构如下:\n\n```java\n{\n    u2             fields_count;\n    field_info     fields[fields_count];\n}\n```\n\n由两部分组成\n\n- 字段数量（fields_count）：字段表也是一个变长的结构，类中定义的若干个字段的个数会被存储到字段数量里。\n- 字段集合（fields）：字段集合是一个类数组的结构，共有 fields_count 个，对应类中定义的若干个字段，每一个字段 field_info 的结构会在下面介绍。\n\n如下图所示:\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125345.png)\n\n### 字段结构\n\n每个字段（field_info）的格式如下：\n\n```plain text\nfield_info {\n    u2             access_flags; \n    u2             name_index;\n    u2             descriptor_index;\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n字段结构分为四部分：\n\n- access_flags：字段的访问标记。是 public、private 还是 protected，是否是 static，是否是 final 等。\n- name_index：字段名的索引值，指向常量池的的字符串常量。\n- descriptor_index：字段描述符的索引，指向常量池的字符串常量。\n- attributes_count、attribute_info：属性的个数和属性集合。\n\n这些组成部分接下来的会有详细介绍。\n\n### 字段访问标记\n\n与类一样，字段也拥有自己的字段访问标记，不过要比类的访问标记要更丰富一些，共有 9 种，详细的列表如下：\n\n| 访问标记名    | 十六进制值 | 描述                                                      |\n| ------------- | ---------- | --------------------------------------------------------- |\n| ACC_PUBLIC    | 0x0001     | 声明为 public                                             |\n| ACC_PRIVATE   | 0x0002     | 声明为 private                                            |\n| ACC_PROTECTED | 0x0004     | 声明为 protected                                          |\n| ACC_STATIC    | 0x0008     | 声明为 static                                             |\n| ACC_FINAL     | 0x0010     | 声明为 final                                              |\n| ACC_VOLATILE  | 0x0040     | 声明为 volatile，解决内存可见性的问题                     |\n| ACC_TRANSIENT | 0x0080     | 声明为 transient，被 transient 修饰的字段默认不会被序列化 |\n| ACC_SYNTHETIC | 0x1000     | 表示这个字段是由编译器自动生成，而不是用户代码编译产生    |\n| ACC_ENUM      | 0x4000     | 表示这是一个枚举类型的变量                                |\n\n如果在类中定义了如下的字段：\n\n```java\npublic static final int DEFAULT_SIZE = 128;\n```\n\n编译后 DEFAULT_SIZE 字段在类文件中存储的访问标记值为 0x0019，则它的访问标记为 ACC_PUBLIC | ACC_STATIC | ACC_FINAL，表示它是一个 public static final 类型的变量。如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125404.png)\n\n### 字段描述符\n\n当定义一个 int 类型的变量时，类文件中存储的类型并不是字符串的 “int”，而是使用了更精简的 I 来表示。\n\n\u003cstrong\u003e引用类型\u003c/strong\u003e使用 “L;” 的方式来表示为了防止多个连续的引用类型描述符出现混淆，引用类型描述符最后都加上了一个 “;” 作为分隔。比如字符串类型 String 的描述符为  “Ljava/lang/String;\"，\n\nJVM 使用一个前置的 “[” 来表示数组类型，如 int[] 类型描述符为 “[I”，字符串数组 String[] 的描述符为 “[Ljava/lang/String;”。多维数组描述符只是多加了几个 “[” 而已，比如 Object[][][] 类型描述符为 “[[[Ljava/lang/Object;”。\n\n完整的字段类型描述符映射表如下所示：\n\n| 描述符        | 类型                                     |\n| ------------- | ---------------------------------------- |\n| B             | byte 类型                                |\n| C             | char 类型                                |\n| D             | double 类型                              |\n| F             | float 类型                               |\n| I             | int 类型                                 |\n| J             | long 类型                                |\n| S             | short 类型                               |\n| Z             | bool 类型                                |\n| L ClassName ; | 引用类型，\"L\" + 对象类型的全限定名 + \";\" |\n| [             | 一维数组                                 |\n\n### 字段属性表\n\n与字段相关的属性有下面这几个：ConstantValue、Synthetic 、Signature、Deprecated、RuntimeVisibleAnnotations 和 RuntimeInvisibleAnnotations 这六个，比较常见的是 ConstantValue 这属性，用来表示一个常量字段的值。\n\n### 案例分析\n\n以文章开头 ByteCodeDemo 类的字节码中的字段表为例，如下图所示。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125423.png)\n\n0001：字段表计数。实例代码中只有一个字段，故值为 1\n\n剩下为字段属性，一共由四个部分组成：\n\n1. 0002：表示字段的访问标志。对应为 Private\n2. 0007：字段名称。指向常量池中第 7 项：字符 “a”\n3. 0008：字段描述符。指向常量池中第 8 项：字符 “I”（代表 int）\n4. 0000：字段属性个数。没有属性，值为 0\n\n综上，就可以唯一确定出一个类中声明的变量：private int a。\n\n## 方法表（Methods）\n\n### 方法表概述\n\n在字段表后面的是方法表，类中定义的方法会被存储在这里，与前面介绍的字段表很类似，方法表也是一个变长结构：\n\n```java\n{\n    u2             methods_count;\n    method_info    methods[methods_count];\n}\n```\n\n由表示方法个数的 methods_count 和对应个数的方法项集合组成，如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125440.png)\n\n### 方法结构\n\n每个字段（method_info）的格式如下：\n\n```plain text\nmethod_info {\n    u2             access_flags;\n    u2             name_index;\n    u2             descriptor_index;\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n字段结构分为四部分：\n\n- access_flags：方法的访问标记。是 public、private 还是 protected，是否是 static，是否是 final 等。\n- name_index：方法名的索引值，指向常量池的的字符串常量。\n- descriptor_index：方法描述符的索引，指向常量池的字符串常量。\n- attributes_count、attribute_info：属性的个数和属性集合。\n\n### 方法访问标记\n\n方法的访问标记比类和字段的访问标记类型更丰富，有 12 种之多，如下表所示：\n\n| 方法访问标记     | 值     | 描述                                                          |\n| ---------------- | ------ | ------------------------------------------------------------- |\n| ACC_PUBLIC       | 0x0001 | 声明为 public                                                 |\n| ACC_PRIVATE      | 0x0002 | 声明为 private                                                |\n| ACC_PROTECTED    | 0x0004 | 声明为 protected                                              |\n| ACC_STATIC       | 0x0008 | 声明为 static                                                 |\n| ACC_FINAL        | 0x0010 | 声明为 final                                                  |\n| ACC_SYNCHRONIZED | 0x0020 | 声明为 synchronized                                           |\n| ACC_BRIDGE       | 0x0040 | bridge 方法, 由编译器生成                                     |\n| ACC_VARARGS      | 0x0080 | 方法包含可变长度参数，比如 String... args                     |\n| ACC_NATIVE       | 0x0100 | 声明为 native                                                 |\n| ACC_ABSTRACT     | 0x0400 | 声明为 abstract                                               |\n| ACC_STRICT       | 0x0800 | 声明为 strictfp，表示使用 IEEE-754 规范的精确浮点数，极少使用 |\n| ACC_SYNTHETIC    | 0x1000 | 表示这个方法是由编译器自动生成，而不是用户代码编译产生        |\n\n以下面的代码为例：\n\n```java\nprivate static synchronized void foo() {\n}\n```\n\n生成的类文件中 foo 方法的访问标记等于 0x002a（ACC_PRIVATE | ACC_STATIC | ACC_SYNCHRONIZED），，表示这是一个 private static synchronized 的方法，如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125456.png)\n\n### 方法名与描述符\n\n紧随方法访问标记是方法名索引 name_index，指向常量池中 CONSTANT_Utf8_info 类型的字符串常量，比如有这样一个方法定义 “private void foo()”，编译器会生成一个类型为 CONSTANT_Utf8_info 的字符串常量项，里面存储了 “foo”，方法名索引 name_index 指向了这个常量项。\n\n方法描述符索引 descriptor_index，它也是方法名指向常量池中类型为 CONSTANT_Utf8_info 的字符串常量项。方法描述符用来表示一个方法所需参数和返回值，格式为：\n\n(参数 1 类型 参数 2 类型 参数 3 类型 ...)返回值类型\n\n比如方法 “Object foo(int i, double d, Thread t)” 的描述符为“(IDLjava/lang/Thread;)Ljava/lang/Object;”，其中 “I” 表示第一个参数 i 的参数类型 int，“D” 表示第二个参数 d 的类型 double，“Ljava/lang/Thread;” 表示第三个参数 t 的类型 Thread，“Ljava/lang/Object;” 表示返回值类型 Object。\n\n如下图所示:\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125513.png)\n\n### 方法属性表\n\n前面介绍了方法的访问标记、方法签名，还有一些重要的信息没有出现，如方法声明抛出的异常，方法的字节码，方法是否被标记为 deprecated，这些信息存在哪里呢？这就是方法属性表的作用。跟方法相关的属性有很多，其中重要的是 Code 和 Exceptions 属性，其中 Code 属性存放方法体的字节码指令，Exceptions 属性用于存储方法声明抛出的异常。\n\n### 案例分析\n\n还是以文章中 ByteCodeDemo 类的字节码中的字段表为例，如下图所示。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125530.png)\n\n共分为四个部分：\n\n1. 0001：方法访问标记。表示 public\n2. 0010：方法名的索引值。指向第 16 个常量，即 “add”\n3. 0011：方法描述符的索引。指向第 17 个常量，即 ()I（返回值类型为 int）\n4. 0001000b...：属性表。0001 表示只有一个属性，000b 表示属性名称为 “Code”，具体分析见下文\n\n## 属性表（Attributes）\n\n### 属性表概述\n\n在方法表之后的结构是 class 文件的最后一步部分属性表。\u003cstrong\u003e属性出现的地方比较广泛，不止出现在字段和方法中，在 class 文件中也会出现。\u003c/strong\u003e\n\n相比于常量池只有 14 种固定的类型，属性表是的类型是更加灵活的，不同的虚拟机实现厂商可以自定义自己的属性，JVM 运行时会忽略掉它不认识的属性。\n\n属性表的结构如下所示：\n\n```java\n{\n    u2             attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\n与其它结构类似，属性表使用两个字节表示属性的个数 attributes_count，接下来是若干个属性项的集合，可以看做是一个数组，数组的每一项都是一个属性项 attribute_info，数组的大小为 attributes_count。\n\n### 属性结构\n\n每个属性（attribute_info）的格式如下：\n\n```plain text\nattribute_info {\n    u2 attribute_name_index;\n    u4 attribute_length;\n    u1 info[attribute_length];\n}\n```\n\n属性结构分为三部分：\n\n- attribute_name_index：属性名索引\n- attribute_length：属性长度\n- info[attribute_length]：属性数组\n\n属性表其实只是定义了属性的长度，里面还有一个不定长的数组，具体的结构需要自己定义。\n\n### 属性类型\n\n| 属性名称                            | 使用位置           | 含义                                                                                              |\n| ----------------------------------- | ------------------ | ------------------------------------------------------------------------------------------------- |\n| Code                                | 方法表             | Java 代码编译成的字节码指令                                                                       |\n| ConstantValue                       | 字段表             | final 关键字定义的常量池                                                                          |\n| Deprecated                          | 类，方法表，字段表 | 被声明为 deprecated 的方法和字段                                                                  |\n| Exceptions                          | 方法表             | 方法抛出的异常                                                                                    |\n| EnclosingMethod                     | 类文件             | 仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法              |\n| InnerClass                          | 类文件             | 内部类列表                                                                                        |\n| LineNumberTable                     | Code 属性          | Java 源码的行号与字节码指令的对应关系                                                             |\n| LocalVariableTable                  | Code 属性          | 方法的局部变量描述                                                                                |\n| StackMapTable                       | Code 属性          | JDK1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配 |\n| Signature                           | 类，方法表，字段表 | 用于支持泛型情况下的方法签名                                                                      |\n| SourceFile                          | 类文件             | 记录源文件名称                                                                                    |\n| SourceDebugExtension                | 类文件             | 用于存储额外的调试信息                                                                            |\n| Synthetic                           | 类，方法表，字段表 | 标志方法或字段为编译器自动生成的                                                                  |\n| LocalVariableTypeTable              | 类                 | 使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加                          |\n| RuntimeVisibleAnnotations           | 类，方法表，字段表 | 为动态注解提供支持                                                                                |\n| RuntimeInvisibleAnnotations         | 表，方法表，字段表 | 用于指明哪些注解是运行时不可见的                                                                  |\n| RuntimeVisibleParameterAnnotation   | 方法表             | 作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法                                   |\n| RuntimeInvisibleParameterAnnotation | 方法表             | 作用与 RuntimeInvisibleAnnotations 属性类似，作用对象哪个为方法参数                               |\n| AnnotationDefault                   | 方法表             | 用于记录注解类元素的默认值                                                                        |\n| BootstrapMethods                    | 类文件             | 用于保存 invokeddynamic 指令引用的引导方式限定符                                                  |\n\n### ConstantValue 属性\n\nConstantValue 属性只会出现字段 field_info 中，表示静态变量的初始值，它的结构如下：\n\n```plain text\nConstantValue_attribute {\n    u2 attribute_name_index;\n    u4 attribute_length;\n    u2 constantvalue_index;\n}\n```\n\n其中 attribute_name_index 是指向常量池中值为 \"ConstantValue\" 的常量项，ConstantValue 属性的 attribute_length 值恒定为 2，constantvalue_index 指向常量池中具体的常量值索引，根据变量的类型不同 constantvalue_index 指向不同的常量项。\n\n以 “public static final int DEFAULT_SIZE = 128;” 为例，字段对应的 class 文件如下图高亮部分：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125546.png)\n\n它对应的字段结构如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125607.png)\n\n### Code 属性\n\nCode 属性可以说是类文件中最重要的组成部分了，它包含了所有方法的字节码，结构如下：\n\n```plain text\nCode_attribute {\n    u2 attribute_name_index;\n    u4 attribute_length;\n    u2 max_stack;\n    u2 max_locals;\n    u4 code_length;\n    u1 code[code_length];\n    u2 exception_table_length;\n    {   u2 start_pc;\n        u2 end_pc;\n        u2 handler_pc;\n        u2 catch_type;\n    } exception_table[exception_table_length];\n    u2 attributes_count;\n    attribute_info attributes[attributes_count];\n}\n```\n\nCode 属性表的字段含义如下：\n\n- 属性名索引（attribute_name_index）占两个字节，指向常量池中 CONSTANT_Utf8_info 常量，表示属性的名字，比如这里对应的常量池的字符串常量\"Code\"。\n- 属性长度（attribute_length）占用两个字节，表示属性值大小。\n- max_stack 表示操作数栈的最大深度，方法执行的任意期间操作数栈的深度都不会超过这个值。它的计算规则是有入栈的指令 stack 增加，有出栈的指令 stack 减少，在整个过程中 stack 的最大值就是 max_stack 的值，增加和减少的值一般都是 1，但也有例外：LONG 和 DOUBLE 相关的指令入栈 stack 会增加 2，VOID 相关的指令则为 0。\n- max_locals 表示局部变量表的大小，它的值并不是等于方法中所有局部变量的数量之和。当一个局部作用域结束，它内部的局部变量占用的位置就可以被接下来的局部变量复用了。\n- code_length 和 code 用来表示字节码相关的信息，其中 code_length 表示字节码指令的长度，占用 4 个字节。code 是一个长度为 code_length 的字节数组，存储真正的字节码指令。\n- exception_table_length 和 exception_table 用来表示代码内部的异常表信息，如我们熟知的 try-catch 语法就会生成对应的异常表。\n- attributes_count 和 attributes[] 用来表示 Code 属性相关的附属属性，Java 虚拟机规定 Code 属性只能包含这四种可选属性：LineNumberTable、LocalVariableTable、LocalVariableTypeTable、StackMapTable。以 LineNumberTable 为例，LineNumberTable 用来存放源码行号和字节码偏移量之间的对应关系，这 LineNumberTable 属于调试信息，不是类文件运行的必需的属性，默认情况下都会生成。如果没有这两个属性，那么在调试时没有办法在源码中设置断点，也没有办法在代码抛出异常的时候在错误堆栈中显示出错的行号信息。\n\n以下面的代码为例：\n\n```java\npublic static void main(String[] args) {\n    try {\n        foo();\n    } catch (NullPointerException e) {\n        System.out.println();\n    } catch (IOException e) {\n        System.out.println();\n    }\n\n    try {\n        foo();\n    } catch (Exception e) {\n        System.out.println();\n    }\n}\n```\n\n如下图所示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125622.png)\n\n### 案例分析\n\n同样以 ByteCodeDemo 类的字节码为例，如下图所示。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JVM-ByteCode/clipboard_20230323_125755.png)\n\n0001 表示为属性表计数，这里只有一个附加属性。属性表\n\n```plain text\nSourceFile_attribute {\n     u2 attribute_name_index;\n     u4 attribute_length;\n     u2 sourcefile_index;\n}\n```\n\nSourceFile_attribute 一共分为三个部分。\n\n0014：指向第 20 个常量，为 “SourceFile”，说明这个属性是 Source\n\n00000002：表示长度为 2\n\n0015：指向第 21 个常量，即 “ByteCodeDemo.java”\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["JVM","字节码","Java"]},"/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6":{"title":"JVM 类加载机制","content":"# 概述\n\nJVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被 JVM 直接使用的 Java 类型，这个过程被称作 JVM 的类加载机制。\n\n与那些在编译时需要进行连接的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。\n\n# 类加载的时机\n\n一个类型从被加载到虚拟机内存中开始到卸载位置，整个生命周期会经历如下七个阶段，其中验证、准备、解析三个部分统称为连接。\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/ClassLoader/clipboard_20230323_120031.png)\n上图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段后再开始，这是为了支持 Java 语言的运行时半丁特性（也被称为动态绑定或者晚期绑定）。\n\n## 主动引用\n\n关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java 虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java 虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证和准备阶段自然需要在此之前开始）：\n\n- 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这四条指令的场景是：\n\n  - 使用 new 关键字实例化对象的时候。\n  - 读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。\n  - 调用一个类的静态方法的时候。\n- 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。\n- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；\n- 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。\n- 当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\n\n## 被动引用\n\n以上六种场景中的行为称为对一个类型进行主动引用，除此之外所有引用类型的方式都不会触发初始化，被称为被动引用。\n\n```java\npublic class SuperClass {\n    static {\n        System.out.println(\"SuperClass init!\");\n    }\n\n    public static int value = 123;\n}\n\npublic class SubClass extends SuperClass {\n    static {\n        System.out.println(\"SubClass init!\");\n    }\n    \n    public static final String CONS = \"hello\";\n}\n```\n\n- 通过子类引用父类的静态字段，不会导致子类初始化\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(SubClass.value);\n    }\n}\n输出结果：\nSuperClass init!\n123\n```\n\n- 通过数组定义来引用类，不会触发此类的初始化\n\n该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        SuperClass[] sca = new SuperClass[10];\n    }\n}\n没有任何输出\n```\n\n- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(SubClass.CONS);\n    }\n}\n输出结果：\nhello\n```\n\n# 类加载的过程\n\n类加载的过程包含了加载、验证、准备、解析和初始化这 5 个阶段。\n\n## 加载\n\n这里的加载指的是类加载的一个阶段，注意不要混淆。\n\n加载过程完成以下三件事：\n\n- 通过类的\u003cstrong\u003e完全限定名称\u003c/strong\u003e获取定义该类的二进制字节流。\n- 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。\n- 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。\n\n其中二进制字节流可以从以下方式中获取：\n\n- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。\n- 从网络中获取，最典型的应用是 Applet。\n- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。\n- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。\n- 从数据库中读取，这种场景相对比较少见。\n- 从加密文件中获取，这是典型的防 Class 文件被反编译的保护措施，通过加载时解密 Class 文件来保障程序运行逻辑不被窥探。\n\n## 验证\n\n验证流程确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成下面四个阶段的动作。\n\n### 文件格式验证\n\n主要验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。\n\n### 元数据验证\n\n对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java 语言规范》的要求。\n\n### 字节码验证\n\n通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这个阶段就要对类的方法体（Class 文件中的 Code 属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。这个阶段是整个验证过程中最复杂的一个阶段。\n\n### 符号引用验证\n\n这个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配行校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。\n\n符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，JVM 将会抛出异常。\n\n## 准备\n\n准备阶段时正式为类中定义的变量（即被 static 修饰的静态变量）\u003cstrong\u003e分配内存并设置类变量初始值\u003c/strong\u003e的阶段。\n\n实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。\n\n类变量初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。\n\npublic static int value = 123;\n\n把 value 赋值为 123 的 putstatic 指令要到类的初始化阶段中执行类构造器 `\u003cclinit\u003e() `方法时才会被执行。\n\n如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。\n\npublic static final int value = 123;\n\n## 解析\n\n解析阶段是 JVM 将常量池的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行。\n\n解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。\n\n## 初始化\n\n初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 `\u003cclinit\u003e()` 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序制定的主观计划去初始化类变量和其它资源。\n\n- `\u003cclinit\u003e()` 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：\n\n```java\npublic class Test {\n    static {\n        i = 0;                // 给变量赋值可以正常编译通过\n        System.out.print(i);  // 这句编译器会提示“非法向前引用”\n    }\n    static int i = 1;\n}\n```\n\n- 由于父类的 `\u003cclinit\u003e()` 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：\n\n```java\nstatic class Parent {\n    public static int A = 1;\n    static {\n        A = 2;\n    }\n}\n\nstatic class Sub extends Parent {\n    public static int B = A;\n}\n\npublic static void main(String[] args) {\n     System.out.println(Sub.B);  // B 的值为 2\n}\n```\n\n- `\u003cclinit\u003e() `方法对于类或接口来说不是必需的。\n- 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 `\u003cclinit\u003e()` 方法。但接口与类不同的是，执行接口的 `\u003cclinit\u003e()` 方法不需要先执行父接口的 `\u003cclinit\u003e()` 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 `\u003cclinit\u003e()` 方法。\n- 虚拟机会保证一个类的 `\u003cclinit\u003e()` 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 `\u003cclinit\u003e()` 方法，其它线程都会阻塞等待，直到活动线程执行 `\u003cclinit\u003e()` 方法完毕。如果在一个类的 `\u003cclinit\u003e()` 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞往往是很隐蔽的。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/ClassLoader/clipboard_20230323_120337.png)\n\n# 类加载器\n\nJava 虚拟机设计团队有意把了加载阶段中的“通过一个类的全限定名称来获取描述该类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器（Class Loader）”。\n\n## 类与类加载器\n\n对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。\n\n换句话说，虚拟句认定两个类是否相等，除了需要比较类本身相等之外，并且还要判断它们是否使用同一个类加载器进行加载，因为每一个类加载器都拥有一个独立的类名称空间。\n\n这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。\n\n## 类加载器的分类\n\n从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：\n\n- 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；\n- 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。\n\n从 Java 开发人员的角度看，类加载器可以划分得更细致一些：\n\n##### \u003cstrong\u003e启动类加载器（Bootstrap ClassLoader）\u003c/strong\u003e\n\n此类加载器负责将存放在 \u003cJRE_HOME\u003e\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（\u003cstrong\u003e仅按照文件名识别\u003c/strong\u003e，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。\n\n##### \u003cstrong\u003e扩展类加载器（Extension ClassLoader）\u003c/strong\u003e\n\n这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 \u003cJAVA_HOME\u003e/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。\n\n##### \u003cstrong\u003e应用程序类加载器（Application ClassLoader）\u003c/strong\u003e\n\n这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为\u003cstrong\u003e系统类加载器\u003c/strong\u003e。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n## 双亲委派模型\n\n应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。\n\n下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/ClassLoader/clipboard_20230323_120403.png)\n\n### 工作过程\n\n一个类加载器收到加载请求，首先将类加载请求转发到\u003cstrong\u003e父类加载器\u003c/strong\u003e，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类加载器无法完成时，子加载器才尝试自己去加载。\n\n### 优点\n\n1. 避免重复加载。\n2. 防止 Java 核心 api 被篡改\n\n### 实现过程\n\n以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。\n\n```java\npublic abstract class ClassLoader {\n    // The parent class loader for delegation\n    private final ClassLoader parent;\n\n    public Class\u003c?\u003e loadClass(String name) throws ClassNotFoundException {\n        return loadClass(name, false);\n    }\n\n    protected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class\u003c?\u003e c = findLoadedClass(name);\n            if (c == null) {\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    c = findClass(name);\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n\n    protected Class\u003c?\u003e findClass(String name) throws ClassNotFoundException {\n        throw new ClassNotFoundException(name);\n    }\n}\n\n```\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["JVM","类加载机制","Java"]},"/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B":{"title":"Java 内存模型","content":"# JMM 是什么？\n\nJMM 是和多线程相关的一组规范，它 定义了 JVM 在计算机内存中的工作方式，需要各个 JVM 的实现来遵守 JMM 规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。这样，即便同一个程序在不同的虚拟机上运行，得到的程序结果也是一致的，从而保证了“一次编译，处处运行”。\n\n因此，JMM 与处理器、缓存、并发、编译器有关。它解决了 CPU 多级缓存、处理器优化、指令重排等导致的结果不可预期的问题。\n\n比如关键字 synchronized，JVM 就会在 JMM 的规则下，“翻译”出合适的指令，包括限制指令之间的顺序，以便在即使发生了重排序的情况下，也能保证必要的“可见性”。这样一来，不同的 JVM 对于相同的代码的执行结果就变得可预期了，Java 程序员就只需要用同步工具和关键字就可以开发出正确的并发程序了。\n\n# JMM 抽象结构\n\nJava 作为高级语言，他向开发者屏蔽了多层缓存等底层细节，用 JMM 定义了一套读写数据的规范。Java 线程之间的通信由 JMM 控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：\n\n- 线程之间的共享变量存储在主内存中；\n- 每个线程只能够直接接触到本地内存，无法直接操作主内存；\n- 每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。\n\n本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Java-Memory-Model/clipboard_20230323_103037.png)\n\n# 内存间交互操作\n\nJava 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Java-Memory-Model/clipboard_20230323_103049.png)\n\n- read：把一个变量的值从主内存传输到工作内存中\n- load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中\n- use：把工作内存中一个变量的值传递给执行引擎\n- assign：把一个从执行引擎接收到的值赋给工作内存的变量\n- store：把工作内存的一个变量的值传送到主内存中\n- write：在 store 之后执行，把 store 得到的值放入主内存的变量中\n- lock：作用于主内存的变量\n- unlock\n\n# JMM 三大特性\n\n## 原子性\n\n如果一个或者一系列的操作，要么全部执行成功，要么全部不执行，不会出现执行一半就终止的情况，则认为此操作具有原子性。\n\n具有原子性的操作有：\n\n- （非 64 位 JDK）除 long 和 double 之外的基本类型（int、byte、boolean、short、char、float）的读 / 写操作；\n- 所有引用 reference 的读 / 写操作；\n- java.concurrent.Atomic.* 包中的一部分类的一部分方法是具备原子性的，比如 AtomicInteger 的 incrementAndGet 方法；\n- 加了 volatile 后，所有变量的读 / 写操作（包含 long 和 double）。这也就意味着 long 和 double 加了 volatile 关键字之后，对它们的读写操作同样具备原子性。\n\n## 可见性\n\n即内存可见性，是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n\n因为工作内存之间的通信，都需要通过主内存来中转。正是由于所有的共享变量都存在于主内存中，每个线程有自己的工作内存，其中存储的是变量的副本，所以这个副本就有可能是过期的，也就是与主内存不是同步的。比如，当 B 线程从主内存中同步共享变量 V 的时候，就有可能出现与 A 线程的变量 V 的副本不一致的情况，则称线程 A 对变量 V 的操作对于线程 B 不具备可见性了。\n\n主要有三种实现可见性的方式：\n\n- \u003cstrong\u003evolatile \u003c/strong\u003e—— 用于保证单个变量的可见性；\n- \u003cstrong\u003esynchronized \u003c/strong\u003e—— 对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。\n- \u003cstrong\u003efinal \u003c/strong\u003e—— 被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。\n\n单个变量要保证内存可见性，可以使用 volitale 关键字修饰。synchronized 关键字也可以保证内存可见性。\n\n## 有序性\n\n一个 Java 程序，包含一系列的语句，开发者默认期望这些语句的实际运行顺序和写的代码顺序一致。但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整，这就是重排序。\n\n这些重排序在单线程环境中不会影响程序执行，但是可能会导致\u003cstrong\u003e多线程程序\u003c/strong\u003e出现内存可见性问题。JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。\n\n要实现多线程环境下的有序性，可以通过两种方式实现：\n\n\u003cstrong\u003evolatile \u003c/strong\u003e—— 通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。\n\n\u003cstrong\u003esynchronized\u003c/strong\u003e —— 保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。\n\n# happens-before 规则\n\nHappens-before 关系是用来描述和可见性相关问题的：如果第一个操作 happens-before 第二个操作（也可以描述为，第一个操作和第二个操作之间满足 happens-before 关系），那么我们就说第一个操作对于第二个操作一定是可见的，也就是第二个操作在执行时就一定能保证看见第一个操作执行的结果。\n\n从 JDK 5 开始，Java 使用新的 JSR-133 内存模型，而 JSR-133 使用 happens-before 的概念来阐述操作之间的内存可见性。在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。\n\nhappens-before 规则如下：\n\n- 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。\n- 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。\n- volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\n- start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程 B），那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作。\n- join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。\n- interupt()规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。\n- 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。\n\n# volitale\n\n第一个作用是保证可见性。如果变量被 volatile 修饰，那么每次修改之后，接下来在读取这个变量的时候一定能读取到该变量最新的值。这是由 hanppens-before 规则保证的。\n\n第二个的作用就是禁止重排序。先介绍一下 as-if-serial 语义：不管怎么重排序，（单线程）程序的执行结果不会改变。在满足 as-if-serial 语义的前提下，由于编译器或 CPU 的优化，代码的实际执行顺序可能与我们编写的顺序是不同的，这在单线程的情况下是没问题的，但是一旦引入多线程，这种乱序就可能会导致严重的线程安全问题。用了 volatile 关键字就可以在一定程度上禁止这种重排序。\n\n但是特别注意，使用 volitale 修饰的变量并不能保证对它操作的原子性，比如 int 类型数据的 ++ 操作（它会分三步：Load、Add、Store）。\n\nvolatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。\n\n# synchronized\n\nsynchronized 包裹的代码块或者它所修饰的方法中的操作是具备原子性的。它会设立一个临界区，在一个线程操作临界区内的数据的时候，另一个线程无法进来同时操作。它利用对其他线程的排他性来实现保证操作原子性。\n\nsynchronized 不仅保证了临界区内最多同时只有一个线程执行操作，同时还保证了在前一个线程释放锁之后，之前所做的所有修改，都能被获得同一个锁的下一个线程所看到，也就是能读取到最新的值。因此 synchronized 也能够避免内存可见性问题。\n\n在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，通常称之为“内置锁”或“对象锁”。类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。针对每个类也有一个锁，可以称为“类锁”，类锁实际上是就是类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。\n\nMonitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有\n\n一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中有\n\n一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。Monitor 是\n\n依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的线程同步。\n\n# final\n\nJMM 对 final 域遵守如下两个重排序规则：\n\n1. 在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。\n2. 初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。\n\n以上两个规则就限制了 final 域的初始化必须在构造函数内，不能重排序到构造函数之外，普通变量则可以。具体的操作为：\n\n1. JMM 在 final 域写入和构造函数返回之前，插入一个 StoreStore 内存屏障，静止处理器将 final 域重排序到构造函数之外。\n2. JMM 在初次读 final 域的对象和读对象内 final 域之间插入一个 LoadLoad 内存屏障。\n\n# 单例模式中的 DCL\n\nDCL 单例标准写法：\n\n```java\npublic class Singleton {\n\n    private static volatile Singleton singleton;\n\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n\n\u003cstrong\u003e为什么需要使用 volatile 关键字？\u003c/strong\u003e\n\nsingleton = new Singleton() ，它并非是一个原子操作，事实上，在 JVM 中上述语句至少做了以下这 3 件事：\n\n1. 给 singleton 分配内存空间；\n2. 调用 Singleton 的构造函数等，来初始化 singleton；\n3. 将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。\n\n因为存在指令重排序的优化，也就是说第 2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。\n\n如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，如果这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候就会报错。\n\n\u003cstrong\u003e为什么两次判断 singleton 是否为空？\u003c/strong\u003e\n\n如果去掉第一次 check，那么所有线程获取实例的时候都要进行同步，都会串行执行，效率低下。\n\n对于第二次 check，如果有两个线程同时调用 getInstance 方法，由于 singleton 是空的 ，因此两个线程都可以通过第一重的 if 判断；然后由于锁机制的存在，会有一个线程先进入同步语句，并进入第二重 if 判断 ，而另外的一个线程就会在 synchronized 处等待。当第一个线程执行完 new Singleton() 语句后，就会退出 synchronized 保护的区域，这时如果没有第二重 if (singleton == null) 判断，那么第二个线程也会创建一个实例。\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["内存模型","JMM","原子类","happens-before","volitale","synchrionized","final","面试","Java"]},"/Java-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86":{"title":"ADB 命令","content":"代理模式是软件开发中常见的设计模式，它的目的是让调用者不用持有具体操作者的引用，而是通过代理者去对具体操作者执行具体的操作。本文通过使用静态代理和动态代理分别实现代理模式，来对比和分析两者的实现原理。\n\n# 静态代理的实现\n\n\u003cstrong\u003e代理接口：\u003c/strong\u003e\n\n```java  \npublic interface Person {  \n    String doSomething(int i);  \n}  \n```  \n\n\u003cstrong\u003e目标对象：\u003c/strong\u003e\n\n```java  \npublic class Worker implements Person {  \n    @Override  \n    public String doSomething(int i) {  \n        System.out.println(\"I'm doing something by param: \" + i);  \n    }  \n}  \n```  \n\n\u003cstrong\u003e代理对象：\u003c/strong\u003e\n\n```java  \npublic class PersonProxy implements Person {  \n\n    private Worker worker = null;  \n  \n    @Override  \n    public String doSomething(int i) {  \n        beforeDoSomething();  \n        if(worker == null) {  \n            worker = new Worker();  \n        }  \n  \n        Stirng result = worker.doSomething();  \n        afterDoSomething();  \n        return result;  \n    }  \n  \n    private void beforeDoSomething() {  \n        System.out.println(\"before doing something\");  \n    }  \n\n    private void afterDoSomething() {  \n        System.out.println(\"after doing something\");  \n    }  \n}  \n```  \n\n\u003cstrong\u003e调用者：\u003c/strong\u003e\n\n```java  \npublic class StaticProxyTest {  \n    public static void main(String[] args) {  \n        Person person = new PersonProxy();//实例化代理对象  \n        String result = person.doSomething(666);  \n        System.out.println(\"result: \" + result);  \n    }  \n}  \n```  \n\n输出结果：\nbefore doing something\nI'm doing something by param: 666\nafter doing something\nresult: 666\n\n# 静态代理的局限性\n\n可以看到，静态代理让调用者不用再直接持有操作者的引用，而是将一切操作交由代理者去完成。但是静态代理也有它的局限性：\n\n1. 如果需要增加一个需要代理的方法，代理者的代码也必须改动进而适配新的操作；\n2. 如果需要代理者代理另外一个操作者，同样需要对代理者进行扩展并且更加麻烦。\n\n可能有人想到可以用策略模式和工厂模式分别解决上面两个问题，但是，有没有更加巧妙的方法呢？首先，我们了解一下 Java 代码的执行过程。\n\n# 理解 Java 代码执行流程\n\n要从根本上理解动态代理的实现原理，得先从 Java 代码的执行流程说起：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JavaProxy/clipboard_20230323_041701.png)\n\nJVM 在运行 .class 文件之前，首先通过 ClassLoader 将 .class 文件以二进制的形式解析并生成实例以供调用，我们的代码执行逻辑是在 JVM 的运行期系统中进行工作的。那么，我们可不可以在自己的代码里面按照 .class 的格式生成自己的 .class 文件，进而调用自定义的 ClassLoader 将其加载出来呢？答案是肯定的，这样我们就可以动态地创建一个类了。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JavaProxy/clipboard_20230323_041705.png)\n\n# 生成自己的 .class 文件\n\n当然我们不用手动去一点一点拼装 .class 文件，目前比较常用的字节码生成工具有 [ASM](https://link.juejin.cn?target=https%3A%2F%2Fasm.ow2.io%2F) 和 [Javassist](https://link.juejin.cn?target=http%3A%2F%2Fwww.javassist.org%2F)，根据这个思路，生成 .class 文件的过程如下：\n\n```java  \nimport javassist.ClassPool;  \nimport javassist.CtClass;  \nimport javassist.CtMethod;  \nimport javassist.CtNewMethod;  \n   \npublic class Test {  \n  \n    public static void main(String[] args) throws Exception {  \n        ClassPool pool = ClassPool.getDefault();  \n        //创建 AutoGenerateClass 类  \n        CtClass cc= pool.makeClass(\"com.guanpj.AutoGenerateClass\");  \n        //定义 show 方法  \n        CtMethod method = CtNewMethod.make(\"public void show(){}\", cc);  \n        //插入方法代码  \n        method.insertBefore(\"System.out.println(\\\"I'm just test generate .class file by javassit.....\\\");\");  \n        cc.addMethod(method);  \n        //保存生成的字节码  \n        cc.writeFile(\"D://temp\");  \n    }  \n  \n}  \n```  \n\n生成的 .class 文件如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JavaProxy/clipboard_20230323_041710.png)\n\n反编译后查看内容：\n\n```java  \n//  \n// Source code recreated from a .class file by IntelliJ IDEA  \n// (powered by Fernflower decompiler)  \n//  \npackage com.guanpj;  \n\npublic class AutoGenerateClass {  \n    public void show() {  \n        System.out.println(\"I'm just test generate .class file by javassit.....\");  \n    }  \n\n    public AutoGenerateClass() {  \n  \n    }  \n}  \n```  \n\n可以看到，javassit 生成的类中，除了 show() 方法之外还默认生成了一个无参的构造方法。\n\n# 自定义类加载器加载\n\n为了能够让自定的类被加载出来，我们自定义了一个类加载器来加载指定的 .class 文件：\n\n```java  \npublic class CustomClassLoader extends ClassLoader {  \n\n    public CustomClassLoader() {  \n  \n    }  \n\n    protected Class\u003c?\u003e findClass(String className) {  \n        String path = \"D://temp//\" + className.replace(\".\",\"//\") + \".class\";  \n        byte[] classData = getClassData(path);  \n        return defineClass(className, classData, 0, classData.length);  \n    }  \n\n    private byte[] getClassData(String path) {  \n        try {  \n            InputStream ins = new FileInputStream(path);  \n            ByteArrayOutputStream baos = new ByteArrayOutputStream();  \n            int bufferSize = 4096;  \n            byte[] buffer = new byte[bufferSize];  \n            int bytesNumRead = 0;  \n            while ((bytesNumRead = ins.read(buffer)) != -1) {  \n                baos.write(buffer, 0, bytesNumRead);  \n            }  \n            return baos.toByteArray();  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n        return null;  \n    }  \n}  \n```  \n\n接着，用 ClassLoader 加载刚才生成的 .class 文件：\n\n```java  \npublic class TestLoadClass {  \n  \n    public static void main(String[] args) throws Exception {  \n        CustomClassLoader classLoader = new CustomClassLoader();  \n        Class clazz = classLoader.findClass(\"com.guanpj.AutoGenerateClass\");  \n \n        Object object = clazz.newInstance();  \n        Method showMethod = clazz.getMethod(\"show\", null);  \n        showMethod.invoke(object, null);  \n    }  \n}  \n```  \n\n控制台输出如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/JavaProxy/clipboard_20230323_041716.png)\n\n成功执行了 show 方法！\n\n# 利用 JDK 中的 Proxy 类进行动态代理\n\n使用动态代理的初衷是简化代码，但不管是 ASM 还是 Javassist，在进行动态代理的时候操作还是不够简便，这也违背了初衷。来看一下怎么 InvocationHandler 怎么做：\n\n\u003cstrong\u003e创建 InvocationHandler：\u003c/strong\u003e\n\n```java  \npublic static class InvocationHandlerImpl implements InvocationHandler {  \n  \n    Person person;  \n\n    //注入目标对象  \n    public InvocationHandlerImpl(Person person) {  \n        this.person = person;  \n    }  \n\n    @Override  \n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  \n        System.out.println(\"before calling method: \" + method.getName());  \n        //反射调用目标方法并获取返回值  \n        Object result = method.invoke(person, args);  \n        System.out.println(\"after calling method: \" + method.getName());  \n        //将返回值作为 invoke 方法的返回值  \n        return result;  \n    }  \n}  \n```  \n\n\u003cstrong\u003e使用动态代理创建代理对象并使用：\u003c/strong\u003e\n\n```java  \npublic class DynamicProxyTest {  \n  \n    public static void main(String[] args) {  \n  \n        //实例化目标对象  \n        Person person = new Worker();  \n  \n        //实例化 InvocationHandler，并传入目标对象  \n        InvocationHandlerImpl handler = new InvocationHandlerImpl(person);  \n  \n        //生成代理对象，并传入 InvocationHandler  \n        Person operationProxy = (Person)   \n                Proxy.newProxyInstance(person.getClass().getClassLoader(),  \n                person.getClass().getInterfaces(), handler);  \n  \n        //调用目标方法  \n        String result = operationProxy.doSomething(777);  \n        System.out.println(\"result: \" + result);  \n    }  \n}  \n```  \n\n输出结果：\nbefore calling method: doSomething\nI'm doing something by param: 777\nafter calling method: doSomething\nresult: 777\n\n动态代理实际上是 JVM 在运行期动态创建 .class 字节码并加载的过程。它在运行时生成了一个静态代理类，并且这个静态代理类是通过反射的方式获取到代理对象的目标方法。\n\n```java  \npublic static class DynamicProxy implements Person {  \n  \n    InvocationHandler handler;  \n\n    public DynamicProxy(InvocationHandler handler) {  \n        this.handler = handler;  \n    }  \n\n    @Override  \n    public String doSomething(int i) {  \n        try {  \n            return (String) handler.invoke(this,  \n                    Person.class.getMethod(\"doSomething\", int.class),  \n                    new Object[] { i });  \n        } catch (Throwable throwable) {  \n            throwable.printStackTrace();  \n        }  \n  \n        return null;  \n    }  \n}  \n```  \n\n使用这个代理对象进行代理的过程：\n\n```java  \npublic static void main(String[] args) {  \n  \n    //实例化目标对象  \n    Person person = new Worker();  \n  \n    //实例化 InvocationHandler，并传入目标对象  \n    InvocationHandlerImpl handler = new InvocationHandlerImpl(person);  \n  \n    //实例化代理对象，并传入 InvocationHandler  \n    DynamicProxy dynamicProxy = new DynamicProxy(handler);  \n  \n    //调用目标方法  \n    String result = dynamicProxy.doSomething(888);  \n  \n    System.out.println(\"result: \" + result);  \n}  \n```  \n\n输出结果：\nbefore calling method: doSomething\nI'm doing something by param: 888\nafter calling method: doSomething\nresult: 888\n\n# 利用 CGLIB 进行动态代理\n\n用 Proxy 类生成代理类的方法为 `newProxyInstance(ClassLoader loader, Class\u003c?\u003e[] interfaces, InvocationHandler h)` ，第二个参数是操作者的接口数组，意味着只能代理它实现的接口里的方法，对于本来在操作者类中定义的方法表示无能为力，CGLIB(Code Generation Library) 解决了这个问题。\n\n\u003cstrong\u003eMethodInterceptorImpl：\u003c/strong\u003e\n\n```java  \npublic class MethodInterceptorImpl implements MethodInterceptor {  \n  \n    @Override  \n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {  \n        System.out.println(\"before calling method:\" + method.getName());  \n        proxy.invokeSuper(obj, args);  \n        System.out.println(\"after calling method:\" + method.getName());  \n  \n        return null;  \n    }  \n}  \n```  \n\n\u003cstrong\u003e调用者：\u003c/strong\u003e\n\n```java  \npublic class ProxyTest {  \n  \n    public static void main(String[] args) {  \n        Operator operator = new Operator();  \n        MethodInterceptorImpl methodInterceptorImpl = new MethodInterceptorImpl();  \n\n        //初始化加强器对象  \n        Enhancer enhancer = new Enhancer();  \n  \n        //设置代理类  \n        enhancer.setSuperclass(operator.getClass());  \n  \n        //设置代理回调  \n        enhancer.setCallback(methodInterceptorImpl);  \n  \n        //创建代理对象  \n        Operator operationProxy = (Operator) enhancer.create();  \n  \n        //调用操作方法  \n        operationProxy.doSomething();  \n    }  \n}  \n```  \n\n使用 CGLIB 进行动态代理的过程分为四个步骤：\n\n- 使用 MethodInterceptorImpl 实现 MethodInterceptor 接口，并在 intercept 方法中进行额外的操作\n- 创建增强器 Enhance 并设置被代理的操作类\n- 生成代理类\n- 调用代理对象的操作方法\n\n# 总结\n\n无论是静态代理还是动态代理，都能一定程度地解决我们的问题，在开发过程中可以根据实际情况选择合适的方案。总之，没有好不好的方案，只有适不适合自己项目的方案，我们应该深入研究和理解方案背后的原理，以便能够应对开发过程中产生的变数。","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["代理模式","动态代理","Java"]},"/Kanban":{"title":"Kanban","content":"\n## Todo\n\n- [ ] RecyclerView 分析 @{2023-03-29}\n- [ ] Fragment 分析\n- [ ] 协程学习\n- [ ] KMM 学习\n- [ ] Jetpack 学习\n\n\n## Done\n\n**完成**\n\n\n## In progress\n\n\n\n\n\n%% kanban:settings\n```\n{\"kanban-plugin\":\"basic\"}\n```\n%%","lastmodified":"2023-04-21T14:55:32.605227307Z","tags":[]},"/LeakCanary-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90":{"title":"LeakCanary 使用及源码解析","content":"\n# Reference 介绍\n\nReference 即是我们平时所说的“引用”，与之对应的是一个泛型抽象类。四种引用类型：SoftReference(软引用)、WeakReference(弱引用)、PhantomReference（虚引用）都继承自 Reference。它的声明如下：\n\n```java\npublic abstract class Reference\u003cT\u003e {\n    //引用对象\n    volatile T referent;\n    //保存即将被回收的Reference对象\n    final ReferenceQueue\u003c? super T\u003e queue;\n    \n    //在Enqueued状态下即引用加入队列时，指向下一个待处理Reference对象,默认为null\n    Reference queueNext;\n    //在Pending状态下，待入列引用，默认为null\n    Reference\u003c?\u003e pendingNext;\n    \n    ...\n}\n```\n\nReference 有四种状态：Active、Pending、Enqueued、Inactive，默认为 Active 状态。\n\nReferenceQueue 则是一个单向链表实现的队列数据结构，存储的是 Reference 对象。包含了入列 enqueue、出列 poll 和移除 remove 操作。\n\n# ReferenceQueue 原理和使用示例\n\nReference 配合 ReferenceQueue 可以实现对象回收监听，使用方法如下：\n\n```java\n//创建一个引用队列\nReferenceQueue queue = new ReferenceQueue();\n//创建对象\nObject object = new Object();\n//创建 object 对象的弱引用，并关联引用队列 queue\nWeakReference reference = new WeakReference(object, queue);\nSystem.out.println(reference);\nSystem.gc();\n//当 reference 被成功回收后，可以从 queue 中获取到该引用\nSystem.out.println(queue.remove());\n\n输出结果：\njava.lang.ref.WeakReference@3d833955\njava.lang.ref.WeakReference@3d833955\n```\n\n示例中的对象当然是可以正常回收的，所以回收后可以在关联的引用队列 queue 中获取到该引用。反之，若某个应该被回收的对象，GC 结束后在 queue 中未找到该引用，则表明该引用存在内存泄漏风险，这也就是 LeakCanary 的基本原理。\n\n# LeakCanary 基本使用\n\n## 2.0 之前\n\n导入依赖：\n\n```plain text\ndebugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.1'\nreleaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.1'\ndebugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.1'\n```\n\n在项目的自定义 Application 中进行初始化：\n\n```kotlin\nprivate fun initLeakCanary(){\n    if (LeakCanary.isInAnalyzerProcess(this)) {\n        return\n    }\n    LeakCanary.install(this)\n}\n```\n\n## 2.0 开始\n\nLeakCanary 从 2.0 开始采用 Kotlin 编写，并且只需要导入依赖即可，不用再手动进行初始化操作：\n\n```plain text\ndebugImplementation 'com.squareup.leakcanary:leakcanary-android:2.7'\n```\n\n并且 Leakcanary 2.0 版本还增加了 shark 模块，用于 dumpFile 分析，相比于之前的方法大幅减少了内存的占用。\n\n接下来的分析流程也是基于 2.7 版本进行的。\n\n# LeakCanary 原理分析\n\n## 初始化\n\n既然不用手动初始化，那必定有自动初始化的入口。在 leakcanary-object-watcher-android 模块的 [Manifest 文件](https://github.com/square/leakcanary/blob/main/leakcanary-object-watcher-android/src/main/AndroidManifest.xml) 中声明了一个 Provider 组件：\n\n```xml\n\u003capplication\u003e\n\t\u003cprovider\n\t    android:name=\"leakcanary.internal.AppWatcherInstaller$MainProcess\"\n\t    android:authorities=\"${applicationId}.leakcanary-installer\"\n\t    android:enabled=\"@bool/leak_canary_watcher_auto_install\"\n\t    android:exported=\"false\"/\u003e\n\u003c/application\u003e\n```\n\n顺蔓摸瓜，查看 AppWatcherInstaller：\n\n```kotlin\noverride fun onCreate(): Boolean {\n  val application = context!!.applicationContext as Application\n  AppWatcher.manualInstall(application)\n  return true\n}\n```\n\n果然找到了初始化方法，接着跟踪 AppWatcher 类：\n\n```kotlin\n@JvmOverloads\nfun manualInstall(\n  application: Application,\n  retainedDelayMillis: Long = TimeUnit.SECONDS.toMillis(5),\n  watchersToInstall: List\u003cInstallableWatcher\u003e = appDefaultWatchers(application)\n) {\n  //1、确保在主线程，否则抛出UnsupportedOperationException异常\n  checkMainThread()\n  if (isInstalled) {\n    throw IllegalStateException(\n      \"AppWatcher already installed, see exception cause for prior install call\", installCause\n    )\n  }\n  check(retainedDelayMillis \u003e= 0) {\n    \"retainedDelayMillis $retainedDelayMillis must be at least 0 ms\"\n  }\n  installCause = RuntimeException(\"manualInstall() first called here\")\n  this.retainedDelayMillis = retainedDelayMillis\n  if (application.isDebuggableBuild) {\n    LogcatSharkLog.install()\n  }\n  //2、Requires AppWatcher.objectWatcher to be set\n  LeakCanaryDelegate.loadLeakCanary(application)\n  //3、初始化 Activity 和 Fragment 监听器\n  watchersToInstall.forEach {\n    it.install()\n  }\n}\n```\n\n跟踪注释 2 处：\n\n```kotlin\ninternal object LeakCanaryDelegate {\n\n  //使用 lazy 实现懒汉单例\n  @Suppress(\"UNCHECKED_CAST\")\n  val loadLeakCanary by lazy {\n    try {\n      //反射调用 InternalLeakCanary\n      val leakCanaryListener = Class.forName(\"leakcanary.internal.InternalLeakCanary\")\n      leakCanaryListener.getDeclaredField(\"INSTANCE\")\n        .get(null) as (Application) -\u003e Unit\n    } catch (ignored: Throwable) {\n      NoLeakCanary\n    }\n  }\n\n  object NoLeakCanary : (Application) -\u003e Unit, OnObjectRetainedListener {\n    override fun invoke(application: Application) {\n    }\n\n    override fun onObjectRetained() {\n    }\n  }\n}\n```\n\n接着查看 InternalLeakCanary 的 invoke 方法：\n\n```kotlin\noverride fun invoke(application: Application) {\n  _application = application\n\n  checkRunningInDebuggableBuild()\n\n  //为 objectWatcher 对象添加 this 作为对象保留监听器\n  AppWatcher.objectWatcher.addOnObjectRetainedListener(this)\n  //初始化 AndroidHeapDumper\n  val heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application))\n  //GcTrigger\n  val gcTrigger = GcTrigger.Default\n\n  val configProvider = { LeakCanary.config }\n\n  //初始化 backgroundHandler\n  val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)\n  handlerThread.start()\n  val backgroundHandler = Handler(handlerThread.looper)\n\n  //初始化 HeapDumpTrigger\n  heapDumpTrigger = HeapDumpTrigger(\n    application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper,\n    configProvider\n  )\n  \n  //监听 app 进入后台/返回前台事件\n  application.registerVisibilityListener { applicationVisible -\u003e\n    this.applicationVisible = applicationVisible\n    heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)\n  }\n  registerResumedActivityListener(application)\n  addDynamicShortcut(application)\n\n  // We post so that the log happens after Application.onCreate()\n  mainHandler.post {\n    // https://github.com/square/leakcanary/issues/1981\n    // We post to a background handler because HeapDumpControl.iCanHasHeap() checks a shared pref\n    // which blocks until loaded and that creates a StrictMode violation.\n    backgroundHandler.post {\n      SharkLog.d {\n        when (val iCanHasHeap = HeapDumpControl.iCanHasHeap()) {\n          is Yup -\u003e application.getString(R.string.leak_canary_heap_dump_enabled_text)\n          is Nope -\u003e application.getString(\n            R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()\n          )\n        }\n      }\n    }\n  }\n}\n```\n\n至此，InternalLeakCanary 初始化完成。回到 manualInstall 方法中继续查看注释 3 处代码：\n\n```kotlin\nwatchersToInstall.forEach {\n  it.install()\n}\nwatchersToInstall 来自 appDefaultWatchers 方法：\nfun appDefaultWatchers(\n  application: Application,\n  reachabilityWatcher: ReachabilityWatcher = objectWatcher\n): List\u003cInstallableWatcher\u003e {\n  return listOf(\n    ActivityWatcher(application, reachabilityWatcher),\n    FragmentAndViewModelWatcher(application, reachabilityWatcher),\n    RootViewWatcher(reachabilityWatcher),\n    ServiceWatcher(reachabilityWatcher)\n  )\n}\n```\n\n以 ActivityWatcher 为例：\n\n```kotlin\nclass ActivityWatcher(\n  private val application: Application,\n  private val reachabilityWatcher: ReachabilityWatcher\n) : InstallableWatcher {\n  private val lifecycleCallbacks =\n    object : Application.ActivityLifecycleCallbacks by noOpDelegate() {\n      override fun onActivityDestroyed(activity: Activity) {\n        reachabilityWatcher.expectWeaklyReachable(\n          activity, \"${activity::class.java.name} received Activity#onDestroy() callback\"\n        )\n      }\n    }\n    \n  override fun install() {\n    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)\n  }\n  \n  override fun uninstall() {\n    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)\n  }\n}\n```\n\ninstall 方法将 lifecycleCallbacks 注册为 application 的 ActivityLifecycleCallbacks，用来感知所有 Activity 的声明周期。\n\nby noOpDelegate() 通过类委托机制将其他回调实现都交给 noOpDelegate，而 noOpDelegate 是一个空实现的动态代理。这里只需要监听 Activity 销毁事件，因此只需要重写 onActivityDestroyed 即可。\n\n## Activity 回收监听\n\n在 onActivityDestroyed 方法被回调时，调用了 reachabilityWatcher 的 expectWeaklyReachable 方法并将 activity 对象传进去。这里 reachabilityWatcher 的唯一实现类为 ObjectWatcher，查看它的 expectWeaklyReachable 方法内容：\n\n```kotlin\n@Synchronized override fun expectWeaklyReachable(\n  watchedObject: Any,\n  description: String\n) {\n  if (!isEnabled()) {\n    return\n  }\n  //将 ReferenceQueue 中出现的弱引用移除，即忽略已被回收的 Activity\n  removeWeaklyReachableObjects()\n  //生成随机的 key 值\n  val key = UUID.randomUUID().toString()\n  //记录时间\n  val watchUptimeMillis = clock.uptimeMillis()\n  //将 Activity 对象（watchedObject）封装成 KeyedWeakReference\n  //并关联引用队列 queue\n  val reference =\n    KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)\n  SharkLog.d {\n    \"Watching \" +\n      (if (watchedObject is Class\u003c*\u003e) watchedObject.toString() else \"instance of ${watchedObject.javaClass.name}\") +\n      (if (description.isNotEmpty()) \" ($description)\" else \"\") +\n      \" with key $key\"\n  }\n\n  //将弱引用 reference 存入监听 map 集合\n  watchedObjects[key] = reference\n  //5 秒之后在主线程执行 moveToRetained(key) 方法\n  checkRetainedExecutor.execute {\n    moveToRetained(key)\n  }\n}\n\nprivate fun removeWeaklyReachableObjects() {\n  // WeakReferences are enqueued as soon as the object to which they point to becomes weakly\n  // reachable. This is before finalization or garbage collection has actually happened.\n  var ref: KeyedWeakReference?\n  do {\n    //从 queue 中取出对象\n    ref = queue.poll() as KeyedWeakReference?\n    if (ref != null) {\n      //将该对象从集合中移除\n      watchedObjects.remove(ref.key)\n    }\n  } while (ref != null)\n}\n```\n\n为什么会是 5 秒，这里猜测与 Android GC 有关。在 Activity.H 中，收到 GC_WHEN_IDLE 消息时会进行 Looper.myQueue().addIdleHandler(mGcIdler)，而 mGcIdler 最后会触发 doGcIfNeeded 操作，在该方法中会判断上次 GC 与现在时间的差值，而这个值就是 MIN_TIME_BETWEEN_GCS = 5*1000。\n\n查看 moveToRetained 方法：\n\n```kotlin\n@Synchronized private fun moveToRetained(key: String) {\n  //再次移除已被回收的对象对应的弱引用 Reference\n  removeWeaklyReachableObjects()\n  val retainedRef = watchedObjects[key]\n  //如果用这个 key 对应的 Reference 没有被移除，说明已经发生泄漏\n  if (retainedRef != null) {\n    retainedRef.retainedUptimeMillis = clock.uptimeMillis()\n    //通知 listener\n    onObjectRetainedListeners.forEach { it.onObjectRetained() }\n  }\n}\n```\n\n在经过 5s 后，再次移除被回收的对象对应的 Reference。然后再判断 watchedObjects 集合中是否是否仍然存在该 key 对应的 value，如果存在则认为该 value 对应的对象发生了泄露。随后记录下发生时间，并通知 listener 发生对象残留情况。\n\n这里的 listener 就是 InternalLeakCanary 的 invoke 方法中设置的 InternalLeakCanary.this 对象，查看 InternalLeakCanary 的 onObjectRetained 方法：\n\n```kotlin\noverride fun onObjectRetained() = scheduleRetainedObjectCheck()\n继续跟进：\nfun scheduleRetainedObjectCheck() {\n  if (this::heapDumpTrigger.isInitialized) {\n    heapDumpTrigger.scheduleRetainedObjectCheck()\n  }\n}\n继续追踪 HeapDumpTrigger 的 scheduleRetainedObjectCheck 方法：\nfun scheduleRetainedObjectCheck(\n  delayMillis: Long = 0L\n) {\n  val checkCurrentlyScheduledAt = checkScheduledAt\n  if (checkCurrentlyScheduledAt \u003e 0) {\n    return\n  }\n  checkScheduledAt = SystemClock.uptimeMillis() + delayMillis\n  //将后面的流程 post 到后台线程执行\n  backgroundHandler.postDelayed({\n    checkScheduledAt = 0\n    checkRetainedObjects()\n  }, delayMillis)\n}\n查看 checkretainedObjects 方法：\nprivate fun checkRetainedObjects() {\n  val iCanHasHeap = HeapDumpControl.iCanHasHeap()\n\n  val config = configProvider()\n\n  if (iCanHasHeap is Nope) {\n    ...\n    return\n  }\n  //获取没有被回收对象的个数\n  var retainedReferenceCount = objectWatcher.retainedObjectCount\n  //如果没有被回收的对象个数大于 0\n  if (retainedReferenceCount \u003e 0) {\n    //执行一次GC\n    gcTrigger.runGc()\n    //再次获取没有被回收对象的个数\n    retainedReferenceCount = objectWatcher.retainedObjectCount\n  }\n  //检查没有被回收对象的个数，如果少于 5 个则返回\n  if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return\n\n  val now = SystemClock.uptimeMillis()\n  val elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis\n  //WAIT_BETWEEN_HEAP_DUMPS_MILLIS 为 60_000L\n  //即 60 秒内再次发现泄漏只会发出通知并返回\n  if (elapsedSinceLastDumpMillis \u003c WAIT_BETWEEN_HEAP_DUMPS_MILLIS) {\n    onRetainInstanceListener.onEvent(DumpHappenedRecently)\n    showRetainedCountNotification(\n      objectCount = retainedReferenceCount,\n      contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)\n    )\n    scheduleRetainedObjectCheck(\n      delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis\n    )\n    return\n  }\n\n  dismissRetainedCountNotification()\n  val visibility = if (applicationVisible) \"visible\" else \"not visible\"\n  //获取内存快照，即.hprof文件\n  dumpHeap(\n    retainedReferenceCount = retainedReferenceCount,\n    retry = true,\n    reason = \"$retainedReferenceCount retained objects, app is $visibility\"\n  )\n}\n```\n\n## 获取 dumpHeap 文件\n\n继续查看：\n\n```kotlin\nprivate fun dumpHeap(\n  retainedReferenceCount: Int,\n  retry: Boolean,\n  reason: String\n) {\n  saveResourceIdNamesToMemory()\n  val heapDumpUptimeMillis = SystemClock.uptimeMillis()\n  KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis\n  //调用 AndroidHeapDumper 的 dumpHeap 方法\n  when (val heapDumpResult = heapDumper.dumpHeap()) {\n    is NoHeapDump -\u003e {\n      if (retry) {\n        SharkLog.d { \"Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms\" }\n        scheduleRetainedObjectCheck(\n          delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS\n        )\n      } else {\n        SharkLog.d { \"Failed to dump heap, will not automatically retry\" }\n      }\n      showRetainedCountNotification(\n        objectCount = retainedReferenceCount,\n        contentText = application.getString(\n          R.string.leak_canary_notification_retained_dump_failed\n        )\n      )\n    }\n    is HeapDump -\u003e {\n      lastDisplayedRetainedObjectCount = 0\n      lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()\n      //清理 objectWatcher 中 heapDumpUptimeMillis 之前保存的键值对\n      objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)\n      //分析 dump 文件\n      HeapAnalyzerService.runAnalysis(\n        context = application,\n        heapDumpFile = heapDumpResult.file,\n        heapDumpDurationMillis = heapDumpResult.durationMillis,\n        heapDumpReason = reason\n      )\n    }\n  }\n}\n\n@Synchronized fun clearObjectsWatchedBefore(heapDumpUptimeMillis: Long) {\n  val weakRefsToRemove =\n    watchedObjects.filter { it.value.watchUptimeMillis \u003c= heapDumpUptimeMillis }\n  weakRefsToRemove.values.forEach { it.clear() }\n  watchedObjects.keys.removeAll(weakRefsToRemove.keys)\n}\n```\n\n## heapDump 文件解析\n\n继续查看 HeapAnalyzerService 类：\n\n```kotlin\nfun runAnalysis(\n  context: Context,\n  heapDumpFile: File,\n  heapDumpDurationMillis: Long? = null,\n  heapDumpReason: String = \"Unknown\"\n) {\n  val intent = Intent(context, HeapAnalyzerService::class.java)\n  intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile)\n  intent.putExtra(HEAPDUMP_REASON_EXTRA, heapDumpReason)\n  heapDumpDurationMillis?.let {\n    intent.putExtra(HEAPDUMP_DURATION_MILLIS_EXTRA, heapDumpDurationMillis)\n  }\n  //启动一个 Service，并将 heapDump 文件信息传入进去\n  startForegroundService(context, intent)\n}\n\nprivate fun startForegroundService(\n  context: Context,\n  intent: Intent\n) {\n  if (SDK_INT \u003e= 26) {\n    context.startForegroundService(intent)\n  } else {\n    // Pre-O behavior.\n    context.startService(intent)\n  }\n}\n```\n\n启动 HeapAnalyzerService 后：\n\n```kotlin\noverride fun onHandleIntentInForeground(intent: Intent?) {\n  if (intent == null || !intent.hasExtra(HEAPDUMP_FILE_EXTRA)) {\n    SharkLog.d { \"HeapAnalyzerService received a null or empty intent, ignoring.\" }\n    return\n  }\n\n  // Since we're running in the main process we should be careful not to impact it.\n  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)\n  val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File\n  val heapDumpReason = intent.getStringExtra(HEAPDUMP_REASON_EXTRA)\n  val heapDumpDurationMillis = intent.getLongExtra(HEAPDUMP_DURATION_MILLIS_EXTRA, -1)\n\n  val config = LeakCanary.config\n  val heapAnalysis = if (heapDumpFile.exists()) {\n    // 分析heapDump 文件\n    analyzeHeap(heapDumpFile, config)\n  } else {\n    missingFileFailure(heapDumpFile)\n  }\n  val fullHeapAnalysis = when (heapAnalysis) {\n    is HeapAnalysisSuccess -\u003e heapAnalysis.copy(\n      dumpDurationMillis = heapDumpDurationMillis,\n      metadata = heapAnalysis.metadata + (\"Heap dump reason\" to heapDumpReason)\n    )\n    is HeapAnalysisFailure -\u003e heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis)\n  }\n  onAnalysisProgress(REPORTING_HEAP_ANALYSIS)\n  //将分析结果回调给 onHeapAnalyzedListener\n  config.onHeapAnalyzedListener.onHeapAnalyzed(fullHeapAnalysis)\n}\n\nprivate fun analyzeHeap(\n  heapDumpFile: File,\n  config: Config\n): HeapAnalysis {\n  val heapAnalyzer = HeapAnalyzer(this)\n\n  val proguardMappingReader = try {\n    ProguardMappingReader(assets.open(PROGUARD_MAPPING_FILE_NAME))\n  } catch (e: IOException) {\n    null\n  }\n  return heapAnalyzer.analyze(\n    heapDumpFile = heapDumpFile,\n    leakingObjectFinder = config.leakingObjectFinder,\n    referenceMatchers = config.referenceMatchers,\n    computeRetainedHeapSize = config.computeRetainedHeapSize,\n    objectInspectors = config.objectInspectors,\n    metadataExtractor = config.metadataExtractor,\n    proguardMapping = proguardMappingReader?.readProguardMapping()\n  )\n}\n```\n\n查看 heapAnalyzer.analyzeHeap 方法：\n\n```kotlin\nfun analyze(\n  heapDumpFile: File,\n  leakingObjectFinder: LeakingObjectFinder,\n  referenceMatchers: List\u003cReferenceMatcher\u003e = emptyList(),\n  computeRetainedHeapSize: Boolean = false,\n  objectInspectors: List\u003cObjectInspector\u003e = emptyList(),\n  metadataExtractor: MetadataExtractor = MetadataExtractor.NO_OP,\n  proguardMapping: ProguardMapping? = null\n): HeapAnalysis {\n  val analysisStartNanoTime = System.nanoTime()\n\n  if (!heapDumpFile.exists()) {\n    val exception = IllegalArgumentException(\"File does not exist: $heapDumpFile\")\n    return HeapAnalysisFailure(\n      heapDumpFile = heapDumpFile,\n      createdAtTimeMillis = System.currentTimeMillis(),\n      analysisDurationMillis = since(analysisStartNanoTime),\n      exception = HeapAnalysisException(exception)\n    )\n  }\n\n  return try {\n    listener.onAnalysisProgress(PARSING_HEAP_DUMP)\n    val sourceProvider = ConstantMemoryMetricsDualSourceProvider(FileSourceProvider(heapDumpFile))\n    //从文件中解析获取对象关系图结构 graph\n    //并获取图中的所有 GC roots 根节点\n    sourceProvider.openHeapGraph(proguardMapping).use { graph -\u003e\n      //创建 FindLeakInput 对象\n      val helpers =\n        FindLeakInput(graph, referenceMatchers, computeRetainedHeapSize, objectInspectors)\n       //查找内存泄漏对象\n       val result = helpers.analyzeGraph(\n        metadataExtractor, leakingObjectFinder, heapDumpFile, analysisStartNanoTime\n      )\n      val lruCacheStats = (graph as HprofHeapGraph).lruCacheStats()\n      val randomAccessStats =\n        \"RandomAccess[\" +\n          \"bytes=${sourceProvider.randomAccessByteReads},\" +\n          \"reads=${sourceProvider.randomAccessReadCount},\" +\n          \"travel=${sourceProvider.randomAccessByteTravel},\" +\n          \"range=${sourceProvider.byteTravelRange},\" +\n          \"size=${heapDumpFile.length()}\" +\n          \"]\"\n      val stats = \"$lruCacheStats $randomAccessStats\"\n      result.copy(metadata = result.metadata + (\"Stats\" to stats))\n    }\n  } catch (exception: Throwable) {\n    HeapAnalysisFailure(\n      heapDumpFile = heapDumpFile,\n      createdAtTimeMillis = System.currentTimeMillis(),\n      analysisDurationMillis = since(analysisStartNanoTime),\n      exception = HeapAnalysisException(exception)\n    )\n  }\n}\n\nprivate fun FindLeakInput.analyzeGraph(\n  metadataExtractor: MetadataExtractor,\n  leakingObjectFinder: LeakingObjectFinder,\n  heapDumpFile: File,\n  analysisStartNanoTime: Long\n): HeapAnalysisSuccess {\n  listener.onAnalysisProgress(EXTRACTING_METADATA)\n  val metadata = metadataExtractor.extractMetadata(graph)\n\n  //通过过滤 graph 中的 KeyedWeakReference 类型对象来\n  //找到对应的内存泄漏对象\n  val retainedClearedWeakRefCount = KeyedWeakReferenceFinder.findKeyedWeakReferences(graph)\n    .filter { it.isRetained \u0026\u0026 !it.hasReferent }.count()\n\n  // This should rarely happens, as we generally remove all cleared weak refs right before a heap\n  // dump.\n  val metadataWithCount = if (retainedClearedWeakRefCount \u003e 0) {\n    metadata + (\"Count of retained yet cleared\" to \"$retainedClearedWeakRefCount KeyedWeakReference instances\")\n  } else {\n    metadata\n  }\n\n  listener.onAnalysisProgress(FINDING_RETAINED_OBJECTS)\n  val leakingObjectIds = leakingObjectFinder.findLeakingObjectIds(graph)\n  //计算内存泄漏对象到 GC roots 的路径\n  val (applicationLeaks, libraryLeaks, unreachableObjects) = findLeaks(leakingObjectIds)\n\n  return HeapAnalysisSuccess(\n    heapDumpFile = heapDumpFile,\n    createdAtTimeMillis = System.currentTimeMillis(),\n    analysisDurationMillis = since(analysisStartNanoTime),\n    metadata = metadataWithCount,\n    applicationLeaks = applicationLeaks,\n    libraryLeaks = libraryLeaks,\n    unreachableObjects = unreachableObjects\n  )\n}\n\nprivate fun FindLeakInput.findLeaks(leakingObjectIds: Set\u003cLong\u003e): LeaksAndUnreachableObjects {\n  val pathFinder = PathFinder(graph, listener, referenceMatchers)\n  //计算并获取目标对象到 GC roots 的最短路径\n  val pathFindingResults =\n    pathFinder.findPathsFromGcRoots(leakingObjectIds, computeRetainedHeapSize)\n\n  val unreachableObjects = findUnreachableObjects(pathFindingResults, leakingObjectIds)\n\n  val shortestPaths =\n    deduplicateShortestPaths(pathFindingResults.pathsToLeakingObjects)\n\n  val inspectedObjectsByPath = inspectObjects(shortestPaths)\n\n  val retainedSizes =\n    if (pathFindingResults.dominatorTree != null) {\n      computeRetainedSizes(inspectedObjectsByPath, pathFindingResults.dominatorTree)\n    } else {\n      null\n    }\n  val (applicationLeaks, libraryLeaks) = buildLeakTraces(\n    shortestPaths, inspectedObjectsByPath, retainedSizes\n  )\n  return LeaksAndUnreachableObjects(applicationLeaks, libraryLeaks, unreachableObjects)\n}\n```\n\n## 展示通知\n\n回到 HeapAnalyzerService 中，analyzeHeap 方法得到分析结果后，会将结果回调给 onHeapAnalyzedListener。\n\n这里 onHeapAnalyzedListener 的唯一实现类为 DefaultOnHeapAnalyzedListener：\n\n```kotlin\noverride fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {\n  SharkLog.d { \"\\u200B\\n${LeakTraceWrapper.wrap(heapAnalysis.toString(), 120)}\" }\n\n  val db = LeaksDbHelper(application).writableDatabase\n  val id = HeapAnalysisTable.insert(db, heapAnalysis)\n  db.releaseReference()\n\n  val (contentTitle, screenToShow) = when (heapAnalysis) {\n    is HeapAnalysisFailure -\u003e application.getString(\n      R.string.leak_canary_analysis_failed\n    ) to HeapAnalysisFailureScreen(id)\n    is HeapAnalysisSuccess -\u003e {\n      val retainedObjectCount = heapAnalysis.allLeaks.sumBy { it.leakTraces.size }\n      val leakTypeCount = heapAnalysis.applicationLeaks.size + heapAnalysis.libraryLeaks.size\n      application.getString(\n        R.string.leak_canary_analysis_success_notification, retainedObjectCount, leakTypeCount\n      ) to HeapDumpScreen(id)\n    }\n  }\n\n  if (InternalLeakCanary.formFactor == TV) {\n    showToast(heapAnalysis)\n    printIntentInfo()\n  } else {\n    //展示通知\n    showNotification(screenToShow, contentTitle)\n  }\n}\n```\n\n最后将结果通过通知的方式展示出来：\n\n```kotlin\nprivate fun showNotification(\n  screenToShow: Screen,\n  contentTitle: String\n) {\n  val pendingIntent = LeakActivity.createPendingIntent(\n    application, arrayListOf(HeapDumpsScreen(), screenToShow)\n  )\n\n  val contentText = application.getString(R.string.leak_canary_notification_message)\n\n  Notifications.showNotification(\n    application, contentTitle, contentText, pendingIntent,\n    R.id.leak_canary_notification_analysis_result,\n    LEAKCANARY_MAX\n  )\n}\n```\n\n## 总结\n\n总结下 LeakCanary 对于 Activity 内存泄漏分析过程：\n\n1. 初始化 LeakCanary 需要的对象\n2. 注册监听 Activity 生命周期 onDestroy 事件\n3. 在 Activity 的 onDestroy 事件回调后，创建 KeyedWeakReference 对象，并关联 ReferenceQueue\n4. 延时 5 秒检查目标对象是否回收\n5. 未回收则开启服务，dump heap 获取内存快照 hprof 文件\n6. 解析 hprof 文件根据 KeyedWeakReference 类型过滤找到内存泄漏对象\n7. 计算对象到 GC roots 的最短路径，并合并所有最短路径为一棵树\n8. 输出分析结果，并根据分析结果通过通知的方式展示出来\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/LeakCanary/clipboard_20230323_035231.png)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/LeakCanary/clipboard_20230323_035234.png)\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["LeakCanary","源码解析"]},"/MyDraw":{"title":"MyDraw","content":"==⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==\n\n\n# Text Elements\n塑料袋放进啊 ^etTuiyn6\n\n撒地方 ^mLPqq627\n\n%%\n# Drawing\n```json\n{\n\t\"type\": \"excalidraw\",\n\t\"version\": 2,\n\t\"source\": \"https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.8.20\",\n\t\"elements\": [\n\t\t{\n\t\t\t\"id\": \"aIIHmrl8D5QZxwcdvXN8I\",\n\t\t\t\"type\": \"rectangle\",\n\t\t\t\"x\": -540,\n\t\t\t\"y\": -257.25,\n\t\t\t\"width\": 203,\n\t\t\t\"height\": 114,\n\t\t\t\"angle\": 0,\n\t\t\t\"strokeColor\": \"#000000\",\n\t\t\t\"backgroundColor\": \"transparent\",\n\t\t\t\"fillStyle\": \"hachure\",\n\t\t\t\"strokeWidth\": 1,\n\t\t\t\"strokeStyle\": \"solid\",\n\t\t\t\"roughness\": 1,\n\t\t\t\"opacity\": 100,\n\t\t\t\"groupIds\": [],\n\t\t\t\"roundness\": {\n\t\t\t\t\"type\": 3\n\t\t\t},\n\t\t\t\"seed\": 626168919,\n\t\t\t\"version\": 121,\n\t\t\t\"versionNonce\": 1582943353,\n\t\t\t\"isDeleted\": false,\n\t\t\t\"boundElements\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Z080p_bcAjknqx0PmQ1B5\",\n\t\t\t\t\t\"type\": \"arrow\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"id\": \"etTuiyn6\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"updated\": 1679729051048,\n\t\t\t\"link\": null,\n\t\t\t\"locked\": false\n\t\t},\n\t\t{\n\t\t\t\"id\": \"etTuiyn6\",\n\t\t\t\"type\": \"text\",\n\t\t\t\"x\": -535,\n\t\t\t\"y\": -212.25,\n\t\t\t\"width\": 120,\n\t\t\t\"height\": 24,\n\t\t\t\"angle\": 0,\n\t\t\t\"strokeColor\": \"#000000\",\n\t\t\t\"backgroundColor\": \"transparent\",\n\t\t\t\"fillStyle\": \"hachure\",\n\t\t\t\"strokeWidth\": 1,\n\t\t\t\"strokeStyle\": \"solid\",\n\t\t\t\"roughness\": 1,\n\t\t\t\"opacity\": 100,\n\t\t\t\"groupIds\": [],\n\t\t\t\"roundness\": null,\n\t\t\t\"seed\": 747135831,\n\t\t\t\"version\": 108,\n\t\t\t\"versionNonce\": 642913175,\n\t\t\t\"isDeleted\": false,\n\t\t\t\"boundElements\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Z080p_bcAjknqx0PmQ1B5\",\n\t\t\t\t\t\"type\": \"arrow\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"updated\": 1679729051048,\n\t\t\t\"link\": null,\n\t\t\t\"locked\": false,\n\t\t\t\"text\": \"塑料袋放进啊\",\n\t\t\t\"rawText\": \"塑料袋放进啊\",\n\t\t\t\"fontSize\": 20,\n\t\t\t\"fontFamily\": 1,\n\t\t\t\"textAlign\": \"left\",\n\t\t\t\"verticalAlign\": \"middle\",\n\t\t\t\"containerId\": \"aIIHmrl8D5QZxwcdvXN8I\",\n\t\t\t\"originalText\": \"塑料袋放进啊\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"6mDUFAncWZj1XvY0fMWFP\",\n\t\t\t\"type\": \"diamond\",\n\t\t\t\"x\": 80,\n\t\t\t\"y\": -122.25,\n\t\t\t\"width\": 155,\n\t\t\t\"height\": 155,\n\t\t\t\"angle\": 0,\n\t\t\t\"strokeColor\": \"#000000\",\n\t\t\t\"backgroundColor\": \"transparent\",\n\t\t\t\"fillStyle\": \"hachure\",\n\t\t\t\"strokeWidth\": 1,\n\t\t\t\"strokeStyle\": \"solid\",\n\t\t\t\"roughness\": 1,\n\t\t\t\"opacity\": 100,\n\t\t\t\"groupIds\": [],\n\t\t\t\"roundness\": {\n\t\t\t\t\"type\": 2\n\t\t\t},\n\t\t\t\"seed\": 27747223,\n\t\t\t\"version\": 62,\n\t\t\t\"versionNonce\": 450150295,\n\t\t\t\"isDeleted\": false,\n\t\t\t\"boundElements\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"Z080p_bcAjknqx0PmQ1B5\",\n\t\t\t\t\t\"type\": \"arrow\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"type\": \"text\",\n\t\t\t\t\t\"id\": \"mLPqq627\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"updated\": 1679729058632,\n\t\t\t\"link\": null,\n\t\t\t\"locked\": false\n\t\t},\n\t\t{\n\t\t\t\"id\": \"mLPqq627\",\n\t\t\t\"type\": \"text\",\n\t\t\t\"x\": 127.75,\n\t\t\t\"y\": -56.5,\n\t\t\t\"width\": 60,\n\t\t\t\"height\": 24,\n\t\t\t\"angle\": 0,\n\t\t\t\"strokeColor\": \"#000000\",\n\t\t\t\"backgroundColor\": \"transparent\",\n\t\t\t\"fillStyle\": \"hachure\",\n\t\t\t\"strokeWidth\": 1,\n\t\t\t\"strokeStyle\": \"solid\",\n\t\t\t\"roughness\": 1,\n\t\t\t\"opacity\": 100,\n\t\t\t\"groupIds\": [],\n\t\t\t\"roundness\": null,\n\t\t\t\"seed\": 2058146519,\n\t\t\t\"version\": 48,\n\t\t\t\"versionNonce\": 965339481,\n\t\t\t\"isDeleted\": false,\n\t\t\t\"boundElements\": null,\n\t\t\t\"updated\": 1679729058632,\n\t\t\t\"link\": null,\n\t\t\t\"locked\": false,\n\t\t\t\"text\": \"撒地方\",\n\t\t\t\"rawText\": \"撒地方\",\n\t\t\t\"fontSize\": 20,\n\t\t\t\"fontFamily\": 1,\n\t\t\t\"textAlign\": \"center\",\n\t\t\t\"verticalAlign\": \"middle\",\n\t\t\t\"containerId\": \"6mDUFAncWZj1XvY0fMWFP\",\n\t\t\t\"originalText\": \"撒地方\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"Z080p_bcAjknqx0PmQ1B5\",\n\t\t\t\"type\": \"arrow\",\n\t\t\t\"x\": -327.048791540695,\n\t\t\t\"y\": -211.45858296917035,\n\t\t\t\"width\": 430.754583832652,\n\t\t\t\"height\": 112.50279067721335,\n\t\t\t\"angle\": 0,\n\t\t\t\"strokeColor\": \"#000000\",\n\t\t\t\"backgroundColor\": \"transparent\",\n\t\t\t\"fillStyle\": \"hachure\",\n\t\t\t\"strokeWidth\": 1,\n\t\t\t\"strokeStyle\": \"solid\",\n\t\t\t\"roughness\": 1,\n\t\t\t\"opacity\": 100,\n\t\t\t\"groupIds\": [],\n\t\t\t\"roundness\": {\n\t\t\t\t\"type\": 2\n\t\t\t},\n\t\t\t\"seed\": 1018162841,\n\t\t\t\"version\": 393,\n\t\t\t\"versionNonce\": 1796560441,\n\t\t\t\"isDeleted\": false,\n\t\t\t\"boundElements\": null,\n\t\t\t\"updated\": 1679729058633,\n\t\t\t\"link\": null,\n\t\t\t\"locked\": false,\n\t\t\t\"points\": [\n\t\t\t\t[\n\t\t\t\t\t0,\n\t\t\t\t\t0\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\t430.754583832652,\n\t\t\t\t\t112.50279067721335\n\t\t\t\t]\n\t\t\t],\n\t\t\t\"lastCommittedPoint\": null,\n\t\t\t\"startBinding\": {\n\t\t\t\t\"elementId\": \"aIIHmrl8D5QZxwcdvXN8I\",\n\t\t\t\t\"gap\": 9.951208459305008,\n\t\t\t\t\"focus\": -0.47925117469243583\n\t\t\t},\n\t\t\t\"endBinding\": {\n\t\t\t\t\"elementId\": \"6mDUFAncWZj1XvY0fMWFP\",\n\t\t\t\t\"gap\": 21.566756826189703,\n\t\t\t\t\"focus\": 0.5181423531225512\n\t\t\t},\n\t\t\t\"startArrowhead\": null,\n\t\t\t\"endArrowhead\": \"arrow\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"jpwKOwkP\",\n\t\t\t\"type\": \"text\",\n\t\t\t\"x\": -56.25,\n\t\t\t\"y\": -222.5,\n\t\t\t\"width\": 10,\n\t\t\t\"height\": 24,\n\t\t\t\"angle\": 0,\n\t\t\t\"strokeColor\": \"#000000\",\n\t\t\t\"backgroundColor\": \"transparent\",\n\t\t\t\"fillStyle\": \"hachure\",\n\t\t\t\"strokeWidth\": 1,\n\t\t\t\"strokeStyle\": \"solid\",\n\t\t\t\"roughness\": 1,\n\t\t\t\"opacity\": 100,\n\t\t\t\"groupIds\": [],\n\t\t\t\"roundness\": null,\n\t\t\t\"seed\": 922744119,\n\t\t\t\"version\": 4,\n\t\t\t\"versionNonce\": 266011513,\n\t\t\t\"isDeleted\": true,\n\t\t\t\"boundElements\": null,\n\t\t\t\"updated\": 1679729054749,\n\t\t\t\"link\": null,\n\t\t\t\"locked\": false,\n\t\t\t\"text\": \"\",\n\t\t\t\"rawText\": \"\",\n\t\t\t\"fontSize\": 20,\n\t\t\t\"fontFamily\": 1,\n\t\t\t\"textAlign\": \"center\",\n\t\t\t\"verticalAlign\": \"middle\",\n\t\t\t\"containerId\": \"6mDUFAncWZj1XvY0fMWFP\",\n\t\t\t\"originalText\": \"\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"hk26Otpb\",\n\t\t\t\"type\": \"text\",\n\t\t\t\"x\": -56.25,\n\t\t\t\"y\": -222.5,\n\t\t\t\"width\": 10,\n\t\t\t\"height\": 24,\n\t\t\t\"angle\": 0,\n\t\t\t\"strokeColor\": \"#000000\",\n\t\t\t\"backgroundColor\": \"transparent\",\n\t\t\t\"fillStyle\": \"hachure\",\n\t\t\t\"strokeWidth\": 1,\n\t\t\t\"strokeStyle\": \"solid\",\n\t\t\t\"roughness\": 1,\n\t\t\t\"opacity\": 100,\n\t\t\t\"groupIds\": [],\n\t\t\t\"roundness\": null,\n\t\t\t\"seed\": 366220409,\n\t\t\t\"version\": 4,\n\t\t\t\"versionNonce\": 762679767,\n\t\t\t\"isDeleted\": true,\n\t\t\t\"boundElements\": null,\n\t\t\t\"updated\": 1679729041768,\n\t\t\t\"link\": null,\n\t\t\t\"locked\": false,\n\t\t\t\"text\": \"\",\n\t\t\t\"rawText\": \"\",\n\t\t\t\"fontSize\": 20,\n\t\t\t\"fontFamily\": 1,\n\t\t\t\"textAlign\": \"center\",\n\t\t\t\"verticalAlign\": \"middle\",\n\t\t\t\"containerId\": \"6mDUFAncWZj1XvY0fMWFP\",\n\t\t\t\"originalText\": \"\"\n\t\t},\n\t\t{\n\t\t\t\"id\": \"u6JEjyvG\",\n\t\t\t\"type\": \"text\",\n\t\t\t\"x\": -429,\n\t\t\t\"y\": -273.25,\n\t\t\t\"width\": 10,\n\t\t\t\"height\": 24,\n\t\t\t\"angle\": 0,\n\t\t\t\"strokeColor\": \"#000000\",\n\t\t\t\"backgroundColor\": \"transparent\",\n\t\t\t\"fillStyle\": \"hachure\",\n\t\t\t\"strokeWidth\": 1,\n\t\t\t\"strokeStyle\": \"solid\",\n\t\t\t\"roughness\": 1,\n\t\t\t\"opacity\": 100,\n\t\t\t\"groupIds\": [],\n\t\t\t\"roundness\": null,\n\t\t\t\"seed\": 2072928953,\n\t\t\t\"version\": 2,\n\t\t\t\"versionNonce\": 352911703,\n\t\t\t\"isDeleted\": true,\n\t\t\t\"boundElements\": null,\n\t\t\t\"updated\": 1679729012202,\n\t\t\t\"link\": null,\n\t\t\t\"locked\": false,\n\t\t\t\"text\": \"\",\n\t\t\t\"rawText\": \"\",\n\t\t\t\"fontSize\": 20,\n\t\t\t\"fontFamily\": 1,\n\t\t\t\"textAlign\": \"left\",\n\t\t\t\"verticalAlign\": \"top\",\n\t\t\t\"containerId\": null,\n\t\t\t\"originalText\": \"\"\n\t\t}\n\t],\n\t\"appState\": {\n\t\t\"theme\": \"light\",\n\t\t\"viewBackgroundColor\": \"#ffffff\",\n\t\t\"currentItemStrokeColor\": \"#000000\",\n\t\t\"currentItemBackgroundColor\": \"transparent\",\n\t\t\"currentItemFillStyle\": \"hachure\",\n\t\t\"currentItemStrokeWidth\": 1,\n\t\t\"currentItemStrokeStyle\": \"solid\",\n\t\t\"currentItemRoughness\": 1,\n\t\t\"currentItemOpacity\": 100,\n\t\t\"currentItemFontFamily\": 1,\n\t\t\"currentItemFontSize\": 20,\n\t\t\"currentItemTextAlign\": \"left\",\n\t\t\"currentItemStartArrowhead\": null,\n\t\t\"currentItemEndArrowhead\": \"arrow\",\n\t\t\"scrollX\": 637,\n\t\t\"scrollY\": 480.75,\n\t\t\"zoom\": {\n\t\t\t\"value\": 1\n\t\t},\n\t\t\"currentItemRoundness\": \"round\",\n\t\t\"gridSize\": null,\n\t\t\"colorPalette\": {},\n\t\t\"currentStrokeOptions\": null,\n\t\t\"previousGridSize\": null\n\t},\n\t\"files\": {}\n}\n```\n%%","lastmodified":"2023-04-21T14:55:32.605227307Z","tags":["excalidraw"]},"/OkHttp-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90":{"title":"OkHttp 使用及源码分析 ","content":"[https://juejin.cn/post/6881436122950402056](https://juejin.cn/post/6881436122950402056)\n\n# 请求流程\n\n## \u003cstrong\u003e同步请求\u003c/strong\u003e\n\n\u003cem\u003eMainActivity.kt\u003c/em\u003e\n\n```kotlin\nval user = \"guanpj\"\n\nval client = OkHttpClient.Builder()\n    .connectTimeout(15, TimeUnit.SECONDS)\n    .writeTimeout(30, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .proxy(Proxy.NO_PROXY)\n    .addInterceptor(HttpLoggingInterceptor { message -\u003e\n        if (BuildConfig.DEBUG) {\n            Log.i(\"OkHttp\", message)\n        }\n    })\n    .build()\n    \nval request: Request = Request.Builder()\n    .url(\"https://api.github.com/users/$user/repos\")\n    .build()\n\nval response = client.newCall(request).execute()\n\nprintln(\"Response status code: ${response.code}\")\n```\n\n\u003cem\u003eOkHttpClient.kt\u003c/em\u003e\n\n```kotlin\n/** Prepares the [request] to be executed at some point in the future. */\noverride fun newCall(request: Request): Call =\n         RealCall(this, request, forWebSocket = false)\n```\n\n\u003cem\u003eRealCall.execute\u003c/em\u003e\n\n```kotlin\noverride fun execute(): Response {\n  //保证每个 call 只能被执行一次\n  check(executed.compareAndSet(false, true)) { \"Already Executed\" }\n\n  timeout.enter()\n  callStart()\n  try {\n    client.dispatcher.executed(this)\n    return getResponseWithInterceptorChain()\n  } finally {\n    client.dispatcher.finished(this)\n  }\n}\n```\n\n\u003cem\u003eDispatcher.executed\u003c/em\u003e\n\n```kotlin\n@Synchronized internal fun executed(call: RealCall) {\n  runningSyncCalls.add(call)\n}\n```\n\n可以看到，在 extcuted 方法中并没有具体执行请求的方法，仅仅是把当前对象存入 runningSyncCalls 集合中。同步请求的核心部分在接下来的 getResponseWithInterceptorChain 中，此方法直接返回了请求结果 Response，事实上这个方法调用栈非常复杂，这里先按下不表。最后在 finially 代码块中调用了 `client.dispatcher.finished(this)`，也是传入了 this 对象，我们有理由猜测这一步就是将它从 runningSyncCalls 集合中移除，这里同样等到异步请求流程一并分析。\n\n## \u003cstrong\u003e异步请求\u003c/strong\u003e\n\n\u003cem\u003eMainActivity.kt\u003c/em\u003e\n\n```kotlin\nval user = \"guanpj\"\n\nval client = OkHttpClient.Builder()\n    .build()\nval request: Request = Request.Builder()\n    .url(\"https://api.github.com/users/$user/repos\")\n    .build()\n\nclient.newCall(request)\n    .enqueue(object : Callback {\n        override fun onFailure(call: Call, e: IOException) {\n            e.printStackTrace()\n        }\n\n        override fun onResponse(call: Call, response: Response) {\n            println(\"Response status code: ${response.code}\")\n        }\n    })\n```\n\n\u003cem\u003eRealCall.enqueue\u003c/em\u003e\n\n```kotlin\noverride fun enqueue(responseCallback: Callback) {\n  check(executed.compareAndSet(false, true)) { \"Already Executed\" }\n\n  callStart()\n  //包装成 AsyncCall，放入待执行的异步请求请求列表\n  client.dispatcher.enqueue(AsyncCall(responseCallback))\n}\n```\n\n\u003cem\u003eDispatcher.enqueue\u003c/em\u003e\n\n```kotlin\ninternal fun enqueue(call: AsyncCall) {\n  synchronized(this) {\n    //首先将 call 放入 readyAsyncCalls 集合\n    readyAsyncCalls.add(call)\n\n    // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to\n    // the same host.\n    if (!call.call.forWebSocket) {\n      val existingCall = findExistingCallWithHost(call.host)\n      if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)\n    }\n  }\n  //然后调用此方法执行\n  promoteAndExecute()\n}\n```\n\nreadyAsyncCalls 意思温为“准备好的异步请求”，而 promoteAndExecute 方法单从命名来看就是提升和执行，具体分析如下：\n\n\u003cem\u003eDispatcher.promoteAndExecute\u003c/em\u003e\n\n```kotlin\nprivate fun promoteAndExecute(): Boolean {\n  this.assertThreadDoesntHoldLock()\n  //新建一个列表存放可执行的请求\n  val executableCalls = mutableListOf\u003cAsyncCall\u003e()\n  val isRunning: Boolean\n  synchronized(this) {\n    val i = readyAsyncCalls.iterator()\n    //遍历准备好的异步请求\n    while (i.hasNext()) {\n      val asyncCall = i.next()\n      //总请求数不能超过 64 个\n      if (runningAsyncCalls.size \u003e= this.maxRequests) break // Max capacity.\n      //每个主机请求数量不能超过 5 个\n      if (asyncCall.callsPerHost.get() \u003e= this.maxRequestsPerHost) continue // Host max capacity.\n      //从 readyAsyncCalls 集合中移除\n      i.remove()\n      //安全自增\n      asyncCall.callsPerHost.incrementAndGet()\n      //加入到 executableCalls 集合\n      executableCalls.add(asyncCall)\n      //加入到 runningAsyncCalls 集合\n      runningAsyncCalls.add(asyncCall)\n    }\n    //获取正在执行中的请求（同步和异步）总数\n    isRunning = runningCallsCount() \u003e 0\n  }\n  //遍历可执行请求的集合\n  for (i in 0 until executableCalls.size) {\n    val asyncCall = executableCalls[i]\n    //调用它们的 executeOn 方法\n    asyncCall.executeOn(executorService)\n  }\n  //返回正在执行中的请求（同步和异步）总数\n  return isRunning\n}\n\n@Synchronized fun runningCallsCount(): Int \n        = runningAsyncCalls.size + runningSyncCalls.size\n```\n\n可以看到，该方法可拆分为三个步骤：\n\n1. 首先，一个请求从上一步被放入 readyAsyncCalls 集合中，在这里将遍历该集合并在条件允许的情况下将集合中的请求移除并分别加入到 runningAsyncCalls 和 executableCalls 集合；\n2. 接着遍历 executableCalls 集合并调用每个 AysncCall 的 executeOn 方法，并传入 executorService 对像用于执行这个 Call。AsyncCall 是 RealCall 中的一个内部类；\n3. 最后返回正在执行中的同步和异步请求的总数。\n\n这里重点看第二点：\n\n\u003cem\u003eRealCall.AsyncCall\u003c/em\u003e\n\n```kotlin\ninternal inner class AsyncCall(\n  private val responseCallback: Callback\n) : Runnable {\n  @Volatile var callsPerHost = AtomicInteger(0)\n    private set\n  fun reuseCallsPerHostFrom(other: AsyncCall) {\n    this.callsPerHost = other.callsPerHost\n  }\n  \n  val host: String\n    get() = originalRequest.url.host\n  val request: Request\n      get() = originalRequest\n  val call: RealCall\n      get() = this@RealCall\n  /**\n   * Attempt to enqueue this async call on [executorService]. This will attempt to clean up\n   * if the executor has been shut down by reporting the call as failed.\n   */\n  fun executeOn(executorService: ExecutorService) {\n    client.dispatcher.assertThreadDoesntHoldLock()\n    var success = false\n    try {\n      //调用 executorService 执行自己\n      executorService.execute(this)\n      success = true\n    } catch (e: RejectedExecutionException) {\n      val ioException = InterruptedIOException(\"executor rejected\")\n      ioException.initCause(e)\n      noMoreExchanges(ioException)\n      responseCallback.onFailure(this@RealCall, ioException)\n    } finally {\n      if (!success) {\n        client.dispatcher.finished(this) // This call is no longer running!\n      }\n    }\n  }\n  \n  //被 executorService.execute 时调用\n  override fun run() {\n    threadName(\"OkHttp ${redactedUrl()}\") {\n      var signalledCallback = false\n      timeout.enter()\n      try {\n        //1、在 executorService 中异步执行\n        val response = getResponseWithInterceptorChain()\n        signalledCallback = true\n        //2、回调结果\n        responseCallback.onResponse(this@RealCall, response)\n      } catch (e: IOException) {\n        if (signalledCallback) {\n          // Do not signal the callback twice!\n          Platform.get().log(\"Callback failure for ${toLoggableString()}\", Platform.INFO, e)\n        } else {\n          //回调结果\n          responseCallback.onFailure(this@RealCall, e)\n        }\n      } catch (t: Throwable) {\n        cancel()\n        if (!signalledCallback) {\n          val canceledException = IOException(\"canceled due to $t\")\n          canceledException.addSuppressed(t)\n          //回调结果\n          responseCallback.onFailure(this@RealCall, canceledException)\n        }\n        throw t\n      } finally {\n        //3、后续操作\n        client.dispatcher.finished(this)\n      }\n    }\n  }\n}\n```\n\n因为是异步请求，所以请求操作必然是在异步线程中执行的，可以看到，在 run 方法中，异步请求正常情况下分为三个步骤：\n\n1. 调用 getResponseWithInterceptorChain 方法获取 Resonse 结果，这点和同步请求一样。\n2. 将 Response 对象通过 responseCallback 进行回调。\n3. 在 finally 中调用 `client.dispatcher.finished(this)` 方法。\n\n第一步还是留到后面，第二步无须多解释，来看第三步，在同步请求流程的足后也同样执行了这个步骤。\n\n\u003cem\u003eDispatcher.finish\u003c/em\u003e\n\n```kotlin\ninternal fun finished(call: AsyncCall) {\n  call.callsPerHost.decrementAndGet()\n  finished(runningAsyncCalls, call)\n}\n\ninternal fun finished(call: RealCall) {\n  finished(runningSyncCalls, call)\n}\n\nprivate fun \u003cT\u003e finished(calls: Deque\u003cT\u003e, call: T) {\n  val idleCallback: Runnable?\n  synchronized(this) {\n    if (!calls.remove(call)) throw AssertionError(\"Call wasn't in-flight!\")\n    idleCallback = this.idleCallback\n  }\n\n  val isRunning = promoteAndExecute()\n\n  if (!isRunning \u0026\u0026 idleCallback != null) {\n    idleCallback.run()\n  }\n}\n```\n\n不管同步还是异步的 Call，最后都会走到最后一个方法，果然这里分别移除了 runningAsyncCalls 和 runningSyncCalls 集合中的 Call 对象。除此之外，这里再次调用了 promoteAndExecute 方法，前面提到过，这里返回的是正在执行中的同步和异步请求个数。当所有请求都执行完成后，会调用 idleCallback.run 方法进行回调。\n\n## getResponseWithInterceptorChain\n\n```kotlin\ninternal fun getResponseWithInterceptorChain(): Response {\n  // Build a full stack of interceptors.\n  val interceptors = mutableListOf\u003cInterceptor\u003e()\n  interceptors += client.interceptors\n  interceptors += RetryAndFollowUpInterceptor(client)\n  interceptors += BridgeInterceptor(client.cookieJar)\n  interceptors += CacheInterceptor(client.cache)\n  interceptors += ConnectInterceptor\n  if (!forWebSocket) {\n    interceptors += client.networkInterceptors\n  }\n  interceptors += CallServerInterceptor(forWebSocket)\n  \n  val chain = RealInterceptorChain(\n      call = this,\n      interceptors = interceptors,\n      index = 0,\n      exchange = null,\n      request = originalRequest,\n      connectTimeoutMillis = client.connectTimeoutMillis,\n      readTimeoutMillis = client.readTimeoutMillis,\n      writeTimeoutMillis = client.writeTimeoutMillis\n  )\n  \n  var calledNoMoreExchanges = false\n  try {\n    val response = chain.proceed(originalRequest)\n    if (isCanceled()) {\n      response.closeQuietly()\n      throw IOException(\"Canceled\")\n    }\n    return response\n  } catch (e: IOException) {\n    calledNoMoreExchanges = true\n    throw noMoreExchanges(e) as Throwable\n  } finally {\n    if (!calledNoMoreExchanges) {\n      noMoreExchanges(null)\n    }\n  }\n}\n```\n\n首先将以下拦截器依次加入到 List 中：\n\n1. OkHttpClient 设置的拦截器 interceptors()\n2. 重试、重定向拦截器 RetryAndFollowUpInterceptor\n3. 把用户请求转换为服务器请求、把服务器返响应转换为用户响应的 BridgeInterceptor\n4. 读取缓存直接返回、将响应写入到缓存中的 CacheInterceptor\n5. 与服务器建立连接的 ConnectInterceptor\n6. OkHttpClient 设置的网络拦截器 networkInterceptors()\n7. 真正执行网络请求的 CallServerInterceptor\n\n将所有的拦截器保存在 interceptors 集合中后，创建一个拦截器责任链 RealInterceptorChain，并调用其 proceed 开始处理网络请求。那么责任链模式是如何工作的呢？\n\n首先查看 RealInterceptorChain 的源码：\n\n```kotlin\nclass RealInterceptorChain(\n  internal val call: RealCall,\n  private val interceptors: List\u003cInterceptor\u003e,\n  private val index: Int,\n  internal val exchange: Exchange?,\n  internal val request: Request,\n  internal val connectTimeoutMillis: Int,\n  internal val readTimeoutMillis: Int,\n  internal val writeTimeoutMillis: Int\n) : Interceptor.Chain {\n\n  private var calls: Int = 0\n\n  internal fun copy(\n    index: Int = this.index,\n    exchange: Exchange? = this.exchange,\n    request: Request = this.request,\n    connectTimeoutMillis: Int = this.connectTimeoutMillis,\n    readTimeoutMillis: Int = this.readTimeoutMillis,\n    writeTimeoutMillis: Int = this.writeTimeoutMillis\n  ) = RealInterceptorChain(call, interceptors, index, exchange, request, connectTimeoutMillis,\n      readTimeoutMillis, writeTimeoutMillis)\n\n  ...\n\n  @Throws(IOException::class)\n  override fun proceed(request: Request): Response {\n    check(index \u003c interceptors.size)\n\n    calls++\n\n    ...\n\n    // Call the next interceptor in the chain.\n    val next = copy(index = index + 1, request = request)\n    val interceptor = interceptors[index]\n\n    @Suppress(\"USELESS_ELVIS\")\n    val response = interceptor.intercept(next) ?: throw NullPointerException(\n        \"interceptor $interceptor returned null\")\n\n    ...\n\n    return response\n  }\n}\n```\n\n在不考虑 OkHttpClient.interceptor() 的情况下，首次执行 getResponseWithInterceptorChain 方法时上面这两段代码的解释如下：\n\n1. 在 getResponseWithInterceptorChain 创建了一个 index 为 0 的 RealInterceptorChain，接着调用了其 proceed 方法；\n2. 在 RealInterceptorChain.proceed 方法中，将 index+1 并且和其它成员变量一起 copy 出一个新的 RealInterceptorChain 对象 next；\n3. 然后对当前 index 的拦截器（即 RetryAndFollowUpInterceptor）执行 interceptor.intercept(next)。在 RetryAndFollowUpInterceptor 方法中执行了 next.proceed 方法，而这里的 next 同样是 RealInterceptorChain 实例，所以回到了 RealInterceptorChain.proceed 方法中；\n4. 此时 index=1，同理链条可以一直执行下去直到 index 等于 n-1；\n5. 遇到最后一个拦截器 CallServerInterceptor，链不能继续下去了，CallServerInterceptor.intercept 方法中也不会再 proceed 了；\n6. CallServerInterceptor 建立连接后开始递归返回，Response 的返回与 Request 相反，会从最后一个开始依次往前经过这些 Intercetor。\n\n下图为 OkHttp 工作的大致流程，参考自 [拆轮子系列：拆 OkHttp](https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html)\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035335.png)\n\n同步请求和异步请求流程时序图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035341.png)\n\n# OkHttpClient\n\nOkHttpClient 相当于配置中心，所有的请求都会共享这些配置（例如出错是否重试、共享的连接池）。 OkHttpClient 中的配置主要有:\n\n- `Dispatcher dispatcher` : 调度器，用于调度后台发起的网络请求， 有后台总请求数和单主机总请求数的控制。\n- `List\u003cProtocol\u003e protocols` : 支持的应用层协议，即 HTTP/1.1、 HTTP/2 等。\n- `List\u003cConnectionSpec\u003e connectionSpecs` : 应用层支持的 Socket 设置，即使用明文传输（用于 HTTP）还是某个版本的 TLS（用于 HTTPS）。\n- `List\u003cInterceptor\u003e interceptors` : 大多数时候使用的 Interceptor 都应该配置到这里。\n- `List\u003cInterceptor\u003e networkInterceptors` : 直接和网络请求交互的 Interceptor 配置到这里，例如如果要查看返回的 301 报文或者未解压的 Response Body，需要在这里看。\n- CookieJar cookieJar : 管理 Cookie 的控制器。OkHttp 提供了 Cookie 存取的判断支持（即什么时候需要存 Cookie，什么时候需要读取 Cookie，但没有给出具体的存取实现。如果需要存取 Cookie，需要自己写实现，例如用 Map 存在内存里，或者用别的方式存在本地存储或者数据库。\n- Cache cache : Cache 存储的配置。默认是没有，如果需要用，得自己配置出 Cache 存储的文件位置以及存储空间上限。\n- HostnameVerifier hostnameVerifier : 用于验证 HTTPS 握手过程中下载到的证书所属者是否和自己要访问的主机名一致。\n- CertificatePinner certificatePinner : 用于设置 HTTPS 握手 过程中针对某个 Host 额外的的 Certificate Public Key Pinner，即把网站证书链中的每一个证书公钥直接拿来提前配置进 OkHttpClient 里去，作为正常的证书验证机制之外的一次额外验证。\n- Authenticator authenticator : 用于自动重新认证。配置之后，在请求收到 401 状态码的响应时，会直接调用 authenticator ，手动加入 Authorization header 之后自动重新发起请求。\n- boolean followRedirects : 遇到重定向的要求是，是否自动 follow。\n- boolean followSslRedirects : 在重定向时，如果原先请求的是 http 而重定向的目标是 https，或者原先请求的是 https 而重定向的目标是 http，是否依然自动 follow。注意：不是「是否自动 follow HTTPS URL 重定向的意思，而是是否自动 follow 在 HTTP 和 HTTPS 之间切换的重定向。\n- boolean retryOnConnectionFailure : 在请求失败的时候是否自动重试。注意：大多数的请求失败并不属于 OkHttp 所定义的「需要重试」， 这种重试只适用于「同一个域名的多个 IP 切换重试」「Socket 失效重试」 等情况。\n- int connectTimeout : 建立连接（TCP 或 TLS）的超时时间。\n- int readTimeout : 发起请求到读到响应数据的超时时间。\n- int writeTimeout : 发起请求并被目标服务器接受的超时时间。（因为有时候对方服务器可能由于某种原因而不读取你的 Request）\n\n# \u003cstrong\u003eRequest 和 Response\u003c/strong\u003e\n\nRequest 是发送请求封装类，内部有 url, header , method，body 等常见的参数。\n\n```kotlin\nclass Request internal constructor(\n  @get:JvmName(\"url\") val url: HttpUrl,\n  @get:JvmName(\"method\") val method: String,\n  @get:JvmName(\"headers\") val headers: Headers,\n  @get:JvmName(\"body\") val body: RequestBody?,\n  internal val tags: Map\u003cClass\u003c*\u003e, Any\u003e\n) {\n  ...\n}\n```\n\nResponse 是请求的结果，包含 code、message、header、body:\n\n```kotlin\nclass Response internal constructor(\n  /**\n   * The wire-level request that initiated this HTTP response. This is not necessarily the same\n   * request issued by the application:\n   *\n   * * It may be transformed by the HTTP client. For example, the client may copy headers like\n   *   `Content-Length` from the request body.\n   * * It may be the request generated in response to an HTTP redirect or authentication\n   *   challenge. In this case the request URL may be different than the initial request URL.\n   */\n  @get:JvmName(\"request\") val request: Request,\n\n  /** Returns the HTTP protocol, such as [Protocol.HTTP_1_1] or [Protocol.HTTP_1_0]. */\n  @get:JvmName(\"protocol\") val protocol: Protocol,\n\n  /** Returns the HTTP status message. */\n  @get:JvmName(\"message\") val message: String,\n\n  /** Returns the HTTP status code. */\n  @get:JvmName(\"code\") val code: Int,\n\n  /**\n   * Returns the TLS handshake of the connection that carried this response, or null if the\n   * response was received without TLS.\n   */\n  @get:JvmName(\"handshake\") val handshake: Handshake?,\n\n  /** Returns the HTTP headers. */\n  @get:JvmName(\"headers\") val headers: Headers,\n\n  /**\n   * Returns a non-null value if this response was passed to [Callback.onResponse] or returned\n   * from [Call.execute]. Response bodies must be [closed][ResponseBody] and may\n   * be consumed only once.\n   *\n   * This always returns null on responses returned from [cacheResponse], [networkResponse],\n   * and [priorResponse].\n   */\n  @get:JvmName(\"body\") val body: ResponseBody?,\n\n  /**\n   * Returns the raw response received from the network. Will be null if this response didn't use\n   * the network, such as when the response is fully cached. The body of the returned response\n   * should not be read.\n   */\n  @get:JvmName(\"networkResponse\") val networkResponse: Response?,\n\n  /**\n   * Returns the raw response received from the cache. Will be null if this response didn't use\n   * the cache. For conditional get requests the cache response and network response may both be\n   * non-null. The body of the returned response should not be read.\n   */\n  @get:JvmName(\"cacheResponse\") val cacheResponse: Response?,\n\n  /**\n   * Returns the response for the HTTP redirect or authorization challenge that triggered this\n   * response, or null if this response wasn't triggered by an automatic retry. The body of the\n   * returned response should not be read because it has already been consumed by the redirecting\n   * client.\n   */\n  @get:JvmName(\"priorResponse\") val priorResponse: Response?,\n\n  /**\n   * Returns a [timestamp][System.currentTimeMillis] taken immediately before OkHttp\n   * transmitted the initiating request over the network. If this response is being served from the\n   * cache then this is the timestamp of the original request.\n   */\n  @get:JvmName(\"sentRequestAtMillis\") val sentRequestAtMillis: Long,\n\n  /**\n   * Returns a [timestamp][System.currentTimeMillis] taken immediately after OkHttp\n   * received this response's headers from the network. If this response is being served from the\n   * cache then this is the timestamp of the original response.\n   */\n  @get:JvmName(\"receivedResponseAtMillis\") val receivedResponseAtMillis: Long,\n\n  @get:JvmName(\"exchange\") internal val exchange: Exchange?\n) : Closeable {\n  ...\n}\n```\n\n这两个类的定义是完全符合 Http 协议所定义的请求内容和响应内容。\n\n# RealCall\n\nOkHttpClient 的 newCall(Request) 方法会返回一个 RealCall 对象，它是 Call 接口的实现。\n\n当调用 RealCall.execute() 的时候， RealCall.getResponseWithInterceptorChain() 会被调用，它会发起网络请求并拿到返回的响应，装进一个 Response 对象并作为返回值返回；\n\nRealCall.enqueue() 被调用的时候大同小异，区别在于 enqueue() 会使用 Dispatcher 的线程池来把请求放在后台线程进行，但实质上使用的也是 getResponseWithInterceptorChain() 方法。\n\ngetResponseWithInterceptorChain() 方法做的事：把所有配置好的 Interceptor 放在一个 List 里，然后作为参数，创建一个 RealInterceptorChain 对象，并调 chain.proceed(request) 来发起请求和获取响应。\n\n```kotlin\ninternal fun getResponseWithInterceptorChain(): Response {\n  // Build a full stack of interceptors.\n  val interceptors = mutableListOf\u003cInterceptor\u003e()\n  interceptors += client.interceptors\n  interceptors += RetryAndFollowUpInterceptor(client)\n  interceptors += BridgeInterceptor(client.cookieJar)\n  interceptors += CacheInterceptor(client.cache)\n  interceptors += ConnectInterceptor\n  if (!forWebSocket) {\n    interceptors += client.networkInterceptors\n  }\n  interceptors += CallServerInterceptor(forWebSocket)\n  \n  val chain = RealInterceptorChain(\n      call = this,\n      interceptors = interceptors,\n      index = 0,\n      exchange = null,\n      request = originalRequest,\n      connectTimeoutMillis = client.connectTimeoutMillis,\n      readTimeoutMillis = client.readTimeoutMillis,\n      writeTimeoutMillis = client.writeTimeoutMillis\n  )\n  ...\n}\n```\n\n在 RealInterceptorChain 中，多个 Interceptor 会依次调用自己的 intercept() 方法。这个方法会做三件事:\n\n1. 对请求进行预处理\n2. 预处理之后，重新调用 RealIntercepterChain.proceed() 把请求交给下一个 Interceptor\n3. 在下一个 Interceptor 处理完成并返回之后，拿到 Response 进行后续处理\n\n结合源码和该示意图，可以得到拦截器具有如下特点：\n\n- 拦截器按照添加顺序依次执行\n- 拦截器的执行从 RealInterceptorChain.proceed() 开始，进入到第一个拦截器的执行逻辑\n- 每个拦截器在执行之前，会将剩余尚未执行的拦截器组成新的 RealInterceptorChain\n- 拦截器的逻辑被新的责任链调用 next.proceed() 切分为 start、next.proceed、end 这三个部分依次执行\n- next.proceed() 所代表的其实就是剩余所有拦截器的执行逻辑\n- 所有拦截器最终形成一个层层内嵌的嵌套结构\n\n# Interceptor\n\n上面提到过，OkHttp 的所有拦截器会组成链式结构：各个拦截器完成前置工作后调用下一个拦截器的 proceed 方法，再执行后置工作。通过递归调用，每个拦截器完成各自的任务。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035349.png)\n\n## client.interceptors\n\n首先是开发者使用 addInterceptor(Interceptor) 所设置的，它们会按照开发者的要求，在所有其他 Interceptor 处理之前，进行最早的预处理工作，以及在收到 Response 之后，做最后的善后工作。如果你有统一的 header 要添加，可以在这里设置。\n\n## RetryAndFollowUpInterceptor\n\n它会对连接做一些初始化工作，并且负责在请求失败时的重试，以及重定向的自动后续请求。它的存在，可以让\u003cstrong\u003e重试和重定向\u003c/strong\u003e对于开发者是无感知的。\n\nRetryAndFollowUpInterceptor.intercept 代码如下：\n\n```kotlin\n@Throws(IOException::class)\noverride fun intercept(chain: Interceptor.Chain): Response {\n  val realChain = chain as RealInterceptorChain\n  var request = chain.request\n  val call = realChain.call\n  var followUpCount = 0\n  var priorResponse: Response? = null\n  var newExchangeFinder = true\n  var recoveredFailures = listOf\u003cIOException\u003e()\n  while (true) {\n    call.enterNetworkInterceptorExchange(request, newExchangeFinder)\n\n    var response: Response\n    var closeActiveExchange = true\n    try {\n      //先判断请求是否已被取消\n      if (call.isCanceled()) {\n        throw IOException(\"Canceled\")\n      }\n\n      try {\n        //执行下一个链的 proceed\n        response = realChain.proceed(request)\n        newExchangeFinder = true\n      } catch (e: RouteException) {\n        //判断是否能恢复，如果能则继续，否则结束\n        // The attempt to connect via a route failed. The request will not have been sent.\n        if (!recover(e.lastConnectException, call, request, requestSendStarted = false)) {\n          throw e.firstConnectException.withSuppressed(recoveredFailures)\n        } else {\n          recoveredFailures += e.firstConnectException\n        }\n        newExchangeFinder = false\n        continue\n      } catch (e: IOException) {\n        // An attempt to communicate with a server failed. The request may have been sent.\n        if (!recover(e, call, request, requestSendStarted = e !is ConnectionShutdownException)) {\n          throw e.withSuppressed(recoveredFailures)\n        } else {\n          recoveredFailures += e\n        }\n        newExchangeFinder = false\n        continue\n      }\n\n      // Attach the prior response if it exists. Such responses never have a body.\n      if (priorResponse != null) {\n        response = response.newBuilder()\n            .priorResponse(priorResponse.newBuilder()\n                .body(null)\n                .build())\n            .build()\n      }\n\n      val exchange = call.interceptorScopedExchange\n      val followUp = followUpRequest(response, exchange)\n\n      if (followUp == null) {\n        if (exchange != null \u0026\u0026 exchange.isDuplex) {\n          call.timeoutEarlyExit()\n        }\n        closeActiveExchange = false\n        return response\n      }\n\n      val followUpBody = followUp.body\n      if (followUpBody != null \u0026\u0026 followUpBody.isOneShot()) {\n        closeActiveExchange = false\n        //返回\n        return response\n      }\n\n      response.body?.closeQuietly()\n\n      if (++followUpCount \u003e MAX_FOLLOW_UPS) {\n        throw ProtocolException(\"Too many follow-up requests: $followUpCount\")\n      }\n\n      request = followUp\n      priorResponse = response\n    } finally {\n      call.exitNetworkInterceptorExchange(closeActiveExchange)\n    }\n  }\n}\n\nprivate fun recover(\n  e: IOException,\n  call: RealCall,\n  userRequest: Request,\n  requestSendStarted: Boolean\n): Boolean {\n  // The application layer has forbidden retries.\n  if (!client.retryOnConnectionFailure) return false\n\n  // We can't send the request body again.\n  if (requestSendStarted \u0026\u0026 requestIsOneShot(e, userRequest)) return false\n\n  // This exception is fatal.\n  if (!isRecoverable(e, requestSendStarted)) return false\n\n  // No more routes to attempt.\n  if (!call.retryAfterFailure()) return false\n\n  // For failure recovery, use the same route selector with a new connection.\n  return true\n}\n\n\n@Throws(IOException::class)\nprivate fun followUpRequest(userResponse: Response, exchange: Exchange?): Request? {\n  val route = exchange?.connection?.route()\n  val responseCode = userResponse.code\n\n  val method = userResponse.request.method\n  when (responseCode) {\n    HTTP_PROXY_AUTH -\u003e {\n      val selectedProxy = route!!.proxy\n      if (selectedProxy.type() != Proxy.Type.HTTP) {\n        throw ProtocolException(\"Received HTTP_PROXY_AUTH (407) code while not using proxy\")\n      }\n      return client.proxyAuthenticator.authenticate(route, userResponse)\n    }\n\n    HTTP_UNAUTHORIZED -\u003e return client.authenticator.authenticate(route, userResponse)\n\n    HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT, HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -\u003e {\n      return buildRedirectRequest(userResponse, method)\n    }\n\n    HTTP_CLIENT_TIMEOUT -\u003e {\n      // 408's are rare in practice, but some servers like HAProxy use this response code. The\n      // spec says that we may repeat the request without modifications. Modern browsers also\n      // repeat the request (even non-idempotent ones.)\n      if (!client.retryOnConnectionFailure) {\n        // The application layer has directed us not to retry the request.\n        return null\n      }\n\n      val requestBody = userResponse.request.body\n      if (requestBody != null \u0026\u0026 requestBody.isOneShot()) {\n        return null\n      }\n      val priorResponse = userResponse.priorResponse\n      if (priorResponse != null \u0026\u0026 priorResponse.code == HTTP_CLIENT_TIMEOUT) {\n        // We attempted to retry and got another timeout. Give up.\n        return null\n      }\n\n      if (retryAfter(userResponse, 0) \u003e 0) {\n        return null\n      }\n\n      return userResponse.request\n    }\n\n    HTTP_UNAVAILABLE -\u003e {\n      val priorResponse = userResponse.priorResponse\n      if (priorResponse != null \u0026\u0026 priorResponse.code == HTTP_UNAVAILABLE) {\n        // We attempted to retry and got another timeout. Give up.\n        return null\n      }\n\n      if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {\n        // specifically received an instruction to retry without delay\n        return userResponse.request\n      }\n\n      return null\n    }\n\n    HTTP_MISDIRECTED_REQUEST -\u003e {\n      // OkHttp can coalesce HTTP/2 connections even if the domain names are different. See\n      // RealConnection.isEligible(). If we attempted this and the server returned HTTP 421, then\n      // we can retry on a different connection.\n      val requestBody = userResponse.request.body\n      if (requestBody != null \u0026\u0026 requestBody.isOneShot()) {\n        return null\n      }\n\n      if (exchange == null || !exchange.isCoalescedConnection) {\n        return null\n      }\n\n      exchange.connection.noCoalescedConnections()\n      return userResponse.request\n    }\n\n    else -\u003e return null\n  }\n}\n```\n\n这个过程的大致流程如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035354.png)\n\n从上图中可以看出，RetryAndFollowUpInterceptor 开启了一个 while(true) 的循环，并在循环内部完成两个重要的判定，如图中的蓝色方框：\n\n1. 当请求内部抛出异常时，判定是否需要重试\n2. 当响应结果是 3xx 重定向时，构建新的请求并发送请求\n\n重试的逻辑相对复杂，有如下的判定逻辑（具体代码在 RetryAndFollowUpInterceptor 类的 recover 方法）：\n\n- 规则 1: client 的 retryOnConnectionFailure 参数设置为 false，不进行重试\n- 规则 2: 请求的 body 已经发出，不进行重试\n- 规则 3: 特殊的异常类型不进行重试（如 ProtocolException，SSLHandshakeException 等）\n- 规则 4: 没有更多的 route（包含 proxy 和 inetaddress），不进行重试\n\n## BridgeInterceptor\n\n负责一些不影响开发者开发，但影响 HTTP 交互的一些额外预处理。\n\n```kotlin\n@Throws(IOException::class)\noverride fun intercept(chain: Interceptor.Chain): Response {\n  val userRequest = chain.request()\n  val requestBuilder = userRequest.newBuilder()\n\n  val body = userRequest.body\n  if (body != null) {\n    val contentType = body.contentType()\n    if (contentType != null) {\n      requestBuilder.header(\"Content-Type\", contentType.toString())\n    }\n\n    val contentLength = body.contentLength()\n    if (contentLength != -1L) {\n      requestBuilder.header(\"Content-Length\", contentLength.toString())\n      requestBuilder.removeHeader(\"Transfer-Encoding\")\n    } else {\n      requestBuilder.header(\"Transfer-Encoding\", \"chunked\")\n      requestBuilder.removeHeader(\"Content-Length\")\n    }\n  }\n\n  if (userRequest.header(\"Host\") == null) {\n    requestBuilder.header(\"Host\", userRequest.url.toHostHeader())\n  }\n\n  if (userRequest.header(\"Connection\") == null) {\n    requestBuilder.header(\"Connection\", \"Keep-Alive\")\n  }\n\n  // If we add an \"Accept-Encoding: gzip\" header field we're responsible for also decompressing\n  // the transfer stream.\n  var transparentGzip = false\n  if (userRequest.header(\"Accept-Encoding\") == null \u0026\u0026 userRequest.header(\"Range\") == null) {\n    transparentGzip = true\n    requestBuilder.header(\"Accept-Encoding\", \"gzip\")\n  }\n\n  val cookies = cookieJar.loadForRequest(userRequest.url)\n  if (cookies.isNotEmpty()) {\n    requestBuilder.header(\"Cookie\", cookieHeader(cookies))\n  }\n\n  if (userRequest.header(\"User-Agent\") == null) {\n    requestBuilder.header(\"User-Agent\", userAgent)\n  }\n\n  val networkResponse = chain.proceed(requestBuilder.build())\n\n  //收到响应后，存储 Cookie：\n  cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)\n\n  val responseBuilder = networkResponse.newBuilder()\n      .request(userRequest)\n\n  if (transparentGzip \u0026\u0026\n      \"gzip\".equals(networkResponse.header(\"Content-Encoding\"), ignoreCase = true) \u0026\u0026\n      networkResponse.promisesBody()) {\n    val responseBody = networkResponse.body\n    if (responseBody != null) {\n      val gzipSource = GzipSource(responseBody.source())\n      val strippedHeaders = networkResponse.headers.newBuilder()\n          .removeAll(\"Content-Encoding\")\n          .removeAll(\"Content-Length\")\n          .build()\n      responseBuilder.headers(strippedHeaders)\n      val contentType = networkResponse.header(\"Content-Type\")\n      responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))\n    }\n  }\n\n  return responseBuilder.build()\n}\n```\n\nBridgeInterceptor 拦截器的功能如下：\n\n1. 负责把用户构造的请求转换为发送到服务器的请求 、把服务器返回的响应转换为用户友好的响应，是从应用程序代码到网络代码的桥梁\n2. 设置内容长度，内容编码\n3. 设置 gzip 压缩，并在接收到内容后进行解压。省去了应用层处理数据解压的麻烦\n4. 添加 cookie\n5. 设置其他报头，如 Content-Length、User-Agent、Host、Keep-alive 等。其中 Keep-Alive 是实现连接复用的必要步骤\n\n## CacheInterceptor\n\n负责 Cache 的处理。把它放在后面的网络交互相关 Interceptor 的前面的好处是，如果本地有了可用的 Cache，一个请求可以在没有发生实质网络交互的情况下就返回缓存结果，而完全不需要开发者做出任何的额外工作，让 Cache 更加无感知。\n\n```kotlin\n@Throws(IOException::class)\noverride fun intercept(chain: Interceptor.Chain): Response {\n  val call = chain.call()\n  val cacheCandidate = cache?.get(chain.request())\n\n  val now = System.currentTimeMillis()\n\n  val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()\n  val networkRequest = strategy.networkRequest\n  val cacheResponse = strategy.cacheResponse\n\n  cache?.trackResponse(strategy)\n  val listener = (call as? RealCall)?.eventListener ?: EventListener.NONE\n\n  if (cacheCandidate != null \u0026\u0026 cacheResponse == null) {\n    // The cache candidate wasn't applicable. Close it.\n    cacheCandidate.body?.closeQuietly()\n  }\n\n  // If we're forbidden from using the network and the cache is insufficient, fail.\n  if (networkRequest == null \u0026\u0026 cacheResponse == null) {\n    return Response.Builder()\n        .request(chain.request())\n        .protocol(Protocol.HTTP_1_1)\n        .code(HTTP_GATEWAY_TIMEOUT)\n        .message(\"Unsatisfiable Request (only-if-cached)\")\n        .body(EMPTY_RESPONSE)\n        .sentRequestAtMillis(-1L)\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build().also {\n          listener.satisfactionFailure(call, it)\n        }\n  }\n\n  // If we don't need the network, we're done.\n  if (networkRequest == null) {\n    return cacheResponse!!.newBuilder()\n        .cacheResponse(stripBody(cacheResponse))\n        .build().also {\n          listener.cacheHit(call, it)\n        }\n  }\n\n  if (cacheResponse != null) {\n    listener.cacheConditionalHit(call, cacheResponse)\n  } else if (cache != null) {\n    listener.cacheMiss(call)\n  }\n\n  // 没有命中缓存\n  var networkResponse: Response? = null\n  try {\n    networkResponse = chain.proceed(networkRequest)\n  } finally {\n    // If we're crashing on I/O or otherwise, don't leak the cache body.\n    if (networkResponse == null \u0026\u0026 cacheCandidate != null) {\n      cacheCandidate.body?.closeQuietly()\n    }\n  }\n\n  // 如果缓存策略中，网络响应和响应缓存都不为null，需要更新响应缓存\n  // (比如 需要向服务器确认缓存是否可用的情况)\n  // If we have a cache response too, then we're doing a conditional get.\n  if (cacheResponse != null) {\n    // 304 的返回是不带 body 的,此时必须获取 cache 的 body\n    if (networkResponse?.code == HTTP_NOT_MODIFIED) {\n      val response = cacheResponse.newBuilder()\n          .headers(combine(cacheResponse.headers, networkResponse.headers))\n          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)\n          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)\n          .cacheResponse(stripBody(cacheResponse))\n          .networkResponse(stripBody(networkResponse))\n          .build()\n\n      networkResponse.body!!.close()\n\n      // Update the cache after combining headers but before stripping the\n      // Content-Encoding header (as performed by initContentStream()).\n      cache!!.trackConditionalCacheHit()\n      cache.update(cacheResponse, response)\n      return response.also {\n        listener.cacheHit(call, it)\n      }\n    } else {\n      cacheResponse.body?.closeQuietly()\n    }\n  }\n\n  // 构建响应对象，等待返回\n  val response = networkResponse!!.newBuilder()\n      .cacheResponse(stripBody(cacheResponse))\n      .networkResponse(stripBody(networkResponse))\n      .build()\n\n  if (cache != null) {\n    // 将请求放到缓存中\n    if (response.promisesBody() \u0026\u0026 CacheStrategy.isCacheable(response, networkRequest)) {\n      // Offer this request to the cache.\n      val cacheRequest = cache.put(response)\n      return cacheWritingResponse(cacheRequest, response).also {\n        if (cacheResponse != null) {\n          // This will log a conditional cache miss only.\n          listener.cacheMiss(call)\n        }\n      }\n    }\n\n    // 如果请求不能被缓存，则移除该请求\n    if (HttpMethod.invalidatesCache(networkRequest.method)) {\n      try {\n        cache.remove(networkRequest)\n      } catch (_: IOException) {\n        // The cache cannot be written.\n      }\n    }\n  }\n\n  return response\n}\n```\n\n这个过程的流程如下：\n\n1. 通过 Request 尝试到 Cache 中拿缓存，当然前提是 OkHttpClient 中配置了缓存，默认是不支持的。\n2. 根据 response、time、request 创建一个缓存策略，用于判断怎样使用缓存。\n3. 如果缓存策略中设置禁止使用网络，并且缓存又为空，则构建一个 Response 直接返回（返回码为 504）\n4. 缓存策略中设置不使用网络，但是又缓存，直接返回缓存\n5. 接着走后续过滤器的流程，chain.proceed(networkRequest)\n6. 当缓存存在的时候，如果网络返回的 Response 为 304，则使用缓存的 Response。\n7. 构建网络请求的 Response\n8. 当在 OkHttpClient 中配置了缓存，则将这个 Response 缓存起来。\n9. 缓存起来的步骤也是先缓存 header，再缓存 body。\n10. 返回 Response\n\n## ConnectInterceptor\n\n负责建立连接，它的源码如下：\n\n```kotlin\nobject ConnectInterceptor : Interceptor {\n  @Throws(IOException::class)\n  override fun intercept(chain: Interceptor.Chain): Response {\n    val realChain = chain as RealInterceptorChain\n    val exchange = realChain.call.initExchange(chain)\n    val connectedChain = realChain.copy(exchange = exchange)\n    //开始下一个拦截器的工作\n    return connectedChain.proceed(realChain.request)\n  }\n}\n```\n\n这个类本身很简单，从源码来看，关键的代码只有注释 1 处的那一句。它的作用是：从 RealCall 中获得了一个新的 ExChange 的对象。跟踪它的执行，可以发现它有如下调用逻辑：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035402.png)\n\n在这个步骤中，ConnectInterceptor 最终会通过 Socket 创建出网络请求所需要的 TCP 连接（如果是 HTTP），或者是建立在 TCP 连接之上的 TLS 连接（如果是 HTTPS）。并且会创建出对应的 HttpCodec 对象 （用于编码解码 HTTP 请求），并且最终封装成 Exchange 对象并返回。\n\n## client.networkInterceptors\n\nclient.networkInterceptors 是由开发者使用 addNetworkInterceptor(Interceptor) 所设置的，它们的行为逻辑和使用 addInterceptor(Interceptor) 创建的一样，但由于位置不同，所以这里创建的 Interceptor 会看到每个请求和响应的数据（包括重定向以及重试的一些中间请求和响应），并且看到的是完整原始数据，而不是没有加 Content-Length 的请求数据，或者 Body 还没有被 gzip 解压的响应数据。多数情况，这个方法不需要被使用，不过如果需要做网络调试，可以用它来实现。\n\n## CallServerInterceptor\n\nCalllServerInterceptor 是最后一个拦截器了，它负责实质的请求与响应的 I/O 操作，即：往 Socket 里写入请求数据和从 Socket 里读取响应数据，进行 http 请求报文的封装与请求报文的解析。\n\n```kotlin\n@Throws(IOException::class)\noverride fun intercept(chain: Interceptor.Chain): Response {\n  val realChain = chain as RealInterceptorChain\n  val exchange = realChain.exchange!!\n  val request = realChain.request\n  val requestBody = request.body\n  val sentRequestMillis = System.currentTimeMillis()\n\n  exchange.writeRequestHeaders(request)\n\n  var invokeStartEvent = true\n  var responseBuilder: Response.Builder? = null\n  if (HttpMethod.permitsRequestBody(request.method) \u0026\u0026 requestBody != null) {\n    // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n    // Continue\" response before transmitting the request body. If we don't get that, return\n    // what we did get (such as a 4xx response) without ever transmitting the request body.\n    if (\"100-continue\".equals(request.header(\"Expect\"), ignoreCase = true)) {\n      exchange.flushRequest()\n      responseBuilder = exchange.readResponseHeaders(expectContinue = true)\n      exchange.responseHeadersStart()\n      invokeStartEvent = false\n    }\n    if (responseBuilder == null) {\n      if (requestBody.isDuplex()) {\n        // Prepare a duplex body so that the application can send a request body later.\n        exchange.flushRequest()\n        val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()\n        requestBody.writeTo(bufferedRequestBody)\n      } else {\n        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n        val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()\n        requestBody.writeTo(bufferedRequestBody)\n        bufferedRequestBody.close()\n      }\n    } else {\n      exchange.noRequestBody()\n      if (!exchange.connection.isMultiplexed) {\n        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n        // from being reused. Otherwise we're still obligated to transmit the request body to\n        // leave the connection in a consistent state.\n        exchange.noNewExchangesOnConnection()\n      }\n    }\n  } else {\n    exchange.noRequestBody()\n  }\n\n  if (requestBody == null || !requestBody.isDuplex()) {\n    exchange.finishRequest()\n  }\n  if (responseBuilder == null) {\n    responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!\n    if (invokeStartEvent) {\n      exchange.responseHeadersStart()\n      invokeStartEvent = false\n    }\n  }\n  var response = responseBuilder\n      .request(request)\n      .handshake(exchange.connection.handshake())\n      .sentRequestAtMillis(sentRequestMillis)\n      .receivedResponseAtMillis(System.currentTimeMillis())\n      .build()\n  var code = response.code\n  if (code == 100) {\n    // Server sent a 100-continue even though we did not request one. Try again to read the actual\n    // response status.\n    responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!\n    if (invokeStartEvent) {\n      exchange.responseHeadersStart()\n    }\n    response = responseBuilder\n        .request(request)\n        .handshake(exchange.connection.handshake())\n        .sentRequestAtMillis(sentRequestMillis)\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build()\n    code = response.code\n  }\n\n  exchange.responseHeadersEnd(response)\n\n  response = if (forWebSocket \u0026\u0026 code == 101) {\n    // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n    response.newBuilder()\n        .body(EMPTY_RESPONSE)\n        .build()\n  } else {\n    response.newBuilder()\n        .body(exchange.openResponseBody(response))\n        .build()\n  }\n  if (\"close\".equals(response.request.header(\"Connection\"), ignoreCase = true) ||\n      \"close\".equals(response.header(\"Connection\"), ignoreCase = true)) {\n    exchange.noNewExchangesOnConnection()\n  }\n  if ((code == 204 || code == 205) \u0026\u0026 response.body?.contentLength() ?: -1L \u003e 0L) {\n    throw ProtocolException(\n        \"HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}\")\n  }\n  return response\n}\n```\n\nCallServerInterceptor 由以下步骤组成：\n\n1. 向服务器发送 request header\n2. 如果有 request body，就向服务器发送\n3. 读取 response header，先构造一个 Response 对象\n4. 如果有 response body，就在 3 的基础上加上 body 构造一个新的 Response 对象\n\n可以看到，核心工作都由 \u003cstrong\u003eHttpCodec\u003c/strong\u003e 对象完成，而 HttpCodec 实际上利用的是 Okio，而 Okio 实际上还是用的 Socket，只不过是经过了层层嵌套。\n\n# 总结\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/OkHttp/clipboard_20230323_035408.png)\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["OkHttp","源码解析"]},"/Retrofit-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90":{"title":"Retrofit 使用及源码分析","content":"\n# 使用\n\n1. 导入依赖。\n\n```groovy\nimplementation \"com.squareup.okhttp3:okhttp:4.9.0\"\nimplementation \"com.squareup.okhttp3:logging-interceptor:4.9.0\"\n\nimplementation \"com.squareup.retrofit2:retrofit:2.9.0\"\nimplementation \"com.squareup.retrofit2:converter-gson:2.9.0\"\nimplementation \"com.squareup.retrofit2:adapter-rxjava3:2.9.0\"\n\nimplementation \"io.reactivex.rxjava3:rxjava:3.0.0\"\nimplementation \"io.reactivex.rxjava3:rxandroid:3.0.0\"\n```\n\n2. 创建一个 interface 作为 WebService 的请求集合，在里面用注解写入需要配置的请求方法。\n\n```kotlin\ninterface GitHubService {\n  @GET(\"users/{user}/repos\")\n  fun listRepos(@Path(\"user\") user: String?): Call\u003cList\u003cRepo\u003e\u003e\n\n  @GET(\"users/{user}/repos\")\n  fun listReposRx(@Path(\"user\") user: String?): Observable\u003cList\u003cRepo\u003e\u003e\n  \n  @GET(\"users/{user}/repos\")\n  fun listReposCompletable(@Path(\"user\") user: String?): CompletableFuture\u003cList\u003cRepo\u003e\u003e\n\n  @GET(\"users/{user}/repos\")\n  suspend fun listReposSuspend(@Path(\"user\") user: String?): List\u003cRepo\u003e\n  \n  @GET(\"users/{user}/repos\")\n  fun listReposOptional(@Path(\"user\") user: String?): Call\u003cOptional\u003cList\u003cRepo\u003e\u003e\u003e\n}\n```\n\n3. 在正式代码里用 Retrofit 创建出 interface 的实例。\n\n```kotlin\nval user = \"guanpj\"\n\nval okHttpClient = OkHttpClient.Builder()\n    .connectTimeout(15, TimeUnit.SECONDS)\n    .writeTimeout(30, TimeUnit.SECONDS)\n    .readTimeout(30, TimeUnit.SECONDS)\n    .proxy(Proxy.NO_PROXY)\n    .addInterceptor(HttpLoggingInterceptor { message -\u003e\n        if (BuildConfig.DEBUG) {\n            Log.i(\"OkHttp\", message)\n        }\n    })\n    .build()\n\nval retrofit = Retrofit.Builder()\n    .client(okHttpClient)\n    .baseUrl(\"https://api.github.com/\")\n    .addCallAdapterFactory(RxJava3CallAdapterFactory.create())\n    .addConverterFactory(GsonConverterFactory.create())\n    .build()\n    \nval service = retrofit.create(GitHubService::class.java)\n```\n\n4. 调用创建出的 Service 实例的对应方法，创建出相应的可以用来发起网络请求的 Call 对象 / Obsevable 对象 / suspend 挂起函数，并发起请求。\n\n```kotlin\nval listRepos = service.listRepos(user)\nlistRepos.enqueue(object : retrofit2.Callback\u003cList\u003cRepo\u003e?\u003e {\n    override fun onFailure(call: retrofit2.Call\u003cList\u003cRepo\u003e?\u003e, t: Throwable) {\n\n    }\n\n    override fun onResponse(call: retrofit2.Call\u003cList\u003cRepo\u003e?\u003e, response: retrofit2.Response\u003cList\u003cRepo\u003e?\u003e) {\n      Log.e(\"gpj\", \"Response: ${response.body()!![0].name}\")\n    }\n})\n\nval listReposRx = service.listReposRx(user)\nlistReposRx.subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(object : Observer\u003cList\u003cRepo\u003e\u003e {\n        override fun onSubscribe(d: Disposable?) {\n        }\n\n        override fun onNext(t: List\u003cRepo\u003e?) {\n          Log.e(\"gpj\", \"size:${t?.size}\")\n        }\n\n        override fun onComplete() {\n        }\n\n        override fun onError(e: Throwable?) {\n        }\n    })\n\nval future: CompletableFuture\u003cList\u003cRepo\u003e\u003e = service.listReposCompletable(user)\nfuture.thenAccept { Log.e(\"gpj\", \"size:${it.size}\") }\n\nMainScope().launch {\n    val list = service.listReposSuspend(user)\n    Log.e(\"gpj\", \"size:${list.size}\")\n}\n\nval call = service.listReposOptional(user)\nthread {\n    // 实际上这里是会抛出异常的，原因见后文分析\n    val optionalList = call.execute().body()\n    optionalList?.ifPresent { list -\u003e list.map { Log.e(\"gpj\", it.full_name) } }\n}\n```\n\n# 解析\n\n在正式开始前，先简单介绍一下几个关键词，供备忘：\n\n- `CallAdapter\u003cR, T\u003e`：将一个 Call 从响应类型 R 适配成 T 类型的适配器。\n  - `Type responseType()` 适配器将 HTTP 响应体转换为 Java 对象时，该对象的类型。比如 `Call\u003cRepo\u003e` 的返回值是 Repo\n  - `T adapt(Call\u003cR\u003e call)`：返回一个代理了 call 的 T\n- `CallAdapter.Factory`：用于创建 CallAdapter 实例的工厂\n  - `CallAdapter\u003c?, ?\u003e get(Type returnType, Annotation[] annotations, Retrofit retrofit)`：返回一个可以返回 returnType 的接口方法的 CallAdapter，如果不能处理，则返回 null\n- `Converter\u003cF, T\u003e`：将 F 转换为 T 类型的值的转换器。\n  - `T convert(F value) throws IOException`\n- `Converter.Factory`：基于一个类型和目标类型创建一个 Converter 实例的工厂\n  - `Converter\u003cResponseBody, ?\u003e responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit)`：返回一个可以转换 HTTP 响应体到 type 的转换器\n  - `Converter\u003c?, RequestBody\u003e requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit)`：返回一个可以转换 type 到 HTTP 请求体的转换器\n  - `Converter\u003c?, String\u003e stringConverter(Type type, Annotation[] annotations, Retrofit retrofit)`：返回一个可以转换 type 到 String 的转换器\n\n## Retrofit.Builder\n\n如果想知道 Retrofit 在创建时干了些什么，就不得不看 Retrofit.Builder ，它的构造方法如下：\n\n```java\nBuilder(Platform platform) {\n  this.platform = platform;\n}\n\npublic Builder() {\n  this(Platform.get());\n}\n```\n\n这里首先是调用了 `Platform.get()` 获取了一个 Platform 实例，然后保存到变量 platform 中。\n\n```java\nclass Platform {\n  private static final Platform PLATFORM = findPlatform();\n\n  static Platform get() {\n    return PLATFORM;\n  }\n\n  private static Platform findPlatform() {\n    return \"Dalvik\".equals(System.getProperty(\"java.vm.name\"))\n        ? new Android() //\n        : new Platform(true);\n  }\n\n  private final boolean hasJava8Types;\n  private final @Nullable Constructor\u003cLookup\u003e lookupConstructor;\n\n  Platform(boolean hasJava8Types) {\n    this.hasJava8Types = hasJava8Types;\n\n    Constructor\u003cLookup\u003e lookupConstructor = null;\n    if (hasJava8Types) {\n      try {\n        // Because the service interface might not be public, we need to use a MethodHandle lookup\n        // that ignores the visibility of the declaringClass.\n        lookupConstructor = Lookup.class.getDeclaredConstructor(Class.class, int.class);\n        lookupConstructor.setAccessible(true);\n      } catch (NoClassDefFoundError ignored) {\n        // Android API 24 or 25 where Lookup doesn't exist. Calling default methods on non-public\n        // interfaces will fail, but there's nothing we can do about it.\n      } catch (NoSuchMethodException ignored) {\n        // Assume JDK 14+ which contains a fix that allows a regular lookup to succeed.\n        // See https://bugs.openjdk.java.net/browse/JDK-8209005.\n      }\n    }\n    this.lookupConstructor = lookupConstructor;\n  }\n\n  @Nullable\n  Executor defaultCallbackExecutor() {\n    return null;\n  }\n\n  // 1、如果 API \u003c 24，这里列表中只有一个 DefaultCallAdapterFactory\n  // 否则多一个 CompletableFutureCallAdapterFactory 用于支持 Java8\n  List\u003c? extends CallAdapter.Factory\u003e defaultCallAdapterFactories(\n      @Nullable Executor callbackExecutor) {\n    DefaultCallAdapterFactory executorFactory = new DefaultCallAdapterFactory(callbackExecutor);\n    return hasJava8Types\n        ? asList(CompletableFutureCallAdapterFactory.INSTANCE, executorFactory)\n        : singletonList(executorFactory);\n  }\n\n  int defaultCallAdapterFactoriesSize() {\n    return hasJava8Types ? 2 : 1;\n  }\n\n  // 2、如果 API \u003c 24，这里列表为空；\n  // 否则会有一个 OptionalConverterFactory 用于支持 Java8\n  List\u003c? extends Converter.Factory\u003e defaultConverterFactories() {\n    return hasJava8Types ? singletonList(OptionalConverterFactory.INSTANCE) : emptyList();\n  }\n\n  int defaultConverterFactoriesSize() {\n    return hasJava8Types ? 1 : 0;\n  }\n\n  @IgnoreJRERequirement // Only called on API 24+.\n  boolean isDefaultMethod(Method method) {\n    return hasJava8Types \u0026\u0026 method.isDefault();\n  }\n\n  @IgnoreJRERequirement // Only called on API 26+.\n  @Nullable\n  Object invokeDefaultMethod(Method method, Class\u003c?\u003e declaringClass, Object object, Object... args)\n      throws Throwable {\n    Lookup lookup =\n        lookupConstructor != null\n            ? lookupConstructor.newInstance(declaringClass, -1 /* trusted */)\n            : MethodHandles.lookup();\n    return lookup.unreflectSpecial(method, declaringClass).bindTo(object).invokeWithArguments(args);\n  }\n\n  static final class Android extends Platform {\n    Android() {\n      //API 24 以上才支持 Java8\n      super(Build.VERSION.SDK_INT \u003e= 24);\n    }\n\n    @Override\n    public Executor defaultCallbackExecutor() {\n      return new MainThreadExecutor();\n    }\n\n    @Nullable\n    @Override\n    Object invokeDefaultMethod(\n        Method method, Class\u003c?\u003e declaringClass, Object object, Object... args) throws Throwable {\n      if (Build.VERSION.SDK_INT \u003c 26) {\n        throw new UnsupportedOperationException(\n            \"Calling default methods on API 24 and 25 is not supported\");\n      }\n      return super.invokeDefaultMethod(method, declaringClass, object, args);\n    }\n\n    static final class MainThreadExecutor implements Executor {\n      private final Handler handler = new Handler(Looper.getMainLooper());\n\n      @Override\n      public void execute(Runnable r) {\n        handler.post(r);\n      }\n    }\n  }\n}\n```\n\nfindPlatform 方法会返回一个 Android 类型的 Platform 对象，它继承自 Platform 并重写了 defaultCallbackExecutor 返回一个 MainThreadExecutor。\n\n同时注意 43 行注释一和 57 行注释二关于 defaultCallAdapterFactories 和 defaultConverterFactories 集合的赋值情况。\n\n接下来我们在创建 Retrofit 对象的时候通过 Retrofit.Builder 设置了一些参数，这些参数都会保存到成员变量中，我们对照 Retrofit.Builder.build 方法进行解释：\n\n```java\npublic Retrofit build() {\n  if (baseUrl == null) {\n    throw new IllegalStateException(\"Base URL required.\");\n  }\n\n  // callFactory 就是传入的 OkHttpClient\n  // 因为 OkHttpClient 实现了 okhttp3.Call.Factory这个接口\n  okhttp3.Call.Factory callFactory = this.callFactory;\n  if (callFactory == null) {\n    callFactory = new OkHttpClient();\n  }\n\n  // 如果没有设置 callbackExecutor，则获取 platform 的默认 callbackExecutor\n  // 这里被赋值为了 MainThreadExecutor\n  Executor callbackExecutor = this.callbackExecutor;\n  if (callbackExecutor == null) {\n    callbackExecutor = platform.defaultCallbackExecutor();\n  }\n\n  // 在配置的时候设置了一个 RxJava3CallAdapterFactory\n  // 然后这里另外添加了一个 DefaultCallAdapterFactory，并传入刚获取的 callbackExecutor \n  // 如果 Android API \u003e= 24，默认还有一个 CompletableFutureCallAdapterFactory\n  // Make a defensive copy of the adapters and add the default Call adapter.\n  List\u003cCallAdapter.Factory\u003e callAdapterFactories = new ArrayList\u003c\u003e(this.callAdapterFactories);\n  callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));\n\n  // Make a defensive copy of the converters.\n  List\u003cConverter.Factory\u003e converterFactories =\n      new ArrayList\u003c\u003e(\n          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());\n\n  // Add the built-in converter factory first. This prevents overriding its behavior but also\n  // ensures correct behavior when using converters that consume all types.\n  // 添加内置 ConverterFactory\n  converterFactories.add(new BuiltInConverters());\n  // 添加我们设置的 GsonConverterFactory\n  converterFactories.addAll(this.converterFactories);\n  // 如果 Android API \u003e= 24，添加默认的 OptionalConverterFactory 支持 Java8\n  converterFactories.addAll(platform.defaultConverterFactories());\n\n  return new Retrofit(\n      callFactory,\n      baseUrl,\n      unmodifiableList(converterFactories),\n      unmodifiableList(callAdapterFactories),\n      callbackExecutor,\n      validateEagerly);\n}\n```\n\n这里首先是根据配置的内容和 Platform 获取到 callAdapterFactories 和 converterFactories 集合，然后利用这些参数创建一个 Retrofit 实例。\n\n需要注意的是，第 37-39 行添加用户配置的 ConverterFactory 和 Platform 默认的 ConverterFactory 的顺序值得怀疑。后文分析过程将会进行解释。\n\n## Retrofit.create\n\n```java\npublic \u003cT\u003e T create(final Class\u003cT\u003e service) {\n  validateServiceInterface(service);\n  return (T)\n      Proxy.newProxyInstance(\n          service.getClassLoader(),\n          new Class\u003c?\u003e[] {service},\n          new InvocationHandler() {\n            private final Platform platform = Platform.get();\n            private final Object[] emptyArgs = new Object[0];\n\n            @Override\n            public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)\n                throws Throwable {\n              // If the method is a method from Object then defer to normal invocation.\n              if (method.getDeclaringClass() == Object.class) {\n                return method.invoke(this, args);\n              }\n              args = args != null ? args : emptyArgs;\n              // 如果是 default 方法，则通过 platform 调用此方法\n              // 普通方法则进行 loadServiceMethod(method).invoke(args)\n              return platform.isDefaultMethod(method)\n                  ? platform.invokeDefaultMethod(method, service, proxy, args)\n                  : loadServiceMethod(method).invoke(args);\n            }\n          });\n}\n\nprivate void validateServiceInterface(Class\u003c?\u003e service) {\n  // service 必需是接口\n  if (!service.isInterface()) {\n    throw new IllegalArgumentException(\"API declarations must be interfaces.\");\n  }\n\n  Deque\u003cClass\u003c?\u003e\u003e check = new ArrayDeque\u003c\u003e(1);\n  check.add(service);\n  while (!check.isEmpty()) {\n    Class\u003c?\u003e candidate = check.removeFirst();\n    if (candidate.getTypeParameters().length != 0) {\n      StringBuilder message =\n          new StringBuilder(\"Type parameters are unsupported on \").append(candidate.getName());\n      if (candidate != service) {\n        message.append(\" which is an interface of \").append(service.getName());\n      }\n      throw new IllegalArgumentException(message.toString());\n    }\n    Collections.addAll(check, candidate.getInterfaces());\n  }\n\n  // 如果 Retrofit.Builder 中设置了此参数\n  if (validateEagerly) {\n    Platform platform = Platform.get();\n    // 提前解析并验证所有非 default 和非 static 方法是否配置正确，并缓存解析结果\n    for (Method method : service.getDeclaredMethods()) {\n      if (!platform.isDefaultMethod(method) \u0026\u0026 !Modifier.isStatic(method.getModifiers())) {\n        loadServiceMethod(method);\n      }\n    }\n  }\n}\n```\n\n可以看出，通过 Retrofit.create(Class) 方法的调用，会创建出 GitHubService 的实例，从而使得 GitHubService 中配置的方法变得可用，这是 Retrofit 代码结构的核心。\n\nRetrofit.create() 方法的核心，使用的是 Proxy.newProxyInstance() 方法来创建 GitHubService 实例。这个方法会为参数中的多个 interface（具体到 Retrofit 来说，是固定传入一个 interface）创建一个对象，这个对象实现了所有 interface 的每个方法，并且每个方法的实现都是雷同的：调用对象实例内部的一个 InvocationHandler 成员变量的 invoke() 方法，并把自己的方法信息传递进去。这样就在实质上实现了代理逻辑：interface 中的方法全部由一个另外设定的 InvocationHandler 对象来进行代理操作。并且，这些方法的具体实现是在运行时生成 interface 实例时才确定的，而不是在编译时（虽然在编译时就已经可以通过代码逻辑推断出来）。这就是\u003cstrong\u003e「动态代理机制」\u003c/strong\u003e的具体含义。\n\n因此，invoke() 方法中的逻辑，就是 Retrofit 创建 Service 实例的关键。\n\n当调用 GitHubService 中配置好的请求方法时，`InvocationHandler.invoke()` 方法就会被回调。在 invoke 方法中，会进行判断，如果调用的是我们配置的请求方法，则会走到 `loadServiceMethod(method).invoke(args)`。\n\n## loadServiceMethod(method)\n\n```java\nServiceMethod\u003c?\u003e loadServiceMethod(Method method) {\n  ServiceMethod\u003c?\u003e result = serviceMethodCache.get(method);\n  if (result != null) return result;\n\n  synchronized (serviceMethodCache) {\n    result = serviceMethodCache.get(method);\n    if (result == null) {\n      result = ServiceMethod.parseAnnotations(this, method);\n      serviceMethodCache.put(method, result);\n    }\n  }\n  return result;\n}\n```\n\n可以看到，这里对 ServiceMethod 进行了缓存设计。具体解析方法还是在 ServiceMethod 中：\n\n```java\nabstract class ServiceMethod\u003cT\u003e {\n  static \u003cT\u003e ServiceMethod\u003cT\u003e parseAnnotations(Retrofit retrofit, Method method) {\n    // 解析方法注解并创建 RequestFactory\n    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);\n\n    Type returnType = method.getGenericReturnType();\n    if (Utils.hasUnresolvableType(returnType)) {\n      throw methodError(\n          method,\n          \"Method return type must not include a type variable or wildcard: %s\",\n          returnType);\n    }\n    if (returnType == void.class) {\n      throw methodError(method, \"Service methods cannot return void.\");\n    }\n    // 解析方法注解并创建 HttpServiceMethod \n    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n  }\n\n  abstract @Nullable T invoke(Object[] args);\n}\n```\n\nHttpServiceMethod 继承自 ServiceMethod，parseAnnotations 方法如下：\n\n```java\nstatic \u003cResponseT, ReturnT\u003e HttpServiceMethod\u003cResponseT, ReturnT\u003e parseAnnotations(\n    Retrofit retrofit, Method method, RequestFactory requestFactory) {\n  boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;\n  boolean continuationWantsResponse = false;\n  boolean continuationBodyNullable = false;\n\n  Annotation[] annotations = method.getAnnotations();\n  Type adapterType;\n  // 如果是 Kotlin suspend 方法\n  if (isKotlinSuspendFunction) {\n    Type[] parameterTypes = method.getGenericParameterTypes();\n    Type responseType =\n        Utils.getParameterLowerBound(\n            0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]);\n    if (getRawType(responseType) == Response.class \u0026\u0026 responseType instanceof ParameterizedType) {\n      // Unwrap the actual body type from Response\u003cT\u003e.\n      responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);\n      continuationWantsResponse = true;\n    } else {\n      // TODO figure out if type is nullable or not\n      // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)\n      // Find the entry for method\n      // Determine if return type is nullable or not\n    }\n\n    adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);\n    annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);\n  } else {\n    // 普通方法返回泛型参数\n    adapterType = method.getGenericReturnType();\n  }\n\n  // 1、根据 method 的返回值类型以及方法注解返回第一个可以处理的 CallAdapter\n  CallAdapter\u003cResponseT, ReturnT\u003e callAdapter =\n      createCallAdapter(retrofit, method, adapterType, annotations);\n  Type responseType = callAdapter.responseType();\n  if (responseType == okhttp3.Response.class) {\n    throw methodError(\n        method,\n        \"'\"\n            + getRawType(responseType).getName()\n            + \"' is not a valid response body type. Did you mean ResponseBody?\");\n  }\n  if (responseType == Response.class) {\n    throw methodError(method, \"Response must include generic type (e.g., Response\u003cString\u003e)\");\n  }\n  // TODO support Unit for Kotlin?\n  if (requestFactory.httpMethod.equals(\"HEAD\") \u0026\u0026 !Void.class.equals(responseType)) {\n    throw methodError(method, \"HEAD method must use Void as response type.\");\n  }\n\n  // 2、根据 responseType 以及方法注解返回第一个可以处理的 Converter\n  Converter\u003cResponseBody, ResponseT\u003e responseConverter =\n      createResponseConverter(retrofit, method, responseType);\n\n  // 3、根据不同的场景返回不同的 HttpServiceMethod 实现\n  okhttp3.Call.Factory callFactory = retrofit.callFactory;\n  if (!isKotlinSuspendFunction) {\n    // 3.1、根据\n    return new CallAdapted\u003c\u003e(requestFactory, callFactory, responseConverter, callAdapter);\n  } else if (continuationWantsResponse) {\n    //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.\n    return (HttpServiceMethod\u003cResponseT, ReturnT\u003e)\n        new SuspendForResponse\u003c\u003e(\n            requestFactory,\n            callFactory,\n            responseConverter,\n            (CallAdapter\u003cResponseT, Call\u003cResponseT\u003e\u003e) callAdapter);\n  } else {\n    //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.\n    return (HttpServiceMethod\u003cResponseT, ReturnT\u003e)\n        new SuspendForBody\u003c\u003e(\n            requestFactory,\n            callFactory,\n            responseConverter,\n            (CallAdapter\u003cResponseT, Call\u003cResponseT\u003e\u003e) callAdapter,\n            continuationBodyNullable);\n  }\n}\n```\n\n这行代码负责读取 interface 中原方法的信息（包括返回值类型、方法注解、参数类型、参数注解），并将这些信息做初步分析后根据这些信息创建出每个方法对应的 CallAdapter 和 Convetor 等对象，并将这些对象传入一个 CallAdapted 对象并返回此对象。\n\n这里分别分析 32 行 `createCallAdapter` 和 51 行 `createResponseConverter` 的代码。\n\n### createCallAdapter\n\n```java\nprivate static \u003cResponseT, ReturnT\u003e CallAdapter\u003cResponseT, ReturnT\u003e createCallAdapter(\n    Retrofit retrofit, Method method, Type returnType, Annotation[] annotations) {\n  try {\n    //noinspection unchecked\n    return (CallAdapter\u003cResponseT, ReturnT\u003e) retrofit.callAdapter(returnType, annotations);\n  } catch (RuntimeException e) { // Wide exception range because factories are user code.\n    throw methodError(method, e, \"Unable to create call adapter for %s\", returnType);\n  }\n}\n```\n\n还是交给 Retrofit 类处理：\n\n```java\npublic CallAdapter\u003c?, ?\u003e callAdapter(Type returnType, Annotation[] annotations) {\n  return nextCallAdapter(null, returnType, annotations);\n}\n\npublic CallAdapter\u003c?, ?\u003e nextCallAdapter(\n    @Nullable CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) {\n  Objects.requireNonNull(returnType, \"returnType == null\");\n  Objects.requireNonNull(annotations, \"annotations == null\");\n\n  // 遍历 callAdapterFactories 集合\n  int start = callAdapterFactories.indexOf(skipPast) + 1;\n  for (int i = start, count = callAdapterFactories.size(); i \u003c count; i++) {\n    // 通过 CallAdapter.Factory.get 判断是否为符合要求的 CallAdapter\n    CallAdapter\u003c?, ?\u003e adapter = callAdapterFactories.get(i).get(returnType, annotations, this);\n    if (adapter != null) {\n      return adapter;\n    }\n  }\n\n  StringBuilder builder =\n      new StringBuilder(\"Could not locate call adapter for \").append(returnType).append(\".\\n\");\n  if (skipPast != null) {\n    builder.append(\"  Skipped:\");\n    for (int i = 0; i \u003c start; i++) {\n      builder.append(\"\\n   * \").append(callAdapterFactories.get(i).getClass().getName());\n    }\n    builder.append('\\n');\n  }\n  builder.append(\"  Tried:\");\n  for (int i = start, count = callAdapterFactories.size(); i \u003c count; i++) {\n    builder.append(\"\\n   * \").append(callAdapterFactories.get(i).getClass().getName());\n  }\n  throw new IllegalArgumentException(builder.toString());\n}\n```\n\n逻辑比较简单，就是遍历 callAdapterFactories 集合，调用每个 CallAdapter.Factory.get() 方法并传入请求方法的注解信息和返回值信息，根据这些信息每个 CallAdapter.Factory 去判断此请求方法适不适合自己。\n\n#### DefaultCallAdapterFactory.get()\n\n```java\n@Override\npublic @Nullable CallAdapter\u003c?, ?\u003e get(\n    Type returnType, Annotation[] annotations, Retrofit retrofit) {\n  // 方法返回值为 Call 类型\n  if (getRawType(returnType) != Call.class) {\n    return null;\n  }\n  \n  // 方法返回值必须包含泛型 Call\u003cFoo\u003e\n  if (!(returnType instanceof ParameterizedType)) {\n    throw new IllegalArgumentException(\n        \"Call return type must be parameterized as Call\u003cFoo\u003e or Call\u003c? extends Foo\u003e\");\n  }\n  final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);\n\n  // executor = callbackExecutor = MainThreadExecutor\n  final Executor executor =\n      Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)\n          ? null\n          : callbackExecutor;\n\n  // 返回匿名对象实现 CallAdapter\n  return new CallAdapter\u003cObject, Call\u003c?\u003e\u003e() {\n    @Override\n    public Type responseType() {\n      return responseType;\n    }\n\n    @Override\n    public Call\u003cObject\u003e adapt(Call\u003cObject\u003e call) {\n      return executor == null ? call : new ExecutorCallbackCall\u003c\u003e(executor, call);\n    }\n  };\n}\n```\n\n1. DefaultCallAdapterFactory 首先通过判断方法返回值是否为 Call 类型并且是否带有泛型参数来确定能不能处理这个请求；\n2. 然后将 executor 赋值为前面 Retrofit.create 流程中获取到的 MainThreadExecutor；\n3. 最后返回一个 CallAdapter 的匿名实现类。\n\n#### RxJava3CallAdapterFactory.get()\n\n```java\n@Override\npublic @Nullable CallAdapter\u003c?, ?\u003e get(\n  Type returnType, Annotation[] annotations, Retrofit retrofit) {\n    Class\u003c?\u003e rawType = getRawType(returnType);\n\n    if (rawType == Completable.class) {\n      // Completable is not parameterized (which is what the rest of this method deals with) so it\n      // can only be created with a single configuration.\n      return new RxJava3CallAdapter(\n          Void.class, scheduler, isAsync, false, true, false, false, false, true);\n    }\n\n    boolean isFlowable = rawType == Flowable.class;\n    boolean isSingle = rawType == Single.class;\n    boolean isMaybe = rawType == Maybe.class;\n    if (rawType != Observable.class \u0026\u0026 !isFlowable \u0026\u0026 !isSingle \u0026\u0026 !isMaybe) {\n      return null;\n    }\n\n    boolean isResult = false;\n    boolean isBody = false;\n    Type responseType;\n    if (!(returnType instanceof ParameterizedType)) {\n      String name =\n          isFlowable ? \"Flowable\" : isSingle ? \"Single\" : isMaybe ? \"Maybe\" : \"Observable\";\n      throw new IllegalStateException(\n          name\n              + \" return type must be parameterized\"\n              + \" as \"\n              + name\n              + \"\u003cFoo\u003e or \"\n              + name\n              + \"\u003c? extends Foo\u003e\");\n    }\n\n    Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);\n    Class\u003c?\u003e rawObservableType = getRawType(observableType);\n    if (rawObservableType == Response.class) {\n      if (!(observableType instanceof ParameterizedType)) {\n        throw new IllegalStateException(\n            \"Response must be parameterized\" + \" as Response\u003cFoo\u003e or Response\u003c? extends Foo\u003e\");\n      }\n      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);\n    } else if (rawObservableType == Result.class) {\n      if (!(observableType instanceof ParameterizedType)) {\n        throw new IllegalStateException(\n            \"Result must be parameterized\" + \" as Result\u003cFoo\u003e or Result\u003c? extends Foo\u003e\");\n      }\n      responseType = getParameterUpperBound(0, (ParameterizedType) observableType);\n      isResult = true;\n    } else {\n      responseType = observableType;\n      isBody = true;\n    }\n\n    return new RxJava3CallAdapter(\n        responseType, scheduler, isAsync, isResult, isBody, isFlowable, isSingle, isMaybe, false);\n  }\n}\n```\n\n#### CompletableFutureCallAdapterFactory.get()\n\n```java\n@Override\npublic @Nullable CallAdapter\u003c?, ?\u003e get(\n    Type returnType, Annotation[] annotations, Retrofit retrofit) {\n  if (getRawType(returnType) != CompletableFuture.class) {\n    return null;\n  }\n  if (!(returnType instanceof ParameterizedType)) {\n    throw new IllegalStateException(\n        \"CompletableFuture return type must be parameterized\"\n            + \" as CompletableFuture\u003cFoo\u003e or CompletableFuture\u003c? extends Foo\u003e\");\n  }\n  Type innerType = getParameterUpperBound(0, (ParameterizedType) returnType);\n\n  if (getRawType(innerType) != Response.class) {\n    // Generic type is not Response\u003cT\u003e. Use it for body-only adapter.\n    return new BodyCallAdapter\u003c\u003e(innerType);\n  }\n\n  // Generic type is Response\u003cT\u003e. Extract T and create the Response version of the adapter.\n  if (!(innerType instanceof ParameterizedType)) {\n    throw new IllegalStateException(\n        \"Response must be parameterized\" + \" as Response\u003cFoo\u003e or Response\u003c? extends Foo\u003e\");\n  }\n  Type responseType = getParameterUpperBound(0, (ParameterizedType) innerType);\n  return new ResponseCallAdapter\u003c\u003e(responseType);\n}\n```\n\n#### 小结\n\n对于例子中 GithubService 中的请求方法：\n\n1. `fun listRepos(@Path(\"user\") user: String?): Call\u003cList\u003cRepo\u003e\u003e`\n\n返回匿名的 CallAdapter 实现类\n\n2. `fun listReposRx(@Path(\"user\") user: String?): Observable\u003cList\u003cRepo\u003e\u003e`\n\n返回 RxJava3CallAdapter 实例\n\n3. `fun listReposCompletable(@Path(\"user\") user: String?): CompletableFuture\u003cList\u003cRepo\u003e\u003e`\n\n返回 CompletableFutureCallAdapterFactory.ResponseCallAdapter 实例\n\nRetrofit.callAdapter() 方法的逻辑如下：\n\n- 首先会遍历 callAdapterFactories 集合，并调用每个 CallAdapter.Factory.get() 方法并传入请求方法的注解信息和返回值信息，根据这些信息每个 CallAdapterFactory 去判断此请求方法适不适合自己。\n- 一旦找到合适的 CallAdapter 则会立即打破循环并返回。\n- DefaultCallAdapterFactory 只能处理返回值为 `Call\u003cFoo\u003e` 或者 `Call\u003c? extends Foo\u003e` 的请求方法，并且为它们返回一个匿名的 CallAdapter 实现。\n- 其它情况，如果要支持 Rxjava，则需要额外增加 CallAdapterFactory 支持。\n- 如果 Android API \u003e= 24，如果请求方法返回的是 CompletableFuture，Retrofit 默认会进行支持并返回 CompletableFutureCallAdapterFactory 进行处理。\n- 如果需要支持其它的返回值类型，则需要手动通过 addCallAdapterFactory() 方法增加对 CallAdapterFactory 的支持。\n- 如果请求方法返回值不受支持，则会抛出异常。\n\n### createResponseConverter\n\n```java\nprivate static \u003cResponseT\u003e Converter\u003cResponseBody, ResponseT\u003e createResponseConverter(\n    Retrofit retrofit, Method method, Type responseType) {\n  Annotation[] annotations = method.getAnnotations();\n  try {\n    return retrofit.responseBodyConverter(responseType, annotations);\n  } catch (RuntimeException e) { // Wide exception range because factories are user code.\n    throw methodError(method, e, \"Unable to create converter for %s\", responseType);\n  }\n}\n```\n\n还是从 Retrofit 类中获取：\n\n```java\npublic \u003cT\u003e Converter\u003cResponseBody, T\u003e responseBodyConverter(Type type, Annotation[] annotations) {\n  return nextResponseBodyConverter(null, type, annotations);\n}\n\npublic \u003cT\u003e Converter\u003cResponseBody, T\u003e nextResponseBodyConverter(\n    @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {\n  Objects.requireNonNull(type, \"type == null\");\n  Objects.requireNonNull(annotations, \"annotations == null\");\n\n  int start = converterFactories.indexOf(skipPast) + 1;\n  for (int i = start, count = converterFactories.size(); i \u003c count; i++) {\n    Converter\u003cResponseBody, ?\u003e converter =\n        converterFactories.get(i).responseBodyConverter(type, annotations, this);\n    if (converter != null) {\n      //noinspection unchecked\n      return (Converter\u003cResponseBody, T\u003e) converter;\n    }\n  }\n\n  StringBuilder builder =\n      new StringBuilder(\"Could not locate ResponseBody converter for \")\n          .append(type)\n          .append(\".\\n\");\n  if (skipPast != null) {\n    builder.append(\"  Skipped:\");\n    for (int i = 0; i \u003c start; i++) {\n      builder.append(\"\\n   * \").append(converterFactories.get(i).getClass().getName());\n    }\n    builder.append('\\n');\n  }\n  builder.append(\"  Tried:\");\n  for (int i = start, count = converterFactories.size(); i \u003c count; i++) {\n    builder.append(\"\\n   * \").append(converterFactories.get(i).getClass().getName());\n  }\n  throw new IllegalArgumentException(builder.toString());\n}\n```\n\n#### BuiltInConverters.responseBodyConverter()\n\n```java\n@Override\npublic @Nullable Converter\u003cResponseBody, ?\u003e responseBodyConverter(\n    Type type, Annotation[] annotations, Retrofit retrofit) {\n  // 返回值类型为 ResponseBody\n  if (type == ResponseBody.class) {\n    return Utils.isAnnotationPresent(annotations, Streaming.class)\n        ? StreamingResponseBodyConverter.INSTANCE\n        : BufferingResponseBodyConverter.INSTANCE;\n  }\n  // 返回值为 void\n  if (type == Void.class) {\n    return VoidResponseBodyConverter.INSTANCE;\n  }\n  // 返回值为 Kotlin 的 Unit\n  if (checkForKotlinUnit) {\n    try {\n      if (type == Unit.class) {\n        return UnitResponseBodyConverter.INSTANCE;\n      }\n    } catch (NoClassDefFoundError ignored) {\n      checkForKotlinUnit = false;\n    }\n  }\n  return null;\n}\n```\n\n据前面分析可知，BuiltInConverters 是 Retrofit 在 Android Platform 上唯一默认的 ConvertFactory。因此，请求方法的返回值的数据类型（注意不是返回值类型）只有在以上三种情况下，通过 Retrofit.Builder() 创建 Retrofit 的时候才可以不指定 ConvertFactory，否则调用该方法的时候将会抛出异常。\n\n#### GsonConverterFactory. responseBodyConverter()\n\n```java\n@Override\npublic Converter\u003cResponseBody, ?\u003e responseBodyConverter(\n    Type type, Annotation[] annotations, Retrofit retrofit) {\n  TypeAdapter\u003c?\u003e adapter = gson.getAdapter(TypeToken.get(type));\n  return new GsonResponseBodyConverter\u003c\u003e(gson, adapter);\n}\n```\n\n如果通过 addConverterFactory() 添加了 GsonConverterFactory ，这里将返回一个 GsonResponseBodyConverter 实例，不用进行任何判断，当然 gson.getAdapter 中不能抛出异常。\n\n#### OptionalConverterFactory.responseBodyConverter()\n\n```java\n@Override\npublic @Nullable Converter\u003cResponseBody, ?\u003e responseBodyConverter(\n    Type type, Annotation[] annotations, Retrofit retrofit) {\n  if (getRawType(type) != Optional.class) {\n    return null;\n  }\n\n  // 获取 Option 内层的泛型类型\n  Type innerType = getParameterUpperBound(0, (ParameterizedType) type);\n  \n  Converter\u003cResponseBody, Object\u003e delegate =\n      retrofit.responseBodyConverter(innerType, annotations);\n  return new OptionalConverter\u003c\u003e(delegate);\n}\n```\n\n它只处理返回值为 `Call\u003cOption\u003cFoo\u003e\u003e` 类型的请求，并且脱去外衣获取 Option 内层的泛型类型 innerType，并且使用这个 innerType 查找到另外一个符合要求 Converter，最后的 Convert 操作都使用这个 delegate 进行转换操作。\n\n#### 小结\n\n对于 BuiltInConverters，它只会查看泛型参数内容，如果泛型参数为 ResponseBody、Void 或者 Kotlin 的 Unit，BuiltInConverters 将会返回相应的 Converter；\n\n对于 GsonConverterFactory，它将来者不拒，返回 GsonResponseBodyConverter。\n\n对于 OptionalConverterFactory，它只处理返回值为 `Call\u003cOption\u003cFoo\u003e\u003e` 类型的请求，并且委托另外一个符合要求 Converter 进行转换操作。\n\nRetrofit.responseBodyConverter() 方法一旦找到合适的 CallAdapterFactory 则会立即打破循环并返回。\n\n因此这里需要特别注意，前面提到过的 Retrofit.Builder.build() 方法中，converterFactories 的添加顺序如下：\n\n```java\n// 添加内置 ConverterFactory\nconverterFactories.add(new BuiltInConverters());\n// 添加我们设置的 GsonConverterFactory\nconverterFactories.addAll(this.converterFactories);\n// 如果 Android API \u003e= 24，添加默认的 OptionalConverterFactory 支持 Java8\nconverterFactories.addAll(platform.defaultConverterFactories());\n```\n\n这时候如果要像这样使用 Optional 去接收数据：\n\n```kotlin\n@GET(\"users/{user}/repos\")\nfun listReposOptional(@Path(\"user\") user: String?): Call\u003cOptional\u003cList\u003cRepo\u003e\u003e\u003e\n```\n\n就会抛出异常：\n\n```plain text\ncom.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was BEGIN_ARRAY at line 1 column 2 path $\n        at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:226)\n        at retrofit2.converter.gson.GsonResponseBodyConverter.convert(GsonResponseBodyConverter.java:40)\n        at retrofit2.converter.gson.GsonResponseBodyConverter.convert(GsonResponseBodyConverter.java:27)\n        at retrofit2.OkHttpCall.parseResponse(OkHttpCall.java:243)\n        at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:153)\n```\n\n很明显这是来自 gson 的错误，根据前面的分析，如果在 Retrofit.Builder 过程添加了 GsonConverterFactory，responseBodyConverter() 方法中会直接返回一个 GsonResponseBodyConverter 对象，在解释返回结果的时候会拿 `Optional\u003cList\u003cRepo\u003e\u003e` 去接收 JSON 数组，导致解析出错。\n\n如果要使这个流程走得通，就需要将第 4 行和第 6 行代码进行交换。（本人亲自验证可行）\n\n可能这是 Retrofit 的一个 bug，如果有其他不同的理解，欢迎讨论。\n\n### return\n\n从以上分析可知，parseAnnotations() 方法最终会返回 HttpServiceMethod 实例，而 HttpServiceMethod 类又三个子类，parseAnnotations() 方法的最后会根据不同的条件来返回不同的子类实例。\n\n如果我们的请求方法不是 Kotlin 挂起函数，返回的是 CallAdapted 对象。\n\n#### CallAdapted\n\n此时 loadServiceMethod() 返回的对象为 CallAdapted：\n\n```java\nstatic final class CallAdapted\u003cResponseT, ReturnT\u003e extends HttpServiceMethod\u003cResponseT, ReturnT\u003e {\n  private final CallAdapter\u003cResponseT, ReturnT\u003e callAdapter;\n\n  CallAdapted(\n      RequestFactory requestFactory,\n      okhttp3.Call.Factory callFactory,\n      Converter\u003cResponseBody, ResponseT\u003e responseConverter,\n      CallAdapter\u003cResponseT, ReturnT\u003e callAdapter) {\n    super(requestFactory, callFactory, responseConverter);\n    this.callAdapter = callAdapter;\n  }\n\n  @Override\n  protected ReturnT adapt(Call\u003cResponseT\u003e call, Object[] args) {\n    return callAdapter.adapt(call);\n  }\n}\n```\n\n#### SuspendForResponse\n\n```java\nstatic final class SuspendForResponse\u003cResponseT\u003e extends HttpServiceMethod\u003cResponseT, Object\u003e {\n  private final CallAdapter\u003cResponseT, Call\u003cResponseT\u003e\u003e callAdapter;\n\n  SuspendForResponse(\n      RequestFactory requestFactory,\n      okhttp3.Call.Factory callFactory,\n      Converter\u003cResponseBody, ResponseT\u003e responseConverter,\n      CallAdapter\u003cResponseT, Call\u003cResponseT\u003e\u003e callAdapter) {\n    super(requestFactory, callFactory, responseConverter);\n    this.callAdapter = callAdapter;\n  }\n\n  @Override\n  protected Object adapt(Call\u003cResponseT\u003e call, Object[] args) {\n    call = callAdapter.adapt(call);\n\n    //noinspection unchecked Checked by reflection inside RequestFactory.\n    Continuation\u003cResponse\u003cResponseT\u003e\u003e continuation =\n        (Continuation\u003cResponse\u003cResponseT\u003e\u003e) args[args.length - 1];\n\n    // See SuspendForBody for explanation about this try/catch.\n    try {\n      return KotlinExtensions.awaitResponse(call, continuation);\n    } catch (Exception e) {\n      return KotlinExtensions.suspendAndThrow(e, continuation);\n    }\n  }\n}\n```\n\n#### SuspendForBody\n\n```java\nstatic final class SuspendForBody\u003cResponseT\u003e extends HttpServiceMethod\u003cResponseT, Object\u003e {\n  private final CallAdapter\u003cResponseT, Call\u003cResponseT\u003e\u003e callAdapter;\n  private final boolean isNullable;\n\n  SuspendForBody(\n      RequestFactory requestFactory,\n      okhttp3.Call.Factory callFactory,\n      Converter\u003cResponseBody, ResponseT\u003e responseConverter,\n      CallAdapter\u003cResponseT, Call\u003cResponseT\u003e\u003e callAdapter,\n      boolean isNullable) {\n    super(requestFactory, callFactory, responseConverter);\n    this.callAdapter = callAdapter;\n    this.isNullable = isNullable;\n  }\n\n  @Override\n  protected Object adapt(Call\u003cResponseT\u003e call, Object[] args) {\n    call = callAdapter.adapt(call);\n\n    //noinspection unchecked Checked by reflection inside RequestFactory.\n    Continuation\u003cResponseT\u003e continuation = (Continuation\u003cResponseT\u003e) args[args.length - 1];\n\n    // Calls to OkHttp Call.enqueue() like those inside await and awaitNullable can sometimes\n    // invoke the supplied callback with an exception before the invoking stack frame can return.\n    // Coroutines will intercept the subsequent invocation of the Continuation and throw the\n    // exception synchronously. A Java Proxy cannot throw checked exceptions without them being\n    // declared on the interface method. To avoid the synchronous checked exception being wrapped\n    // in an UndeclaredThrowableException, it is intercepted and supplied to a helper which will\n    // force suspension to occur so that it can be instead delivered to the continuation to\n    // bypass this restriction.\n    try {\n      return isNullable\n          ? KotlinExtensions.awaitNullable(call, continuation)\n          : KotlinExtensions.await(call, continuation);\n    } catch (Exception e) {\n      return KotlinExtensions.suspendAndThrow(e, continuation);\n    }\n  }\n}\n```\n\n## HttpServiceMethod.invoke(Object[] args)\n\n```java\n@Override\nfinal @Nullable ReturnT invoke(Object[] args) {\n  Call\u003cResponseT\u003e call = new OkHttpCall\u003c\u003e(requestFactory, args, callFactory, responseConverter);\n  return adapt(call, args);\n}\n\nprotected abstract @Nullable ReturnT adapt(Call\u003cResponseT\u003e call, Object[] args);\n```\n\n### new OkHttpCall\u003c\u003e()\n\nOkHttpCall 的创建：`new OkHttpCall\u003c\u003e(requestFactory, args, callFactory, responseConverter)`\n\nOkHttpCall 是 retrofit2.Call 的子类。这行代码负责将 ServiceMethod 解读到的信息（主要是一个 RequestFactory 、一个 CallFactory 和一个 ResponseConverter）封装进 OkHttpCall；而这个对象可以在需要的时候（例如它的 enqueue() 方法被调用的时候）， 利用 RequestFactory 和 CallFactory 来创建一个 okhttp3.Call 对象，并调用这个 okhttp3.Call 对象来进行网络请求的发起，然后利用 ResponseConverter 对结果进行预处理之后，交回给 Retrofit 的 Callback 。\n\n### HttpServiceMethod.adapt()\n\n调用 adapt() 方法：`adapt(call, args)`\n\n创建 OkHttpCall 对象后，会调用 abstract 方法 `adapt(Call\u003cResponseT\u003e call, Object[] args)` 将 OkHttpCall 对象和请求参数传入。\n\n根据前面的分析，HttpServiceMethod 有三个子类并且都是 HttpServiceMethod 的内部类，分别是\n\nCallAdapted、SuspendForResponse 和 SuspendForBody。\n\n#### CallAdapted.adapt\n\n```java\n@Override\nprotected ReturnT adapt(Call\u003cResponseT\u003e call, Object[] args) {\n  return callAdapter.adapt(call);\n}\n```\n\n可以看到，这里是直接调用了 callAdapter 的 adapt 方法，这个 callAdapter 就是前面 loadServiceMethod() 流程中通过 createCallAdapter() 方法获取到的 CallAdapter 对象。\n\n因此，根据前面的分析可知，此时的 CallAdapter 会根据请求方法的类型来使相应的实现类。\n\n##### DefaultCallAdapterFactory 中的匿名 CallAdapter\n\n```java\nnew CallAdapter\u003cObject, Call\u003c?\u003e\u003e() {\n  @Override\n  public Type responseType() {\n    return responseType;\n  }\n\n  @Override\n  public Call\u003cObject\u003e adapt(Call\u003cObject\u003e call) {\n    return executor == null ? call : new ExecutorCallbackCall\u003c\u003e(executor, call);\n  }\n}\n```\n\n可以看到，adapt 方法返回的是 ExecutorCallbackCall 对象。\n\n##### RxJava3CallAdapterFactory.RxJava3CallAdapter\n\n```java\n@Override\npublic Object adapt(Call\u003cR\u003e call) {\n  Observable\u003cResponse\u003cR\u003e\u003e responseObservable =\n      isAsync ? new CallEnqueueObservable\u003c\u003e(call) : new CallExecuteObservable\u003c\u003e(call);\n\n  Observable\u003c?\u003e observable;\n  if (isResult) {\n    observable = new ResultObservable\u003c\u003e(responseObservable);\n  } else if (isBody) {\n    observable = new BodyObservable\u003c\u003e(responseObservable);\n  } else {\n    observable = responseObservable;\n  }\n\n  if (scheduler != null) {\n    observable = observable.subscribeOn(scheduler);\n  }\n\n  if (isFlowable) {\n    // We only ever deliver a single value, and the RS spec states that you MUST request at least\n    // one element which means we never need to honor backpressure.\n    return observable.toFlowable(BackpressureStrategy.MISSING);\n  }\n  if (isSingle) {\n    return observable.singleOrError();\n  }\n  if (isMaybe) {\n    return observable.singleElement();\n  }\n  if (isCompletable) {\n    return observable.ignoreElements();\n  }\n  return RxJavaPlugins.onAssembly(observable);\n}\n```\n\n##### CompletableFutureCallAdapterFactory.ResponseCallAdapter\n\n```java\n@Override\npublic CompletableFuture\u003cR\u003e adapt(final Call\u003cR\u003e call) {\n  CompletableFuture\u003cR\u003e future = new CallCancelCompletableFuture\u003c\u003e(call);\n  call.enqueue(new BodyCallback(future));\n  return future;\n}\n```\n\n##### 小结\n\n对于例子中 GithubService 中的请求方法：\n\n1. `fun listRepos(@Path(\"user\") user: String?): Call\u003cList\u003cRepo\u003e\u003e`\n\n返回 DefaultCallAdapterFactory.ExecutorCallbackCall 实例\n\n2. `fun listReposRx(@Path(\"user\") user: String?): Observable\u003cList\u003cRepo\u003e\u003e`\n\n异步方式返回 CallEnqueueObservable 实例，同步方式返回 CallExecuteObservable 实例\n\n3. `fun listReposCompletable(@Path(\"user\") user: String?): CompletableFuture\u003cList\u003cRepo\u003e\u003e`\n\n返回 CompletableFutureCallAdapterFactory.CallCancelCompletableFuture 实例\n\n因此，CallAdatper 的作用就是把 OkHttpCall 根据请求方法的返回值包装成一个新的对象，并且返回给调用者。\n\n#### SuspendForResponse.adapt\n\n#### SuspendForBody.adapt\n\n## Call.enqueue()\n\n根据前面的分析，在 Android 平台上，对于返回 Call 类型的请求方法被调用时，会被一个匿名 CallAdapter 在 adapt 方法中包装成 ExecutorCallbackCall 并返回给调用者。不用多说也应该知道，这个类继承自 Call 接口。那么它是怎么实现请求的呢？\n\n```java\nstatic final class ExecutorCallbackCall\u003cT\u003e implements Call\u003cT\u003e {\n  final Executor callbackExecutor;\n  final Call\u003cT\u003e delegate;\n\n  ExecutorCallbackCall(Executor callbackExecutor, Call\u003cT\u003e delegate) {\n    this.callbackExecutor = callbackExecutor;\n    this.delegate = delegate;\n  }\n\n  @Override\n  public void enqueue(final Callback\u003cT\u003e callback) {\n    Objects.requireNonNull(callback, \"callback == null\");\n\n    delegate.enqueue(\n        new Callback\u003cT\u003e() {\n          @Override\n          public void onResponse(Call\u003cT\u003e call, final Response\u003cT\u003e response) {\n            callbackExecutor.execute(\n                () -\u003e {\n                  if (delegate.isCanceled()) {\n                    // Emulate OkHttp's behavior of throwing/delivering an IOException on\n                    // cancellation.\n                    callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\"));\n                  } else {\n                    callback.onResponse(ExecutorCallbackCall.this, response);\n                  }\n                });\n          }\n\n          @Override\n          public void onFailure(Call\u003cT\u003e call, final Throwable t) {\n            callbackExecutor.execute(() -\u003e callback.onFailure(ExecutorCallbackCall.this, t));\n          }\n        });\n  }\n\n  @Override\n  public boolean isExecuted() {\n    return delegate.isExecuted();\n  }\n\n  @Override\n  public Response\u003cT\u003e execute() throws IOException {\n    return delegate.execute();\n  }\n\n  @Override\n  public void cancel() {\n    delegate.cancel();\n  }\n\n  @Override\n  public boolean isCanceled() {\n    return delegate.isCanceled();\n  }\n\n  @SuppressWarnings(\"CloneDoesntCallSuperClone\") // Performing deep clone.\n  @Override\n  public Call\u003cT\u003e clone() {\n    return new ExecutorCallbackCall\u003c\u003e(callbackExecutor, delegate.clone());\n  }\n\n  @Override\n  public Request request() {\n    return delegate.request();\n  }\n\n  @Override\n  public Timeout timeout() {\n    return delegate.timeout();\n  }\n}\n```\n\n可以看到，这是一个典型的代理模式的实现，ExecutorCallbackCall 的全部实现都交给了 delegate 对象，而这个 delegate 正是 HttpServiceMethod.invoke() 流程中生成的 OkHttpCall 对象。\n\n在 enqueue() 方法中，首先会调用 OkHttpCall.enqueue() 方法获取请求结果，然后在 CallBack 回调中在 callbackExecutor.execute() 中将回调结果再次回调给 callback。\n\n这里 callbackExecutor 就是 Platform.Android.MainThreadExecutor，因此外层获取的回调实在主线程中的，不用再切换线程。\n\n那么再看 OkHttpCall.enqueue() 是如何工作的：\n\n```java\n@Override\npublic void enqueue(final Callback\u003cT\u003e callback) {\n  Objects.requireNonNull(callback, \"callback == null\");\n\n  okhttp3.Call call;\n  Throwable failure;\n\n  synchronized (this) {\n    if (executed) throw new IllegalStateException(\"Already executed.\");\n    executed = true;\n\n    call = rawCall;\n    failure = creationFailure;\n    if (call == null \u0026\u0026 failure == null) {\n      try {\n        call = rawCall = createRawCall();\n      } catch (Throwable t) {\n        throwIfFatal(t);\n        failure = creationFailure = t;\n      }\n    }\n  }\n\n  if (failure != null) {\n    callback.onFailure(this, failure);\n    return;\n  }\n\n  if (canceled) {\n    call.cancel();\n  }\n\n  call.enqueue(\n      new okhttp3.Callback() {\n        @Override\n        public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {\n          Response\u003cT\u003e response;\n          try {\n            // 解析结果\n            response = parseResponse(rawResponse);\n          } catch (Throwable e) {\n            throwIfFatal(e);\n            callFailure(e);\n            return;\n          }\n\n          try {\n            callback.onResponse(OkHttpCall.this, response);\n          } catch (Throwable t) {\n            throwIfFatal(t);\n            t.printStackTrace(); // TODO this is not great\n          }\n        }\n\n        @Override\n        public void onFailure(okhttp3.Call call, IOException e) {\n          callFailure(e);\n        }\n\n        private void callFailure(Throwable e) {\n          try {\n            callback.onFailure(OkHttpCall.this, e);\n          } catch (Throwable t) {\n            throwIfFatal(t);\n            t.printStackTrace(); // TODO this is not great\n          }\n        }\n      });\n}\n\nResponse\u003cT\u003e parseResponse(okhttp3.Response rawResponse) throws IOException {\n  ResponseBody rawBody = rawResponse.body();\n\n  // Remove the body's source (the only stateful object) so we can pass the response along.\n  rawResponse =\n      rawResponse\n          .newBuilder()\n          .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))\n          .build();\n\n  int code = rawResponse.code();\n  if (code \u003c 200 || code \u003e= 300) {\n    try {\n      // Buffer the entire body to avoid future I/O.\n      ResponseBody bufferedBody = Utils.buffer(rawBody);\n      return Response.error(bufferedBody, rawResponse);\n    } finally {\n      rawBody.close();\n    }\n  }\n\n  if (code == 204 || code == 205) {\n    rawBody.close();\n    return Response.success(null, rawResponse);\n  }\n\n  ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);\n  try {\n    // 使用 responseConverter 完成转换\n    T body = responseConverter.convert(catchingBody);\n    return Response.success(body, rawResponse);\n  } catch (RuntimeException e) {\n    // If the underlying source threw an exception, propagate that rather than indicating it was\n    // a runtime exception.\n    catchingBody.throwIfCaught();\n    throw e;\n  }\n}\n```\n\n可以看到，这里是依赖 OkHttp3 来实现网络请求的。获取到请求结果后，第 40 行将会调用 parseResponse() 方法将结果解析出来。parseResponse() 方法第 100 行将会调用 responseConverter 进行转换。\n\n这一整个过程可以一下时序图直观展示：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Retrofit/clipboard_20230323_035658.png)\n\n## Observable.subscribe()\n\n对于返回 Observable 的请求方法，我们知道经过 RxJava3CallAdapter.adapt 方法的包装，最终返回的是 CallEnqueueObservable 或者 CallExecuteObservable。以前者为例，来看看具体的实现方式。\n\n```java\nfinal class CallEnqueueObservable\u003cT\u003e extends Observable\u003cResponse\u003cT\u003e\u003e {\n  private final Call\u003cT\u003e originalCall;\n\n  CallEnqueueObservable(Call\u003cT\u003e originalCall) {\n    this.originalCall = originalCall;\n  }\n\n  @Override\n  protected void subscribeActual(Observer\u003c? super Response\u003cT\u003e\u003e observer) {\n    // Since Call is a one-shot type, clone it for each new observer.\n    Call\u003cT\u003e call = originalCall.clone();\n    CallCallback\u003cT\u003e callback = new CallCallback\u003c\u003e(call, observer);\n    observer.onSubscribe(callback);\n    if (!callback.isDisposed()) {\n      call.enqueue(callback);\n    }\n  }\n\n  private static final class CallCallback\u003cT\u003e implements Disposable, Callback\u003cT\u003e {\n    private final Call\u003c?\u003e call;\n    private final Observer\u003c? super Response\u003cT\u003e\u003e observer;\n    private volatile boolean disposed;\n    boolean terminated = false;\n\n    CallCallback(Call\u003c?\u003e call, Observer\u003c? super Response\u003cT\u003e\u003e observer) {\n      this.call = call;\n      this.observer = observer;\n    }\n\n    @Override\n    public void onResponse(Call\u003cT\u003e call, Response\u003cT\u003e response) {\n      if (disposed) return;\n\n      try {\n        observer.onNext(response);\n\n        if (!disposed) {\n          terminated = true;\n          observer.onComplete();\n        }\n      } catch (Throwable t) {\n        Exceptions.throwIfFatal(t);\n        if (terminated) {\n          RxJavaPlugins.onError(t);\n        } else if (!disposed) {\n          try {\n            observer.onError(t);\n          } catch (Throwable inner) {\n            Exceptions.throwIfFatal(inner);\n            RxJavaPlugins.onError(new CompositeException(t, inner));\n          }\n        }\n      }\n    }\n\n    @Override\n    public void onFailure(Call\u003cT\u003e call, Throwable t) {\n      if (call.isCanceled()) return;\n\n      try {\n        observer.onError(t);\n      } catch (Throwable inner) {\n        Exceptions.throwIfFatal(inner);\n        RxJavaPlugins.onError(new CompositeException(t, inner));\n      }\n    }\n\n    @Override\n    public void dispose() {\n      disposed = true;\n      call.cancel();\n    }\n\n    @Override\n    public boolean isDisposed() {\n      return disposed;\n    }\n  }\n}\n```\n\n在 subscribeActual() 方法中，同样调用的是 OkHttpCall.enqueue() 方法实现请求，并且在 CallCallback 回调中把请求结果通过 onNext(response) 发射给下游的 Observer。\n\n这个过程的时序图如下：\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Retrofit/clipboard_20230323_035702.png)\n\n# 总结\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/Retrofit/clipboard_20230323_035708.png)\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["Retrofit","源码解析"]},"/RxJava-%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90":{"title":"RxJava 使用及源码分析","content":"[https://juejin.cn/post/6881436122950402056](https://juejin.cn/post/6881436122950402056)\n\n# 介绍\n\nRx 是 ReactiveX 的简写，后者是 Reactive Extensions 的缩写，Rx 是一种编程模型，用于方便处理异步数据流。\n\nRxJava 是响应式编程（Reactive Extensions）在 Java VM 上的实现，是一个在 Java VM 上使用可观察序列来组成异步的、基于事件的程序库。\n\n它扩展了观察者模式以支持数据/事件序列，并添加了运算符，允许以声明方式将序列组合在一起，同时抽象出对低级线程、同步、线程安全和并发数据结构等事物的关注。\n\nRxJava 是一个 基于事件流、实现异步操作的库，因此它具有如下特点：\n\n- 异步。这里主要就是两个核心的方法 subscribeOn 和 observeOn。这两个方法都传入一个 Scheduler 对象，subscribeOn 指定产生事件的线程，observeOn 指定消费事件的线程。\n- 强大的操作符。提供了一系列的转换操作符，可以将事件序列中的某个事件或整个事件序列进行加工处理，转换成不同的事件或事件序列，然后再发送出去。\n- 简洁。由于采用链式调用的方式进行事件流的处理，RxJava 在应对较复杂的逻辑的时候，也能展现出清晰的思路。异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和 Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。\n\n## 观察者模式\n\nRxJava 有四个基本概念：Observable (可观察者，被观察者，生产者)、 Observer (观察者，消费者)、 subscribe (订阅)、Event (事件)。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，Observable 可以在需要的时候发出事件来通知 Observer，且 RxJava 支持事件以队列的形式连续发送。\n\n| 角色                   | 作用                         |\n| ---------------------- | ---------------------------- |\n| 被观察者（Observable） | 产生事件                     |\n| 观察者（Observer）     | 接收事件，并给出响应动作     |\n| 订阅（Subscribe）      | 连接 被观察者 \u0026 观察者       |\n| 事件（Event）          | 被观察者 \u0026 观察者 沟通的载体 |\n\nRxJava 的整体结构是一条链，其中：\n\n1. 链的最上游：生产者 Observable\n2. 链的最下游：观察者 Observer\n3. 链的中间：各个中介节点，既是下游的 Observable，又是上游的 Observer\n\n## 函数响应式编程结构\n\n### 响应式编程（Reactive Programming）\n\n响应式编程是一种\u003cstrong\u003e面向数据流和变化传播\u003c/strong\u003e的一种编程范式。是发送，流转，监听，响应数据流的一套编程范式。在流转的过程中可以对数据流进行过滤，转变，合并，去重等方式的处理。其中变化传播在程序中也是转换为数据流的形式进行处理。\n\n什么是响应式编程？ 正常情况下，\"a = b + c;\" 这句代码将 b+c 的值赋给 a，而之后如果 b 和 c 的值改变了不会影响到 a。然而，在响应式编程的框架之下，之后 b 和 c 的值的改变也动态影响着 a，意味着 a 会随着 b 和 c 的变化而变化。\n\n响应式编程的终极思想，一切皆流（everything is stream）。根据唯物辩证法的思想，物质世界是普遍联系和不断运动变化的统一整体，而一切“运动变化”这一“客观现象”都可以通过数据流进行“抽象描述”，也可以说，物质世界是数据流的客观存在。\n\n在程序中数据流是轻量而常见的，变量，数组，集合，对象，事件都可当做数据流来发送处理。\n\n例如：\n\n- 界面数据的展示：可以将要展示的数据由其数据源（网络请求，数据库查询等）将其以数据流的形式进行发出，通过一系列的传递，转变（后台线程传递到 UI 线程，对数据进行条件过滤等），交给界面，界面在拿到数据后，做出相应的响应，将其展示出来。\n- 用户动作的交互：可以将一些用户输入事件（触摸屏幕，点击鼠标，敲击键盘等），转换为约定的数据符号，将其以数据流的形式发送，通过层层传递，交给相应的窗口，窗口交给相应的控件，控件监听到相应的事件后，响应用户的行为。\n\n### 函数式编程（Functional programming）\n\n函数式编程是一种通过函数或者函数的组合调用来处理数据，获取结果的一种编程范式。\n\n函数是函数式编程的核心，相当于对象在面向对象编程中的地位一样。在函数式编程中，函数可以独立地解决特定的问题，可以通过与其他函数的组合调用来解决复杂的问题，可以作为另一个函数的参数，可以返回一个新的函数，也可以当做变量在函数之间或函数内部传递。\n\n在函数式编程中，纯函数和高阶函数是两大重要的角色。纯函数具有相互独立性和对外封闭性特点：\n\n1. 纯函数的返回结果只受函数参数的影响，如果输入参数相同不论在哪调用，何时调用，调用多少次其输出结果都是一样的。\n2. 纯函数内部的数据处理不受外部环境的影响也不会影响外部环境，每一个函数内部均有一套属于自己的局部变量，只在本函数内部调用也只在本函数内部起作用，其取值由函数的初始参数决定，不受外部变量的影响，同时函数的计算结果只影响函数的返回值，不影响外部变量的值。\n\n高阶函数（Higher-order function）：允许将函数作为参数传入，或者将函数作为返回值返回的函数称为高阶函数。通过高阶函数可以对纯函数进行传递，组合，链接等操作来解决不能靠单一函数解决的复杂问题。\n\n当遇到单一函数无法解决的复杂问题时，可以将其化整为零，拆分成能被单一函数处理的小问题，然后通过高阶函数对这些单一函数进行组合，链接，顺序调用进行解决。\n\n### 函数响应式编程（Functional Reactive Programming）\n\nRxjava，包括一个事件流的发送源，后面跟着 0 ~ N 个消费者消费事件流，是一种通过一系列函数的组合调用来发送，转变，监听，响应数据流的编程范式。\n\nRxJava 的函数响应式编程具体表现为一个 Observer 订阅一个 Observable，通过创建 Observable 对象发送数据流，经过一系列 Operators（操作符）加工处理和 Scheduler 在不同线程间的转发，最后由观察者接受并做出响应的一个过程。\n\nRxJava 响应式编程的组成：\n\n\u003cstrong\u003eObservable/Operator/ Observer\u003c/strong\u003e\n\nRxJava 响应式编程中的基本流程：\n\n\u003cstrong\u003eObservable -\u003e Operator1 -\u003e Operator2 -\u003e Operator3 -\u003e Observer\u003c/strong\u003e\n\n1. Observable 发出一系列事件，他是事件的产生者；\n2. Observer 负责处理事件，他是事件的最终消费者；\n3. Operator 是对 Observable 发出的事件进行修改和变换（线程，数据类型，中间计算等等）；\n4. 若事件从产生到消费不需要其他处理，则可以省略掉中间的 Operator，从而流程变为 Obsevable -\u003e Observer；\n5. Observer 通常在主线程执行，所以原则上不要去处理太多的事务，而这些复杂的处理则交给 Operator；\n\n## 操作符 Operator\n\n1. 基于原 Observable 创建一个新的 Observable\n2. Observable 内部创建一个 Observer\n3. 通过定制 Observable 的 subscribeActual() 方法和 Observer 的 onXxx() 方法，来实现自己的中介角色（例如数据转换、线程切换等）。\n\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/RxJava/clipboard_20230323_040144.png)\n\n## 背压（Backpressure）\n\n当\u003cstrong\u003e上下游在不同的线程\u003c/strong\u003e中，通过 Observable 发射、处理、响应数据流时，如果上游发射数据的速度快于下游接收处理数据的速度，这样对于那些没来得及处理的数据就会造成积压，这些数据既不会丢失，也不会被垃圾回收机制回收，而是存放在一个异步缓存池中，如果缓存池中的数据一直得不到处理，越积越多，最后就会造成内存溢出，这便是响应式编程中的背压（backpressure）问题。\n\n为此，RxJava 带来了 backpressure 的概念。背压是一种流量的控制步骤，在不知道上流还有多少数据的情形下控制内存的使用，表示它们还能处理多少数据。背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略\n\n在 Rxjava 1.0 中，有的 Observable 支持背压，有的不支持，为了解决这种问题，RxJava 2.0 把支持背压和不支持背压的 Observable 区分开来：支持背压的有 Flowable 类，不支持背压的有 Observable、Single、Maybe 和 Completable 类。\n\n1. 在订阅的时候如果使用 FlowableSubscriber，需要通过 s.request(Long.MAX_VALUE) 去主动请求上游的数据项。如果遇到背压报错的时候，FlowableSubscriber 默认已经将错误 try-catch，并通过 onError() 进行回调，程序并不会崩溃；\n2. 在订阅的时候如果使用 Consumer，那么不需要主动去请求上游数据，默认已经调用了 s.request(Long.MAX_VALUE)。如果遇到背压报错、且对 Throwable 的 Consumer 没有 new 出来，则程序直接崩溃；\n3. 背压策略的上游的默认缓存池是 128。\n\n背压策略：\n\n- error: 缓冲区大概在 128\n- buffer: 缓冲区大小在 1000 左右\n- drop: 把存不下的事件丢弃\n- latest: 只保留最新的\n- missing: 缺省设置，不做任何操作\n\n# 观察者基类\n\n## Flowable/Subscriber\n\nFlowable 允许发送 0 - N 个的数据，支持 Reactive-Streams 和背压。\n\n```java\nFlowable.range(0, 5)\n        .subscribe(new Subscriber\u003cInteger\u003e() {\n            Subscription subscription;\n            //当订阅后，会首先调用这个方法\n            //Subscription 可以用于请求数据或者取消订阅\n            @Override\n            public void onSubscribe(Subscription s) {\n                System.out.println(\"onSubscribe\");\n                subscription = s;\n                //下游订阅时请求一个数据\n                subscription.request(1);\n            }\n            @Override\n            public void onNext(Integer o) {\n                System.out.println(\"onNext:\" + o);\n                //之后下游每接收到一个数据就请求下一个数据\n                subscription.request(1);\n            }\n            @Override\n            public void onError(Throwable t) {\n                System.out.println(\"onError:\" + t.getMessage());\n            }\n            @Override\n            public void onComplete() {\n                System.out.println(\"onComplete\");\n            }\n        });\n        \n输出结果：\nonSubscribe\nonNext:0\nonNext:1\nonNext:2\nonNext:3\nonNext:4\nonComplete\n```\n\nFlowable 也可以通过 create 操作符来创建：\n\n```java\nFlowable.create(new FlowableOnSubscribe\u003cInteger\u003e() {\n    @Override\n    public void subscribe(FlowableEmitter\u003cInteger\u003e e) throws Exception {\n        for (int i = 0; i \u003c 5; i++) {\n            e.onNext(i);\n        }\n        e.onComplete();\n    }\n}, BackpressureStrategy.BUFFER);\n```\n\n## Observable/Observer\n\nObservable 允许发送 0 - N 个 的数据，但不支持背压。\n\n```java\nObservable.create(new ObservableOnSubscribe\u003cInteger\u003e() {\n    @Override\n    public void subscribe(ObservableEmitter\u003cInteger\u003e e) throws Exception {\n        for (int i = 0; i \u003c 5; i++) {\n            e.onNext(i);\n        }\n        e.onComplete();\n    }\n}).subscribe(new Observer\u003cInteger\u003e() {\n    Disposable disposable;\n\n    @Override\n    public void onSubscribe(Disposable d) {\n        System.out.println(\"onSubscribe\");\n        disposable = d;\n    }\n\n    @Override\n    public void onNext(Integer value) {\n        System.out.println(\"onNext:\" + value);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(\"onError:\" + e.getMessage());\n    }\n\n    @Override\n    public void onComplete() {\n        System.out.println(\"onComplete\");\n    }\n});\n\n输出结果：\nonSubscribe\nonNext:0\nonNext:1\nonNext:2\nonNext:3\nonNext:4\nonComplete\n```\n\n这种观察者模型不支持背压：当被观察者快速发送大量数据时，下游不会做其他处理，即使数据大量堆积，调用链也不会报 MissingBackpressureException，消耗内存过大只会 OOM。所以，当我们使用 Observable/Observer 的时候，我们需要考虑的是，数据量是不是很大 (官方给出以 1000 个事件为分界线作为参考)。\n\n## Single/SingleObserver\n\nSingle 类似于 Observable，不同的是，它总是只发射一个值，或者一个错误通知，而不是发射一系列的值（当然就不存在背压问题），所以可以使用 Single 处理单一时间流。Single 观察者只包含两个事件，一个是正常处理成功的 onSuccess，另一个是处理失败的 onError。因此，不同于 Observable 需要三个方法 onNext, onError, onCompleted，订阅 Single 只需要两个方法：\n\n- onSuccess - Single 发射单个的值到这个方法\n- onError - 如果无法发射需要的值，Single 发射一个 Throwable 对象到这个方法\n\nSingle 只会调用这两个方法中的一个，而且只会调用一次，\u003cstrong\u003e调用了任何一个方法之后，订阅关系终止\u003c/strong\u003e。\n\n```java\nSingle.create(new SingleOnSubscribe\u003cString\u003e() {\n    @Override\n    public void subscribe(SingleEmitter\u003cString\u003e e) throws Exception {\n        e.onSuccess(\"test\");\n        e.onSuccess(\"test2\");//错误写法，重复调用也不会处理，因为只会调用一次\n    }\n}).subscribe(new SingleObserver\u003cString\u003e() {\n    @Override\n    public void onSubscribe(Disposable d) {\n        System.out.println(\"onSubscribe\");\n    }\n\n    @Override\n    public void onSuccess(String s) {\n        //相当于onNext和onComplete\n        System.out.println(\"onSuccess:\" + s );\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(\"onError:\" + e.getMessage());\n    }\n});\n\n输出结果：\nonSubscribe\nonSuccess:test\n```\n\n## Completable/CompletableObserver\n\nCompletable 没有发送任何数据，但只处理 onComplete 和 onError 事件。如果你的观察者连 onNext 事件都不关心，可以使用 Completable，它只有 onComplete 和 onError 两个事件：\n\n```java\nCompletable.create(new CompletableOnSubscribe() {\n    @Override\n    public void subscribe(CompletableEmitter e) throws Exception {\n        e.onComplete();//单一 onComplete 或者 onError\n    }\n\n}).subscribe(new CompletableObserver() {\n    @Override\n    public void onSubscribe(Disposable d) {\n        System.out.println(\"onSubscribe\");\n    }\n\n    @Override\n    public void onComplete() {\n        System.out.println(\"onComplete\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(\"onError:\" + e.getMessage());\n    }\n});\n\n输出结果：\nonSubscribe\nonComplete\n```\n\n要转换成其他类型的被观察者，也是可以使用 toFlowable()、toObservable() 等方法去转换。\n\n## Maybe/MaybeObserver\n\nMaybe 模型能够发射 0 个或者 1 个数据，要么成功，要么失败。\n\n如果你有一个需求是可能发送一个数据或者不会发送任何数据，这时候你就需要 Maybe，它类似于 Single 和 Completable 的混合体。\n\nMaybe 可能会调用以下其中一种情况（也就是所谓的 Maybe）：\n\n- 发送数据时：onSuccess 或者 onError\n- 不发送数据时：onComplete 或者 onError\n\n可以看到 onSuccess 和 onComplete 是互斥的存在，例子代码如下：\n\n```java\nMaybe.create(new MaybeOnSubscribe\u003cString\u003e() {\n    @Override\n    public void subscribe(MaybeEmitter\u003cString\u003e e) throws Exception {\n        e.onSuccess(\"test\");//发送一个数据的情况，或者 onError，不需要再调用 onComplete(调用了也不会触发 onComplete 回调方法)\n        //e.onComplete();//不需要发送数据的情况，或者 onError\n    }\n}).subscribe(new MaybeObserver\u003cString\u003e() {\n    @Override\n    public void onSubscribe(Disposable d) {\n        System.out.println(\"onSubscribe\");\n    }\n\n    @Override\n    public void onSuccess(String s) {\n        //发送一个数据时，相当于 onNext 和 onComplete，但不会触发另一个方法 onComplete\n        System.out.println(\"onSuccess:\" + s );\n    }\n\n    @Override\n    public void onComplete() {\n        //无数据发送时候的 onComplete 事件\n        System.out.println(\"onComplete\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(\"onError:\" + e.getMessage());\n    }\n});\n```\n\n# Disposable\n\nRxJava 通过 Disposable（RxJava1 为 Subscription）在适当的时机取消订阅、停止数据流的发射。这在 Android 等具有 Lifecycle 概念的场景中非常重要，能够避免造成一些不必要 bug 以及内存泄露。\n\n可以通过 Disposable.dispose() 方法来让上游或内部调度器（或两者都有）停止工作，达到“丢弃”的效果。\n\n下面分几种情况分别介绍 Disposable 的工作原理。\n\n无后续，无延迟\n\n有后续，有延迟\n\n无后续，无延迟，有上下游\n\n无后续，有延迟\n\n有后续，无延迟\n\n无后续，有延迟\n\n# Scheduler\n\n1. Scheduler：线程控制器 / 调度器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 内置几种 Scheduler 类型，基本适合大多数的使用场景：\n2. Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。\n3. Schedulers.io(): 用于 IO 密集型的操作，例如读写 SD 卡文件，查询数据库，网络信息交互等，具有线程缓存机制。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程。调度器接收到任务后，先检查线程缓存池中，如果有空闲的线程，则复用，否则创建新的线程，并加入到线程池中，如果每次都没有空闲线程使用，可以无上限的创建新线程。因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n4. Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。\n5. Schedulers.trampoline( )：在当前线程立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行。\n6. Schedulers.single()：拥有一个线程单例，所有的任务都在这一个线程中执行，当此线程中有任务执行时，其他任务将会按照先进先出的顺序依次执行。\n7. Scheduler.from(@NonNull Executor executor)：指定一个线程调度器，由此调度器来控制任务的执行策略。\n8. 另外，Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。\n\n## subscribeOn()\n\n指定 subscribe() 所发生的线程，即事件产生的线程。若多次设定，则只有一次起作用。\n\n## observeOn()\n\n指定 Observer 所运行在的线程，事件消费的线程。若多次设定，每次均起作用。\n","lastmodified":"2023-04-21T14:55:33.029222555Z","tags":["RxJava","源码解析"]},"/inline-noinline-crossinline":{"title":"inline noinline crossinline","content":"\n# 普通函数\n\n## 加入 inline 前\n\n```kotlin\nfun main() {  \n\tprintName(\"guanpj\")  \n}  \n  \nfun printName(name: String) {  \n\tprintln(\"your name is: $name\")  \n}\n```\n反编译后：\n```java\npublic static final void main() {  \n\tprintName(\"guanpj\");  \n}\n\npublic static final void printName(@NotNull String name) {  \n\tString var1 = \"your name is: \" + name;  \n\tSystem.out.println(var1);  \n}\n```\n输出结果：\n\thello!\n\tyour name is: guanpj\n\tbye!\n\n## 加入 inline 后\n\n```kotlin\npublic static final void main() {  \n\tprintName(\"guanpj\");  \n}\n  \ninline fun printName(name: String) {  \n\tprintln(\"your name is: $name\")  \n}\n```\n反编译后：\n```java\npublic static final void main() {  \n\tString name$iv = \"guanpj\";  \n\tString var2 = \"your name is: \" + name$iv;  \n\tSystem.out.println(var2);  \n}\n\npublic static final void printName(@NotNull String name) {  \n\tString var2 = \"your name is: \" + name;  \n\tSystem.out.println(var2);  \n}\n```\n\n# inline 对 lambda 参数的作用\n\n## 加入 inline 前\n\n```kotlin\nfun main() {  \n\tprintName(\"abc\", { println(\"hello!\") }, { println(\"bye!\") })  \n}  \n  \nfun printName(name: String, preAction: () -\u003e Unit, postAction: () -\u003e Unit) {  \n\tpreAction()  \n\tprintln(\"your name is: $name\")  \n\tpostAction()  \n}  \n```\n反编译结果：\n```java\npublic static final void main() {  \n\tprintName(\"guanpj\", (Function0)null.INSTANCE, (Function0)null.INSTANCE);  \n}  \n  \npublic static final void printName(@NotNull String name, @NotNull Function0 preAction, \n\t\t\t\t\t\t\t\t   @NotNull Function0 postAction) {  \n\tpreAction.invoke();  \n\tString var3 = \"your name is: \" + name;  \n\tSystem.out.println(var3);  \n\tpostAction.invoke();  \n}\n```\n可以看到，main() 函数在调用 printName() 方法前，创建了一个 Function0 对象，对应类型为 `() -\u003e Unit` 的 lambda 表达式。\n\n因为 Java 并没有对函数类型的变量的原生支持，Kotlin 需要想办法来让这种自己新引入的概念在 JVM 中落地。而它想的办法是什么呢？就是用一个 JVM 对象来作为函数类型的变量的实际载体，让这个对象去执行实际的代码。也就是说，程序在每次调用 printName() 的时候都会创建一个对象来执行 lambda 表达式里的代码，虽然这个对象是用一下之后马上就被抛弃，但它确实被创建了。\n\n这有什么坏处？其实一般情况下也没什么坏处，多创建个对象算什么？但是你想一下，如果这种函数被放在循环里执行，就会造成比较大的内存开支。\n\n## 加入 inline 后\n\n```kotlin\nfun main() {  \n\tprintName(\"guanpj\", { println(\"hello!\") }, { println(\"bye!\") })  \n}  \n  \ninline fun printName(name: String, preAction: () -\u003e Unit, postAction: () -\u003e Unit) {  \n\tpreAction()  \n\tprintln(\"your name is: $name\")  \n\tpostAction()  \n}\n```\n反编译结果：\n```java\npublic static final void main() {  \n\tString name$iv = \"guanpj\";   \n\tString var3 = \"hello!\";  \n\tSystem.out.println(var3);  \n\tString var5 = \"your name is: \" + name$iv;  \n\tSystem.out.println(var5);  \n\tString var4 = \"bye!\";  \n\tSystem.out.println(var4);  \n}  \n  \npublic static final void printName(@NotNull String name, @NotNull Function0 preAction, \n\t\t\t\t\t\t\t\t   @NotNull Function0 postAction) {  \n\tpreAction.invoke();  \n\tString var4 = \"your name is: \" + name;  \n\tSystem.out.println(var4);  \n\tpostAction.invoke();  \n}\n```\n从句字节码中可以看到，经过这种优化，就避免了函数类型的参数所造成的临时对象的创建。也就不怕在循环或者界面刷新这样的高频场景里调用它们了。\n\n## 注意事项\n\n### public inline 方法不能私有属性\n\n```kotlin\nclass Demo(private val title: \"String) {\"\n\t// 编译错误\n    inline fun test(l: () -\u003e Unit) {\n        println(\"Title: $title\") \n    }\n\n    // 编译通过\n    private inline fun test(l: () -\u003e Unit) {\n        println(\"Title: $title\")\n    }\n}\n```\n\n### lambda 中的 return 造成意外返回\n\n在普通函数中，是不允许 lambda 中直接 return 的。但是在内联函数中是允许的，如下所示：\n```kotlin\nfun main() {  \n\tprintName(\"guanpj\",  \n\t\t{  \n\t\t\tprintln(\"hello!\")  \n\t\t\treturn // 注意这里返回了 Unit\n\t\t},  \n\t\t{ println(\"bye!\") }  \n\t)  \n}  \n  \ninline fun printName(name: String, preAction: () -\u003e Unit, postAction: () -\u003e Unit) {  \n\tpreAction()  \n\tprintln(\"your name is: $name\")  \n\tpostAction()  \n}\n```\n执行结果：\nhello!\n\n反编译后：\n```java\npublic static final void main() {  \n\tString name$iv = \"guanpj\";  \n\tint var2 = false;  \n\tString var3 = \"hello!\";  \n\tSystem.out.println(var3);  \n}  \n  \npublic static final void printName(@NotNull String name, @NotNull Function0 preAction, \n\t\t\t\t\t\t\t\t   @NotNull Function0 postAction) {  \n\tpreAction.invoke();  \n\tString var4 = \"your name is: \" + name;  \n\tSystem.out.println(var4);  \n\tpostAction.invoke();  \n}\n```\n\n#### 如何避免？\n\n通过 @ 标签返回到指定位置：\n```kotlin\nfun main() {  \n\tprintName(\"guanpj\",  \n\t\t{  \n\t\t\tprintln(\"hello!\")  \n\t\t\treturn@printName  \n\t\t},  \n\t\t{ println(\"bye!\") }  \n\t)  \n}\n```\n输出结果：\nhello!\nyour name is: guanpj\nbye!\n\n# noinline\n\nnoinline 的意思很直白：inline 是内联，而 noinline 就是不内联。不过它不是作用于函数的，而是作用于函数的参数：对于一个标记了 inline 的内联函数，你可以对它的任何一个或多个函数类型的参数添加 noinline 关键字。\n\n## 加入 noinline 前\n\n```kotlin\nfun main() {  \n\tval postAction = printName(\"guanpj\",  \n\t\t{ println(\"hello!\") },  \n\t\t{ println(\"bye!\") }  \n\t)  \n\tpostAction()  \n}  \n  \ninline fun printName(name: String, preAction: () -\u003e Unit, postAction: () -\u003e Unit): () -\u003e \nUnit {  \n\tpreAction()  \n\tprintln(\"your name is: $name\")  \n\treturn postAction // IDE 报错\n}\n```\n编译器报错内容：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/inline%26noinline%26crossinline/noinline.png)\n把函数进行内联的时候，它内部的这些参数就不再是对象了，因为它们会被编译器拿到调用处去展开。\n\n也就是说，main() 方法里面会将 printName() 方法进行了展开，同时会把 postAction 参数进行展开，从而获取不到 printName() 方法的返回值。\n\n如果真的需要用这个对象，则需要加上 noinline 关键字。\n\n## 加入 noinline 后\n\n```kotlin\ninline fun printName(name: String, preAction: () -\u003e Unit, noinline postAction: \n\t\t\t\t\t () -\u003e Unit): () -\u003e Unit {  \n\tpreAction()  \n\tprintln(\"your name is: $name\")  \n\treturn postAction  \n}\n```\n反编译后：\n```java\npublic static final void main() {  \n\tString name$iv = \"guanpj\";  \n\tFunction0 postAction$iv = (Function0)null.INSTANCE;  \n\tString var5 = \"hello!\";  \n\tSystem.out.println(var5);  \n\tString var6 = \"your name is: \" + name$iv;  \n\tSystem.out.println(var6);  \n\tpostAction$iv.invoke();  \n}  \n  \n@NotNull  \npublic static final Function0 printName(@NotNull String name, @NotNull Function0 \n\t\t\t\t\t\t\t\t\t\t preAction, @NotNull Function0 postAction) {  \n\tpreAction.invoke();  \n\tString var4 = \"your name is: \" + name;  \n\tSystem.out.println(var4);  \n\treturn postAction;  \n}\n```\n可以看到，noline 加入后，preAction 没有被内联，并创建了一个 Function0 对象。\n\n所以，noinline 的作用是什么？是用来局部地、指向性地关掉函数的内联优化的。既然是优化，为什么要关掉？因为这种优化会导致函数中的函数类型的参数无法被当做对象使用，也就是说，这种优化会对 Kotlin 的功能做出一定程度的收窄。而当你需要这个功能的时候，就要手动关闭优化了。这也是 inline 默认是关闭、需要手动开启的另一个原因：它会收窄 Kotlin 的功能。\n\n那么，我们应该怎么判断什么时候用 noinline 呢？很简单，比 inline 还要简单：你不用判断，Android Studio 会告诉你的。当你在内联函数里对函数类型的参数使用了风骚操作，Android Studio 拒绝编译的时候，你再加上 noinline 就可以了。\n\n# crossinline\n\n## 突破间接调用\n\n### 加入 crossinline 前\n\n```kotlin\nfun main() {  \n\tprintName(\"guanpj\",  \n\t\t{ println(\"hello!\") },  \n\t\t{ println(\"bye!\") }  \n\t)  \n}  \n  \ninline fun printName(name: String, preAction: () -\u003e Unit, postAction: () -\u003e Unit) {  \n\tpreAction()  \n\tprintln(\"your name is: $name\")  \n\trunOnUiThread {  \n\t\tpostAction() // IDE 报错\n\t}  \n}  \n  \nfun runOnUiThread(runner: () -\u003e Unit) {  \n\tprintln(\"Now in UI thread!\")  \n\trunner()  \n}\n```\n编译器报错内容：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/inline%26noinline%26crossinline/crossinline.png)\n\n### 加入 crossinline 后\n\n```kotlin\ninline fun printName(name: String, preAction: () -\u003e Unit, crossinline postAction: () -\u003e \nUnit) {  \n\tpreAction()  \n\tprintln(\"your name is: $name\")  \n\trunOnUiThread {  \n\t\tpostAction()  \n\t}  \n}\n```\n反编译：\n```java\npublic static final void main() {  \n\tString name$iv = \"guanpj\";  \n\tString var3 = \"hello!\";  \n\tSystem.out.println(var3);  \n\tString var4 = \"your name is: \" + name$iv;  \n\tSystem.out.println(var4);  \n\trunOnUiThread((Function0)(new Test2Kt$main$$inlined$printName$1()));  \n}  \n  \npublic static final void printName(@NotNull String name, @NotNull Function0 \n\t\t\t\t\t\t\t\t\tpreAction, @NotNull final Function0 postAction) {  \n\tpreAction.invoke();  \n\tString var4 = \"your name is: \" + name;  \n\tSystem.out.println(var4);  \n\trunOnUiThread((Function0)(new Function0() {  \n\t\tpublic Object invoke() {  \n\t\t\tthis.invoke();  \n\t\t\treturn Unit.INSTANCE;  \n\t\t}  \n\t  \n\t\tpublic final void invoke() {  \n\t\t\tpostAction.invoke();  \n\t\t}  \n\t}));  \n}  \n\t  \npublic static final void runOnUiThread(@NotNull Function0 runner) {  \n\tString var1 = \"Now in UI thread!\";  \n\tSystem.out.println(var1);  \n\trunner.invoke();  \n}\n```\n这下明白 crossinline 里的 `cross` 是什么意思了。\n当然，如果把 runOnUiThread 也改成内联函数，也可以突破间接调用。\n\n## 解决 lambda 中的 return 造成意外返回\n\n另外，前面提到的 lambda 中的 return 造成意外返回的问题，也可以通过 crossinline 来解决：\n\n### 加入 crossinline 前\n\n```kotlin\nfun main() {  \n\tprintName(\"guanpj\",  \n\t\t{  \n\t\t\tprintln(\"hello!\")  \n\t\t\treturn\n\t\t},  \n\t\t{ println(\"bye!\") }  \n\t)  \n}\n\ninline fun printName(name: String, preAction: () -\u003e Unit, postAction: () -\u003e \nUnit) {  \n\tpreAction()  \n\tprintln(\"your name is: $name\")  \n\tpostAction()  \n}\n```\n输出结果：\nhello!\n\n### 加入 crossinline 后\n\n```kotlin\nfun main() {  \n\tprintName(\"guanpj\",  \n\t\t{  \n\t\t\tprintln(\"hello!\")  \n\t\t\treturn // IDE 报错\n\t\t},  \n\t\t{ println(\"bye!\") }  \n\t)  \n}\n\ninline fun printName(name: String, crossinline preAction: () -\u003e Unit, postAction: \n\t\t\t\t\t () -\u003e Unit) {  \n\tpreAction()  \n\tprintln(\"your name is: $name\")  \n\tpostAction()  \n}\n```\n编译器报错内容：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/inline%26noinline%26crossinline/crossinline1.png)\n\n反编译：\n```java\npublic static final void main() {  \n\tString name$iv = \"guanpj\";  \n\tString var3 = \"hello!\";  \n\tSystem.out.println(var3);  \n\tString var5 = \"your name is: \" + name$iv;  \n\tSystem.out.println(var5);  \n\tString var4 = \"bye!\";  \n\tSystem.out.println(var4);  \n}  \n  \npublic static final void printName(@NotNull String name, @NotNull Function0 preAction, \n\t\t\t\t\t\t\t\t   @NotNull Function0 postAction) {  \n\tpreAction.invoke();  \n\tString var4 = \"your name is: \" + name;  \n\tSystem.out.println(var4);  \n\tpostAction.invoke();  \n}\n```\n可以看到，添加了 crossinline 后反编译的代码其实跟没加的时候是一模一样的。因此 crossinline 关键字只是在语法上限制了被它修饰的 lambda 中使用 return 返回到外层函数。\n\n# 总结\n\n1.  inline 可以让你用内联——也就是函数内容直插到调用处的方式来优化代码结构，从而减少函数类型的对象的创建；\n2.  noinline 是局部关掉这个优化，来摆脱 inline 带来的「不能把函数类型的参数当对象使用」的限制；\n3.  crossinline 是局部加强这个优化，让内联函数里的函数类型的参数可以被当做对象使用，从而突破间接调用。","lastmodified":"2023-04-21T14:55:33.03322251Z","tags":["inline","noinline","crossinline"]}}