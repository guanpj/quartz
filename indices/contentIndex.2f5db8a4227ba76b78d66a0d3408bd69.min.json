{"/":{"title":"AboutTheGardens","content":"## 111111\n\n### hello everyone!\n\n#### 哈哈哈哈哈\n\nsldfjlsajdfl sldfjlasjdlfjsld\nalsjfsd\nldjfsdf sld\n\n## 了散打减肥了\n\nsldfjlsdfj\nThis is my note:[[2023-03-20]]\n\n### 啊啊啊啊啊\n\n#### 手里的积分啦\n\n了散打发**教练**\n我这里讲了泛型：[[泛型]]\n我这里讲了IO：[[IO]]\n\ntoday's note:[[2023-03-22]]\nhashmap:[[HashMap 源码解析]]\n\n","lastmodified":"2023-03-22T10:53:40.981860045Z","tags":["本库教程"]},"/%E5%85%B6%E4%BB%96%E6%A8%A1%E7%89%88":{"title":"其他模版","content":"### 史蒂夫\n\nline1: \u003c% tp.file.cursor(1) %\u003e\nline2: \u003c% tp.file.cursor(2) %\u003e","lastmodified":"2023-03-22T10:53:40.653856551Z","tags":[]},"/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0":{"title":"我的日记","content":"### 今日开发工作\n### 今日感想","lastmodified":"2023-03-22T10:53:40.653856551Z","tags":[]},"/%E6%9C%AA%E5%91%BD%E5%90%8D":{"title":"未命名","content":"","lastmodified":"2023-03-22T10:53:40.653856551Z","tags":[]},"/%E6%B3%9B%E5%9E%8B":{"title":"泛型","content":"## 什么是泛型？\n\n声明中具有一个或者多个类型参数(type parameter)的类或者接口，就是泛型类或者接口。泛型类和接口统称为泛型(generic type)。\n\n每种泛型定义一组类型形参(formal type parameters)，这些类型形参有时也被简称为类型参数(type parameter)，例如对于 `List\u003cE\u003e` 而言，`List\u003cString\u003e` 就是一个参数化的类型(parameterized type)，String 就是对应于类型形参(formal type parameters)的类型实参(actual type parameter)。\n\n而如果 `List\u003cE\u003e` 不使用泛型参数，List 则为原生类型(raw type)。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。\n\n每个泛型定义一个原生类型(raw type)，即不带任何类型参数的类型名称，例如，与 `List\u003cString\u003e` 对应的原生类型是 List。原生类型就像从类型声明中删除了所有泛型信息一样。实际上原生类型 List 与 Java 平台在有泛型之前的接口类型 List 完全一样。\n\nJava 泛型是自 JDK5 起引入的一种参数化类型特性，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型泛型的本质是参数类型，也就是说所操作的数据类型被指定为一个参数。因为类型擦除机制，泛型不存在于 JVM 虚拟机。\n\n## 为什么使用泛型？\n\n1.使代码更健壮\n\n2.使代码更简洁(不用强转)\n\n3.使代码可复用性更高，程序更灵活\n\n通俗地说，泛型是「有远⻅的创造者」创造的「方便使用者」的工具。也就是说，使用泛型能够让开发这编写出更加灵活的代码。\n\n## 泛型的使用\n\n### 作为类/接口的类型参数\n\n可以在一个类或者接口里定义一个类型参数，等着子类/实现类去写出不同的实现：\n\n```java\npublic interface Comparable\u003cT\u003e {\n  int compareTo(T o);\n  ...\n}\n\npublic String implements Comparable\u003cString\u003e {\n  int compareTo(String anotherString);\n  ...\n}\n\npublic class Stack\u003cE\u003e extends Vector\u003cE\u003e {\n  ...\n}\n\nStack\u003cString\u003e stack = new Stack\u003c\u003e();\n```\n\n### 作为方法的返回值类型\n\n```java\nT buy();\n```\n\n### 用于类型约束\n\n由于泛型语法自身特性，某些情形下也可以用于类型约束\n\n```java\n// 约束类型参数上界\npublic \u003cE extends Runnable, Serializable\u003e void someMethod(E param);\n\n// 约束方法参数之间的关系\npublic \u003cT\u003e void merge(T item, List\u003cT\u003e list) {\n  list.add(item);\n}\n```\n\n## 泛型擦除的过程\n\n1. 类型检查：在生成字节码之前提供类型检查\n2. 类型擦除：所有类型参数都用他们的限定类型替换，包括类、变量和方法（类型擦除）\n3. 如果类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决\n4. 如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转换\n\n## 泛型的限制\n\n1. 不能用基本类型作为泛型参数\n2. 不能在运行时获取泛型类型\n3. 不能静态字段或方法中引用泛型变量\n4. 不能创建参数化类型数组\n5. 不能实例化类型变量\n6. 不能捕获泛型类的实例，类不能继承自 Exception，只能派生自 Throwable\n\n```java\npublic \u003cT extends Throwable\u003e void fun1(T t) {\n  try {\n    ...\n  } catch(T x) {//不允许\n  }\n}\n\npublic \u003cT extends Throwable\u003e void fun2(T t) throws T {\n  try {\n    ...\n  } catch(Throwable t) {\n    throw t;\n  }\n}\n```\n\n## 编译时和运行时类型\n\n```java\npublic class Fruit {}\n\npublic class Apple extends Fruit {}\n\npublic class GreenApple extends Apple {}\n\nApple apple = new Apple();//普通变量声明和初始化\n\nFruit apple = new Apple();//向上转型\n```\n\nJava 允许把一个子类对象（Apple 对象）直接赋值给一个父类引用变量（Fruit 类变量），一般我们称之为「向上转型」。apple 变量所指向的对象，其在编译时的类型是 Fruit 类型，而在运行时的类型就是 Apple 类型。\n\n因为在编译的时候，JVM 只知道 Fruit 类变量指向了一个对象，并且这个对象是 Fruit 的子类对象或自身对象，其具体的类型并不确定，有可能是 Apple 类型，也有可能是 Orange 类型。而为了安全方面的考虑，JVM 此时将 apple 属性指向的对象定义为 Fruit 类型。因为无论其是 Apple 类型还是 Orange 类型，它们都可以安全转为 Fruit 类型。\n\n而在运行时阶段，JVM 通过初始化知道了它指向了一个 Apple 对象，所以其在运行时的类型就是 Apple 类型。\n\n## 泛型类型实例化的边界\n\n在前面的例子的基础上，定义一个容器类：\n\n```java\npublic class Plate\u003cT\u003e {\n  private List\u003cT\u003e list;\n\n  public Plate(){}\n\n  public void add(T item) {\n    list.add(item);\n  }\n\n  public T get() {\n    return list.get(0);\n  }\n}\n```\n\n如果想要一个装水果的盘子，则有如下定义：\n\n```java\nPlate\u003cFruit\u003e plate = new Plate\u003cFruit\u003e();\n```\n\n这里直接定义了一个 Plate 对象，并且指定其泛型类型为 Fruit 类。这样我们就可以往里面加水果了：\n\n```java\nplate.add(new Fruit());\n\nplate.add(new Apple());\n```\n\n按照 Java 向上转型的原则，Java 泛型可以向上转型，上面关于水果盘子的定义可以变为这样：\n\n```java\nPlate\u003cFruit\u003e plate = new Plate\u003cApple\u003e();  //编译错误\n```\n\n错误的原因就是：\tJava 并不支持支持泛型的向上转型，所以不能够使用上面的写法，这样的写法在 Java 中是不被支持的。\n\n解决方法就是：使用通配符。\n\n### `\u003c? extends Xxx\u003e` 限定上界通配符\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cApple\u003e();\n```\n\n上面的这行代码表示：plate 实例可以指向任何 Fruit 类对象，或者任何 Fruit 的子类对象。Apple 是 Fruit 的子类，自然就可以正常编译了。\n\n虽然通过这种方式，Java 支持了 Java 泛型的向上转型，但是这种方式是有缺陷的：\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cApple\u003e();\n\nplate.add(new Apple()); //Compile Error\n\nplate.add(new Fruit()); //Compile Error\n\nplate.get();    // Compile Success\n```\n\n这时候发现：无法向 Plate 中添加任何对象，只能从中读取对象。\n\n这是什么原因？还得从 plate 的定义说起：\n\n```java\nPlate\u003c? extends Fruit\u003e plate = new Plate\u003cXXX\u003e();\n```\n\n上面对盘子的定义中，plate 可以指向任何 Fruit 类对象，或者任何 Fruit 的子类对象。也就是说，plate 属性指向的对象其在运行时可以是 Apple 类型，也可以是 Orange 类型，也可以是 Banana 类型，只要它是 Fruit 类，或任何 Fruit 的子类即可。\n\n这样子的话，在我们还未具体运行时，JVM 并不知道我们要往盘子里放的是什么水果，到底是苹果，还是橙子，还是香蕉，完全不知道。既然我们不能确定要往里面放的类型，那 JVM 就干脆什么都不给放，避免出错。\n\n那为什么又可以取出数据呢？因为无论是取出苹果，还是橙子，还是香蕉，我们都可以通过向上转型用 Fruit 类型的变量指向它，这在 Java 中都是允许的：\n\n```java\nFruit apple = plate.get(); //能够保证取出来的是水果\n\nApple apple = plate.get(); //编译报错，JVM 不能保证取出来的就是苹果\n```\n\n我们通过 extends 关键字可以实现向上转型。但是我们却失去了部分的灵活性，即我们不能往其中添加任何东西，只能取出东西。\n\n### `\u003c? super Xxx\u003e` 限定下界通配符\n\n与 extends 通配符相似的另一个通配符是 super 通配符，其特性与 extends 完全相反。\tsuper 通配符可以存入对象，但是取出对象的时候受到限制。\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n```\n\n上面这行代码表示 plate 属性可以指向一个特定类型的 Plate 对象，只要这个特定类型是 Apple 或 Apple 的父类。上面的 Fruit 类就是 Apple 类的父级，所以上面的语法是对的。\n\n也就是说，如果 Food 类是 Fruit 的父级，那么则有下面的声明：\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n\nPlate\u003c? super Apple\u003e plate2 = new Plate\u003cApple\u003e();\n\nPlate\u003c? super Apple\u003e plate3 = new Plate\u003cGreenApple\u003e(); //Error\n```\n\n既然这样，也就是说 plate 指向的具体类型可以是任何 Apple 的父级，JVM 在编译的时候肯定无法判断具体是哪个父类型。但 JVM 能确定的是：任何 Apple 的子类都可以转为 Apple 类型，但任何 Apple 的父类都无法转为 Apple 类型。\n\n所以对于使用了 super 通配符的情况，我们只能存入 T 类型及 T 类型的子类对象。\n\n```java\nPlate\u003c? super Apple\u003e plate = new Plate\u003cFruit\u003e();\n\nplate.add(new Apple());\n\nplate.add(new GreenApple());\n\nplate.add(new Fruit()); //Error\n```\n\n当我们向 plate 存入 Apple 对象时，编译正常。但是存入 Fruit 对象，就会报编译错误。\n\n而当我们取出数据的时候，也是类似的道理。JVM 在编译的时候知道，我们具体的运行时类型可以是任何 Apple 的父级，那么为了安全起见，我们就用一个最顶层的父级来指向取出的数据，这样就可以避免发生强制类型转换异常了。\n\n```java\nObject object = plate.get();\n\nApple apple = plate.get();  //Error\n\nFruit fruit = plate.get();  //Error\n```\n\n当使用 Apple 类型或 Fruit 类型的变量指向 plate 取出的对象，会出现编译错误。而使用 Object 类型的额变量指向 plate 取出的对象，则可以正常通过。\n\n也就是说对于使用了 super 通配符的情况，我们取出的时候只能用 Object 类型的属性指向取出的对象。\n\n### `\u003c?\u003e` 无限定边界通配符\n\n也就是不限定泛型参数的边界，所以对 Plate\u003c?\u003e 实例来说可以存放任何任意类型的对象，由于所有类型都继承自 Object，因此 Plate\u003c?\u003e等价于 `Plate\u003c? extends Object\u003e`。所以只能够对该集合进行读操作，并且只能把读取到的元素当成 Object 实例来对待。\n\n### 小结\n\n- 对于 extends 通配符，我们无法向其中加入任何对象，但是我们可以进行正常的取出。\n- 对于 super 通配符，我们可以存入 T 类型对象或 T 类型的子类对象，但是我们取出的时候只能用 Object 类变量指向取出的对象。\n\n从上面的总结可以看出，extends 通配符偏向于内容的获取，而 super 通配符更偏向于内容的存入。我们有一个 PECS 原则（Producer Extends Consumer Super）很好的解释了这两个通配符的使用场景。\n\nProducer Extends 说的是当你的情景是生产者类型，需要获取资源以供生产时，我们建议使用 extends 通配符，因为使用了 extends 通配符的类型更适合获取资源。\n\nConsumer Super 说的是当你的场景是消费者类型，需要存入资源以供消费时，我们建议使用 super 通配符，因为使用 super 通配符的类型更适合存入资源。\n\n但如果既想存入，又想取出，那么最好还是不要使用 extends 或 super 通配符。\n\n## 面试题\n\n### `List\u003cT\u003e` 和数组的区别\n\n```java\nApple apple = new Fruit();\n\nApple[] appleArr = new Fruit[5];\n```\n\n在 Java 语言中，数组是协变的，即 Apple extends Fruit，那么子类 Apple[] 数组实例是可以赋值给父类 Fruit[] 数组实例的。那是由于 Java 中的数组类型本质上会由虚拟机运行时动态生成一个类型，这个类型除了记录数组的必要属性，如长度，元素类型等，会有一个指针指向内存某个位置，这个位置就是该数组元素的起始位置。\n\n所以子类数组实例赋值父类数组实例时，只是意味着父类数组实例的引用指向堆中子类数组而已，并不会有所冲突，因此是 Java 允许这种操作的。\n\n而泛型是不允许这么做的：\n\n```java\nArrayList\u003cNumber\u003e numbers = new ArrayList\u003cInteger\u003e(); \n\nnumbers = integers;//假设编译器是能通过的 \n\nnumbers.add(23.5);//将一个浮点数放入了整型容器中\n```\n\n前面已经说过，假设 Java 允许泛型协变，那么上述代码在编译器看来是没问题的，但运行时就会出现问题。这个 add 方法实际上就将一个浮点数放入了整型容器中了，虽然由于类型擦除并不会对程序运行造成问题，但显然违背了泛型的设计初衷，容易造成逻辑混乱，所以 Java 干脆禁止泛型协变。\n\n所以虽然 `ArrayList\u003cInteger\u003e` 和 `ArrayList\u003cNumber\u003e`编译器类型擦除之后都是 ArrayList 的实例，但是起码在编译器看来，这两者是两种不同的类型。\n\n但是对于数组，尽管 Apple 可以向上转型为 Fruit，但是 fruits 对象在运行时却是 Apple[] 类型的，因此只能向数组中放入 Apple 或者其子类对象。尽管在编译时不会报错，到了运行时仍然是会报错的。\n\n```java\nFruit[] fruits = new Apple[5];\n\nfruits[0] = new Apple();\n\nfruits[1] = new GreenApple();\n\nfruits[2] = new Fruit(); //RTE：ArrayStoreException\n```\n\n### Java 为什么不支持创建泛型数组\n\n首先对于 Java 数组，必须明确知道内部元素的类型，而且 JVM 会“记住”这个类型。每次往数组里插入新元素都会进行类型检查，不匹配则抛出 ArrayStoreException 错误。\n\n而由于泛型擦除机制的存在，因此 JVM 并不能确定数组中的泛型类型，因此创建泛型数组被编译器拦下来了。\n\n```java\nList\u003cInteger\u003e[] intListArray = new List\u003cInteger\u003e[10]; //Error\n```\n\n前面说过，因为泛型是协变的，而且 Object 是所有类的共同父类。如果允许创建泛型数组，则有：\n\n```java\nList\u003cInteger\u003e[] listArr= new ArrayList\u003cInteger\u003e[10];\n\nObject[] objArr= listArr;\n\nobjArr[0] = new ArrayList\u003cString\u003e(Arrays.asList(new String[]{\"abc\"}));\n\n这样做不但编译器不能发现类型错误，就连运行时的数组存储检查对它也无能为力。它能看到的是我们往里面放 List 的对象，我们定义的 `\u003cInteger\u003e` 在这个时候已经被抹掉了。于是而对它而言，只要是 List，都是合法的。\n```\n\n想想看，我们本来定义的是存放 `List\u003cInteger\u003e` 的数组，结果我们却可以往里面放任何 List，接下来如果有代码试图按原有的定义去取值，后果可想而知。\n\n实际上，泛型数组是可以定义出来的，然后通过强制转型，也是可以为其赋值的。\n\n```java\nList\u003cInteger\u003e[] listArr= (List\u003cInteger\u003e[])new ArrayList[10];\n\nObject[] objArr= listArr;\n\nobjArr[0] = new ArrayList\u003cString\u003e(Arrays.asList(new String[]{\"abc\"}));\n```\n\n这样不但编译可以通过，而且运行时也不会报任何错误。\n\n### `List`、`List\u003c?\u003e`、`List\u003cObject\u003e`的区别\n\n容器类使用泛型的好处：\n\n- 安全性：在对参数化类型的容器中放入了错误即不匹配的类型的时候，编译器将会强制性进行错误提示。\n- 便利性：当从容器中取出元素的时候不用自己手动将 Object 转换为元素的实际类型了，编译器将隐式地进行自动转换。\n- 表述性：带有类型实参的泛型即参数化类型，可以让人看到实参就知道里面的元素 E 都是什么类型。\n\n从以上三点出发，`List\u003cObject\u003e`、`List\u003c?\u003e` 和 `List` 的区别如下：\n\n| 类型    | 名称                               | 可以接受的类型                            | 能否添加元素           | 安全性 | 便利性 | 表述性 |\n| ------- | ---------------------------------- | ----------------------------------------- | ---------------------- | ------ | ------ | ------ |\n| List    | 原始类型                           | 任何对应 List 的参数化类型， 包括 List\u003c?\u003e | 可以添加任意类型的元素 | 无     | 无     | 无     |\n| List\u003c?\u003e | 通配符类型                         | 任何对应 List 的参数化类型，包括 List     | 不能添加任何元素       | 有     | 无     | 有     |\n| List    | 实际类型参数为 Object 的参数化类型 | 仅可以接受 List 和其本身类型              | 可以添加任意类型元素   | 有     | 有     | 有     |\n\nJVM 如何解决泛型类型擦除导致多态冲突\n","lastmodified":"2023-03-22T10:53:40.981860045Z","tags":["泛型","Java"]},"/2023-03-15":{"title":"2023-03-15","content":"弄完了同步，牛逼","lastmodified":"2023-03-22T10:53:40.653856551Z","tags":[]},"/2023-03-16":{"title":"2023-03-16","content":"","lastmodified":"2023-03-22T10:53:40.653856551Z","tags":[]},"/2023-03-18":{"title":"2023-03-18","content":"# 2023-03-18\n### 今日开发工作\n### 今日感想","lastmodified":"2023-03-22T10:53:40.653856551Z","tags":["哈哈","好"]},"/2023-03-19":{"title":"2023-03-19","content":"### 今日开发工作\n### 今日感想","lastmodified":"2023-03-22T10:53:40.653856551Z","tags":[]},"/2023-03-20":{"title":"2023-03-20","content":"### 今日开发工作\n### 今日感想\nsadlfjsal \n\nfrom windows\n\n之类主页是[[AboutTheGarden]]","lastmodified":"2023-03-22T10:53:40.653856551Z","tags":[]},"/2023-03-22":{"title":"Troubleshooting and FAQ","content":"\nStill having trouble? Here are a list of common questions and problems people encounter when installing Quartz.\n\nWhile you're here, join our [Discord](https://discord.gg/cRFFHYye7t) :)\n\n### Does Quartz have Latex support?\nYes! See [CJK + Latex Support (测试)](notes/CJK%20+%20Latex%20Support%20(测试).md) for a brief demo.\n\n### Can I use \\\u003cObsidian Plugin\\\u003e in Quartz?\nUnless it produces direct Markdown output in the file, no. There currently is no way to bundle plugin code with Quartz.\n\nThe easiest way would be to add your own HTML partial that supports the functionality you are looking for.\n\n### My GitHub pages is just showing the README and not Quartz\nMake sure you set the source to deploy from `master` (and not `hugo`) using `/ (root)`! See more in the [hosting](/notes/hosting) guide\n\n### Some of my pages have 'January 1, 0001' as the last modified date\nThis is a problem caused by `git` treating files as case-insensitive by default and some of your posts probably have capitalized file names. You can turn this off in your Quartz by running this command.\n\n```shell\n# in the root of your Quartz (same folder as config.toml)\ngit config core.ignorecase true\n\n# or globally (not recommended)\ngit config --global core.ignorecase true\n```\n\n### Can I publish only a subset of my pages?\nYes! Quartz makes selective publishing really easy. Heres a guide on [excluding pages from being published](notes/ignore%20notes.md).\n\n### Can I host this myself and not on GitHub Pages?\nYes! All built files can be found under `/public` in the `master` branch. More details under [hosting](notes/hosting.md).\n\n### `command not found: hugo-obsidian`\nMake sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize `hugo-obsidian` as an executable.\n\n```shell\n# Add the following 2 lines to your ~/.bash_profile (~/.zshrc if you are on Mac)\nexport GOPATH=/Users/$USER/go\nexport PATH=$GOPATH/bin:$PATH\n\n# In your current terminal, to reload the session\nsource ~/.bash_profile # again, (~/.zshrc if you are on Mac)\n```\n\n### How come my notes aren't being rendered?\nYou probably forgot to include front matter in your Markdown files. You can either setup [Obsidian](notes/obsidian.md) to do this for you or you need to manually define it. More details in [the 'how to edit' guide](notes/editing.md).\n\n### My custom domain isn't working!\nWalk through the steps in [the hosting guide](notes/hosting.md) again. Make sure you wait 30 min to 1 hour for changes to take effect.\n\n### How do I setup analytics?\nQuartz by default uses [Plausible](https://plausible.io/) for analytics. \n\nIf you would prefer to use Google Analytics, you can follow this [guide in the Hugo documentation](https://gohugo.io/templates/internal/#google-analytics). \n\nAlternatively, you can also import your Google Analytics data into Plausible by [following this guide](https://plausible.io/docs/google-analytics-import).\n\n\n### How do I change the content on the home page?\nTo edit the main home page, open `/content/_index.md`.\n\n### How do I change the colours?\nYou can change the theme by editing `assets/custom.scss`. More details on customization and themeing can be found in the [customization guide](notes/config.md).\n\n### How do I add images?\nYou can put images anywhere in the `/content` folder.\n\n### My Interactive Graph and Backlinks aren't up to date\nBy default, the `linkIndex.json` (which Quartz needs to generate the Interactive Graph and Backlinks) are not regenerated locally. To set that up, see the guide on [local editing](notes/editing.md)\n\n### Can I use React/Vue/some other framework?\nNot out of the box. You could probably make it work by editing `/layouts/_default/single.html` but that's not what Quartz is designed to work with. 99% of things you are trying to do with those frameworks you can accomplish perfectly fine using just vanilla HTML/CSS/JS.\n\n## Still Stuck?\nQuartz isn't perfect! If you're still having troubles, file an issue in the GitHub repo with as much information as you can reasonably provide. Alternatively, you can message me on [Twitter](https://twitter.com/_jzhao) and I'll try to get back to you as soon as I can.\n\n🐛 [Submit an Issue](https://github.com/jackyzha0/quartz/issues)\n","lastmodified":"2023-03-22T10:53:40.981860045Z","tags":[]},"/About-Atlas":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: tutorial\ntitle: \"About Atlas\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\nAtlas意思是地图集。\n\n单个案例或项目的MOC，考虑直接放在对应文件夹里面，相当于起到一个个文件夹的readme和导览的作用。这里专门放这些MOC的MOC。\n\n围绕本库和obsidian的使用教程、方法和细节，也放到这里，就像是地图的指南针。\n","lastmodified":"2023-03-22T10:53:40.981860045Z","tags":[]},"/About-Extras":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: tutorial\ntitle: \"About Extras\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n[[图片保存：图床or本地]]\n","lastmodified":"2023-03-22T10:53:40.981860045Z","tags":[]},"/HashMap-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90":{"title":"HashMap 源码解析","content":"## 前言  \n  \nHashMap 是 Java 中最常用 K-V 容器，使用哈希值来确定元素存储的位置，HashMap 对 Entry 进行了扩展（Node），使其形成以链表或者树的形式存储在 HashMap 的容器里。  \n  \n在 Java 8 之前和之后，HashMap 的实现有较大的不同，因此对于 put 流程、扩容机制等主要过程分析将会采用两个版本进行对比。  \n  \n## 成员变量  \n  \nHashMap 成员变量和构造方法声明如下（Java 7 和 8 大致相同，以下为 Java 8 版本）：  \n  \n```java  \npublic class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e  \n  \n    implements Map\u003cK,V\u003e, Cloneable, Serializable {  \n\n    // 初始容量 16  \n    static final int DEFAULT_INITIAL_CAPACITY = 1 \u003c\u003c 4; // aka 16  \n  \n    // 最大容量，该数组最大值为2^31一次方。  \n    static final int MAXIMUM_CAPACITY = 1 \u003c\u003c 30;  \n  \n    // 默认的加载因子，如果构造的时候不传则为 0.75  \n    static final float DEFAULT_LOAD_FACTOR = 0.75f;  \n  \n    // @1.8：数组某个位置下的 node 链表转化为红黑树对该链表的最小长度要求  \n    static final int TREEIFY_THRESHOLD = 8;  \n  \n    // @1.8：当一个反树化的阈值，当这个 node 长度减少到该值就会从树转化成链表  \n    static final int UNTREEIFY_THRESHOLD = 6;  \n  \n    // @1.8：数组某个位置下的 node 链表转化为红黑树对元素个数的最小要求  \n    static final int MIN_TREEIFY_CAPACITY = 64;  \n  \n    // 具体存放数据的数组  \n    transient Node\u003cK,V\u003e[] table;  \n  \n    // entrySet，一个存放 k-v 缓冲区  \n    transient Set\u003cMap.Entry\u003cK,V\u003e\u003e entrySet;  \n  \n    // 存放键值对的个数。  \n    transient int size;  \n  \n    // 记录更改 map 结构次数(添加、删除、扩容？)  \n    transient int modCount;  \n  \n    // 临界值，当实际大小(容量*填充因子)超过临界值时，会进行扩容  \n  \n    int threshold;  \n  \n    // 填充因子  \n    final float loadFactor;  \n  \n    // 指定初始容量  \n    public HashMap(int initialCapacity) {  \n        this(initialCapacity, DEFAULT_LOAD_FACTOR);  \n    }  \n\n    // 默认构造函数  \n    public HashMap() {  \n        // 默认 threshold 在首次 put 时才复制，Java 7 则是调用  \n        // this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR)  \n        this.loadFactor = DEFAULT_LOAD_FACTOR;   \n    }  \n\n    // 包含另一个 Map  \n    public HashMap(Map\u003c? extends K, ? extends V\u003e m) {  \n        this.loadFactor = DEFAULT_LOAD_FACTOR;  \n  \n        putMapEntries(m, false);  \n    }  \n\n    // 指定初始容量和填充因子  \n    public HashMap(int initialCapacity, float loadFactor) {  \n        if (initialCapacity \u003c 0) // 容量不能为负数  \n  \n            throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);  \n  \n        // 当容量大于 2^31 就取最大值 1\u003c\u003c30;   \n  \n        if (initialCapacity \u003e MAXIMUM_CAPACITY)  \n  \n            initialCapacity = MAXIMUM_CAPACITY;  \n  \n        if (loadFactor \u003c= 0 || Float.isNaN(loadFactor))  \n  \n            throw new IllegalArgumentException(\"Illegal load factor: \"                + loadFactor);  \n  \n        this.loadFactor = loadFactor;  \n  \n        // tableSizeFor 保证了数组长度一定是 2 的幂次方，是大于等于    initialCapacity 最接近的值。  \n        // 这里使用 threshold 暂时保存计算后的 initialCapacity 值  \n        this.threshold = tableSizeFor(initialCapacity);  \n  \n    }  \n    ...  \n}  \n```  \n  \n## 数据结构  \n  \nJava 7 采用数组 + 链表方式进行存储，元素类型为 Entry：  \n  \n```java  \nstatic class Entry\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {  \n  \n    final K key;  \n  \n    V value;  \n  \n    Entry\u003cK,V\u003e next;  \n  \n    int hash;  \n\n    ...  \n}  \n```  \n  \n元素的存储结构如下：  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_035018.png)\nJava 8 开始，采用数组 + 链表 + 红黑树方式进行存储，元素类型为 Node 和 TreeNode：  \n  \n```java  \nstatic class Node\u003cK,V\u003e implements Map.Entry\u003cK,V\u003e {  \n  \n    final int hash;  \n  \n    final K key;  \n  \n    V value;  \n  \n    Node\u003cK,V\u003e next;  \n\n    ...  \n}  \n  \n  \n  \nstatic final class TreeNode\u003cK,V\u003e extends LinkedHashMap.Entry\u003cK,V\u003e {  \n  \n    TreeNode\u003cK,V\u003e parent;  // red-black tree links  \n  \n    TreeNode\u003cK,V\u003e left;  \n  \n    TreeNode\u003cK,V\u003e right;  \n  \n    TreeNode\u003cK,V\u003e prev;    // needed to unlink next upon deletion  \n  \n    boolean red;  \n    \n    ...  \n}  \n```  \n  \n元素的存储结构如下：\n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_041741.png)\n\n## put 流程分析  \n  \n### Java 7 put 流程  \n  \n#### 代码分析  \n  \nJava 7 put 流程主要方法源码如下：  \n  \n```java  \npublic V put(K key, V value)  \n    if (table == EMPTY_TABLE) {  \n        // 初始化 table  \n        inflateTable(threshold);  \n    }  \n  \n    if (key == null) {  \n        // 在 table[0] 处插入 key 为 null 元素并返回  \n        return putForNullKey(value);  \n    }  \n  \n    // 先进行一次 hash 计算     \n    int hash = hash(key);  \n  \n    // 根据 hash 值计算 table 下标  \n    int i = indexFor(hash, table.length);  \n  \n    // 遍历 table[i] 处的链表  \n    for (Entry\u003cK,V\u003e e = table[i]; e != null; e = e.next) {  \n        Object k;  \n        // hash 一样且 key 相等或者 equals 方法返回 true 才进行替换  \n        if (e.hash == hash \u0026\u0026 ((k = e.key) == key || key.equals(k))) {  \n            V oldValue = e.value;  \n  \n            e.value = value;  \n  \n            e.recordAccess(this);  \n  \n            return oldValue;  \n        }  \n    }  \n    // 出循环意味着 table[i] 这条链表没有此元素  \n    // 更新 modCount  \n    modCount++;  \n    // 插入新元素  \n    addEntry(hash, key, value, i);  \n  \n    return null;  \n}  \n  \nprivate void inflateTable(int toSize) {  \n    // 获取大于  \n    int capacity = roundUpToPowerOf2(toSize);  \n    // 重新计算阈值  \n    threshold = (int) Math.min(capacity * loadFactor,   \n            MAXIMUM_CAPACITY + 1);  \n  \n    // 创建数组  \n    table = new Entry[capacity];  \n  \n    // 根据配置判断是否初始化 hashSeed  \n    initHashSeedAsNeeded(capacity);  \n}  \n  \nprivate V putForNullKey(V value) {  \n    // 最多循环一次，因为这个位置最多只有一个元素  \n    for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) {  \n        // key 为 null 直接替换  \n        if (e.key == null) {  \n            V oldValue = e.value;  \n            e.value = value;  \n            e.recordAccess(this);  \n  \n            return oldValue;  \n        }  \n    }  \n  \n    // 更新 modCount  \n    modCount++;  \n  \n    // 在 table[0] 处插入元素  \n    addEntry(0, null, value, 0);  \n  \n    return null;  \n}  \n  \nvoid addEntry(int hash, K key, V value, int bucketIndex) {  \n    // 元素数量达到临界值且 table[bucketIndex] 位置不为空才进行扩容  \n    if ((size \u003e= threshold) \u0026\u0026 (null != table[bucketIndex])) {  \n        // 两倍容量  \n        resize(2 * table.length);  \n  \n        // 重新计算 hash  \n        hash = (null != key) ? hash(key) : 0;  \n  \n        // 重新确定数组下标  \n        bucketIndex = indexFor(hash, table.length);  \n    }\n    // 创建并插入新元素  \n    createEntry(hash, key, value, bucketIndex);  \n}  \n  \n// 在链表头部插入新元素  \nvoid createEntry(int hash, K key, V value, int bucketIndex) {  \n    // 保存原头结点  \n    Entry\u003cK,V\u003e e = table[bucketIndex];  \n    // 创建新元素、把 next 指向头节点，并替换原来 bucketIndex 位置的链表  \n    table[bucketIndex] = new Entry\u003c\u003e(hash, key, value, e);  \n    // 元素数量++  \n    size++；  \n}  \n```  \n  \n#### 流程图示  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040358.png)\n### Java 8 put 流程  \n  \n#### 代码分析  \n  \nJava 8 put 流程主要方法源码如下：  \n  \n```java  \npublic V put(K key, V value) {  \n      // onlyIfAbsent 默认为 false，即元素存在时进行替换  \n    return putVal(hash(key), key, value, false, true);  \n}  \n  \nfinal V putVal(int hash, K key, V value,   \n          boolean onlyIfAbsent, boolean evict) {  \n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i;  \n  \n    // table 未初始化或者长度为 0，进行扩容  \n    if ((tab = table) == null || (n = tab.length) == 0)  \n        n = (tab = resize()).length;  \n  \n    // (n - 1) \u0026 hash 确定元素存放位置，位置为空则直接放入该位置  \n    if ((p = tab[i = (n - 1) \u0026 hash]) == null)  \n        tab[i] = newNode(hash, key, value, null);  \n  \n    // 数组对应位置已经存在元素  \n    else {  \n        Node\u003cK,V\u003e e; K k;  \n  \n        // 比较数组中第一个元素  \n        if (p.hash == hash \u0026\u0026  \n            ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n  \n                // 将第一个元素赋值给 e  \n                e = p;  \n        // 是否为红黑树结点  \n        else if (p instanceof TreeNode)  \n            // 放入树中  \n            e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab,   \n                        hash, key, value);  \n        // 链表结点  \n        else {  \n            // 遍历链表  \n            for (int binCount = 0; ; ++binCount) {  \n                // 到达链表的尾部，说明没有找到相等的 key  \n                if ((e = p.next) == null) {  \n                    // 在尾部插入新结点  \n                    p.next = newNode(hash, key, value, null);  \n  \n                    // 判断结点数量是否达到阈值(TREEIFY_THRESHOLD 默认为 8)  \n                    if (binCount \u003e= TREEIFY_THRESHOLD - 1) {  \n                        // 根据数组长度决定是否树化  \n                        treeifyBin(tab, hash);  \n                    }  \n  \n                    // 跳出循环  \n                    break;  \n                }  \n  \n                // 判断链表中结点的 key 值是否与插入的 key 相等  \n                if (e.hash == hash \u0026\u0026  \n                    ((k = e.key) == key ||   \n                          (key != null \u0026\u0026 key.equals(k))))  \n                    // key 相等，跳出循环，此时 e 就是目标结点  \n                    break;  \n  \n                // 与前面的 e = p.next 组合遍历链表  \n                p = e;  \n            }  \n        }  \n  \n        // 找到 key 值相等的目标结点  \n        if (e != null) {  \n  \n            V oldValue = e.value;  \n  \n            // onlyIfAbsent 为 false 或者目标接点值为 null  \n            if (!onlyIfAbsent || oldValue == null)  \n  \n                //用新值替换旧值  \n                e.value = value;  \n  \n            // 空实现，用于访问后回调给子类，如 LinkedHashMap  \n            afterNodeAccess(e);  \n  \n            // 返回旧值  \n            return oldValue;  \n        }  \n    }  \n  \n    // 结构修改，更新 modCount  \n    ++modCount;  \n  \n    // 实际大小大于阈值则扩容  \n    if (++size \u003e threshold)  \n        resize();  \n  \n    // 插入后回调  \n    afterNodeInsertion(evict);  \n  \n    return null;  \n}  \n```  \n  \n#### 流程图示  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040522.png)\n## hash 计算与元素位置确定  \n  \n### Java 7  \n  \n```java  \nint hash = hash(key);  \n  \nint i = indexFor(hash, table.length);  \n  \nfinal int hash(Object k) {  \n  \n    // 默认为 0，初始化方法见后文  \n    int h = hashSeed;  \n  \n    // 如果 hashSeed 不为零且 key 是 String 类型  \n    if (0 != h \u0026\u0026 k instanceof String) {  \n        // 返回特定 hash 值  \n        return sun.misc.Hashing.stringHash32((String) k);  \n    }  \n  \n    h ^= k.hashCode();  \n  \n    // 多次异或  \n    h ^= (h \u003e\u003e\u003e 20) ^ (h \u003e\u003e\u003e 12);  \n  \n    return h ^ (h \u003e\u003e\u003e 7) ^ (h \u003e\u003e\u003e 4);  \n}  \n  \nstatic int indexFor(int h, int length) {  \n    // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";  \n    return h \u0026 (length-1);  \n}  \n```  \n  \n### Java 8  \n  \n```java  \npublic V put(K key, V value) {  \n    return putVal(hash(key), key, value, false, true);  \n}  \n\nstatic final int hash(Object key) {  \n    int h;  \n  \n    // 让高 16 位和低 16 位异或  \n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16);  \n}  \n\np = tab[index = (n - 1) \u0026 hash]；  \n```  \n  \n## 扩容流程  \n  \n扩容过程涉及到 rehash、复制数据等操作，非常消耗性能。  \n  \n和扩容相关的全局变量及其含义：  \n  \n| 全局变量   | 含义                                                                                                                                                                                                                                                                                                                                                                                                      |  \n| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |  \n| capacity   | table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。                                                                                                                                                                                                                                                                                                                               |  \n| size       | 存放键值对数量。                                                                                                                                                                                                                                                                                                                                                                                          |  \n| threshold  | size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。threshold = (int) (capacity * loadFactor)                                                                                                                                                                                                                                                                                                   |  \n| loadFactor | 填充因子，table 能够使用的比例。loadFactor 能够控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。\u003cbr/\u003eloadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。 |  \n  \n### Java 7 扩容流程  \n  \n#### 代码分析  \n  \nJava 7 的 resize 方法相关代码：  \n  \n```java  \nvoid resize(int newCapacity) {  \n    Entry[] oldTable = table;  \n  \n    // 记录旧容量  \n    int oldCapacity = oldTable.length;  \n  \n    // 如果容量已达到上限，则扩容阈值设置成不可能达到的最大值，即后续不再扩容  \n    if (oldCapacity == MAXIMUM_CAPACITY) {  \n        threshold = Integer.MAX_VALUE;  \n  \n        return;  \n    }  \n  \n    // 根据新容量创建出新数组  \n    Entry[] newTable = new Entry[newCapacity];  \n  \n    // 将旧数组的节点转移到新数组  \n    transfer(newTable, initHashSeedAsNeeded(newCapacity));  \n  \n    // 新旧易主  \n    table = newTable;  \n  \n    // 根据新容量重新确定新阈值  \n    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);  \n}  \n \n// 从配置中获取是否启用备用 hash，用于减少字符串 hash 冲突  \nfinal boolean initHashSeedAsNeeded(int capacity) {  \n    // 是否已经启用备用 hash  \n    boolean currentAltHashing = hashSeed != 0;  \n  \n    // 虚拟机已经启动且数组容量大于 ALTERNATIVE_HASHING_THRESHOLD  \n    boolean useAltHashing = sun.misc.VM.isBooted() \u0026\u0026  \n            (capacity \u003e= Holder.ALTERNATIVE_HASHING_THRESHOLD);  \n  \n    // 异或操作判断是否切换  \n    boolean switching = currentAltHashing ^ useAltHashing;  \n    if (switching) {  \n        // useAltHashing 为 true 则 hashSeed 初始化为也给随机 hash 值  \n        hashSeed = useAltHashing  \n            ? sun.misc.Hashing.randomHashSeed(this)  \n            : 0;  \n    }  \n    return switching;  \n}  \n\nvoid transfer(Entry[] newTable, boolean rehash) {  \n    int newCapacity = newTable.length;  \n  \n    // 遍历旧数组  \n    for (Entry\u003cK,V\u003e e : table) {  \n        // 遍历数组上的链表  \n        while(null != e) {  \n            // 记录下一个位置  \n            Entry\u003cK,V\u003e next = e.next;  \n  \n            // 判断是否重新计算 hash 值  \n            if (rehash) {  \n  \n                e.hash = null == e.key ? 0 : hash(e.key);  \n  \n            }  \n  \n            // 根据新容量重新计算位置  \n            int i = indexFor(e.hash, newCapacity);  \n  \n            // 按旧链表的正序遍历链表、在新链表的头部依次插入  \n            // 因此扩容后可能出现逆序  \n            e.next = newTable[i];  \n  \n            newTable[i] = e;  \n  \n            e = next;  \n        }  \n    }  \n}  \n```  \n  \n#### 扩容流程在多线程环境下的隐患  \n  \n在 resize 扩容过程中，在将旧数组上的数据转移到新数组上时，转移数据操作是按旧链表的正序遍历链表、在新链表的头部依次插入的。在多线程的环境下，由于这些操作不具有原子性和内存可见性，转移数据、扩容后，容易出现环形链表的情况。  \n  \n### Java 8 扩容流程  \n  \n#### 代码分析  \n  \nJava 8 中的 resize 和 treeifyBin 方法：  \n  \n```java  \nfinal void treeifyBin(Node\u003cK,V\u003e[] tab, int hash) {  \n    int n, index; Node\u003cK,V\u003e e;  \n    // 如果数组为空或者数组长度小于 64，则进行扩容  \n    if (tab == null || (n = tab.length) \u003c MIN_TREEIFY_CAPACITY)  \n        resize();  \n    // 根据 hash 获取数组下标，该位置有值再进行树化  \n    else if ((e = tab[index = (n - 1) \u0026 hash]) != null) {  \n        TreeNode\u003cK,V\u003e hd = null, tl = null;  \n        // 遍历链表  \n        do {  \n            // Node 节点转换成 TreeNode 节点  \n            TreeNode\u003cK,V\u003e p = replacementTreeNode(e, null);  \n  \n            if (tl == null)  \n                hd = p;  \n            else {  \n                p.prev = tl;  \n  \n                tl.next = p;  \n            }  \n  \n            tl = p;  \n        } while ((e = e.next) != null);  \n        \n        if ((tab[index] = hd) != null)  \n            hd.treeify(tab);  \n    }  \n}  \n\nfinal Node\u003cK,V\u003e[] resize() {  \n  \n    Node\u003cK,V\u003e[] oldTab = table;  \n  \n    int oldCap = (oldTab == null) ? 0 : oldTab.length;  \n  \n    int oldThr = threshold;  \n  \n    int newCap, newThr = 0;  \n  \n    if (oldCap \u003e 0) {  \n        // 超过最大值后续不再扩容  \n        if (oldCap \u003e= MAXIMUM_CAPACITY) {  \n            threshold = Integer.MAX_VALUE;  \n            return oldTab;  \n        }  \n  \n        // 否则扩充为原来的2倍  \n        else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 oldCap \u003e= DEFAULT_INITIAL_CAPACITY)  \n            newThr = oldThr \u003c\u003c 1; // double threshold  \n    }  \n  \n    else if (oldThr \u003e 0) // initial capacity was placed in threshold  \n        newCap = oldThr;  \n    else {  \n        // signifies using defaults  \n        newCap = DEFAULT_INITIAL_CAPACITY;  \n  \n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  \n    }  \n  \n    // 计算新的 resize 上限  \n  \n    if (newThr == 0) {  \n        float ft = (float)newCap * loadFactor;  \n        newThr = (newCap \u003c MAXIMUM_CAPACITY \u0026\u0026 ft \u003c (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);  \n    }  \n  \n    threshold = newThr;  \n  \n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})  \n  \n    Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap];  \n  \n    table = newTab;  \n\n    if (oldTab != null) {  \n        // 旧数组迁移至新数组  \n        for (int j = 0; j \u003c oldCap; ++j) {  \n            Node\u003cK,V\u003e e;  \n            if ((e = oldTab[j]) != null) {  \n                oldTab[j] = null;  \n                if (e.next == null)  \n                    newTab[e.hash \u0026 (newCap - 1)] = e;  \n                else if (e instanceof TreeNode)  \n                    ((TreeNode\u003cK,V\u003e)e).split(this, newTab, j, oldCap);  \n                else {  \n                    Node\u003cK,V\u003e loHead = null, loTail = null;  \n                    Node\u003cK,V\u003e hiHead = null, hiTail = null;  \n                    Node\u003cK,V\u003e next;  \n                    do {  \n                        next = e.next;  \n                        // 原索引  \n                        if ((e.hash \u0026 oldCap) == 0) {  \n                            if (loTail == null)  \n                                loHead = e;  \n                            else  \n                                loTail.next = e;  \n                            loTail = e;  \n                        }  \n  \n                        // 原索引+oldCap  \n                        else {  \n                            if (hiTail == null)  \n                                hiHead = e;  \n                            else  \n                                hiTail.next = e;  \n                            hiTail = e;  \n                        }  \n                    } while ((e = next) != null);  \n  \n                    // 原索引元素放到新数组中  \n                    if (loTail != null) {  \n                        loTail.next = null;  \n                        newTab[j] = loHead;  \n                    }  \n  \n                    // 原索引 +oldCap 元素放到新数组中  \n                    if (hiTail != null) {  \n                        hiTail.next = null;  \n                        newTab[j + oldCap] = hiHead;  \n                    }  \n                }  \n            }  \n        }  \n    }  \n    return newTab;  \n}  \n```  \n  \nresize 方法中的前半段，关于 newCap 和 newThr 的计算过程，简化后如下：  \n  \n```java  \nif (oldCap \u003e 0) {  \n    // 嵌套条件分支  \n    if (oldCap \u003e= MAXIMUM_CAPACITY) {...}  \n    else if ((newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026  \n                 oldCap \u003e= DEFAULT_INITIAL_CAPACITY) {...}  \n}   \nelse if (oldThr \u003e 0) {...}  \n  \nelse {...}  \n```  \n  \n这些判断分别对应以下几种条件：  \n  \n| 条件                       | 覆盖情况                            | 备注                                                                                                                         |  \n| -------------------------- | ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |  \n| oldCap \u003e 0                 | 桶数组 table 已经被初始化           |                                                                                                                              |  \n| oldThr \u003e 0                 | threshold \u003e 0，且桶数组未被初始化   | 调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况，此种情况下 newCap = oldThr，newThr 在第二个条件分支中算出 |  \n| oldCap == 0 \u0026\u0026 oldThr == 0 | 桶数组未被初始化，且 threshold 为 0 | 调用 HashMap() 构造方法会产生这种情况。                                                                                      |  \n  \noldCap \u003e 0 时表示 table 数组已经被初始化过，这时需要再次计算容量和阈值：  \n  \n| 条件                        | 覆盖情况                                      | 备注                                                      |  \n| --------------------------- | --------------------------------------------- | --------------------------------------------------------- |  \n| oldCap \u003e= 230               | 桶数组容量大于或等于最大桶容量 230            | 后续不再扩容                                              |  \n| newCap \u003c 230 \u0026\u0026 oldCap \u003e 16 | 新桶数组容量小于最大值，且旧桶数组容量大于 16 | 该种情况下新阈值 newThr = oldThr \u003c\u003c 1，移位可能会导致溢出 |  \n  \nresize 方法后续过程中可以看出，Java 8 转移数据操作是按旧链表的正序遍历链表、在新链表的尾部依次插入的，所以不会出现链表 逆序、倒置的情况，故不容易出现环形链表的情况。但仍然还是线程不安全，因为没有加同步锁保护。  \n  \n### 扩容流程对比  \n![](https://my-bucket-1251125515.cos.ap-guangzhou.myqcloud.com/HashMap/clipboard_20230322_040805.png)\n## get 流程分析  \n  \n### Java 7\n  \n```java  \npublic V get(Object key) {  \n    if (key == null)  \n        return getForNullKey();  \n    Entry\u003cK,V\u003e entry = getEntry(key);  \n    return null == entry ? null : entry.getValue();  \n}  \n  \nprivate V getForNullKey() {  \n    if (size == 0) {  \n        return null;  \n    }  \n  \n    // 下标为 0 处获取 key 为 null 的元素  \n    for (Entry\u003cK,V\u003e e = table[0]; e != null; e = e.next) {  \n        if (e.key == null)  \n            return e.value;  \n    }  \n    return null;  \n}  \n\nfinal Entry\u003cK,V\u003e getEntry(Object key) {  \n    if (size == 0) {  \n        return null;  \n    }  \n  \n    int hash = (key == null) ? 0 : hash(key);  \n    for (Entry\u003cK,V\u003e e = table[indexFor(hash, table.length)];  \n             e != null; e = e.next) {  \n        Object k;  \n        if (e.hash == hash \u0026\u0026  \n            ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n            return e;  \n    }  \n    return null;  \n}  \n```  \n  \n### Java 8\n  \n```java  \npublic V get(Object key) {  \n    Node\u003cK,V\u003e e;  \n    return (e = getNode(hash(key), key)) == null ? null : e.value;  \n}  \n\nfinal Node\u003cK,V\u003e getNode(int hash, Object key) {  \n    Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n; K k;  \n    if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026  \n        (first = tab[(n - 1) \u0026 hash]) != null) {  \n        // 先判断 tab[index] 中的第一个元素  \n        if (first.hash == hash \u0026\u0026 // always check first node  \n            ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n            return first;  \n        if ((e = first.next) != null) {  \n            // 结点为红黑树则使用 TreeNode 的方法获取  \n            if (first instanceof TreeNode)  \n                return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key);  \n            do { //否则遍历链表  \n                if (e.hash == hash \u0026\u0026  \n                    ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k))))  \n                    return e;  \n            } while ((e = e.next) != null);  \n        }  \n    }  \n    return null;  \n}  \n```  \n  \n遍历方式  \n  \n```java  \nMap\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e() {{  \n    put(\"a\", 10);  \n    put(\"b\", 20);  \n}};  \n  \n// 方式一：迭代 entrySet  \n  \nfor (Map.Entry\u003cString, Integer\u003e entry : map.entrySet()) {  \n    String key = entry.getKey();  \n    int value = entry.getValue();  \n}  \n\n// 方式二：单独迭代 keySet 或 values  \n// 迭代键  \nfor (String key : map.keySet()) {  \n    System.out.println(\"Key = \" + key);  \n}  \n  \n// 迭代值  \nfor (Integer value : map.values()) {  \n    System.out.println(\"Value = \" + value);  \n}  \n\n// 方式三：使用 iterator  \n  \nIterator\u003cMap.Entry\u003cString, Integer\u003e\u003e entries =         \n          map.entrySet().iterator();  \n  \nwhile (entries.hasNext()) {  \n    Map.Entry\u003cString, Integer\u003e entry = entries.next();  \n    String key = entry.getKey();  \n    int value = entry.getValue();  \n}  \n\n// 方式四：Lambda 表达式  \nmap.forEach((k, v) -\u003e System.out.println(\"key: \" + k + \" value:\" + v));  \n```  \n  \n## 面试题  \n  \n### 为什么 HashMap 数组长度为 2 的幂次方？  \n  \n如果数组中 hash 冲突太过频繁，某些位置的元素形成过长的链表，就会导致数据存取效率过低，因此要使元素均匀地分布在数组中，hash 碰撞就不能太频繁。而 hash 值范围为 -2147483648 到 2147483647，如果用如此长的数组来进行存放加上合理 hash 映射确实可以使 hash 碰撞降到很低的水平，但这明显是不现实的。  \n  \n因此这个 hash 值是不能直接使用的，首先需要进行二次 hash 使得结果更加随机，这时理论上可以使用 hash % length 得到一个不小于数组长度 length 的 index 值，这样不但能避免产生数组越界，并且可以使元素均匀分布，事实上很多 hash 算法都是采用该方法。但是在计算机中，% 取模运算比位 \u0026 运算的效率要低得多，而当 length 为 2 的幂次方时，hash % length 刚好等于 hash \u0026 (length - 1) ，从而能够将 % 运算转换成 \u0026 运算，更加快速地得到 index 值。  \n  \n因此采用 2 的幂次方作为数组的长度的好处是：使元素均匀分部以降低 hash 冲突的基础上，大大加快了计算元素所在数组位置的速度。  \n  \n### hash 冲突有哪些解决方法？HashMap 是怎样解决的？  \n  \n1. 二次 hash，通过高 16 位与低 16 位异或运算，使得结果更加随机；  \n2. 拉链地址法，将 hash 值相同的元素串成一个链表或者转为红黑树。  \n  \n### HashMap 会造成哪些安全问题？怎么解决？  \n  \n如前面文章所述，在 Java 7 中，HashMap 在扩容的时候是通过遍历旧数组，然后在新数组中使用头插法进行转移元素的。这在单线程环境中是没有问题的，但是到了多线程环境下，由于 JMM 的特性，会以一定的概率形成环形链表的情况。在 Java 8 中这个问题通过使用尾插法得到解决，但是多线程下很多操作仍然会导致线程安全问题，比如多个线程 put 后某些元素丢失等。因此多线程环境下要保证线程安全，可以使用 ConcurentHashMap 代替 HashMap。  \n  \n### 使用对象作为 HashMap 的 key 应该注意什么？  \n  \n应当重写对象的 hashCode() 和 equals() 方法。如前面代码所示，HashMap 在 put 一个元素的时候，会调用此元素的 key 值的 hashCode 方法确定元素存放位置，并且会调用 hashCode 和 equals 方法判断元素是否相等。因此如果没有重写这两个方法，或者方法重写的时候没有遵守规则，HashMap 通过 put 存入一组元素后，再通过此元素的 key 值去 get 对象的时候就有可能出现跟预期结果不一致的情况。  \n  \n在重写 equals 方法的时候，需要遵守下面的通用约定：  \n  \n- \u003cstrong\u003e自反性\u003c/strong\u003e：对于任何非空引用 x，x.equals(x) 必须返回 true；  \n- \u003cstrong\u003e对称性\u003c/strong\u003e：对于任何非空引用 x 和 y，如果且仅当 y.equals(x) 返回 true 时 x.equals(y) 必须返回 true；  \n- \u003cstrong\u003e传递性\u003c/strong\u003e：对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，则 x.equals(z) 必须返回 true；  \n- \u003cstrong\u003e一致性\u003c/strong\u003e：对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则 x.equals(y) 的多次调用必须始终返回 true 或始终返回 false；  \n- \u003cstrong\u003e非空性\u003c/strong\u003e：对于任何非空引用 x，x.equals(null) 必须返回 false。  \n  \n\u003cstrong\u003e重写 hashCode 方法的大致方式（非强制）：\u003c/strong\u003e  \n  \n1. 把某个非零常数值，比如说 31（最好是素数，考虑到 HashMap 源码中的异或操作），保存在一个叫 result 的 int 类型的变量中。  \n2. 对于对象中每一个关键域 f（值 equals 方法中考虑的每一个域），完成以下步骤：  \n3. 为该域计算 int 类型的散列码 c:  \n  \n```  \n1. 如果该域是 boolean 类型，则计算 (f?0:1)  \n  \n2. 如果该域是 byte、char、short 或者 int 类型，则计算 (int)f  \n  \n3. 如果该域是 float 类型，则计算 Float.floatToIntBits(f)  \n  \n4. 如果该域是 long 类型，则计算 (int)(f ^ (f\u003e\u003e\u003e32))  \n  \n5. 如果该域是double类型，则计算 Double.doubleToLongBits(f) 得到一个 long 类型的值，然后按照步骤 4，对该 long 型值计算散列值  \n  \n6. 如果该域是一个对象引用，并且该类的 equals 方法通过递归调用 equals 的方式来比较这个域，则同样对这个对象递归调用 hashCode 方法。  \n  \n7. 如果该域是一个数组，则把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤下面的做法把这些散列值组合起来。  \n```  \n  \n2. 按照下面的公式，把步骤 1 中计算得到的散列码 c 组合到 result 中：result = 31 x result+c。  \n3. 返回 result。  \n4. 写完 hashCode 方法之后，确认是否相等的实例具有相等的散列码。如果不是的话，找出原因，并修改。  \n  \n样例：  \n  \n```java  \npublic class Student {  \n  \n    private String name;  \n  \n    private int age;  \n  \n    private Grades grades;  \n  \n    public Student(String name, int age, Grades grades) {  \n        this.name = name;  \n        this.age = age;  \n        this.grades = grades;  \n    }  \n\n    @Override  \n    public int hashCode() {  \n        final int prime = 31;  \n        int result = 1;  \n        \n        result = prime * result + age;  \n        result = prime * result +  \n                ((name == null) ? 0 : name.hashCode());  \n        result = prime * result +  \n                (grades == null ? 0 : grades.hashCode());  \n  \n        return result;  \n  \n    }  \n  \n    @Override  \n    public boolean equals(Object obj) {  \n        if (this == obj) return true;  \n  \n        if (obj == null || getClass() != obj.getClass()) return false;  \n  \n        Student other = (Student) obj;  \n  \n        if (age != other.age) return false;  \n  \n        if (name != null ? !name.equals(other.name) :   \n              other.name != null) return false;  \n  \n        if (grades != null ? !grades.equals(other.grades) :           \n              other.grades != null) return false;  \n  \n        return true;  \n    }  \n}  \n```","lastmodified":"2023-03-22T10:53:40.981860045Z","tags":["HashMap","源码解析","Java"]},"/IO":{"title":"IO","content":"","lastmodified":"2023-03-22T10:53:40.981860045Z","tags":["Java","IO"]},"/Index-for-Atlases":{"title":"Untitled Page","content":"---\ndate created: 2022-06-22\ndate modified: 2022-08-20\ntags: dataview\ntitle: \"Index for Atlases\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n```dataviewjs\n// 获取当前文件所在的文件夹\nconst currentFolder = dv.current().file.folder\n// 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息\nconst groups =  dv.pages(`\"${currentFolder}\"`).groupBy(p =\u003e p.file.folder)\nfor (let group of groups) {\n\tdv.header(4, group.key);\n\tdv.table([\"Name\",\"标签\",\"入链\", \"创建日期\", \"修改日期\"],\n\t\tgroup.rows\n\t\t\t.sort(k =\u003e k.file.name, 'asc')\n\t\t\t.map(k =\u003e [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday]))\n}\n```\n","lastmodified":"2023-03-22T10:53:40.981860045Z","tags":[]},"/Index-for-Extras":{"title":"Untitled Page","content":"---\ndate created: 2022-06-23\ndate modified: 2022-08-20\ntags: dataview\ntitle: \"Index for Extras\"\n---\n\nup:: [[ACCESS 笔记组织法]]\n\n```dataviewjs\n// 获取当前文件所在的文件夹\nconst currentFolder = dv.current().file.folder\n// 通过文件夹分组，检索文件夹下全部文件的标签、修改时间等相关信息\nconst groups =  dv.pages(`\"${currentFolder}\"`).groupBy(p =\u003e p.file.folder)\nfor (let group of groups) {\n\tdv.header(4, group.key);\n\tdv.table([\"Name\",\"标签\",\"入链\", \"创建日期\", \"修改日期\"],\n\t\tgroup.rows\n\t\t\t.sort(k =\u003e k.file.name, 'asc')\n\t\t\t.map(k =\u003e [k.file.link,k.file.tags,k.file.inlinks, k.file.cday, k.file.mday]))\n}\n```\n","lastmodified":"2023-03-22T10:53:40.981860045Z","tags":[]}}